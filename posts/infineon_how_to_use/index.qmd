---
title: "how to use infineon Radar" 
author: "dd21"
date: "2022-12-06" 
categories: [radar, infineon]
image: fusiongui.gif
---


# Description

infineon RadarBTG60 软件架构, 及如何移植

![](https://raw.githubusercontent.com/fly-t/images/main/blog/index-2022-12-06-18-10-26.png)


# Referance

- [https://infineon.github.io/sensor-xensiv-bgt60trxx/html/index.html](https://infineon.github.io/sensor-xensiv-bgt60trxx/html/index.html)

- [AN599_Radar_Baseboard_MCU7_V2.6.pdf](AN599_Radar_Baseboard_MCU7_V2.6.pdf)


# Arduino MKR interface

兼容`Arduino MKR ` 
 
 - MKR Zero  这个开发板可以放sd卡, 可以将原始数据存储在sd卡上
 
 - MKR1000 这个开发板可以wifi传输数据

- MKR Vidor 4000   带有用于并行数据处理的 FPGA 和用于 RAM 扩展的 SDRAM 的电路板

- MKR2UNO 可以扩展更多


# 固件

> 在mcu7上有固件将充当雷达和主机之间的桥梁, 主要的功能如下

> - 通过USB与主机通信
> - 读取和写入传感器寄存器
> - 通过 SPI 读取传感器数据
> - 检查传感器板是否插入连接器之一
> - 读写传感器板上的EEPROM（比如识别板子）
> - 控制一些辅助外围设备，例如基板和传感器板上的状态 LED。

在当前状态下，固件不执行任何信号处理。它可以从主机接收消息，告诉它如何配置传感器，并且可以将获取的数据从传感器转发到主机。但是，如果需要信号处理，则可以添加此功能，因为 MCU 足够强大。固件的编写方式可最大限度地减少将其移植到其他微控制器的工作量。因此，固件结构分为以下层

> - 硬件抽象层 Hardware abstraction layer (HAL)

这是最低层，实现了所有特定于 MCU 的逻辑，例如如何与 SPI、GPIO、定时器和其他 HW 模块接口。当移植到不同的 MCU 时，这一层应该是唯一受影响的层。它还实现了一个 USB CDC 串行接口，通信层使用该接口连接到主机设备



> - 驱动层( Driver layer)

此层位于硬件层的顶部。它提供了参数化和读取的函数来自传感器的数据。它创建适当的SPI 数据包以将这些参数应用于传感器和从 HAL 调用 SPI 函数以启动数据传输。此外，它还解码SPI数据包来自 HAL 接收的传感器。因此，传感器测量值被提取并传递给上面的图层。驱动层独立于MCU。但是，它需要具体到每个型号的传感器, 根据传感器的型号进行配置


> - 通信层 ( Communication layer)
此层位于驱动程序层和硬件层的顶部。它接收通过 USB 接口从主机请求或命令消息。这些消息经过解码，并且提取包含的数据。这是通过调用驱动程序层的相应函数来完成的。当这些函数返回结果时，包含结果的响应消息将转发到主机。从驱动程序层接收传感器数据时，也会生成发往主机的消息。这一层也是独立于硬件的。它使用 HAL USB CDC 接口将数据传输到主机


> -实际固件 (Actual firmware )

它位于所有其他层之上。固件调用所有初始化函数启动时的较低层，用于配置SPI速度和GPIO方向等内容。一旦启动阶段已经完成，进入死循环，在其中调用通信层来获取并在主机之间传输消息。

# 没有mcu7的时候( 移植其他平台 )

> 在没有雷达基板MCU7作为中介的情况下( 其他主控芯片配合radar芯片 )将传感器集成到自定义项目中时，需要在固件中执行以下步骤


- 将整个固件移植到不同的 MCU 时，将 HAL 移植到该 MCU 应该就足够了. 或者将需要的application 移植

- 驱动层可以照原样使用，不做任何修改

- 如果通信层不需要, 算法可以放在该层

- 不会使用雷达基板MCU7的固件代码;但是，初始化代码应为搬入项目的MCU

- 将整个固件移植到其他 MCU 时，将 HAL 移植到该 MCU 就足够了

<b>可以把算法放到mcu上, 可以替换通信协议, 亦可以同时保</b>

# USB

 固件在 USB 接口上实现了一个通信设备类 communication device class(CDC) 设备。这意味着 USB 接口的工作方式类似于串行端口，实现双向接口，在两个方向上传输字节流

在此串行数据流之上，通过在每条消息周围放置开始和结束标记来实现基于消息的协议。消息的第一个字节指定消息所针对的固件的目标模块。消息的字节 2 和 3 设置消息的长度。这样协议解码器就知道消息的长度。结合开始和结束标记，它能够将接收到的流拆分为其组成数据包。固件源代码包括可以集成到主机应用程序中的通信库的一部分，并提供创建和解码固件消息的功能


# EEPROM

固件利用 EEPROM 检测屏蔽类型。 EEPROM的结构如表2所示，其中还包含一个128位的电路板标识符，可以用来区分同一类型的不同电路板。除此之外，固件向主机提供命令以在 EEPROM 中存储和检索有限大小的键/值对。主机可以自由地为这些对分配它想要的任何含义（例如，特定键的值可能指雷达配置数据，而另一个键的值可能用于存储显示设置）。访问 EEPROM 的函数是随固件提供的通信库的一部分

![](https://raw.githubusercontent.com/fly-t/images/main/blog/index-2022-12-06-18-13-48.png)



# RGB 指示灯

主板的当前状态指示在 R GB LED 上。在电路板启动后和电路板空闲时，board 状态如表 3 所示。处于活动状态时，电路板状态指示如下图

![](https://raw.githubusercontent.com/fly-t/images/main/blog/index-2022-12-06-18-16-53.png)


# 调试烧录

![](https://raw.githubusercontent.com/fly-t/images/main/blog/index-2022-12-06-18-22-18.png)

如果用户需要调试器连接器，该板具有两个选项，如图13所示。在顶部雷达基板MCU7的一侧，有一个标签连接调试器的布局。如果用户不想购买Tag Connect调试电缆，他们可以将普通的10针Arm调试连接器焊接到焊盘上雷达基板MCU7底部的组件J1

使用调试器连接器时，可以直接从 Atmel Studio 7 使用Atmel-ICE 程序员或兼容工具

## 引导加载程序刷新

微控制器包含一个引导加载程序。如果调试器是不可用。由于设备通常直接启动到固件而不进入引导加载程序，引导加载程序必须首先手动激活。这可以通过执行以下顺序来完成

1. 断开设备与 USB 的连接

2. 通过将 TP1 连接到 3.3 V 将 MCU ERASE 引脚保持在高电平（参见图 13）

3. 在保持 TP1 高电平的同时再次将设备连接到 USB

4. 松开擦除引脚 （TP1）

5. 设备现在处于引导加载程序模式


> 一旦设备处于引导加载程序模式，就可以使用可用于从Microchip下载（Microchip，SAM-BA启动助手，2019）

