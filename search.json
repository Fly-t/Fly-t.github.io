[
  {
    "objectID": "contact_me/jdbc-- c3p0xml 链接/index.html",
    "href": "contact_me/jdbc-- c3p0xml 链接/index.html",
    "title": "jdbc– c3p0xml 链接",
    "section": "",
    "text": "// 配置文件连接\n    @Test\n    public void c3p0Test02() throws SQLException {\n        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"mysql\");\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i < 5000; i++) {\n            Connection connection = comboPooledDataSource.getConnection();\n            connection.close();\n        }\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n配置文件放src下 c3p0-config.xml\n<c3p0-config >\n  <named-config name=\"mysql\">\n  <property name=\"jdbcUrl\">jdbc:mysql://127.0.0.1:3306/persons?rewriteBatchedStatements=true</property>\n  <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n  <property name=\"user\">root</property>\n  <property name=\"password\">123312</property>\n\n  <property name=\"checkoutTimeout\">3000</property>\n  <property name=\"initialPoolSize\">10</property>\n  <property name=\"maxPoolSize\">100</property>\n  <property name=\"minPoolSize\">10</property>\n  <property name=\"maxStatements\">200</property>\n  <!--每次增长长度-->\n  <property name=\"acquireIncrement\">5</property>\n  <!--每个对象命令数-->\n  <property name=\"maxStatementsPerConnection\">2</property>\n  </named-config>\n</c3p0-config>"
  },
  {
    "objectID": "contact_me/jdbc-- druid/index.html",
    "href": "contact_me/jdbc-- druid/index.html",
    "title": "jdbc– druid",
    "section": "",
    "text": "在访问量很大的情况下,明显看出druid和c3p0的区别\npackage cn.usts.edu.jdbc.druid;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: druid数据库连接池\n * @date ：2021/11/6 14:53\n */\npublic class DruidDemo {\n    public static void main(String[] args) throws Exception {\n        FileInputStream fileInputStream = new FileInputStream(\"src/druid-config.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n        for (int i = 0; i < 500000; i++) {\n            Connection connection = dataSource.getConnection();\n            connection.close();\n        }\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n}"
  },
  {
    "objectID": "contact_me/jdbc-- druid/index.html#配置文件",
    "href": "contact_me/jdbc-- druid/index.html#配置文件",
    "title": "jdbc– druid",
    "section": "配置文件",
    "text": "配置文件\ndruid-config.properties 放src下\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/persons?characterEncoding=UTF-8\nusername=root\npassword=123321\n# 初始化连接数\ninitialSize=5\n#最大连接数\nmaxActive=10\n#超时时间\nmaxWait=3000"
  },
  {
    "objectID": "contact_me/jdbc--事务/index.html",
    "href": "contact_me/jdbc--事务/index.html",
    "title": "jdbc–事务",
    "section": "",
    "text": "事务\n事务的出现是为了防止一个由两个人交互的事情,出现不同的结果,把两个或多个步骤看成一个步骤, 如果有任意一方没有满足,则视为事务终止=没做\n\n执行前\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n执行后\n ## 为了防止这样的事情发生出现了事务\npackage cn.usts.edu.jdbc.rollback;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: 事务操作\n *                  B转钱给A100块\n * @date ：2021/11/6 12:13\n */\npublic class RollbackDemo {\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        try {\n            DriverManager.registerDriver(driver);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        String sql1 = \"UPDATE `persons`.`money` SET `money` = 1400+100 WHERE `name` = 'A'\";\n        String sql2 = \"UPDATE `persons`.`money` SET `money` = 1400-100 WHERE `name` = 'B'\";\n\n\n        PreparedStatement preparedStatement = null;\n        PreparedStatement preparedStatement1 = null;\n        try {\n            connection.setAutoCommit(false);// 默认自动提交,我们设置不自动提交\n\n            preparedStatement = connection.prepareStatement(sql1);\n            preparedStatement.executeUpdate();\n\n            int i=1/0;\n\n            preparedStatement1 = connection.prepareStatement(sql2);\n            preparedStatement1.executeUpdate();\n\n            //提交事务\n            connection.commit();\n        } catch (SQLException e) {\n            System.out.println(\"事务回滚了\");\n            connection.rollback();//回滚\n\n        }\n\n        // 关闭\n        try {\n            preparedStatement.close();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n}\n\n关闭自动提交 connection.setAutoCommit(false)\n捕获异常 try catch\n最后提交 connection.commit();\n回滚 connection.rollback();//回滚"
  },
  {
    "objectID": "contact_me/jdbc-- 批处理/index.html",
    "href": "contact_me/jdbc-- 批处理/index.html",
    "title": "jdbc– 批处理",
    "section": "",
    "text": "## 批处理结果[效果明显]"
  },
  {
    "objectID": "contact_me/jdbc-- 批处理/index.html#未进行批处理",
    "href": "contact_me/jdbc-- 批处理/index.html#未进行批处理",
    "title": "jdbc– 批处理",
    "section": "未进行批处理",
    "text": "未进行批处理\npublic static void main(String[] args) throws IOException, SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n        String sql = \"INSERT INTO `persons`.`admin`(`amin`, `psd`) VALUES (?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n        for (int i = 0; i < 5000; i++) {\n\n            preparedStatement.setString(1,\"root\");\n            preparedStatement.setString(2,\"456456\");\n            // 执行\n            preparedStatement.executeUpdate();\n\n        }\n        // 关闭\n        preparedStatement.close();\n        connection.close();\n\n\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n\n\n    }"
  },
  {
    "objectID": "contact_me/jdbc-- 批处理/index.html#批处理",
    "href": "contact_me/jdbc-- 批处理/index.html#批处理",
    "title": "jdbc– 批处理",
    "section": "批处理",
    "text": "批处理\npublic static void main(String[] args) throws IOException, SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n        String sql = \"INSERT INTO `persons`.`admin`(`amin`, `psd`) VALUES (?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        for (int i = 0; i < 5000; i++) {\n\n            preparedStatement.setString(1,\"root\");\n            preparedStatement.setString(2,\"789\");\n\n            // 添加到batch中\n            preparedStatement.addBatch();\n            if ((i+1)%1000==0){\n                preparedStatement.executeBatch();// 执行batch中的语句\n                preparedStatement.clearBatch();// 清空batch,准备下一轮的接收\n            }\n\n        }\n        // 关闭\n        preparedStatement.close();\n        connection.close();\n\n\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n\n\n    }"
  },
  {
    "objectID": "contact_me/jdbc-- PreparedStatement( DML语句)insert,delete,update/index.html",
    "href": "contact_me/jdbc-- PreparedStatement( DML语句)insert,delete,update/index.html",
    "title": "jdbc– PreparedStatement( DML语句)insert,delete,update",
    "section": "",
    "text": "PreparedStatement( DML语句)insert,delete,update\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n/**\n * @author ：fly\n * @description:  测试PreparedStatement\n *                 对sql注入的解决\n *                 以及常用方法  DML语句\n * @date ：2021/11/5 16:06\n */\npublic class PreparedStatementDemo {\n\n    // CRUD\n    @Test\n    public void crud() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");\n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n\n\n        //String sql =\"insert into admin (amin, psd) values (?,?);\";// insert\n        //String sql =\"update admin set psd = ? where ? = amin\";  // update\n        String sql =\"delete from admin where amin=?\";   // delete\n\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setString(1,name);\n        //preparedStatement.setString(2,name); // 占位符位置\n        //preparedStatement.setString(1,psd);\n        int rows = preparedStatement.executeUpdate();// 这里不用在给sql了 返回修改行数\n\n        System.out.println(\"执行行数\"+rows);\n\n        // 切断链接\n        preparedStatement.close();\n        connection.close();\n\n\n    }\n\n\n\n\n}"
  },
  {
    "objectID": "contact_me/jdbc-- StatementSQL注入演示/index.html",
    "href": "contact_me/jdbc-- StatementSQL注入演示/index.html",
    "title": "jdbc– StatementSQL注入演示",
    "section": "",
    "text": "解决方案: preparedStatement 测试用户名: 1' or 测试密码: or '1'='1\n// StatementSQL注入演示\n    @Test\n    public void statementSqlDemo() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"src/cn/usts/edu/config/db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");  \n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n        String sql =\"select admin.amin,admin.psd from admin where amin='\"+name+\"'and psd='\"+psd+\"'\";\n\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        // 获取结果\n        if (resultSet.next()){ // 查询到结果才会有记录\n            System.out.print(\"登陆成功\");\n        }else{\n            System.out.print(\"登陆失败\");\n        }\n\n\n        // 切断链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n\n    }\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "contact_me/keil5设置调试器stm32/index.html",
    "href": "contact_me/keil5设置调试器stm32/index.html",
    "title": "keil5设置调试器stm32",
    "section": "",
    "text": "> # 选所用的调试器\n > # 设置 \n  \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "contact_me/javaGUI-- 单选框 JRadioButton _ 复选框 JCheckBox/index.html",
    "href": "contact_me/javaGUI-- 单选框 JRadioButton _ 复选框 JCheckBox/index.html",
    "title": "javaGUI– 单选框 JRadioButton _ 复选框 JCheckBox",
    "section": "",
    "text": "单选框记得分组,要不然不是只能选一个 一个分组中只能选择一个 复选框可以选多个 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JButtonDemo extends JFrame {\n    public JButtonDemo() {\n        this.setTitle(\"单选框/复选框\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 单选框\n        JRadioButton radioButton01 = new JRadioButton(\"JRadioButton01\");\n        JRadioButton radioButton02 = new JRadioButton(\"JRadioButton02\");\n        JRadioButton radioButton03 = new JRadioButton(\"JRadioButton03\");\n\n        // 因为单选框智能选择一个,所以分组,每个组内只能选择一个\n        ButtonGroup group = new ButtonGroup();\n        group.add(radioButton01);\n        group.add(radioButton02);\n        group.add(radioButton03);\n\n        // 复选框\n        JCheckBox checkBox01 = new JCheckBox(\"checkBox01\");\n        JCheckBox checkBox02 = new JCheckBox(\"checkBox02\");\n        JCheckBox checkBox03 = new JCheckBox(\"checkBox03\");\n\n        Container container = this.getContentPane();\n        container.add(radioButton01,BorderLayout.WEST);\n        container.add(radioButton02,BorderLayout.CENTER);\n        container.add(radioButton03,BorderLayout.EAST);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new FlowLayout());\n        panel.add(checkBox01);\n        panel.add(checkBox02);\n        panel.add(checkBox03);\n        container.add(panel,BorderLayout.NORTH);\n    }\n\n    public static void main(String[] args) {\n        new JButtonDemo();\n    }\n}"
  },
  {
    "objectID": "contact_me/javaGUI-- 键盘监听/index.html",
    "href": "contact_me/javaGUI-- 键盘监听/index.html",
    "title": "javaGUI– 键盘监听",
    "section": "",
    "text": "键盘监听 监听按下的按键\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class TestKeyPressListener {\n    public static void main(String[] args) {\n        new KeyPressFrame(\"键盘监听\");\n    }\n}\n\n\nclass KeyPressFrame extends Frame{\n    public KeyPressFrame(String title) {\n        super(title);\n        setBounds(100,100,400,200);\n        setVisible(true);\n\n        // 添加键盘监听\n        this.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int keyCode = e.getKeyCode();\n                if (keyCode == KeyEvent.VK_SPACE){\n                    System.out.println(\"按下了空格键\");\n                }\n            }\n        });\n\n    }\n}"
  },
  {
    "objectID": "contact_me/jdbc-- 结果集ResultSet/index.html",
    "href": "contact_me/jdbc-- 结果集ResultSet/index.html",
    "title": "jdbc– 结果集ResultSet",
    "section": "",
    "text": "// 结果集ResultSet\n    @Test\n    public void resultSetTest() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"src/cn/usts/edu/config/db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        String sql =\"select * from per\";\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        // 获取结果\n        while (resultSet.next()){ // 判断有没有下一row行        (列索引从1开始)\n            System.out.print(\"name:\"+resultSet.getString(1));\n            System.out.print(\"\\tid:\"+resultSet.getInt(2));\n            System.out.print(\"\\tage:\"+resultSet.getInt(3)+\"\\n\");\n        }\n\n        // 切断链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n\n    }\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "contact_me/keil5激活---＞2032年/index.html",
    "href": "contact_me/keil5激活---＞2032年/index.html",
    "title": "keil5激活—＞2032年",
    "section": "",
    "text": "keil5激活 蓝奏云下载\n\n\n\n在这里插入图片描述\n\n\nfile-> lice"
  },
  {
    "objectID": "contact_me/jdbc-- 测试PreparedStatement/index.html",
    "href": "contact_me/jdbc-- 测试PreparedStatement/index.html",
    "title": "jdbc– 测试PreparedStatement",
    "section": "",
    "text": "测试PreparedStatement\n\n@description: 测试PreparedStatement\n            对sql注入的解决\n            以及常用方法\n\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n/**\n * @author ：fly\n * @description:  测试PreparedStatement\n *                 对sql注入的解决\n *                 以及常用方法\n * @date ：2021/11/5 16:06\n */\npublic class PreparedStatementDemo {\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");\n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n        String sql =\"select admin.amin,admin.psd from admin where amin=? and psd=?\";\n        // ? 占位符\n\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setString(1,name); // 占位符位置\n        preparedStatement.setString(2,psd);\n        ResultSet resultSet = preparedStatement.executeQuery();// 这里不用在给sql了\n\n        // 获取结果\n        if (resultSet.next()){ // 查询到结果才会有记录\n            System.out.print(\"登陆成功\");\n        }else{\n            System.out.print(\"登陆失败\");\n        }\n\n\n        // 切断链接\n        resultSet.close();\n        preparedStatement.close();\n        connection.close();\n\n\n    }\n\n}\n控制住了sql注入问题\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "contact_me/JDBC操作数据(以mysql为例)的5种常用方法/index.html",
    "href": "contact_me/JDBC操作数据(以mysql为例)的5种常用方法/index.html",
    "title": "JDBC操作数据(以mysql为例)的5种常用方法",
    "section": "",
    "text": "@description: jdbc的使用步骤\n             1.加载数据库驱动\n             2.通过DriverManager获取数据库连接\n             3.执行sql\n             4.释放连接\n\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: jdbc的使用步骤\n *                  1.加载数据库驱动\n *                  2.通过DriverManager获取数据库连接\n *                  3.执行sql\n *                  4.释放连接\n * @date ：2021/11/4 14:58\n */\npublic class JdbcDemo {\n    // 数据库连接方式1\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        // 1.加载数据库驱动\n        //Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver = new Driver();\n        // 2.获取数据库连接\n        // (1) jdbc:mysql 表示规定好的协议, 通过jdbc方式连接mysql\n        // (2) 3306: 表示数据库端口号\n        // (3) 127.0.0.1: 表示主机ip\n        // (4) mybatis: 表示mysql中的哪一个数据库\n        // (5) 数据库的本质连接就是socket连接\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        // (6) 用户名密码user和password是规定好的,不能写别的\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n\n        //3.执行sql\n        String sql = \"insert into persons.per value ('小明',2,18)\";\n        // 执行需要创建statement\n        Statement statement = connect.createStatement();\n        int rows = statement.executeUpdate(sql);// 返回生效行数\n        System.out.println(rows>0 ? \"成功\":\"失败\");\n\n        //4.释放连接\n        statement.close();\n        connect.close();\n    }\n\n    // 数据库连接方式2   动态加载更灵活\n    @Test\n    public void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");// 动态加载类\n        Driver driver = (Driver)aClass.newInstance();\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n        System.out.println(\"方式2\"+connect);\n\n    }\n\n    // 方式3    DriverManager统一管理驱动\n    @Test\n    public void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);//注册驱动\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接3==\"+connection);\n        connection.close();\n    }\n\n    // 方式4    DriverManager统一管理驱动\n    @Test\n    public void connect04() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接4==\"+connection);\n        connection.close();\n    }\n\n    // 方式5    DriverManager统一管理驱动\n    @Test\n    public void connect05() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n//        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");  // jdbc4+ 和 mysql5.1.6+ 就会自动到驱动包里自动加载驱动名,不过还是建议加上!!!\n//        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接5==\"+connection);\n        connection.close();\n    }\n}"
  },
  {
    "objectID": "contact_me/LNK1104错误 无法打开文件“xxx.lib“和查看所有宏定义$xxxx/index.html",
    "href": "contact_me/LNK1104错误 无法打开文件“xxx.lib“和查看所有宏定义$xxxx/index.html",
    "title": "LNK1104错误 无法打开文件“xxx.lib“和查看所有宏定义$xxxx",
    "section": "",
    "text": "## 查看所有宏定义$xxxx"
  },
  {
    "objectID": "posts/javaGUI--浮动布局(FlowLayOut)/index.html",
    "href": "posts/javaGUI--浮动布局(FlowLayOut)/index.html",
    "title": "javaGUI–浮动布局(FlowLayOut)",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestFlowLayOut {\n\n    public static void main(String[] args) {\n        // 窗口\n        Frame frame = new Frame(\"myFlowLayOut\");\n\n        // 按钮\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n\n        frame.setSize(350,350);\n        frame.setVisible(true);\n\n        // 设置流失布局(默认居中)\n        frame.setLayout(new FlowLayout());\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.add(button4);\n    }\n}\n\n\n\n在这里插入图片描述\n\n\n// 左对齐(右对齐......)\nframe.setLayout(new FlowLayout(FlowLayout.LEFT));\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/linux--创建用户修改&修改密码/index.html",
    "href": "posts/linux--创建用户修改&修改密码/index.html",
    "title": "linux–创建用户修改&修改密码",
    "section": "",
    "text": "创建用户\nadduser amdin\n修改密码\nbash-4.2# passwd admin\nChanging password for user admin.\nNew password: \nBAD PASSWORD: The password is a palindrome\nRetype new password: \npasswd: all authentication tokens updated successfully.\n注销\nlogout\n创建用户,并分配组\nadduser -g 组名 用户名\npasswd 用户名\n创建组\ngroupadd 组名\n例子\n修改a.txt从root组分到b组\ntouch a.txt\ngroupadd b\nchgrp b a.txt"
  },
  {
    "objectID": "posts/设置Caps_Lock和Esc交换/index.html",
    "href": "posts/设置Caps_Lock和Esc交换/index.html",
    "title": "设置Caps_Lock和Esc交换",
    "section": "",
    "text": "设置Caps_Lock和Esc交换\nxmodmap xmodmap 的wiki\n\n\narch上直接在设置中就有, arch使用xmodmap还会冲突"
  },
  {
    "objectID": "posts/javaArrayList作业二/index.html",
    "href": "posts/javaArrayList作业二/index.html",
    "title": "javaArrayList作业二",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 12:40\n */\npublic class CarDemo {\n\n    public static void main(String[] args) {\n        Car car1 = new Car(\"宝马\", 4000000);\n        Car car2 = new Car(\"宾利\", 5000000);\n\n        ArrayList<Car> cars = new ArrayList<>();\n        cars.add(car1);\n        cars.add(car2);\n        System.out.println(cars);\n\n        cars.remove(car2);// 删除\n        System.out.println(cars.contains(car1));\n\n        System.out.println(cars.size());//长度\n        System.out.println(cars.isEmpty());//判断空\n        cars.clear();// 清空\n        System.out.println(cars);\n\n        ArrayList<Car> cars1 = new ArrayList<>();\n        cars1.add(new Car(\"大众\",150000));\n        cars1.add(new Car(\"法拉利\",150000));\n        cars.addAll(cars1);// 添加多个\n        cars.addAll(cars1);\n        System.out.println(cars);\n\n        cars.add(car1);\n        System.out.println(cars);\n\n        System.out.println(cars.containsAll(cars1));// 包含多个\n\n        //cars.removeAll(cars1);// 删除列表中的所有\n        //System.out.println(cars);\n\n        // for遍历\n        System.out.println(\"=================for遍历=============\");\n        for (Car car : cars) {\n            System.out.println(car);\n        }\n\n        \n        System.out.println(\"=================迭代器遍历=============\");\n        // 迭代器遍历\n        Iterator<Car> iterator = cars.iterator();\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n\n    }\n}\n\nclass Car{\n    private String name;\n    private double price;\n\n    public Car() {\n    }\n\n    public Car(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java网络编程-- IP地址/index.html",
    "href": "posts/java网络编程-- IP地址/index.html",
    "title": "java网络编程– IP地址",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class TestInetAddress {\n    public static void main(String[] args) {\n        try {\n            // 获取本机地址\n            InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\");\n            System.out.println(inetAddress);\n\n            InetAddress inetAddress02 = InetAddress.getByName(\"localhost\");\n            System.out.println(inetAddress02);\n\n            InetAddress inetAddress03 = InetAddress.getLocalHost();\n            System.out.println(inetAddress03);\n\n            // 查询网络ip地址\n            InetAddress inetAddress01 = InetAddress.getByName(\"www.baidu.com\");\n            System.out.println(inetAddress01);\n\n            // 常用方法\n            //System.out.println(inetAddress01.getAddress()); 不常用\n            System.out.println(inetAddress01.getHostAddress());// ip地址\n            System.out.println(inetAddress01.getCanonicalHostName()); // 规范名字\n            System.out.println(inetAddress01.getHostName()); // 域名/主机名\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/matlab-coder/index.html",
    "href": "posts/matlab-coder/index.html",
    "title": "Matlab Coder",
    "section": "",
    "text": "matlab Coder 可以将matlab脚本转换为c or C++代码, 极大程度让用户专注算法的设计\n\n可以指定接口类型, 但是无法指定中间变量的类型\n在转换后注意tmwtypes.h和rtwtypes.h的include\n接口参数类型的指定\n\n\n\n\nfunction [data_MCA] = MultiChannelAverage(data_radar)\n% 输入data_radar: numADCSamples * 8\n% 输出data_MCA: numADCSamples * 1\n\ndata_MCA = mean(data_radar,2);\nend\n\n\n\n/*\n * File: MultiChannelAverage.c\n *\n * MATLAB Coder version            : 5.2\n * C/C++ source code generated on  : 29-Nov-2022 14:55:50\n */\n\n/* Include Files */\n#include \"MultiChannelAverage.h\"\n\n/* Function Definitions */\n/*\n * 输入data_radar: numADCSamples * 8\n *  输出data_MCA: numADCSamples * 1\n *\n * Arguments    : const cint16_T data_radar[1024]\n *                creal_T data_MCA[128]\n * Return Type  : void\n */\nvoid MultiChannelAverage(const cint16_T data_radar[1024], creal_T data_MCA[128])\n{\n  double ai;\n  double im;\n  double re;\n  int data_radar_re_tmp;\n  int k;\n  int xj;\n  int xoffset;\n  for (xj = 0; xj < 128; xj++) {\n    data_MCA[xj].re = data_radar[xj].re;\n    data_MCA[xj].im = data_radar[xj].im;\n  }\n  for (k = 0; k < 7; k++) {\n    xoffset = (k + 1) << 7;\n    for (xj = 0; xj < 128; xj++) {\n      data_radar_re_tmp = xoffset + xj;\n      data_MCA[xj].re += (double)data_radar[data_radar_re_tmp].re;\n      data_MCA[xj].im += (double)data_radar[data_radar_re_tmp].im;\n    }\n  }\n  for (xj = 0; xj < 128; xj++) {\n    im = data_MCA[xj].re;\n    ai = data_MCA[xj].im;\n    if (ai == 0.0) {\n      re = im / 8.0;\n      im = 0.0;\n    } else if (im == 0.0) {\n      re = 0.0;\n      im = ai / 8.0;\n    } else {\n      re = im / 8.0;\n      im = ai / 8.0;\n    }\n    data_MCA[xj].re = re;\n    data_MCA[xj].im = im;\n  }\n}\n\n/*\n * File trailer for MultiChannelAverage.c\n *\n * [EOF]\n */"
  },
  {
    "objectID": "posts/中科大源/index.html",
    "href": "posts/中科大源/index.html",
    "title": "中科大源",
    "section": "",
    "text": "地址\nhttps://mirrors.ustc.edu.cn/\n\n\n使用帮助文档\nhttps://mirrors.ustc.edu.cn/help/debian.html"
  },
  {
    "objectID": "posts/java EE请求转发（转发和重定向）/index.html",
    "href": "posts/java EE请求转发（转发和重定向）/index.html",
    "title": "java EE请求转发（转发和重定向）",
    "section": "",
    "text": "请求转发和请求重定向的区别是： 请求转发只有一次请求，请求重定向有两次请求。 # 1、 请求转发 方法实现 将RequestFrowardServlet里的company的值转发给ResaultServlet展示  域对象：在一定范围内可以存值和取值 request域对象：在一次请求中可以存值和取值。\n存值： request.setAttribute(String key, Object obj)\n取值： Object obj = request.getAttribute(String key, Object obj)\n删除值： request.removeAttRibute(String key)\nRequestFrowardServlet\n// 获取转发对象\nRequestDispatcher  rd = request.getRequestDispatcher(\"/resault\");\n// 调用转发方法，实现转发效果\nrequest.setAttribute(\"company\",\"abc公司\");\nrd.forward(request, response);\nResaultServlet\n// 处理响应中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取并转换获取的company所对应的的值\nString name = (String) request.getAttribute(\"company\");\n// 输出到页面\nresponse.getWriter().write(name);\n\n2、 请求重定向 方法实现\n将RequestFrowardServlet里的company的值转发给ResaultServlet展示 RequestFrowardServlet\n// 重定向\nresponse.sendRedirect(\"welcom\");\nResaultServlet\n// 处理响应中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取转发过来的参数\nString usr = request.getParameter(\"username\");\nString psd = request.getParameter(\"password\");\n// 打印参数\nresponse.getWriter().write(usr+\"<br>\");\nresponse.getWriter().write(psd+\"<br>\");"
  },
  {
    "objectID": "posts/java多线程-- 线程休眠(sleep)/index.html",
    "href": "posts/java多线程-- 线程休眠(sleep)/index.html",
    "title": "java多线程– 线程休眠(sleep)",
    "section": "",
    "text": "模拟延时,放大问题\n\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 模拟延时,放大问题\n * */\npublic class ThreadSleepDemo implements Runnable{\n    private int tickets =10; // 设置10张票\n\n    @Override\n    public void run() {\n        while (true){\n            if (tickets>0){\n                System.out.println(Thread.currentThread().getName()+\"拿到了票号-----+\"+tickets--);\n            }\n            else {\n                break;\n            }\n            try {\n                Thread.sleep(200);//模拟网络延迟200ms\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n\n    }\n\n    // 模拟三个人抢票\n    public static void main(String[] args) {\n        ThreadSleepDemo t = new ThreadSleepDemo();\n        new Thread(t,\"小红\").start();\n        new Thread(t,\"小明\").start();\n        new Thread(t,\"黄牛\").start();\n    }\n\n\n}"
  },
  {
    "objectID": "posts/arch没有wifi/index.html",
    "href": "posts/arch没有wifi/index.html",
    "title": "arch没有wifi",
    "section": "",
    "text": "确定自己安装了plasma-nm 1 #pacman -S networkmanager plasma-nm 2 #systemctl start NetworkManager 3 #systemctl enable NetworkManager"
  },
  {
    "objectID": "posts/pyqt5 --01简单继承关系/index.html",
    "href": "posts/pyqt5 --01简单继承关系/index.html",
    "title": "pyqt5 –01简单继承关系",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\napp = QApplication(sys.argv)# 创建一个应用（程序） sys.argv接受启动敞口 传递过来的参数\n\n\nwindow = QWidget() # QWidget()是程序内部的位置，不包括最大最小化的那个框\nwindow.setWindowTitle('这是标题')\nwindow.resize(600,500)  # 窗口大小\n\n\n# 按钮\nbtn = QPushButton(window)# 按钮继承了窗口，所以按钮在这个wedget中\nbtn.setText('按钮上的文字')\nbtn.resize(100,50)\nbtn.move(100,100)  # 位置按钮的左上角到widget左上角的位置\nbtn.setStyleSheet('background-color:red')# 样式，css样式的写法\n\n\nlabel = QLabel(window)\nlabel.setText('标签名')\nlabel.setStyleSheet('background-color:red')# 样式，css样式的写法\n\nlabel.show()\nwindow.show()\n\n# sys.exit()  接受程序结束代码号（检测代码退出原因）\nsys.exit(app.exec_())# app.exec_()消息循环功能\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 重定向的多种实现方法/index.html",
    "href": "posts/java EE 重定向的多种实现方法/index.html",
    "title": "java EE 重定向的多种实现方法",
    "section": "",
    "text": "// 重定向到'/myProject/login.html '\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"hello\");\n\n\n\n// 重定向到'/myProject/login.html '\nresponse.sendRedirect(\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.sendRedirect(\"hello\");"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html",
    "href": "posts/mysql8.0安装/index.html",
    "title": "mysql8.0安装",
    "section": "",
    "text": "在这里插入图片描述\n\n\n[mysqld]\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=D:\\environment\\mysql-8.0.27-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\environment\\mysql-8.0.27-winx64\\Data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n\n\n\n\n\n\nmysqld --initialize --console\n\n\n\n在这里插入图片描述\n\n\n\n\n\nmysqld --install\n 如果安装没成功：\nsc delete mysql\nmysqld --install\n\n\n\nnet start mysql\n\n\n\n在这里插入图片描述\n\n\n\n\n           username\nALTER user 'root'@'localhost' IDENTIFIED BY 'new password';\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/linux ssh长时间无操作断连/index.html",
    "href": "posts/linux ssh长时间无操作断连/index.html",
    "title": "linux ssh长时间无操作断连",
    "section": "",
    "text": "修改 vim /etc/ssh/sshd_config\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt线程问题(耗时操作)/index.html",
    "href": "posts/qt线程问题(耗时操作)/index.html",
    "title": "qt线程问题(耗时操作)",
    "section": "",
    "text": "qt多线程问题: 方法1: qtsignal 启动线程,避免界面卡死 方法2: 使用QApplication.processEvents() 方法3: 使用QThread"
  },
  {
    "objectID": "posts/java多线程-- join(线程插队,优先执行)/index.html",
    "href": "posts/java多线程-- join(线程插队,优先执行)/index.html",
    "title": "java多线程– join(线程插队,优先执行)",
    "section": "",
    "text": "使用join方法\n测试再main主线程执行的过程中 强行插入B线程\n测试结果是 main线程执行过程中,添加B线程,等待B线程执行完毕后,main线程接着执行\n一定要是这个顺序,\nthread.start();\nthread.join();\n注意start()和join的位置.很关键 \n\npackage cn.usts.edu.lesson06;\n\n/**\n * 使用join方法\n * 测试再main主线程执行的过程中  强行插入B线程\n *\n * 测试结果是 main线程执行过程中,添加B线程,等待B线程执行完毕后,main线程接着执行\n * \n * 一定要是这个顺序,\n * thread.start();\n * thread.join();\n * 注意start()和join的位置.很关键\n * */\n\npublic class ThreadJoinDemo implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadJoinDemo threadJoinDemo = new ThreadJoinDemo();\n        Thread thread = new Thread(threadJoinDemo,\"B线程\");\n\n        for (int i = 0; i < 200; i++) {\n            if (i==100){\n                    thread.start();// 线程启动\n                    thread.join();// 线程加入,main线程阻塞.等待B线程执行结束\n            }\n            System.out.println(\"main线程\"+i);\n        }\n    }\n}"
  },
  {
    "objectID": "posts/stm32--io口拉高还是拉低/index.html",
    "href": "posts/stm32--io口拉高还是拉低/index.html",
    "title": "stm32–io口拉高还是拉低",
    "section": "",
    "text": "https://zhuanlan.zhihu.com/p/458067480\n1.2GPIO_Mode_IPD (Pull-down):\n输入下拉就是把电压拉低，拉到GND。与上拉原理相似。\n\n简单的说，如果你希望你的引脚平时处于高电平用于检测低电平，你就使用Pull-up。\n\n如果你希望你的引脚平时处于低电平用于检测高电平，你就使用Pull-down。\n\n按键未按下时端口接低电平，即低电平 0 状态---0v\n\n按键按下时端口接高电平，即高电平 1 状态------3.3v"
  },
  {
    "objectID": "posts/linux键盘f1-f12功能键盘失效/index.html",
    "href": "posts/linux键盘f1-f12功能键盘失效/index.html",
    "title": "linux键盘f1-f12功能键盘失效",
    "section": "",
    "text": "echo 0 | sudo tee /sys/module/hid_apple/parameters/fnmode\n\necho \"options hid_apple fnmode=0\" | sudo tee -a /etc/modprobe.d/hid_apple.conf\n\nsudo update-initramfs -u    //Ubuntu\nsudo mkinitcpio -P          //ArchLinux\n参考：https://www.cnblogs.com/orochihuang/p/15193699.html"
  },
  {
    "objectID": "posts/三步简单解决3306端口占用问题（windows）/index.html",
    "href": "posts/三步简单解决3306端口占用问题（windows）/index.html",
    "title": "三步简单解决3306端口占用问题（windows）",
    "section": "",
    "text": "一、查看占用3306端口的进程\n其他端口参照3306\nnetstat  -aon|findstr 3306\n二、记住这个pid号 三、ctrl +shift+esc调出任务管理器\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html",
    "href": "posts/算法 --0_算法是什么/index.html",
    "title": "算法 –0_算法是什么",
    "section": "",
    "text": "算法听起来很神秘(高级),其实算法就是去做一件事情的方法,顺序,一个问题按照什么顺序(方法)去求解是最优的"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html#例子1",
    "href": "posts/算法 --0_算法是什么/index.html#例子1",
    "title": "算法 –0_算法是什么",
    "section": "例子1:",
    "text": "例子1:\n外面下雨了,房间里的水开了,电话响了,衣服还没收\n遇到这些事情怎么做才是最优解,每个人都有不同的答案,取决于每个人的需求"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html#例子2",
    "href": "posts/算法 --0_算法是什么/index.html#例子2",
    "title": "算法 –0_算法是什么",
    "section": "例子2:",
    "text": "例子2:\n淘米,切菜,蒸饭,炒菜 这些事情怎么安排\n大多数人的选怎是:  淘米-->蒸饭\n                        -->切菜\n                        -->炒菜\n因为在蒸饭的同是我们可以切菜炒菜,所以这样的顺序是一个大多数的情况,这就叫算法"
  },
  {
    "objectID": "posts/java多线程-- thread.setDaemon(true) 守护线程简单实现/index.html",
    "href": "posts/java多线程-- thread.setDaemon(true) 守护线程简单实现/index.html",
    "title": "java多线程– thread.setDaemon(true) 守护线程简单实现",
    "section": "",
    "text": "守护线程 ,就是当有其他线程开启时,守护线程就一直开启\n守护线程会在所有线程结束后自动结束,\n\n模型: 人的生命有限 默认100年,上帝会一直存在,所以一直会守护着你\npackage cn.usts.edu.lesson06;\n\n/**\n * 守护线程 ,就是当有其他线程开启时,守护线程就一直开启\n * 守护线程会在所有线程结束后自动结束\n * */\n\npublic class DaemonTest {\n    public static void main(String[] args) {\n        God god = new God();\n        You you = new You();\n        Thread godThread = new Thread(god);\n        godThread.setDaemon(true);// 默认是普通用户线程  默认值是false   true表示开启守护线程\n        godThread.start();//守护线程启动\n\n        Thread youThread = new Thread(you);\n        youThread.start();\n    }\n    \n}\n\nclass God implements Runnable{\n\n    @Override\n    public void run() {\n        while (true){ // 理论上是一直执行,可是当所有线程结束的时候他也会结束.\n            System.out.println(\"上帝一直在守护你\");\n        }\n    }\n}\n\nclass You implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 36500; i++) {\n            System.out.println(\"快乐的一天\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--窗口事件监听/index.html",
    "href": "posts/javaGUI--窗口事件监听/index.html",
    "title": "javaGUI–窗口事件监听",
    "section": "",
    "text": "窗口事件监听 常用的就是窗口激活和窗口关闭,两个事件的监听.\n写法1:(推荐)匿名内部类\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindowsListener {\n    public static void main(String[] args) {\n        new WindowsListenerFrame();\n    }\n}\n\n\nclass WindowsListenerFrame extends Frame{\n    public WindowsListenerFrame() {\n        setBounds(200,200,400,200);\n        setVisible(true);\n        // 匿名内部类\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                setVisible(false);// 隐藏窗口\n            }\n        });\n\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowActivated(WindowEvent e) {\n                WindowsListenerFrame windowsListenerFrame = (WindowsListenerFrame) e.getSource();\n                windowsListenerFrame.setTitle(\"被激活了\");\n            }\n        });\n\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowDeactivated(WindowEvent e) {\n                WindowsListenerFrame source = (WindowsListenerFrame) e.getSource();\n                source.setTitle(\"没有被激活\");\n            }\n        });\n    }\n\n}\n写法2:内部类\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindowsListener {\n    public static void main(String[] args) {\n        new WindowsListenerFrame();\n    }\n}\n\n\nclass WindowsListenerFrame extends Frame{\n    public WindowsListenerFrame() {\n        setBounds(200,200,200,200);\n        setVisible(true);\n        addWindowListener(new MyWindowsListenerFrame());\n    }\n    \n    // 内部类\n    class MyWindowsListenerFrame extends WindowAdapter{\n        @Override\n        public void windowClosing(WindowEvent e) {\n            setVisible(false);// 点击关闭窗口就是隐藏了,不是结束程序,程序还在后台运行\n            //System.exit(0);  // 正常的点击x结束程序的语句\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 静态代理(简单剖析)/index.html",
    "href": "posts/java多线程-- 静态代理(简单剖析)/index.html",
    "title": "java多线程– 静态代理(简单剖析)",
    "section": "",
    "text": "静态代理 * 就是创建一个A对象代替B对象去干活, * 把认为不重要的事情交给A(代理)去做 * 到主要时候换B上厂,有点明星请替身的滋味\npackage cn.usts.edu.lesson04;\n\n/**\n * 静态代理\n * 就是创建一个A对象代替B对象去干活, \n * 把认为不重要的事情交给A(代理)去做\n * 到主要时候换B上厂,有点明星请替身的滋味\n * */\n\ninterface Marry{\n    void doMarry(String name);\n}\n\n// 你去实现Marry接口\nclass You implements Marry{\n    @Override\n    public void doMarry(String name) {\n        System.out.println(name+\"结婚啦\");\n    }\n}\n\n// 婚庆公司 也实现结婚接口\nclass WeddingCompany implements Marry{\n    private Marry target;// 代理的目标 [帮谁代理结婚的]\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    public void before(){\n        System.out.println(\"布置现场\");\n    }\n\n    public void after(){\n        System.out.println(\"收尾款\");\n    }\n\n    @Override\n    public void doMarry(String name) {\n        this.before();\n        this.target.doMarry(name);\n        this.after();\n    }\n}\n\n// 主体类\npublic class staticProxy {\n    public static void main(String[] args) {\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.doMarry(\"小明\");\n    }\n}"
  },
  {
    "objectID": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html",
    "href": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html",
    "title": "java EE 一行代码实现定时刷新，定时跳转",
    "section": "",
    "text": "response.addHeader(\"Refresh\",\"【跳转时间】;url=/【项目名】/【跳转页面名】.html\")\n//例：定时5秒跳转到myProject中的hello.html页面\nresponse.addHeader(\"Refresh\",\"5;url=/myProject/hello.html\")"
  },
  {
    "objectID": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时刷新",
    "href": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时刷新",
    "title": "java EE 一行代码实现定时刷新，定时跳转",
    "section": "2、定时刷新",
    "text": "2、定时刷新\nresponse.addHeader(\"Refresh\",\"【刷新时间】\")\n// 每5秒钟刷新一下页面\nresponse.addHeader(\"Refresh\",'5')"
  },
  {
    "objectID": "posts/树莓派开箱点亮(无屏幕)/index.html",
    "href": "posts/树莓派开箱点亮(无屏幕)/index.html",
    "title": "树莓派开箱点亮(无屏幕)",
    "section": "",
    "text": "树莓派4B\n系统下载连接(64bit):https://downloads.raspberrypi.org/raspios_arm64_latest # 解压下载的系统: 得到xxx.img  # 打开写盘工具 win32disk: https://www.onlinedown.net/iopdfbhjl/110173?module=download&t=website 选中解压好的img文件  # 配置wifi信息  ### 进入到boot分区: 右键新建文件: wpa_supplicant.conf\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n \nnetwork={\nssid=\"WIFI名字\"\npsk=\"密码\"\n}\n\n\n配置ssh:(可以使用功能ssh连接树莓派)\n右键ssh文件: ssh # 查看树莓派ip地址: 进入到路由器里面看192.168.0.1或者192.168.1.1(通常)根据品牌而定义 # 使用windows的ssh连接 ****打开cmd**** 输入 ssh pi@树莓派的ip地址\nssh pi@192.168.0.111\n输入密码"
  },
  {
    "objectID": "posts/java多线程--ReentrantLock ( Lock上锁 _ 解锁 )/index.html",
    "href": "posts/java多线程--ReentrantLock ( Lock上锁 _ 解锁 )/index.html",
    "title": "java多线程–ReentrantLock ( Lock上锁 _ 解锁 )",
    "section": "",
    "text": "Lock 的应用\n\n可重复性锁,相比传统的synchronized\nReentrantLock更直观,直观上锁解锁 \n\npackage cn.usts.edu.lesson08;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 可重复性锁,相比传统的synchronized\n * ReentrantLock更直观,直观上锁解锁\n * */\n\npublic class LockDemo implements Runnable{\n\n    private int tickets=10;\n\n    private final ReentrantLock lock = new ReentrantLock(); // 实例化锁\n\n    public static void main(String[] args) {\n        LockDemo lockDemo = new LockDemo();\n        new Thread(lockDemo).start();\n        new Thread(lockDemo).start();\n        new Thread(lockDemo).start();\n    }\n\n\n\n    @Override\n    public void run() {\n\n        try {\n            lock.lock();// 上锁\n\n            while (true){\n                if (tickets>0){\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(tickets--);\n                }\n                else {\n                    break;\n                }\n            }\n        }finally {\n            lock.unlock();// 解锁\n        }\n\n    }\n}"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html",
    "href": "posts/shell脚本批量创建多个用户/index.html",
    "title": "shell脚本批量创建多个用户",
    "section": "",
    "text": "执行以下命令\nvim adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "href": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "title": "shell脚本批量创建多个用户",
    "section": "2、编写shell代码",
    "text": "2、编写shell代码\n#! /bin/bash\n#filename:add_user\ni=1\ngroupadd user1\nwhile [ $i -le 20 ]\ndo\n        if [ $i -le 9 ]; then\n                USERNAME=student0${i}\n        else\n                USERNAME=student${i}\n        fi\n        useradd $USERNAME\n        mkdir /home/$USERNAME\n        chown -R $USERNAME /home/$USERNAME\n        chgrp -R user1 /home/$USERNAME\n        i=$(($i+1))\ndone"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "href": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "title": "shell脚本批量创建多个用户",
    "section": "3、赋权",
    "text": "3、赋权\nchmod u+x adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#执行",
    "href": "posts/shell脚本批量创建多个用户/index.html#执行",
    "title": "shell脚本批量创建多个用户",
    "section": "4、执行",
    "text": "4、执行\n创建用户需要管理员权限，需要加上sudo\nsudo ./adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "href": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "title": "shell脚本批量创建多个用户",
    "section": "99、运行结果",
    "text": "99、运行结果\n查看是否创建成功\ncat /etc/passwd\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 统一编码方式防止中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取请求方法\nString method = request.getMethod();\n\n\n\n// 获取请求的协议\nString protocol = request.getProtocol();\n\n\n\n// 获取项目名称\nString conttextPath = request.getContextPath();\n        \n\n\n\n// 获取servlet路径\nString servletPath = request.getServletPath();      \n\n\n\n// 获取请求路径\nString requestURI = request.getRequestURI();\nString requestURL = request.getRequestURL().toString();\n\n\n\nresponse.getWriter().write(\"请求方法：\"+method+\"<br>\");\nresponse.getWriter().write(\"请求协议：\"+protocol+\"<br>\");\nresponse.getWriter().write(\"请求项目名称：\"+conttextPath+\"<br>\");\nresponse.getWriter().write(\"请求servlet路径：\"+servletPath+\"<br>\");\nresponse.getWriter().write(\"请求路径URI：\"+requestURI+\"<br>\");\nresponse.getWriter().write(\"请求路径URL：\"+requestURL+\"<br>\");\n # 2、常用请求头中信息获取的方法\n\n\n\n// 请求头信息获取\n        \nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取所有的消息头名称\nEnumeration<String> er = request.getHeaderNames();\n// 遍历\nwhile(er.hasMoreElements()){\n// 3、获取消息头\n    String name = er.nextElement();\n    // 4、获取消息头对应值\n    String value = request.getHeader(name);\n    esponse.getWriter().write(\"消息头：\"+name+\" \"+value+\"<br>\");\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n// 获取请求头中的\"user-agent\"对应的值\nString value = request.getHeader(\"user-agent\");\nresponse.getWriter().write(value);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值-1",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值-1",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.1 获取值",
    "text": "3.1 获取值\n// 根据name属性值获取用户输入的值\nString value = request.getParamerter(\"name属性对应的值\");\n\n// 根据name属性值 获取用户选择的值（复选框等）\nString[] values = request.getParamerterValues(\"name属性对应的值\");\n\n// 没有参数获取所有值\nmap<String, String[]> map = request.getParamerterMap();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#测试",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#测试",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.2 测试",
    "text": "3.2 测试\nresponse.getWriter().write(\"username:\"+value+ \"<br>\");\nresponse.getWriter().write(\"password:\"+psd+ \"<br>\");\nresponse.getWriter().write(\"hobby:\"+Arrays.toString(hobby)+ \"<br>\");\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#form表单",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#form表单",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.3 form表单",
    "text": "3.3 form表单\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n                              \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n    <form action=\"/myProject/para\" method=\"GET\">\n        用户名：<input type=\"text\" name=\"username\"><br>\n        密  &nbsp;&nbsp;&nbsp;码：<input type=\"password\" name=\"password\"><br>\n        爱好：\n        <input type=\"checkbox\" name=\"hobby\" value=\"sing\">唱歌\n        <input type=\"checkbox\" name=\"hobby\" value=\"dance\">跳舞\n        <input type=\"checkbox\" name=\"hobby\" value=\"football\">足球<br>\n        <input type=\"submit\" value=\"提交\">\n    </form>\n</body>\n</html>\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "href": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "title": "qtQByteArry以二进制写入多n个字节",
    "section": "",
    "text": "问题描述\n使用qt串口接收数据，将数据保存成二进制数数据数据中会有多出的字节。但是将数据存储为文本模式（ascii字符·txt·）时没有问题，数据量正确。 # 原因 是因为QByteArry在写入文件时，会默认加上个长度字节，在原始数据中。\n\n\n解决方案\n使用QDataStream进行写入\nQFile qfile_save_adc_bin(\"./out/file.bin\"); \nQDataStream out_adc(&qfile_save_adc_bin);\n\n# 串口接收数据\nQByteArray data_serial = serialRead->readAll();\n# 写入\nout_adc.writeRawData(data_serial,data_serial.size());\nqfile_save_adc_bin.close(); // 关闭文件"
  },
  {
    "objectID": "posts/linux-- linux忘记密码(修改root密码)/index.html",
    "href": "posts/linux-- linux忘记密码(修改root密码)/index.html",
    "title": "linux– linux忘记密码(修改root密码)",
    "section": "",
    "text": "在这里插入图片描述\n\n\n ## 2.在这里输入init = /bin/sh 进入单用户状态  ## 3.按ctrl+x进入单用户模式 接着，在光标闪烁的位置中输入: mount -o remount,rw /(注意:各个单词间有空格,中间的逗号)，完成后按键盘的回车键(Enter)。  ## 4.在新的一行最后面输入: passwd 完成后按键盘的回车键（Enter)。输入密码，然后再次确认密码即可(密码长度最好8位以上,但不是必须的)。密码修改成功后，会显示passw…..的样式，说明密码修改成功\n\n\n\n(注意: touch与 /后面有一个空格)，完成后按键盘的回车键 ## 7.继续在光标闪烁的位置中，输入：exec /sbin/init(注意：exec与/后面有一个空格)，完成后按键盘的回车键(Enter)， 等待系统自动修改密码(这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启,新的密码生效了"
  },
  {
    "objectID": "posts/清除html和css标签自带的默认样式/index.html",
    "href": "posts/清除html和css标签自带的默认样式/index.html",
    "title": "清除html和css标签自带的默认样式",
    "section": "",
    "text": "在我们编写前端页面的时候，html和css标签有时候会自带一些格式，我们一般习惯性把自带格式全部清除，在需要的时候再自己写上，这样代码的可读性更加的高，也不会把自己搞混淆。\nhtml{color:#000;background:#FFF;} \nbody,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td { \nmargin:0; \npadding:0; \n} \ntable { \nborder-collapse:collapse; \nborder-spacing:0; \n} \nfieldset,img { \nborder:0; \n} \naddress,caption,cite,code,dfn,em,strong,th,var { \nfont-style:normal; \nfont-weight:normal; \n} \nol,ul { \nlist-style:none; \n} \ncaption,th { \ntext-align:left; \n} \nh1,h2,h3,h4,h5,h6 { \nfont-size:100%; \nfont-weight:normal; \n} \nq:before,q:after { \ncontent:''; \n} \nabbr,acronym { border:0; \n}"
  },
  {
    "objectID": "posts/pip加速/index.html",
    "href": "posts/pip加速/index.html",
    "title": "pip加速",
    "section": "",
    "text": "pip加速\n清华镜像站使用 https://mirrors.tuna.tsinghua.edu.cn/help/pypi/"
  },
  {
    "objectID": "posts/java注解和反射-- 内置注解/index.html",
    "href": "posts/java注解和反射-- 内置注解/index.html",
    "title": "java注解和反射– 内置注解",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.InnerAnnotation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 内置注解\n * */\npublic class InnerAnnotation extends Object{\n\n    @Override  // 重写注解\n    public String toString() {\n        return \"重写的toString\";\n    }\n\n    @Deprecated // 不推荐程序员使用,或者有更好的方法\n    public void test01(){\n        System.out.println(\"test01\");\n    }\n\n    @SuppressWarnings(\"all\") // 镇压警告\n    public void test02(){\n        List list = new ArrayList(); // 要不然这里会警告\n        System.out.println(\"test03\");\n    }\n\n    public static void main(String[] args) {\n        InnerAnnotation innerAnnotation = new InnerAnnotation();\n        innerAnnotation.test01();\n    }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程管理/index.html",
    "href": "posts/stm32F103-RT-Thread线程管理/index.html",
    "title": "stm32F103-RT-Thread线程管理",
    "section": "",
    "text": "系统总共支持 256 个优先 (0 ~ 255，数值越小的优先级越高，0 为最高优先级，255 分配给空闲线程使用,默认优先级32个，一般用户不使用)。\n\n在一些资源比较紧张的系统中，可以根据实,际情况选择只支持 8 个或 32 个优先级的系统配置。\n\n\n在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行\n\n\nRT-Thread 内核中也允许创建相同优先级的线程。相同优先级的线程采用时间片轮转方式进行调 度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪线程存在 的情况下才有效。\n\n\n\n/*********************key1挂起线程,key2恢复线程*********************/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;               // thread1 control block\nstatic rt_thread_t led2_thread = RT_NULL;               // thread2 control block\nstatic rt_thread_t pause_thread = RT_NULL;              // thread3 control block\n\nstatic rt_thread_t send_thread = RT_NULL;               // message queue send thread\nstatic rt_thread_t receive_thread = RT_NULL;            // messge queue receive thread\n\nint count = 0;\n\n\n\n\n\n\n\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\nstatic void pause_thread_entry(void *parameter);\n\n/*\n*************************************************************************\n*                             main ����\n*************************************************************************\n*/\n/**\n * @brief  ������\n * @param  ��\n * @retval ��\n */\nint main(void)\n{\n    \n    // if (led1_thread != RT_NULL)\n    //  rt_thread_startup(led1_thread);\n    // else\n    //  return -1;\n\n\n\n    // thread 2\n    // led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    // if (led2_thread != RT_NULL)\n    //  rt_thread_startup(led2_thread);\n    // else\n    //  return -1;\n\n    // thread 3 [pause thread]\n    pause_thread = rt_thread_create(\"pause\", pause_thread_entry,RT_NULL,512,2,20);\n    if(pause_thread != RT_NULL){\n        rt_thread_startup(pause_thread);\n    }\n    else{\n        return -1;\n    }\n    \n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED1_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[1], Red  --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[2], Green --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void pause_thread_entry(void *parameter)\n{\n    rt_err_t uwRet_1 = RT_EOK; // monitor the status\n\n    while (1)\n    {\n        \n        if (Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_suspend(led1_thread); /* �0�1�0�6�0�4�0�8LED1�0�3�0�8�0�6�0�0 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[suspend-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[suspend-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n\n        \n\n        if (Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_resume(led1_thread); /* �0�3�0�0�0�0�0�7LED1�0�3�0�8�0�6�0�0�0�5�0�3 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[resume-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[resume-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n      rt_thread_delay(20);\n    }\n}"
  },
  {
    "objectID": "posts/算法-- 1_递归/index.html",
    "href": "posts/算法-- 1_递归/index.html",
    "title": "算法– 1_递归",
    "section": "",
    "text": "递归就是所谓的套娃但是这个套娃是有前提的,要有终止的条件,不能无尽的套娃"
  },
  {
    "objectID": "posts/算法-- 1_递归/index.html#递归的例子",
    "href": "posts/算法-- 1_递归/index.html#递归的例子",
    "title": "算法– 1_递归",
    "section": "递归的例子",
    "text": "递归的例子\n# -*- coding: utf-8 -*-\n# @Time : 2021/11/28 16:08\n\n\ndef r1(n):\n    if n > 0:\n        r1(n - 1)\n        print(n)\n\n\ndef r2(n):\n    if n > 0:\n        print(n)\n        r1(n - 1)\n\n\nr1(3)\nprint('-------------')\nr2(3)\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/TI_js脚本自动调试/index.html",
    "href": "posts/TI_js脚本自动调试/index.html",
    "title": "TI_js脚本自动调试",
    "section": "",
    "text": "脚本执行\n手动创建调试器1642.xml 修改执行脚本ccsdebug.js - 修改脚本中的工作区 - 修改脚本中的项目位置, 和编译后的img位置\n\n\n\n\n在这里插入图片描述\n\n\nccsdebug.js\n// Import the DSS packages into our namespace to save on typing\n\nimportPackage(Packages.com.ti.debug.engine.scripting);\n\nimportPackage(Packages.com.ti.ccstudio.scripting.environment);\n\nimportPackage(Packages.java.lang);\n\nimportPackage(Packages.java.io);\n\n\n\nfunction run_test(){\n//*******User must specify WORKSPACE_DIR***********\n\nvar WORKSPACE_DIR = \"D:/project/board/workspace_v10/\";\n\n//*******User must specify WORKSPACE_DIR***********\n\nvar PROJECT_DIR = WORKSPACE_DIR+\"sdk_demo/\";\n\nvar R4F_OUT_FILE_PATH = PROJECT_DIR+\"mmw_mss_16xx/Debug/xwr16xx_mmw_mss.xer4f\";\n\nvar DSS_OUT_FILE_PATH = PROJECT_DIR+\"mmw_dss_16xx/Debug/xwr16xx_mmw_dss.xe674\";\n\nvar CCS_TARGET_CONFIGURATION_FILE = \"AWR1642.ccxml\";\n\nvar script = ScriptingEnvironment.instance();\n\n//script.traceBegin(\"BreakpointsTestLog.xml\", \"DefaultStylesheet.xsl\");\n//script.traceSetConsoleLevel(TraceLevel.ALL);\n//script.traceSetFileLevel(TraceLevel.ALL);\n\n\nscript.setCurrentDirectory(PROJECT_DIR);\ndebugServer = script.getServer(\"DebugServer.1\");\n\n\ndebugServer.setConfig(CCS_TARGET_CONFIGURATION_FILE);\n\n\n// debug session R4F\nprint(\"Debug session R4F...\");\ndebugSession_MSS = debugServer.openSession(\"*\",\"Cortex_R4_0\");\nprint(\"Connecting to R4F Core...\");\ndebugSession_MSS.target.connect();\ndebugSession_MSS.target.reset();\nprint(\"Done.\");\n\n\n\n\n// debug session C674x\nprint(\"Debug session C674x...\");\ndebugSession_DSS = debugServer.openSession(\"*\",\"C674X_0\");\nprint(\"Connecting to C674x Core...\");\ndebugSession_DSS.target.connect();\ndebugSession_DSS.target.reset();\nprint(\"Done.\");\n\n\n// Loading program - R4F...\nprint(\"Loading program - R4F...\");\ndebugSession_MSS.memory.loadProgram(R4F_OUT_FILE_PATH);\nprint(\"load R4F Done.\");\n\n// Loading program - C674x...\nprint(\"Loading program - C674x...\");\ndebugSession_DSS.memory.loadProgram(DSS_OUT_FILE_PATH);\nprint(\"Loading C674x Done.\");\n\n// run target\nvar dsArray = new Array();\ndsArray[0] = debugSession_MSS;\ndsArray[1] = debugSession_DSS;\n\n//debugServer.simultaneous.run(dsArray); // Run CPUs 1 and 2\nprint(\"please click run...\");\n//debugServer.stop();\n\n//script.traceEnd();\n}\n\nhotmenu.addJSFunction(\"Run Test\",\"run_test()\");\n\nView ->Scripting Console\n\n\n\n在这里插入图片描述\n\n\n\n在终端中输入以下指令,根据脚本所在位置填写脚本\n// 脚本位置\nloadJSFile \"D:\\project\\board\\workspace_v10\\sdk_demo\\ccsdebug.js\"\n >## 点击script,然后运行脚本 \n\n程序启动需手动点击run按钮\n\n > ## 断点调试 > 需要设置hardware breakpoint, 普通的断点无法在mss上停止. 然后就可查看到变量和单步调试了\n 稍微高级点的用法可以查看tools里面的工具"
  },
  {
    "objectID": "posts/vs studio添加include和依赖库/index.html",
    "href": "posts/vs studio添加include和依赖库/index.html",
    "title": "vs studio添加include和依赖库",
    "section": "",
    "text": "无法打开 源 文件 “xxxxxx”\n解决办法: 添加include文件夹\n\n\n\n在这里插入图片描述\n\n\n项目右键属性,c/c++,添加附加包含目录, 找到你所需要的头文件的位置,\n\n\n\n在这里插入图片描述\n\n\n添加lib库: * 链接器->常规->附加库目录->\n\n\n链接器->输入->附加依赖->输入需要的依赖项.\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "href": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "title": "qt –问题总结(头文件问题,QString转换,查找组件)",
    "section": "",
    "text": "项目问题解决\n在使用过程中无法使用控件的大多数原因就是因为没有在.h文件中创建方法. 只有集成的类中才会有组件,单独的cpp中没有组件.所以会报错.如果已经使用继承类,已经可以跳转.但是还是报错,大多刷新解决方案即可.  ### 查找QObject\n  QString objectNameBtn = sender()->objectName();\n    QPushButton *tempButton = this->findChild<QPushButton *>(objectNameBtn);\n\n字符串转换QString < == > std::string\nQString qstr;\nstd::string str;\n//===============================\n//QString转std::string\nstr = qstr.toStdString();\n//===============================\n//std::string转QString\nqstr = QString::fromStdString(str);\n\n\n找到父对象控件\nparent , parentWidget, setParent\nuserFrame->parentWidget()->setWindowFlags(Qt::WindowMinMaxButtonsHint);\n// 用管道符添加多个属性\nuserFrame->parentWidget()->setWindowFlags(Qt::Dialog|Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint);\n\n\n找到子组件\nfindChild,findChildren ### windowFlags参数 原文:https://blog.csdn.net/xuebing1995/article/details/96478891\nQt::Widget               //是一个窗口或部件，有父窗口就是部件，没有就是窗口\nQt::Window               //是一个窗口，有窗口边框和标题\nQt::Dialog               //是一个对话框窗口\nQt::Sheet                //是一个窗口或部件Macintosh表单\nQt::Drawer               //是一个窗口或部件Macintosh抽屉，去掉窗口左上角的图标\nQt::Popup                //是一个弹出式顶层窗口\nQt::Tool                 //是一个工具窗口\nQt::ToolTip              //是一个提示窗口，没有标题栏和窗口边框\nQt::SplashScreen         //是一个欢迎窗口，是QSplashScreen构造函数的默认值\nQt::Desktop              //是一个桌面窗口或部件\nQt::SubWindow            //是一个子窗口\n\n窗口属性\nQt::CustomizeWindowHint          //关闭默认窗口标题提示\nQt::WindowTitleHint              //为窗口修饰一个标题栏\nQt::WindowSystemMenuHint         //为窗口修饰一个窗口菜单系统\nQt::WindowMinimizeButtonHint     //为窗口添加最小化按钮\nQt::WindowMaximizeButtonHint     //为窗口添加最大化按钮\nQt::WindowMinMaxButtonsHint      //为窗口添加最大化和最小化按钮\nQt::WindowCloseButtonHint           //窗口只有一个关闭按钮\nQt::WindowContextHelpButtonHint\nQt::MacWindowToolBarButtonHint\nQt::WindowFullscreenButtonHint\nQt::BypassGraphicsProxyWidget\nQt::WindowShadeButtonHint\nQt::WindowStaysOnTopHint    //总在最上面的窗口,置前\nQt::WindowStaysOnBottomHint\nQt::WindowOkButtonHint\nQt::WindowCancelButtonHint\nQt::WindowTransparentForInput"
  },
  {
    "objectID": "posts/java网络编程-- 通信协议/index.html",
    "href": "posts/java网络编程-- 通信协议/index.html",
    "title": "java网络编程– 通信协议",
    "section": "",
    "text": "通信协议就像是信封上（数据包内）约定好的地址（通信）格式，按照指定的格式填写信息就能将信件准确的送达到你想送达的地址，否则邮递员（计算机）无法识别。 【协议】≈【约定】 理想化的7层模型，现实中用的4层模型  主要的还是TCP/IP协议簇 TCP/IP协议簇：是一组协议\n\nTCP：用户传输协议\nUDP：无连接的传输协议\nIP：网络互联协议\n\ntcp：稳定，三次握手，四次挥手 【打电话】 三次握手 |铁蛋(主机A)|翠花 (主机B) | |–|–| | 谁是翠花 | | || 我是翠花，是铁蛋在叫我吗 | | 是的 | | 四次挥手 |主机A| 主机B | |–|–| | 我要拔网线了 | | | | 行 | | | 我也要拔网线了 | |行 | | udp：响应快 【发短信】"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "href": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "title": "stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数",
    "section": "",
    "text": "在 RT-Thread 中，有一个打印函数 rt_kprintf() 供用户使用，方便在调试的时候输出各种信息。如果 要想使用 rt_kprintf()，则必须将控制台重映射到 rt_kprintf()，这个控制台可以是串口、CAN、USB、 以太网等输出设备，用的最多的就是串口，接下来我们讲解下如何将串口重定向到 rt_kprintf()。[参考野火F103]\n\n\n\n添加bsp_usart.c, bsp_usart.h\n\nbsp_usart.c\n#include \"bsp_usart.h\"\n\n /**\n  * @brief  配置嵌套向量中断控制器NVIC\n  * @param  无\n  * @retval 无\n  */\nstatic void NVIC_Configuration(void)\n{\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  /* 嵌套向量中断控制器组选择 */\n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  /* 配置USART为中断源 */\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  /* 抢断优先级*/\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\n  /* 子优先级 */\n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  /* 使能中断 */\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  /* 初始化配置NVIC */\n  NVIC_Init(&NVIC_InitStructure);\n}\n\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n  // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 串口中断优先级配置\n    NVIC_Configuration();\n    \n    // 使能串口接收中断\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);    \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);        \n}\n\n/*****************  发送一个字节 **********************/\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)\n{\n    /* 发送一个字节数据到USART */\n    USART_SendData(pUSARTx,ch);\n        \n    /* 等待发送数据寄存器为空 */\n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n/****************** 发送8位的数组 ************************/\nvoid Usart_SendArray( USART_TypeDef * pUSARTx, uint8_t *array, uint16_t num)\n{\n  uint8_t i;\n    \n    for(i=0; i<num; i++)\n  {\n        /* 发送一个字节数据到USART */\n        Usart_SendByte(pUSARTx,array[i]);   \n  \n  }\n    /* 等待发送完成 */\n    while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET);\n}\n\n/*****************  发送字符串 **********************/\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str)\n{\n    unsigned int k=0;\n  do \n  {\n      Usart_SendByte( pUSARTx, *(str + k) );\n      k++;\n  } while(*(str + k)!='\\0');\n  \n  /* 等待发送完成 */\n  while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET)\n  {}\n}\n\n/*****************  发送一个16位数 **********************/\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch)\n{\n    uint8_t temp_h, temp_l;\n    \n    /* 取出高八位 */\n    temp_h = (ch&0XFF00)>>8;\n    /* 取出低八位 */\n    temp_l = ch&0XFF;\n    \n    /* 发送高八位 */\n    USART_SendData(pUSARTx,temp_h); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);\n    \n    /* 发送低八位 */\n    USART_SendData(pUSARTx,temp_l); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n///重定向c库函数printf到串口，重定向后可使用printf函数\nint fputc(int ch, FILE *f)\n{\n        /* 发送一个字节数据到串口 */\n        USART_SendData(DEBUG_USARTx, (uint8_t) ch);\n        \n        /* 等待发送完毕 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);     \n    \n        return (ch);\n}\n\n///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\nint fgetc(FILE *f)\n{\n        /* 等待串口输入数据 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);\n\n        return (int)USART_ReceiveData(DEBUG_USARTx);\n}\n\n\n\nbsp_usart.h\n#ifndef __USART_H\n#define __USART_H\n\n\n#include \"stm32f10x.h\"\n#include <stdio.h>\n\n/** \n  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏\n    * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线\n    * 2-修改GPIO的宏\n  */\n    \n// 串口1-USART1\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n    \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define  DEBUG_USART_IRQ                USART1_IRQn\n#define  DEBUG_USART_IRQHandler         USART1_IRQHandler\n\n\n// 串口2-USART2\n//#define  DEBUG_USARTx                   USART2\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3\n\n//#define  DEBUG_USART_IRQ                USART2_IRQn\n//#define  DEBUG_USART_IRQHandler         USART2_IRQHandler\n\n// 串口3-USART3\n//#define  DEBUG_USARTx                   USART3\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART3\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOB   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOB\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                USART3_IRQn\n//#define  DEBUG_USART_IRQHandler         USART3_IRQHandler\n\n// 串口4-UART4\n//#define  DEBUG_USARTx                   UART4\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART4\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOC\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                UART4_IRQn\n//#define  DEBUG_USART_IRQHandler         UART4_IRQHandler\n\n\n// 串口5-UART5\n//#define  DEBUG_USARTx                   UART5\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART5\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOD\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2\n\n//#define  DEBUG_USART_IRQ                UART5_IRQn\n//#define  DEBUG_USART_IRQHandler         UART5_IRQHandler\n\n\nvoid USART_Config(void);\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch);\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str);\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch);\n\n#endif /* __USART_H */\n\n\n\n重构void rt_hw_console_output(const char *str)函数\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include <rthw.h>\n#include <rtthread.h>\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n    // 初始化串口\n    USART_Config();\n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}\n\n\n/**************************重写rtthread控制台输出, 通过串口发送*************************************/\nvoid rt_hw_console_output(const char *str)\n{\n    /*进入临界区*/\n    rt_enter_critical();\n\n    /* 直到将字符串发送完 */\n    while (*str != '\\0')\n    {\n        /* 换行 */\n        if (*str == '\\n')\n        {\n            USART_SendData(DEBUG_USARTx, '\\r');\n            while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n        }\n\n        USART_SendData(DEBUG_USARTx, *str++);\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n    }\n\n    /* 退出临界区 */\n    rt_exit_critical();\n}   \n  \n\n\n\n初始化串口配置\n\nboard.c\nUSART_Config();\n\n\n\n调用\n\nmian.c\n/**\n *********************************************************************\n * @file    main.c\n * @author  fire\n * @version V1.0\n * @date    2018-xx-xx\n * @brief   RT-Thread 3.0 + STM32 工程模版\n *********************************************************************\n * @attention\n *\n * 实验平台:野火 F103-指南者 STM32 开发板\n * 论坛    :http://www.firebbs.cn\n * 淘宝    :https://fire-stm32.taobao.com\n *\n **********************************************************************\n */\n\n/*\n*************************************************************************\n*                             包含的头文件\n*************************************************************************\n*/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n*/\n/**\n * @brief  主函数\n * @param  无\n * @retval 无\n */\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[1], Red\\r\\n\");\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[2], Green\\r\\n\");\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--Swing之[Dialog]弹窗/index.html",
    "href": "posts/javaGUI--Swing之[Dialog]弹窗/index.html",
    "title": "javaGUI–Swing之[Dialog]弹窗",
    "section": "",
    "text": "package cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class JDialogDemo extends JFrame {\n\n    JButton button01,button02,button03;\n\n    public JDialogDemo() {\n        this.setBounds(200,200,400,200);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 获取容器\n        Container container = this.getContentPane();\n        // 绝对布局\n        container.setLayout(null);\n\n        // 按钮\n        button01 = new JButton(\"点击弹出一个对话框\");\n        button01.setBounds(30,30,200,50);\n\n        // 按钮监听\n        button01.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // 弹窗\n                new MyDialogDemo();\n            }\n        });\n\n        this.add(button01);// 添加组件\n    }\n\n    public static void main(String[] args) {\n        new JDialogDemo();\n    }\n}\n\nclass MyDialogDemo extends JDialog{\n    public MyDialogDemo() {\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setTitle(\"hello\");\n        Container container = this.getContentPane();\n        container.setLayout(null);\n\n        JLabel jLabel = new JLabel(\"我的第一个弹窗\");\n        jLabel.setBounds(10,10,100,20);// label需要设置大小才能看的到\n        \n        container.add(jLabel);\n    }\n}"
  },
  {
    "objectID": "posts/TI_dsp入门-ti c660/index.html",
    "href": "posts/TI_dsp入门-ti c660/index.html",
    "title": "TI_dsp入门-ti c660",
    "section": "",
    "text": "dps分类: 都可以进行浮点数的预算 定点 : 无法使用硬件加速, 软件模拟, 性能消耗, 开发耗时(q格式) 浮点 :"
  },
  {
    "objectID": "posts/java网络编程-- URL（基本用法）/index.html",
    "href": "posts/java网络编程-- URL（基本用法）/index.html",
    "title": "java网络编程– URL（基本用法）",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * URL 统一资源定位符\n * 定位到网络中的资源\n * */\npublic class URLDemo {\n\n    public static void main(String[] args) throws MalformedURLException {\n        URL url = new URL(\"https://img-home.csdnimg.cn/images/20211019040101.gif?name=123\");\n        System.out.println(\"协议=\"+url.getProtocol());// 协议\n        System.out.println(\"主机ip=\"+url.getHost());// 主机ip\n        System.out.println(\"文件=\"+url.getPath());// 文件\n        System.out.println(\"全路径=\"+url.getFile());// 全路径\n        System.out.println(\"参数=\"+url.getQuery());// 参数\n\n    }\n}"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html",
    "href": "posts/电动车头盔检测系统(毕设)/index.html",
    "title": "电动车头盔检测系统(毕设)",
    "section": "",
    "text": "技术选型:\nyolov5+pyqt+mysql"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#信息采集",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#信息采集",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.1信息采集",
    "text": "1.1信息采集\n字段\n录入\n展示\n修改\n删除"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#实时检测报警",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#实时检测报警",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.2实时检测报警",
    "text": "1.2实时检测报警\n实时画面\n违章信息"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#视频留存管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#视频留存管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.3视频留存管理模块",
    "text": "1.3视频留存管理模块\n视频保存\n视频列表\n时间查询"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#工作人员管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#工作人员管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "2.1工作人员管理模块",
    "text": "2.1工作人员管理模块\n登陆面板\n人员管理:CRUD"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#违法信息管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#违法信息管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "2.2违法信息管理模块",
    "text": "2.2违法信息管理模块\n发送违章信息[ 时间, 地点, 原因 ]\n(违法信息通过电动车车牌追踪到人并打印通知单)\n方案1:邮件通知\n方案2:短信通知(推荐)"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread定时器/index.html",
    "href": "posts/stm32F103-RT-Thread定时器/index.html",
    "title": "stm32F103-RT-Thread定时器",
    "section": "",
    "text": "创建两个动态定时器，一个是单次定时，一个是周期性定时,并让周期定时器运行一段时间后停止运行 硬件定时器，定时器的回调函数将在系统时钟中断里调用。 软件定时器，定时器的回调函数将在定时器线程中调用。\n\n\n\n\n在这里插入图片描述\n\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nstatic rt_timer_t timer_1;\nstatic rt_timer_t timer_2;\nstatic int count_c = 0;\nstatic int short_c = 0;\n\n\nstatic void timeout_1(void *parameter);\nstatic void timeout_2(void *parameter);\n\n/* timer_1 is run 10 times then stop  */\nstatic void timeout_1(void *parameter){\n    \n    rt_kprintf(\"periodic timer_[1] is start. --> count is [%d]\\n\",count_c);\n    if(count_c++>=90){\n        rt_timer_stop(timer_1);\n        rt_kprintf(\"timer_[1] was stoped!\\n\");\n    }\n}\n\nstatic void timeout_2(void *parameter){\n    short_c++;\n    \n    rt_kprintf(\"short timer_[2] is start. -->short is [%d]\\n\", short_c);\n}\n\nint main(void)\n{\n    // create timer_1 and flag is periodic model\n    timer_1 = rt_timer_create(\"timer1\", timeout_1,RT_NULL,90,RT_TIMER_FLAG_PERIODIC);\n    \n    // create timer_2 and flag is short model(count only once then stop)\n    timer_2 = rt_timer_create(\"timer2\", timeout_2, RT_NULL, 30, RT_TIMER_FLAG_PERIODIC);\n\n    if(timer_1!=RT_NULL){\n        rt_timer_start(timer_1);\n    }\n\n    if (timer_2 != RT_NULL)\n    {\n        rt_timer_start(timer_2);\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html",
    "href": "posts/Spring简单使用（依赖注入）/index.html",
    "title": "Spring简单使用（依赖注入）",
    "section": "",
    "text": "IOC（Inversion of Control）:控制反转\n 创建对象的方式改变了，以前是new创建对象，现在时通过Spring创建对象\nAOP（Aspect Oriented Programming）:面向切片编程\n创建代码会有很多重复的部分，如异常处理、日志等。只需要写一遍，利用aop写入程序中"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring核心包",
    "text": "spring核心包\nbeans：bean管理 Context：上下文（体现在xml配置） Expression Language：spring EL表达式 Core：spring框架核心"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring入门程序",
    "text": "spring入门程序\nUserDao.java\npackage cn.edu.usts.spring;\n\npublic class UserDao {\npublic  void say() {\n    System.out.println(\"spring test！！\");\n}\n}\napplicationContext.xml\nspring-framework-4.3.6.RELEASE-dist\\spring-framework-4.3.6.RELEASE\\docs\\spring-framework-reference\\html\\index.html------>7.2.1\n\n\n\n在这里插入图片描述\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\">\n\n    <bean id=\"userDao\" class=\"cn.edu.usts.spring.UserDao\"></bean>\n\n</beans>\n\nTest,java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport cn.edu.usts.spring.UserDao;\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        // 实例化容器\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        // 通过容器获取实例\n        UserDao userDao = (UserDao)applicationContext.getBean(\"userDao\");\n        // 使用实例中方法\n        userDao.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "href": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "title": "Spring简单使用（依赖注入）",
    "section": "通过set方法进行依赖注入",
    "text": "通过set方法进行依赖注入\nUserService.java\npackage cn.edu.usts.spring;\n\npublic class UserService {\n    public UserDao userDao;\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n\n\n    public void say(){\n        System.out.println(\"userService say test!!!\");\n        this.userDao.say();\n    }\n}\napplicationContext.xml\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}\nTest.java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html",
    "href": "posts/java集合-- 所有/index.html",
    "title": "java集合– 所有",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#arraylist集合的常规操作",
    "href": "posts/java集合-- 所有/index.html#arraylist集合的常规操作",
    "title": "java集合– 所有",
    "section": "ArrayList集合的常规操作",
    "text": "ArrayList集合的常规操作\n\n             ArrayList长度可变,会随数组元素的增加分配更大的内存,\n             因此可以把ArrayList看做是一个可变长的数组\n             由于ArrayList的底层是数组,所以在 增加所删除指定位置元素时会创建新的数组\n             所以效率会比较低,所以不适合做大量的增删操作\n\npackage cn.usts.edu.arrayList;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: ArrayList集合的常规操作\n *                  ArrayList长度可变,会随数组元素的增加分配更大的内存,\n *                  因此可以把ArrayList看做是一个可变长的数组\n *                  由于ArrayList的底层是数组,所以在 增加所删除指定位置元素时会创建新的数组\n *                  所以效率会比较低,所以不适合做大量的增删操作\n *\n * @date ：2021/11/1 9:40\n */\npublic class ArrayListDemo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n        boolean student1 = al.add(\"student1\");\n        boolean student2 = al.add(\"student2\");\n        al.add(\"student3\");\n\n        System.out.println(student1);\n        System.out.println(student2);\n\n        System.out.println(\"集合的长度:\"+al.size());\n        System.out.println(\"第二个元素是:\"+al.get(2));\n        System.out.println(\"第最后一个元素是:\"+al.get(al.size()-1));\n    }\n}\n ## LinkedList 的基本操作 * ArrayList的查询很快,但是在增删的时候效率就慢了,于是出现了LinkedList * 链表中每个元素都用引用方式记住前一个和后一个元素,这样在增删的时候效率就会大大提高\npackage cn.usts.edu.linkedList;\n\nimport java.util.LinkedList;\n\n/**\n * @author ：fly\n * @description: LinkedList 的基本操作\n *                  ArrayList的查询很快,但是在增删的时候效率就慢了,于是出现了LinkedList\n *                  链表中每个元素都用引用方式记住前一个和后一个元素,这样在增删的时候效率就会大大提高\n *\n * @date ：2021/11/1 10:00\n */\npublic class LinkedListDemo {\n    public static void main(String[] args) {\n        LinkedList ll = new LinkedList();\n\n        // 添加\n        ll.add(\"stu1\");\n        ll.add(\"stu2\");\n        ll.add(\"stu3\");\n        ll.add(\"stu4\");\n\n        System.out.println(ll);\n\n        ll.offer(\"stu99\");// 集合尾部追加\n        System.out.println(ll);\n\n        ll.push(\"stu00\");// 集合头部追加\n        System.out.println(ll);\n\n        // 获取\n        Object peek = ll.peek();// 获取集合第一个元素\n        System.out.println(peek);\n\n        // 删除\n\n        System.out.println(\"删除了\"+ll.removeFirst());// 删除第一个元素\n        System.out.println(ll);\n        System.out.println(\"删除了\"+ll.removeLast());// 删除最后一个元素\n        System.out.println(ll);\n        System.out.println(\"删除了\"+ll.remove(2));// 删除index=2的元素\n        System.out.println(ll);\n    }\n}\n ## Iterator的使用方法 * Iterator是java集合框架中的一员, * 主要用于迭代访问(即遍历)Collection中的元素, * 因此Iterator对象也被称为迭代器.\npackage cn.usts.edu.iterator;\n\nimport com.sun.deploy.security.BadCertificateDialog;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description: Iterator的使用方法\n *                  Iterator是java集合框架中的一员,\n *                  主要用于迭代访问(即遍历)Collection中的元素,\n *                  因此Iterator对象也被称为迭代器.\n *\n * @date ：2021/11/1 10:16\n */\npublic class IteratorDemo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        Iterator iterator = al.iterator();// 获取迭代器对象\n\n        // hasNext()判断集合中是否存在下一个对象\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());// next()取出对象\n        }\n\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#foreach增强for循环遍历集合",
    "href": "posts/java集合-- 所有/index.html#foreach增强for循环遍历集合",
    "title": "java集合– 所有",
    "section": "ForEach(增强for循环)遍历集合",
    "text": "ForEach(增强for循环)遍历集合\nForEach的出现就是为了解决Iterator写起来太繁琐的问题\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: ForEach(增强for循环)遍历集合\n *                  ForEach的出现就是为了解决Iterator写起来太繁琐的问题\n * @date ：2021/11/1 10:32\n */\npublic class ForEachDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        for (Object o : al) {\n            System.out.println(o);// 打印元素\n        }\n    }\n}\n ## 迭代器注意点\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description: ForEach(增强for循环)遍历集合\n *                  ForEach的出现就是为了解决Iterator写起来太繁琐的问题\n * @date ：2021/11/1 10:32\n */\npublic class ForEachDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        for (Object o : al) {\n            System.out.println(o);// 打印元素\n            if (o.equals(\"stu2\")){\n                al.remove(o);\n\n                break;// 如果不加上的话,迭代器会报错,就是把这个元素删除掉了,迭代器下一个元素找不到了,用break跳出循环\n                /*\n                Exception in thread \"main\" java.util.ConcurrentModificationException\n                at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)\n                at java.util.ArrayList$Itr.next(ArrayList.java:861)\n                at cn.usts.edu.iterator.ForEachDemo.main(ForEachDemo.java:22)\n\n                * */\n                \n                \n            }\n        }\n        System.out.println(al);\n        \n        // 方法二\n        Iterator iterator = al.iterator();\n        while (iterator.hasNext()){\n            if (iterator.next().equals(\"stu2\")){\n                iterator.remove();\n            }\n        }\n        System.out.println(al);\n    }\n}"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#jdk8新加的foreach遍历集合",
    "href": "posts/java集合-- 所有/index.html#jdk8新加的foreach遍历集合",
    "title": "java集合– 所有",
    "section": "JDK8新加的forEach遍历集合",
    "text": "JDK8新加的forEach遍历集合\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: JDK8新加的forEach遍历集合\n * @date ：2021/11/1 10:58\n */\npublic class ForEachJdk8Demo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        al.forEach(obj-> System.out.println(\"迭代集合元素\"+obj));\n    }\n}\n ## Iterator实现的遍历结果\n@Test\n    public void iteratorMethod(){\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        Iterator iterator = al.iterator();\n        iterator.forEachRemaining(obj-> System.out.println(\"遍历出来的元素\"+obj));\n    }\n ## HashSet\npackage cn.usts.edu.hashSet;\n\nimport java.util.HashSet;\n\n/**\n * @author ：fly\n * @description: HashSet的常规操作\n * @date ：2021/11/1 17:17\n */\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        HashSet hs = new HashSet();\n        hs.add(\"hello1\");\n        hs.add(\"hello2\");\n\n        hs.add(\"hello3\"); // 添加重复元素\n        hs.add(\"hello3\");\n        hs.add(\"hello3\");\n\n        hs.add(\"hello4\");\n\n        hs.forEach(obj-> System.out.println(obj));// 遍历\n    }\n}\n # HashSet自定义obj类型,存储到haset中去重.\npackage cn.usts.edu.hashSet;\n\nimport org.junit.Test;\n\nimport java.util.HashSet;\n\n/**\n * @author ：fly\n * @description: HashSet的常规操作\n*                自己创建的对象要重写hashCode()和equals()方法 \n *\n * @date ：2021/11/1 17:17\n */\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        HashSet hs = new HashSet();\n        hs.add(\"hello1\");\n        hs.add(\"hello2\");\n\n        hs.add(\"hello3\"); // 添加重复元素\n        hs.add(\"hello3\");\n        hs.add(\"hello3\");\n\n        hs.add(\"hello4\");\n\n        hs.forEach(obj-> System.out.println(obj));// 遍历\n    }\n\n\n\n    // 重写hashCode方法,针对自定义存储对象\n    @Test\n    public void test02(){\n        Student stu1 = new Student(1,\"Jack\");\n        Student stu2 = new Student(1,\"Jack\");\n\n        HashSet set = new HashSet();\n        set.add(stu1);\n        set.add(stu2);\n        set.forEach(obj-> System.out.println(obj));\n        //System.out.println(set);\n\n\n\n    }\n}\n\n// pojo\nclass Student{\n    private int id;\n    private String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Student() {\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();//返回name的hash值\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj){//比较地址值,是否是同一个对象\n            return true;\n        }\n        if (!(obj instanceof Student)){// 不是学生的子类\n            return false;\n        }\n        Student student = (Student) obj;// 是学生的子类,且不是本身\n        boolean equals = this.name.equals(student.name);// 判断当前类的名字是否和传进来的name一致\n        return equals;\n    }\n}\n # TreeSet的使用\npackage cn.usts.edu.hashSet;\n\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description: TreeSet常规操作\n *               TreeSet的出现解决了HashSet无法排序的问题,\n * @date ：2021/11/1 17:50\n */\npublic class TreeSetDemo {\n\n    public static void main(String[] args) {\n        TreeSet ts = new TreeSet();\n        ts.add(1);\n        ts.add(82);\n        ts.add(33);\n        ts.add(74);\n        ts.add(5);\n        ts.add(16);\n        ts.add(26);\n        ts.add(36);\n        ts.add(22);\n        System.out.println(ts);\n\n        System.out.println(\"第一个是:\"+ts.first());\n        System.out.println(\"最后一个是:\"+ts.last());\n\n        System.out.println(\"集合中小于或等于26的最大的一个元素是:\"+ts.floor(26));\n        System.out.println(\"集合中大于30的最小的一个元素是:\"+ts.floor(30));// 没有返回null\n\n        System.out.println(\"删除第一个\"+ts.pollFirst());// 删除第一个\n        System.out.println(\"删除最后一个\"+ts.pollLast());// 删除最后一个\n        System.out.println(ts);\n\n    }\n}\n\n\n\n在这里插入图片描述\n\n\n# HashMap的常用操作和遍历 遍历: * 遍历值 - 增强for / 迭代器 * 遍历value - 增强for / 迭代器 * 遍历entrySet - 转换MapEntry对象 - 增强for / 迭代器\npackage cn.usts.edu.map.hashMap;\n\nimport java.util.*;\n\n/**\n * @author ：fly\n * @description: HashMap 的基本操作\n *               hashMap是  Key:Value的形式\n *               put()添加\n *               get()获取\n *               size()大小\n *               isEmpty()判空\n *               clear()清空\n *               remove()删除\n *               constainsKey()查找键是否存在\n *\n *               键不可以重复,key可以为空,value可以重复\n *               key相同会覆盖\n *               多数情况是String类型的key,value  Object类型都可以\n *\n *\n * @date ：2021/11/2 17:23\n */\n\n//@SuppressWarnings(\"all\")\npublic class HashMapDemo {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"小红\",\"95\");\n        map.put(\"小名\",\"85\");\n        map.put(\"小名\",\"85\");// 重复不添加\n        map.put(\"tom\",\"75\");\n        map.put(\"lucy\",79);\n        map.put(\"小军\",null);\n        map.put(\"小网\",null);\n        map.put(null,null);\n        map.put(null,\"小华\");//替换掉上面的null\n        System.out.println(map);\n\n        System.out.println(\"tom的value=\"+map.get(\"tom\"));\n        System.out.println(\"lucy的value=\"+map.get(\"lucy\"));\n\n        Set keySet = map.keySet();// 获取到所有键的集合\n        System.out.println(keySet);\n\n        System.out.println(\"小网是否存在:\"+map.containsKey(\"小网\"));\n        System.out.println(\"小王是否存在:\"+map.containsKey(\"小王\"));\n\n        System.out.println(\"是否包含(int)79:\"+map.containsValue(79));\n        System.out.println(\"是否包含79:\"+map.containsValue(\"79\"));\n\n        Collection values = map.values();\n        System.out.println(\"所有的值=\"+values);\n\n        System.out.println(\"------------遍历1-------------\");\n\n        // 方法1通过for循环和get遍历\n        for (Object key : keySet) {\n            System.out.println(key + \":\" + map.get(key));\n        }\n\n        System.out.println(\"------------遍历2-------------\");\n        // 方法2 迭代器\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext()){\n            String item =(String) iterator.next();// 遍历key\n            System.out.println(item+\":\"+map.get(item));\n        }\n\n        // 方法3  获取所有values 遍历\n        System.out.println(\"------------遍历3-------------\");\n        Collection value = map.values();\n        for (Object val : value) {\n            System.out.println(val);\n        }\n\n        // 方法4  通过获取值迭代器遍历\n        System.out.println(\"------------遍历4-------------\");\n        Iterator iterValue = value.iterator();\n        while (iterValue.hasNext()){\n            System.out.println(iterValue.next());\n        }\n        // 方法5 entrySet获取k-v\n        System.out.println(\"------------遍历5-------------\");\n        Set entrySet = map.entrySet();\n        for (Object o : entrySet) {\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey()+ \":\" + entry.getValue());\n        }\n\n        // 方法6   entrySet用迭代器 遍历\n        System.out.println(\"------------遍历6-------------\");\n        Iterator entryIterator = entrySet.iterator();\n        while (entryIterator.hasNext()){\n            Object next = entryIterator.next();\n            Map.Entry keyValue = (Map.Entry) next;\n            System.out.println(keyValue.getKey()+\":\"+keyValue.getValue());\n        }\n\n    }\n}\n\n\n ## TreeSet排序 Comparator()\npackage cn.usts.edu.collection.set.treeSet;\n\n\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description:  TreeSet 可以排序,但是要重写compare方法\n * @date ：2021/11/3 15:19\n */\npublic class TreeSetDemo {\n    public static void main(String[] args) {\n        TreeSet treeSet = new TreeSet(new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n\n                System.out.println(((String) o1).compareTo((String) o2));\n                // compareTo返回比较结果int,然后传入TreeMap中\n                // TreeMap中的put方法会调用重写compare方法,比较大小,大的放右节点,小的放左节点.\n                // return ((String) o1).compareTo((String) o2);// 字符串的compareTo方法比较\n                return ((String) o2).length() - ((String) o1).length();// 长度比较\n            }\n        });\n        treeSet.add(\"a\");\n        treeSet.add(\"swallow\");\n        treeSet.add(\"tree\");\n        treeSet.add(\"hello\");\n        treeSet.add(\"hello1\");\n        System.out.println(treeSet);// 直接 输出并不会排序,需要重写compare()\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "href": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "title": "qt上位机 – 自己开发出口助手",
    "section": "",
    "text": "概要\n利用qt编写一个串口助手\n\n\n成品效果\n代码地址:https://gitee.com/itengfei/serial-assistant\n\n\n\n在这里插入图片描述\n\n\n\n\nui布局\n代码链接:\n\n\n\n在这里插入图片描述\n\n\n\n\n编码\n\n\n\n在这里插入图片描述\n\n\n串口助手 虚拟串口\nserialAssistant.h代码\n#pragma once\n\n#include <QtWidgets/QWidget>\n#include \"ui_serialassistant.h\"\n\n#include <QSerialPort>        //提供访问串口的功能\n#include <QSerialPortInfo>    //提供系统中存在的串口的信息\n#include<qmessagebox.h>\n\nclass serialAssistant : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    serialAssistant(QWidget* parent = Q_NULLPTR) ;\n    ~serialAssistant() {};\n   \n  \n    QSerialPort* serialPort;\n    QSerialPort::BaudRate baudRate{};\n    QSerialPort::StopBits stopBits{};\n    QSerialPort::DataBits dataBits{};\n    QSerialPort::Parity checkBits{};\n\npublic slots:\n    void start();\n    void stop();\n    void clear();\n    void send();\n    void receive();\n\n\nprivate:\n    Ui::serialAssistantClass ui;\n};\nserialAssistant.cpp代码\n#include \"serialassistant.h\"\n#include <iostream>\n\n\n\nserialAssistant::serialAssistant(QWidget *parent)\n    : QWidget(parent)\n{\n    \n    ui.setupUi(this);\n\n    serialPort = new QSerialPort(this);\n    \n    // get and show  ports\n    for each (const QSerialPortInfo &info in QSerialPortInfo::availablePorts())\n    {\n        ui.serialPortComBox->addItem(info.portName());\n    }\n    \n    connect(serialPort, SIGNAL(readyRead()),this, SLOT(receive()));\n}\n\nvoid serialAssistant::start() {\n    if (ui.baudRatCombox->currentText() == \"4800\") {\n        serialAssistant::baudRate = QSerialPort::Baud4800;\n    }\n    else if (ui.baudRatCombox->currentText() == \"9600\") {\n        serialAssistant::baudRate = QSerialPort::Baud9600;\n    }\n    else if (ui.baudRatCombox->currentText() == \"115200\") {\n        serialAssistant::baudRate = QSerialPort::Baud115200;\n    }\n\n\n    if (ui.dataBitComBox->currentText() == \"5\") {\n        serialAssistant::dataBits = QSerialPort::Data5;\n    }\n    else if (ui.dataBitComBox->currentText() == \"6\") {\n        serialAssistant::dataBits = QSerialPort::Data6;\n    }\n    else if (ui.dataBitComBox->currentText() == \"7\") {\n        serialAssistant::dataBits = QSerialPort::Data7;\n    }\n    else if (ui.dataBitComBox->currentText() == \"8\") {\n        serialAssistant::dataBits = QSerialPort::Data8;\n    }\n\n\n    if (ui.stopBitComBox->currentText() == \"1\") {\n        serialAssistant::stopBits = QSerialPort::OneStop;\n    }\n    else if (ui.stopBitComBox->currentText() == \"1.5\") {\n        serialAssistant::stopBits = QSerialPort::OneAndHalfStop;\n    }\n    else if (ui.stopBitComBox->currentText() == \"2\") {\n        serialAssistant::stopBits = QSerialPort::TwoStop;\n    }\n\n    if (ui.checkComBox->currentText() == \"none\") {\n        serialAssistant::checkBits = QSerialPort::NoParity;\n    }\n   \n    serialPort->setPortName(ui.serialPortComBox->currentText());\n    serialPort->setBaudRate(serialAssistant::baudRate);\n    serialPort->setDataBits(serialAssistant::dataBits);\n    serialPort->setStopBits(serialAssistant::stopBits);\n    serialPort->setParity(serialAssistant::checkBits);\n \n   // std::cout << serialAssistant::baudRate << std::endl;\n    // std::cout << serialAssistant::dataBits << std::endl;\n    // std::cout << serialAssistant::stopBits << std::endl;\n    // std::cout << serialAssistant::checkBits << std::endl;\n\n    // chek status \n    if (serialPort->open(QIODevice::ReadWrite) == true) {\n       \n        QMessageBox::information(this, \"tip\", \"ok\");\n    }\n    else {\n        QMessageBox::critical(this, \"tip\", \"fail\");\n    }\n\n}\n\nvoid serialAssistant::stop()\n{\n    QMessageBox::information(this, \"tip\", \"closed\");\n    serialPort->close();\n}\n\nvoid serialAssistant::clear()\n{\n    ui.sendLineEdit->clear();\n}\n\nvoid serialAssistant::send()\n{\n    serialPort->write(ui.sendLineEdit->text().toLocal8Bit().data());\n    //std::cout << ui.sendLineEdit->text().toLocal8Bit().data() << std::endl;\n}\n\nvoid serialAssistant::receive()\n{\n    QString buffer;\n    buffer =  QString(serialPort->readAll());\n    ui.receivePlainTextEdit->appendPlainText(buffer);\n    //std::cout << buffer.toStdString() << std::endl;\n}"
  },
  {
    "objectID": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "href": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "title": "stm32H743+CubeMX+RtThread工程创建",
    "section": "",
    "text": "CubeMX\n\n时钟修改\n把时钟修改为非sysTicks \n\n\n外部高速时钟\n使能外部高速晶振\n 配置时钟树\n\n\n\n\n在这里插入图片描述\n\n\n\nDebug\n\n\n\n\n在这里插入图片描述\n\n\n\nUsart\n设置引脚, 使能usart\n\n\n\n\n在这里插入图片描述\n\n\n >## RT-Thread >添加rtt参考链接 > \n > 打开动态内存堆.否则无法使用rt_thread_create动态创建线程. >  > ## 生成项目  > 生成keil项目 > \n\n\n工程创建完成后修改\n\n工程创建完成后直接编译会有error无法通过编译\n 添加board.h 删除 rtconfig.h\n  board.h\n\n#ifndef __BOARD_H\n#define __BOARD_H\n\n#include \"main.h\" // 这里可以添加平台文件(stm32h743xx.h)替换\n\n\n\n#endif // !__BOARD_H\n\n修改rtconfig.h添加fish组件\n\n   > ### 修改串口输出 > H7的发送和接收是分开的\n\nboard.c\n  # 重复定义错误  ### 修改堆内存  ### main.c  ## 测试结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html",
    "href": "posts/vue -- 01安装、创建、跑通/index.html",
    "title": "vue – 01安装、创建、跑通",
    "section": "",
    "text": "查看版本\n\nvue/cli --version\n\n查看2.xx版本\n\nnpm view vue-cli versions --json\n\nvue init webpack vue2xx\n\n查看3.xx以上版本\n\nnpm view @vue/cli versions --json\n\nvue create my-project\n\n卸载\n\nnpm uninstall -g @vue/cli\n\n安装指定版本（2.xx）\n\nnpm install -g vue-cli@2.9.6\n\n安装指定版本（3.xx）\n\nnpm install -g @vue/cli@3.9.3\n\n安装最新版本\n\nnpm install -g @vue/cli\n\n作者：铁有情\n链接：https://www.jianshu.com/p/cd5dc9aad773\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "href": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "title": "vue – 01安装、创建、跑通",
    "section": "scss",
    "text": "scss"
  },
  {
    "objectID": "posts/javaGUI--布局练习/index.html",
    "href": "posts/javaGUI--布局练习/index.html",
    "title": "javaGUI–布局练习",
    "section": "",
    "text": "效果: \npackage cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class Ex01 {\n\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"练习\");\n        // 大小\n        frame.setSize(900,600);\n        frame.setBackground(Color.orange);\n        // 位置\n        frame.setLocation(500,500);\n        // 可见\n        frame.setVisible(true);\n        // 2*1\n        frame.setLayout(new GridLayout(2,1));\n\n        // ------------------------------------上半部分----------------------------------\n        Panel pup =new Panel(new BorderLayout());\n        Panel pup_in =new Panel(new GridLayout(2,1));\n\n        pup.add(new Button(\"up-west\"),BorderLayout.WEST);\n        pup.add(new Button(\"up-east\"),BorderLayout.EAST);\n\n        pup_in.add(new Button(\"up-center-01\"));\n        pup_in.add(new Button(\"up-center-02\"));\n\n        pup.add(pup_in,BorderLayout.CENTER);\n\n        frame.add(pup);\n\n        // ------------------------------------下半部分----------------------------------\n        Panel pdown = new Panel();\n        pdown.setLayout(new BorderLayout());\n        pdown.add(new Button(\"down-left-01\"),BorderLayout.WEST);\n        pdown.add(new Button(\"down-left-02\"),BorderLayout.EAST);\n\n        Panel pdwon_in = new Panel();\n        pdwon_in.setLayout(new GridLayout(2,2));\n        pdwon_in.add(new Button(\"down-center-01\"));\n        pdwon_in.add(new Button(\"down-center-02\"));\n        pdwon_in.add(new Button(\"down-center-03\"));\n        pdwon_in.add(new Button(\"down-center-04\"));\n\n        pdown.add(pdwon_in);\n\n        frame.add(pdown);\n    }\n}"
  },
  {
    "objectID": "posts/模仿网易严选(vant)/index.html",
    "href": "posts/模仿网易严选(vant)/index.html",
    "title": "模仿网易严选(vant)",
    "section": "",
    "text": "vue2+vant2+express\n简单使用(模仿网易严选) 地址:https://gitee.com/itengfei/you-163 \n \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI--滚动条JScrollPane/index.html",
    "href": "posts/javaGUI--滚动条JScrollPane/index.html",
    "title": "javaGUI–滚动条JScrollPane",
    "section": "",
    "text": "将区域加上滚动条,和文本域 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JScrollDemo extends JFrame {\n    public JScrollDemo() {\n        this.setTitle(\"文本域\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 文本域\n        JTextArea textArea = new JTextArea(20,50);\n        textArea.setText(\"文本域默认输入的内容\");\n\n        // JScroll带滚动条的\n        JScrollPane scrollPane = new JScrollPane(textArea);\n\n        Container container = this.getContentPane();\n        container.add(scrollPane);\n\n    }\n\n    public static void main(String[] args) {\n        new JScrollDemo();\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射--通过反射获取到注解的值/index.html",
    "href": "posts/java注解和反射--通过反射获取到注解的值/index.html",
    "title": "java注解和反射–通过反射获取到注解的值",
    "section": "",
    "text": "java的注解原理 \npackage cn.usts.edu.ReflectionGetAndSetAnnotation;\n\n\nimport java.lang.annotation.*;\nimport java.lang.reflect.Field;\n\n/**\n * @author ：fly\n * @description: 利用反射操作注解\n * @date ：2021/10/29 15:36\n */\npublic class GetSetAnnotation {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        // 通过反射获取对象\n        Class<?> u1 = Class.forName(\"cn.usts.edu.ReflectionGetAndSetAnnotation.User\");\n\n        // 通过反射对象获取注解\n        Annotation[] annotations = u1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        //   获取注解对象                                         注解名子.class\n        testAnnotation1 testAnnotation1 =u1.getAnnotation(testAnnotation1.class);\n        // 获取注解的value         注解对象.属性()\n        System.out.println(testAnnotation1.tableName());\n\n        // 获取指定属性\n        Field age = u1.getDeclaredField(\"age\");\n        // 指定属性上的注解\n        testFiledAnnotation ageAnnotation = age.getAnnotation(testFiledAnnotation.class);\n        System.out.println(\"columnName-->\"+ageAnnotation.columnName());\n        System.out.println(\"type-->\"+ageAnnotation.type());\n        System.out.println(\"length-->\"+ageAnnotation.length());\n    }\n\n\n}\n\n@testAnnotation1(tableName = \"tb_User\")\nclass User{\n    @testFiledAnnotation(columnName = \"User_age\",type = \"int\",length = 10)\n    int age;\n    @testFiledAnnotation(columnName = \"User_name\",type = \"varChar\",length = 20)\n    String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// 类注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testAnnotation1{\n    String tableName();\n}\n\n// 属性注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testFiledAnnotation{\n    String columnName();\n    int length();\n    String type();\n}"
  },
  {
    "objectID": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html",
    "href": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html",
    "title": "java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）",
    "section": "",
    "text": "字节流：可以输出字符、图片、声音及其他二进制数据 不设置【可能】会出现乱码情况 字符流：只可以输出字符 不设置会出现 ‘’？？？？？？’  中文变【问号】情况 \n处理乱码的方案：让浏览器和服务器端的编码方式一致\n\n\n        String outString = \"服务器编码设置UTF-8\";\n        \n        ServletOutputStream out  = response.getOutputStream();\n        // 服务器编码设置UTF-8\n        \n        // 输出到浏览器\n        out.write(outString.getBytes(\"utf-8\"));\n\n\n\n方法一：（简便写法）\nresponse.setContentType(\"text/html;charset=utf-8\");\n方法二：\nresponse.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");"
  },
  {
    "objectID": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字符流getwriter向浏览器输出中文出现乱码解决方案",
    "href": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字符流getwriter向浏览器输出中文出现乱码解决方案",
    "title": "java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）",
    "section": "1.2字符流(getWriter())向浏览器输出中文出现乱码解决方案：",
    "text": "1.2字符流(getWriter())向浏览器输出中文出现乱码解决方案：\n方法一：\nresponse.setContentType(\"text/html;charset=utf-8\");\n方法二：\n        // 设置服务器编码\n        response.setCharacterEncoding(\"utf-8\");\n        // 设置浏览器编码格式\n        response.setHeader(\"content-type\", \"text/html;charset=utf-8\");"
  },
  {
    "objectID": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html",
    "href": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html",
    "title": "java多线程– sleep实现 ( 时间刷新 , 模拟倒计时)",
    "section": "",
    "text": "时间刷新\n模拟倒计时 ## 时间刷新"
  },
  {
    "objectID": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html#模拟倒计时",
    "href": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html#模拟倒计时",
    "title": "java多线程– sleep实现 ( 时间刷新 , 模拟倒计时)",
    "section": "模拟倒计时",
    "text": "模拟倒计时\n\n\n\n在这里插入图片描述\n\n\n // 模拟倒计时\n    @Test\n    public void tenSecondFlush(){\n        int num = 10;\n        while (true){\n            if (num <= 0) {\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n                System.out.println(num--);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n\n        }\n    }"
  },
  {
    "objectID": "posts/javaArrayList作业1/index.html",
    "href": "posts/javaArrayList作业1/index.html",
    "title": "javaArrayList作业1",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/3 20:03\n */\npublic class NewsDemo {\n    public static void main(String[] args) {\n        ArrayList<News> newsArray = new ArrayList<>();\n        newsArray.add(new News(\"新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧\"));\n        newsArray.add(new News(\"男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生\"));\n\n        System.out.println(\"============默认=============\");\n        System.out.println(newsArray);\n\n        System.out.println(\"============逆序=============\");\n        Collections.reverse(newsArray);\n        System.out.println(newsArray);\n\n        System.out.println(\"============裁剪=============\");\n        for (News one : newsArray) {\n            if (one.getTitle().length()>15){\n                System.out.println(one.getTitle().substring(0,14)+\".....\");\n            }\n        }\n    }\n}\n\nclass News{\n    private String title;\n    private String content;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n\n    public News(String title) {\n        this.title = title;\n    }\n\n    @Override\n    public String toString() {\n        return \"News{\" +\n                \"title='\" + title + '\\'' +\n\n                '}';\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "",
    "text": "编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n账户上有100, A取要90,B要取80;\n连个人同时看到都有100.都可以取出,\n所以问题就产生了.\n解决方案:\n锁块,对account上锁,只能一个线程对account操作.[同步块]\n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n * 账户上有100, A取要90,B要取80;\n * 连个人同时看到都有100.都可以取出,\n * 所以问题就产生了.\n *\n * 解决方案:\n *    锁块,对account上锁,只能一个线程对account操作.[同步块]\n * */\n\npublic class UnSafeBank {\n\n    public static void main(String[] args) {\n        Account account = new Account(100,\"旅游基金\");\n        Drawing a = new Drawing(account, 90);\n        Drawing b = new Drawing(account, 80);\n        new Thread(a, \"A\").start();\n        new Thread(b, \"B\").start();\n    }\n}\n\n// 账户\nclass Account {\n    int money;\n    String name;\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n\n// 银行\nclass Drawing implements Runnable{\n\n    final Account account;\n    int drawMoney;\n    int nowMoney=0;\n\n\n    public Drawing(Account account, int drawMoney) {\n        this.account = account;\n        this.drawMoney = drawMoney;\n\n    }\n\n    @Override\n    public void run() {\n        synchronized (account){   // 锁块,对account上锁,只能一个线程对account操作.\n            System.out.println(Thread.currentThread().getName()+\"要取出\"+drawMoney);\n            // 判断是否够取出的\n            if (account.money-drawMoney<0){\n                System.out.println(Thread.currentThread().getName()+\"==输入的金额有问题,取不了\");\n                return;\n            }\n\n            // 现在手上的钱\n            nowMoney = nowMoney+drawMoney;\n            System.out.println(Thread.currentThread().getName()+\"现在手上:\"+nowMoney);\n\n            // 现在的卡内余额\n            account.money=account.money-drawMoney;\n            System.out.println(account.name+\"余额:\"+account.money);\n        }\n\n\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#网上买票问题",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#网上买票问题",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "网上买票问题",
    "text": "网上买票问题\n不安全的买票机制 * 如果网络拥堵导致网络延时,会使得对于tickets的读取有问题, * 对于并发生的问题就是排队和上锁 * 解决方案: * 在方法前加上 synchronized 同步方法,锁的是this  [同步方法]\npackage cn.usts.edu.lesson07;\n\n/**\n * 不安全的买票机制\n * 如果网络拥堵导致网络延时,会使得对于tickets的读取有问题,\n * 对于并发生的问题就是排队和上锁\n *\n * 解决方案:\n *   在方法前加上 synchronized 同步方法,锁的是this  [同步方法]\n * */\n\npublic class UnSafeBuyTickets {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets,\"小明\").start();\n        new Thread(buyTickets,\"小红\").start();\n        new Thread(buyTickets,\"黄牛\").start();\n\n    }\n}\n\nclass  BuyTickets implements Runnable{\n    // 100张票\n    int tickets = 10;\n    boolean flag = true;\n\n    @Override\n    public void run() {\n        while (flag){\n            buy();\n        }\n    }\n\n\n    // 在方法前加上 synchronized 同步方法,锁的是this\n    public  void buy(){\n\n        if (tickets<=0){\n            flag=false;\n            return; // 程序到这结束\n        }\n        try {\n            Thread.sleep(100);// 模拟网络延时,放大问题\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName()+tickets--);\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#线程不安全集合",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#线程不安全集合",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "线程不安全集合",
    "text": "线程不安全集合\n\n每次执行都无法达到理想的数字,是什么原因,\n是因为反应太快,导致不同线程对同一个list中的位置进行修改,导致了覆盖.\n解决方案:\n添加锁块,等待线程结束\n\npackage cn.usts.edu.lesson07;\n\n/**\n * 每次执行都无法达到理想的数字,是什么原因,\n * 是因为反应太快,导致不同线程对同一个list中的位置进行修改,导致了覆盖.\n *\n * 解决方案:\n *      添加锁块,等待线程结束.\n * */\n\nimport java.util.ArrayList;\n\npublic class UnSafeList {\n    public static void main(String[] args) {\n        ArrayList<String> arrayList = new ArrayList<>();\n\n\n        for (int i = 0; i < 10000; i++) {\n\n\n                new Thread(()->{// 每次循环启动一个线程,并写线程名\n                    synchronized (arrayList){\n                        arrayList.add(Thread.currentThread().getName());//写入线程名\n                    }\n\n                }).start();\n        }\n        try {\n            Thread.sleep(1000);//等待线程跑完,不加可能线程没跑完就打印出来了\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(arrayList.size());// 查看list的大小(list中有多少个线程名)\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 初识多线程的问题(简单案例)/index.html",
    "href": "posts/java多线程-- 初识多线程的问题(简单案例)/index.html",
    "title": "java多线程– 初识多线程的问题(简单案例)",
    "section": "",
    "text": "没有控制的并发会导致数据的不一致 \npackage cn.usts.edu.lesson02;\n\n/**\n * 并发会导致对数据的访问有问题\n * */\npublic class ThreadProblem implements Runnable{\n    private int tickets=10;\n\n    @Override\n\n    public void run() {\n        String threadName = Thread.currentThread().getName(); // 获取当前线程的名字\n        while (true){\n            if (tickets<=0){\n                break;\n            }\n            System.out.println(\"【\"+threadName+\"】\"+tickets--);\n\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadProblem ticket = new ThreadProblem();\n        new Thread(ticket,\"小明\").start();\n        new Thread(ticket,\"小红\").start();\n        new Thread(ticket,\"黄牛\").start();\n    }\n\n\n}"
  },
  {
    "objectID": "posts/腾讯云简单使用-Python/index.html",
    "href": "posts/腾讯云简单使用-Python/index.html",
    "title": "腾讯云简单使用-Python",
    "section": "",
    "text": "腾讯云使用踩坑\nssh无法连接: 修改sshd文件 :PermitRootLogin=yes, PasswordAuthentication 改成yes reboot\n\n\nPython虚拟环境:\npip intall virtualenv之后命令无效,not fund command 修改:vim ~/.bashrc 重启: sudo service ssh restart 最后添加:\nexport WORKON_HOME=$HOME/.virtualenvs\nexport PROJECT_HOME=$HOME/workspace\nsource /usr/local/bin/virtualenvwrapper.sh\n生效:\nsource ~/.bashrc\n指定版本创建:\nmkvirtualenv py39 --python==python3.9\n\n\nAnnaconda环境\n配置环境变量:\nsudo vim /etc/profile\n\nexport PATH=$PATH:/root/anaconda3/bin #conda安装路径\n\nsource /etc/profile"
  },
  {
    "objectID": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html",
    "href": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html",
    "title": "Navicat中 int(0)表示什么【init（0）是什么意思】",
    "section": "",
    "text": "没有指定长度使用默认的设置，出现了int(0)的情况  ## 答案：\nin(0)表示的就是使用int默认的最大展示长度11位\n\n\n为什么是11位 (这里的11表示的是我们看到的11个位数)：\nMysql中int是4字节的\n有符号最大：-2,147,483,648 ~ +2,147,483,647    ( - 2^31^ ~ 2^32^-1)\n\n\n\n有符号数最小值:\n 值：   -   2   1   4   7   4   8   3   6    4   8\n 索引: [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11]    --共11位"
  },
  {
    "objectID": "posts/javaGUI--东西南北中布局/index.html",
    "href": "posts/javaGUI--东西南北中布局/index.html",
    "title": "javaGUI–东西南北中布局",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestBorderLauOut {\n\n    // 东西南北中布局\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"BorderLayout\");\n        frame.setSize(500,500);\n        frame.setVisible(true);\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n        Button button5 = new Button(\"button5\");\n\n        frame.add(button1,BorderLayout.CENTER);\n        frame.add(button2,BorderLayout.NORTH);\n        frame.add(button3,BorderLayout.EAST);\n        frame.add(button4,BorderLayout.SOUTH);\n        frame.add(button5,BorderLayout.WEST);\n\n\n    }\n\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/manjaro install/index.html",
    "href": "posts/manjaro install/index.html",
    "title": "manjaro install",
    "section": "",
    "text": "mirror\nexeuted then select by yourself\npacman-mirrors -i -c China -m rank\n中科大源 https://blog.csdn.net/weixin_49927493/article/details/125616726?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-125616726-blog-84486753.t0_edu_mlt&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-125616726-blog-84486753.t0_edu_mlt&utm_relevant_index=6\narch-fcitx安装链接 gonme可以使用fcitx-configtool pacman -S fcitx fcitx-im kcm-fcitx fcitx安装第一个fcitx即可 vim ~/.pam_environment\nGTK_IM_MODULE DEFAULT=fcitx\nQT_IM_MODULE  DEFAULT=fcitx\nXMODIFIERS    DEFAULT=\\@im=fcitx\n注销 yay -S fcitx-sogoupinyin 右键键盘重启\n\n\n美化\n视频教学 视频文档\n卸载\nsudo pacman -R k3b kcalc kget konversation kwalletmanager qbittorent khelpercenter steam elisa htop yakuake timeshift timeshift-autosnap-manjaro matray manjaro-hello ksystemlog manjaro-documentation-en ksysguard onlyoffice-desktopeditors kfind kwrite okular\n\n\n中文家目录修改为英文\n修改参考\nvim .config/user-dirs.dirs\n\n修改为如下：\n# This file is written by xdg-user-dirs-update\n# If you want to change or add directories, just edit the line you're\n# interested in. All local changes will be retained on the next run.\n# Format is XDG_xxx_DIR=\"$HOME/yyy\", where yyy is a shell-escaped\n# homedir-relative path, or XDG_xxx_DIR=\"/yyy\", where /yyy is an\n# absolute path. No other format is supported.\n# \nXDG_DESKTOP_DIR=\"$HOME/Desktop\"\nXDG_DOWNLOAD_DIR=\"$HOME/Downloads\"\nXDG_TEMPLATES_DIR=\"$HOME/Templates\"\nXDG_PUBLICSHARE_DIR=\"$HOME/Public\"\nXDG_DOCUMENTS_DIR=\"$HOME/Documents\"\nXDG_MUSIC_DIR=\"$HOME/Music\"\nXDG_PICTURES_DIR=\"$HOME/Pictures\"\nXDG_VIDEOS_DIR=\"$HOME/Videos\"\n\ntouch ~/.config/user-dirs.conf\n写入：\nenabled=False\n\n\n安装clash\nclash for windows 下载 修改代理 \n修改浏览器代理, 否则代理一直无效\n # 安装浏览器插件 ad tempmonkey vimium 知呼登录屏蔽\n\n\n键盘f1-f12修改\nhttps://editor.csdn.net/md/?articleId=127000333\n\n\n安装主题\nyay -S ocs-url\n\n然后打开\nhttps://store.kde.org/p/1477945\n\n--> install \n\n\n安装c语言环境\nsudo pacman -Sy base-devel"
  },
  {
    "objectID": "posts/qt多线程QThread()/index.html",
    "href": "posts/qt多线程QThread()/index.html",
    "title": "qt多线程QThread()",
    "section": "",
    "text": "创建\nclass MyThread : public QThread\n{\nprotected:\n    void run()\n    {\n        /* 线程的相关代码 */\n    }\n};\n\n\n调用\nThread *thread = new Thread;\n\nthread->start();"
  },
  {
    "objectID": "posts/java多线程-- 生产者消费者/index.html",
    "href": "posts/java多线程-- 生产者消费者/index.html",
    "title": "java多线程– 生产者消费者",
    "section": "",
    "text": "有一家店,有很多人来,为了提升顾客体验,前台可以放10份餐,不足10份后厨就会通知后厨补上,如果到10份就停止生产.,只要前台有餐就通知顾客取餐,没有餐让顾客等待.\n代码有问题,希望大佬指点下 (已找到, 把else去掉就好了) \n进程会一直卡在这里 \npackage cn.usts.edu.lesson08;\n\nimport cn.usts.util.Utils;\n\n\n/**\n * 生产者消费之\n * 一个资源被需要,才会被创建,\n * 在生产者和消费者中间还有一个容器作为缓冲,作为一个生产的标志\n *\n *\n * 逻辑没有问题,代码有问题.\n * */\n\npublic class ProductorConsumerDemo {\n    public static void main(String[] args) {\n        Container1 container = new Container1();\n        Productor productor = new Productor(container);\n        Consumer consumer = new Consumer(container);\n        productor.start();\n        consumer.start();\n    }\n\n\n}\n\n// 生产者\nclass Productor extends Thread{\n    Container1 container;\n\n    public Productor(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 生产100只鸡\n        for (int i = 0; i < 100; i++) {\n            container.push(new Chicken(i));\n            System.out.println(\"生产了第\"+i+\"只鸡\");\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread{\n    Container1 container;\n\n    public Consumer(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 消费100只鸡\n        for (int i = 0; i < 100; i++) {\n            Chicken chicken = container.pop();\n            System.out.println(\"消费了第--------\"+chicken.id+\"只鸡\");\n        }\n    }\n}\n\n\n// 生产的产品\nclass Chicken{\n    int id;// 产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n\n// 容器 缓冲\nclass Container1 extends Utils {\n\n    // 容器\n    Chicken[]  chickens = new Chicken[10];//默认可以放10只鸡\n\n    int count=0;//用来计数\n    int index=1;\n\n    // 把鸡放到容器中\n    public synchronized void push(Chicken chicken){\n        // 如果数量达到容器的最大数量,停止生产\n        if (chickens.length==count){\n            try {\n                System.out.println(count+\"---------------------\");\n                this.wait();// 容器满了通知生产者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 如果没有达到容器数量,就生产\n        \n            chickens[count] = chicken;//把鸡放到容器中\n            count++;//容器数量加1\n\n            this.notifyAll();//全都唤醒\n        \n    }\n\n    // 消费者消费鸡\n    public synchronized Chicken pop(){\n        // 判断容器中有么有鸡\n        if (count==0){\n            try {\n                this.wait(); // 通知消费者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 有鸡\n        count--;\n        Chicken chicken = chickens[count]; // 有bug\n        this.notify();//通知消费者消费\n        return chicken;\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程停止/index.html",
    "href": "posts/java多线程-- 线程停止/index.html",
    "title": "java多线程– 线程停止",
    "section": "",
    "text": "测试线程停止\n建议线程正常停止,非强行停止—->利用次数控制,不建议死循环\n建议使用标志位(flag)—>设置一个标志位\n不要使用stop和destroy方法和jdk不建议使用的方法\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 测试线程stop\n * 建议线程正常停止,非强行停止---->利用次数控制,不建议死循环\n * 建议使用标志位(flag)--->设置一个标志位\n * 不要使用stop和destroy方法和jdk不建议使用的方法\n * \n * 本实例是实现当main线程跑到500时,B线程也就停止了.\n * */\n\npublic class ThreadStopDemo implements Runnable{\n\n    private boolean flag = true;//设置标志位\n\n    @Override\n    public void run() {\n        int i=0;\n        while (flag){\n            System.out.println(Thread.currentThread().getName()+\"---->\"+i++);\n        }\n    }\n\n    // 自定义的stop方法\n    public void stop(){\n        flag=false;\n    }\n\n    public static void main(String[] args) {\n\n        ThreadStopDemo demo = new ThreadStopDemo();\n        new Thread(demo,\"B线程\").start();\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"main线程\"+i);\n            if (i==500){\n                demo.stop();// 当main线程跑到500就停止另外一个再跑的线程\n            }\n        }\n    }\n\n\n}"
  },
  {
    "objectID": "posts/java网络编程-- URL(网络资源下载)/index.html",
    "href": "posts/java网络编程-- URL(网络资源下载)/index.html",
    "title": "java网络编程– URL(网络资源下载)",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * 利用URL进行网络文件下载\n * */\npublic class URLDownload {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"https://img-home.csdnimg.cn/images/20211019040101.gif\");\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();//打开连接,对链接进行访问;\n        InputStream inputStream = urlConnection.getInputStream();\n        FileOutputStream fileOutputStream = new FileOutputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\" +\n                \"\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson06\\\\download.gif\");\n        byte[] buffer = new byte[1024];\n        int len;\n        while ((len=inputStream.read(buffer))!=-1){\n            fileOutputStream.write(buffer,0,len);\n        }\n        fileOutputStream.close();\n        inputStream.close();\n        System.out.println(\"下载完成\");\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- Tcp聊天/index.html",
    "href": "posts/java网络编程-- Tcp聊天/index.html",
    "title": "java网络编程– Tcp聊天",
    "section": "",
    "text": "客户端\npackage cn.usts.edu.lesson02;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TcpClientDemo01 {\n    public static void main(String[] args) {\n        Socket socket=null;\n        OutputStream os = null;\n\n        // 1*要知道服务器的地址\n        try {\n            InetAddress ServerIP = InetAddress.getByName(\"127.0.0.1\");\n            int port=9999;\n            socket = new Socket(ServerIP, port);//建立一个插座\n            os = socket.getOutputStream();\n            os.write(\"第一个tcp聊天室\".getBytes());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n        if (socket!=null){\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (os!=null){\n            try {\n                os.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n服务端\npackage cn.usts.edu.lesson02;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpServerDemo01 {\n    public static void main(String[] args) {\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream byteArrayOutputStream = null;\n\n        // 1*首先得先有一个地址,让被人连过来\n        try {\n            // serverSocket默认开启服务的主机,当前的ip地址为服务器地址,所以只需要个端口号\n            serverSocket = new ServerSocket(9999);\n            while (true){\n                socket = serverSocket.accept();// 监听  监听接受到socket就是连接上来的socket\n                inputStream = socket.getInputStream();\n                // 读取消息\n            /*  获取超过1024个字节的中文就容易产生乱码\n            InputStream inputStream = socket.getInputStream();\n            byte[] buffer =new byte[1024];\n            int len;\n            // 从输入流读取一些字节数，并将它们存储到缓冲区b 。 实际读取的字节数作为整数返回。\n            while ((len=inputStream.read(buffer))!=-1){\n                String msg = new String(buffer, 0, len);\n                System.out.println(msg);\n            }  */\n                byteArrayOutputStream = new ByteArrayOutputStream();\n                int len;\n                byte[] buffer = new byte[1024];\n                while ((len=inputStream.read(buffer))!=-1){\n                    byteArrayOutputStream.write(buffer,0,len);\n                }\n                System.out.println(byteArrayOutputStream.toString());\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        if (byteArrayOutputStream!=null){\n            try {\n                byteArrayOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream!=null){\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (socket!=null){\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverSocket!=null){\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "posts/毫米波雷达/index.html",
    "href": "posts/毫米波雷达/index.html",
    "title": "毫米波雷达",
    "section": "",
    "text": "参考\n知乎: https://zhuanlan.zhihu.com/p/416269210 TI官方:https://training.ti.com/intro-mmwave-sensing-fmcw-radars-module-1-range-estimation?context=1128486-1139153-1128542\n\n\n单目标测距原理\n\n中频信号 = 斜率 x 时延.\nIF = S*τ\nIF = S*(2d/c) d:传播距离 c:光速\nd = IF*c/2S\n\n\n\n距离分辨率, 区分多目标\n\n通过FFT将时域信号转换为频域信号, 所表现出来的是多个目标的频域信号会出现多个峰, 两个脉冲相差小于一个周期则无法很明显观察到峰, 观测时间越长, 峰越清晰\n观察时长为T的一个观察窗可以分离相隔超过1/T Hz的频率分量(个人理解应该是带宽B/T的频率分量)????\n观察窗口长度为 的 IF 信号能将间距为 的谱峰分开。故通过增加 IF 信号的长度（观察期）来可以改善距离分辨率。而信号长度的增加会使信号带宽 随之变宽，因此，也可以说增加 IF 信号的带宽可以改善距离分辨率。\n\n\n > ## 相关应用的个人推测 > - 因为观察窗时间加长, 所以带宽B也线性增加. > - 所以斜率对于应用的影响非常关键 > - 如果是短距离的目标距离分辨, 那合理推测斜率应该是比较大, 这样可以区分出近距离的不同目标, 且可以使得观察窗T的周期尽可能缩短. > - 如果是远距离的物体, 那斜率应该尽可能的小,这样可以检测到远处目标的反射信号, > - 那这样的话, ti的vitalSign的项目就是斜率比较高的配置\n\n区分多个目标–总结\n\n区分多个目标的原理,就是将两个相距为△d的目标映射到频率差为△f的两个峰\n最小分辨率: c/2B\n\n\n推导:\n\\[\n{△f>}{1\\over T }\n\\]\n\\[\n{2△dS\\over c}>{1\\over T }\n\\] \\[\n{△d}>{c\\over 2ST }\n\\] 又因为: B=ST \\[\n{△d}>{c\\over 2B }\n\\]"
  },
  {
    "objectID": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "href": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "title": "win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）",
    "section": "",
    "text": "问题描述：\n直接点击了删除账户，导致系统无用户存在，重启系统完发现之前账户依旧存在，但是输入密码无法进入系统。 # 解决方案（进入windows自带的启动修复） 登录页面点击电源按钮（关机，重启，注销）选择重启（①在点击重启的同时点击键盘上的shift按键） ，将会进入到下面的界面 ### ①在点击重启的同时点击键盘上的shift按键 ### ②选择系统还原\n ### ③选择还原点\n ### ④windows11需要输入硬盘密码（登录微软账户查询密码：https://account.microsoft.com/devices/recoverykey?refd=account.microsoft.com）  ### 输入以上密钥后系统将进入还原点进行还原，等待系统重启即可恢复。"
  },
  {
    "objectID": "posts/java注解和反射-- 得到class类的几种方式/index.html",
    "href": "posts/java注解和反射-- 得到class类的几种方式/index.html",
    "title": "java注解和反射– 得到class类的几种方式",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.Reflection03;\n\n/**\n * @author ：fly\n * @description: 获取class对象的方法\n * @date ：2021/10/27 14:11\n */\npublic class GetClassDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person = new Teacher();\n        System.out.println(\"这个人是\"+person.name);\n\n        // 方式1: 通过对象获取\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式2: forName获取\n        Class c2 = Class.forName(\"cn.usts.edu.Reflection03.Teacher\");\n        System.out.println(c2.hashCode());\n\n        // 方式3:通过类名.class获取\n        Class c3 = Teacher.class;\n        System.out.println(c3.hashCode());\n\n        // 方式4: 内置类型的包装类都有一个Type属性\n        Class c4 = Integer.TYPE;\n        System.out.println(c4);\n\n        // 方式5: 通过父类获取\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\n// pojo1\nclass Person{\n    int age;\n    String name;\n\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public Person() {\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// pojo2 教师\nclass Teacher extends Person{\n    public Teacher() {\n        this.age = 30;\n        this.name = \"老师\";\n    }\n}\n\n// pojo3 学生\nclass Student extends Person{\n    public Student() {\n        this.age=18;\n        this.name=\"学生\";\n    }\n}"
  },
  {
    "objectID": "posts/java冒泡排序/index.html",
    "href": "posts/java冒泡排序/index.html",
    "title": "java冒泡排序",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.arrayList;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: // 冒泡排序\n * @date ：2021/11/2 12:54\n */\npublic class SortMaoPao {\n    public static void main(String[] args) {\n        Book book1 = new Book(\"三国\", 15.5f, \"施耐庵\");\n        Book book2 = new Book(\"水浒\",55.8f,\"罗贯中\");\n        Book book3 = new Book(\"西游\",19.6f,\"吴承恩\");\n        Book book4 = new Book(\"红楼\",78.1f,\"曹雪芹\");\n\n        ArrayList aList = new ArrayList();\n        aList.add(book1);\n        aList.add(book2);\n        aList.add(book3);\n        aList.add(book4);\n\n        aList.forEach(obj -> System.out.println(obj));\n\n        System.out.println(\"=============排序后==============\");\n        sort(aList);\n        aList.forEach(obj -> System.out.println(obj));\n\n    }\n\n    // 冒泡排序\n    public static void sort(ArrayList arrayList){\n        int size = arrayList.size();\n        for (int i=0; i<size-1;i++){ // 比较的次数\n            for (int j=0;j<size-i-1;j++){ // 比较的元素\n                Book book1 =(Book) arrayList.get(j);\n                Book book2 =(Book) arrayList.get(j+1);\n                if (book1.getPrice()>book2.getPrice()){\n                    arrayList.set(j,book2);\n                    arrayList.set(j+1,book1);\n                }\n            }\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    private float price;\n    private String auth;\n\n    @Override\n    public String toString() {\n        return  \"名称:\" + name +\n                \"\\t 价格:\" + price +\n                \"\\t 作者:\" + auth;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n\n    public String getAuth() {\n        return auth;\n    }\n\n    public void setAuth(String auth) {\n        this.auth = auth;\n    }\n\n    public Book() {\n    }\n\n    public Book(String name, float price, String auth) {\n        this.name = name;\n        this.price = price;\n        this.auth = auth;\n    }\n}"
  },
  {
    "objectID": "posts/vs打包qt程序/index.html",
    "href": "posts/vs打包qt程序/index.html",
    "title": "vs打包qt程序",
    "section": "",
    "text": "把vs切换到Release模式,编译程序  # 进入到项目的Release文件夹中把*.exe文件拷贝出来  # 进入到新建的空文件夹package_demo把.exe文件复制进去.  # 打开qt的MSVC编译器(编译成windows平台的可执行程序) 用windows自带的应用搜索功能搜索即可, 版本号根据所装版本而定 这里用32位的,方便在32和64位机器上运行.因为64位机器是兼容32机器的,方便在两个系统运行  # 进入到exe所在文件夹,执行以下命令\nwindeployqt *.exe\n\n\n\n在这里插入图片描述\n\n\nwindeployqt VitalSignsRadar_Demo.exe\n 执行完效果:   # 到这里在开发环境是运行是没有问题的 打包的目的是为了在用户的环境上使用,所以我们要把开发环境下qt之外的包也打包进来 这里用EnigmaVirtualBox打包额外的需要的包 \n  # 点击 添加 -> 添加文件夹递归"
  },
  {
    "objectID": "posts/java基础知识（笔记）/index.html",
    "href": "posts/java基础知识（笔记）/index.html",
    "title": "java基础知识（笔记）",
    "section": "",
    "text": "1、打开cmd执行javac HelloWorld 的执行原理\n* jiava.exe 命令启动jvm（java虚拟机）\n* jvm启动之后会启动类加载器（classLoader）\n* classLoader会在硬盘上的某个文职搜索HelloWorld.class字节码文件\n* 找到改文件执行\n* 找不到该文件报错\n\n\n疑问：classLoader实在哪个位置上搜素HelloWorld.class字节码文件的？\n    * 默认情况下，classLoader从当前路径下加载xxx.class 字节码文件的\n    * 也可以让classLoader去某个指定的路径下加载字节码文件，这是需要配置环境变量classpath\n    * classpath环境属于java语言中的环境变量，不属于windows操作系统【path环境变量属于操作系统】\n    * classpath是给classLoader类加载器指订路径的\n    * 设置这样环境变量： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n    - 在任意位置打开cmd，都可以执行，java HelloWorld\n    * classpath环境变量没有配置的话，类加载器默认都会从当前路径下找字节码文件（xx.class文件）\n    * 从上所述，环境变量classpath不用配置，这样类加载器会自动从当前路径下加载class字节码文件。所以，每一次执行.class文件程序的时候，都需要在dos命令窗口中先切换到.class字节码文件所在的路径下，然后运行。\n2、关于java源程序中的注释\n* 什么是注释？注释的作用是什么？\n    - 出现在java的源程序中，对java的作用是什么？\n    - 只是不会被编译到.class文件中\n    - 一个好的开发习惯应该是多编写注释，这样代码的的可读性比较高\n* java中的注释怎么写\n\n\n    - 单行注释，只注释当前行\n        // 单行注释，只注释当行\n\n\n\n    - 多行注释\n        /*\n            多行注释\n            多行注释\n            多行注释\n        */\n        \n\n    - javadoc注释\n        /**\n        * javadoc注释\n        * javadoc注释\n        * javadoc注释\n        **/\n3、对HelloWorld程序进行解释： 需要记忆\n* public\n    * class\n    * static \n    * void \n    * System.out.println(\"\"); 向控制台输出消息\n    * 类体\n    * 方法体\n    * 类体中不能直接编辑java语句【除了声明变量】\n    * 一个java语句必须以；结尾\n    * 方法体中可以编写多条java语句\n    * 主方法是程序的入口，固定写法，sun公司规定的\n4、public class 和class 的区别：\n    * 一个java源文件当中可以定义多个class\n    * 一个java源文件中public的class不是必须的，可以没有public class\n    * 一个class会定义生成一个xxx.class 字节码文件\n    * 一个java源文件当中定义公开的类（public class）的话，只能有一个，并且雷鸣必须和java的源文件名一致。\n    *  每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，想执行X.class中的main方法，java X\n    * 注意：当在命令窗口中执行java.Hello，name要求Hello.class中必须有主方法。没有主方法运行会报找不到主方法错发。"
  },
  {
    "objectID": "posts/java基础知识（笔记）/index.html#第二章",
    "href": "posts/java基础知识（笔记）/index.html#第二章",
    "title": "java基础知识（笔记）",
    "section": "第二章",
    "text": "第二章\n1、标识符\njava当中凡是可以自己起名字的单词都是标识符【类名、方法名、接口名、变量名、常量名、、、、、】\n标识符的命名队则: ①标识符必须要由数字、字母、下划线组成，不能含有其他字符。 ②不能由数字开头 ③严格区分大小写 ④关键字不能做标识符\n2、关键字\n具有特殊含义的单词，提前制定好的。\n全部小写\n如：public、static、void 、、、、、、\n3、字面值\n数字、字符、字符串、、、、\n通俗的说字面值就是数据\n4、变量\n内存中存储数据最基本的单元\n    * 每一个变量都由三部分组成\n        - 数据类型\n        - 变量名\n        - 存储的相关数据\n        \n    * 可以重复读取\n    * 变量存储的数据要和变量的类型是一致的\n    * 在同一个作用域内变量不能重名\n    * 声明类型和复制可以同时进行 int a = 100;\n    * 变量的作用域：出了大括号就不认识了\n    * 根据出现的位置可以分为：\n        - 局部变量： 方法体外内【花括号里面】\n        - 成员变量： 方法体之外，类体之内\n    \n5、数据类型\n作用：\n    * 指导java运行机给该变量分配多大的内存空间，不同类型的数据类型分配的内存空间大小也不一样\n    * 数据类型包括：\n        - 基本数据类型【4大类8小种】\n            四大类: 整数型（byte1,short2,int4,long8）、浮点型(float4,double8)、布尔型(boolean1)、字符型(char2)\n        - 引用数据类型【字符串型】"
  },
  {
    "objectID": "posts/java多线程-- 信号灯法则/index.html",
    "href": "posts/java多线程-- 信号灯法则/index.html",
    "title": "java多线程– 信号灯法则",
    "section": "",
    "text": "利用标志位,控制生产和消费 生产一个消费一个\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson08;\npublic class TrafficLightDemo {\n    public static void main(String[] args) {\n        Googs googs = new Googs();\n        new Productor1(googs).start();\n        new Consumer1(googs).start();\n    }\n}\n//生产者\nclass Productor1 extends Thread{\n    Googs goog;\n    Productor1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            goog.production(i+\"产品\");\n        }\n    }\n}\n\n//消费者\nclass Consumer1 extends Thread{\n    Googs goog;\n    Consumer1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            goog.consume();\n        }\n    }\n}\n\n//商品\nclass Googs{\n    //设置产品属性\n    public String name;\n    //设置标识位 flag为true消费者消费，如果false生产者生产\n    boolean flag = true;\n\n    //生产者生产\n    public synchronized void production(String name){\n        //如果生产完之后，等待消费者消费\n        if(!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产者生产了第\"+name);\n        //通知消费者消费\n        this.name = name;\n        this.notifyAll();\n        flag = !this.flag;\n    }\n    //消费者消费\n    public synchronized void consume(){\n        //如果消费完了，等待生产者生产\n        if(flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"消费了\"+this.name+\"产品--\");\n        this.notifyAll();\n        flag = !this.flag;\n\n    }\n}"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html",
    "href": "posts/springmvc-json-乱码解决/index.html",
    "title": "springmvc-json-乱码解决",
    "section": "",
    "text": "@Controller\npublic class UserController {\n\n//   \n    // 多数通过配置xml文件实现乱码过滤，这种方式不推荐，写起来太冗余\n    @RequestMapping(value = \"/json1\")\n    @ResponseBody // 让返回字符串对象，不走视图解析器\n    public String json1() throws JsonProcessingException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        User1 user1 = new User1(\"tom\",12,\"男\");\n        // 将对象转换为字符串对象，如果出现500错误多数是 打包没打jackson的包\n        String st = mapper.writeValueAsString(user1);\n        // 打印转换过的json数据\n        System.out.println(st);\n        return st;\n    }\n\n}"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "href": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "title": "springmvc-json-乱码解决",
    "section": "2、spring解决中文乱码-方法1：",
    "text": "2、spring解决中文乱码-方法1：\n @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\")  解决乱码问题"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "href": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "title": "springmvc-json-乱码解决",
    "section": "3、mvc框架解决中文乱码-方法2：",
    "text": "3、mvc框架解决中文乱码-方法2：\n修改springmvc-servlet.xml\n<!--    json 编码过滤器-->\n    <mvc:annotation-driven>\n        <mvc:message-converters register-defaults=\"true\">\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <constructor-arg value=\"UTF-8\"/>\n            </bean>\n            <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n                <property name=\"objectMapper\">\n                    <bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\">\n                        <property name=\"failOnEmptyBeans\" value=\"false\"/>\n                    </bean>\n                </property>\n            </bean>\n        </mvc:message-converters>\n    </mvc:annotation-driven>"
  },
  {
    "objectID": "posts/中断-轮询/index.html",
    "href": "posts/中断-轮询/index.html",
    "title": "中断-轮询",
    "section": "",
    "text": "阻塞: 等待处理完再处理别的事情\n\n\n轮询: 每隔一段时间查看是否满足处理条件\n- 优点: 实时性较好\n- 缺点: 占用cpu性能\n\n\n中断: 收到信号后处理\n- 优点: cpu利用率高\n- 缺点: 并行处理的中断容易导致cpu无法响应,缓冲区数据较多的时候,cpu会消耗大量时间处理."
  },
  {
    "objectID": "posts/java多线程-- Runnable简单实现(例子)/index.html",
    "href": "posts/java多线程-- Runnable简单实现(例子)/index.html",
    "title": "java多线程– Runnable简单实现(例子)",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\npublic class RunnableSimpleDemo implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            System.out.println(\"吃第\"+i+\"个馒头\");\n        }\n    }\n\n    public static void main(String[] args) {\n//        RunnableSimpleDemo runnableSimpleDemo = new RunnableSimpleDemo();\n//        Thread thread = new Thread(runnableSimpleDemo);\n//        thread.start();// 线程启动\n        new Thread(new RunnableSimpleDemo()).start();// 线程启动\n\n        for (int i = 0; i < 20; i++) {\n            System.out.println(\"喝第\"+i+\"口水\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html",
    "href": "posts/Ubuntu21 美化/index.html",
    "title": "Ubuntu21 美化",
    "section": "",
    "text": "sudo apt update\n\nsudo apt-get install gnome-tweak-tool\n\nsudo apt-get install gnome-shell-extensions\n\nsudo apt-get install gnome-shell-extension-dashtodock\n\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#搜索优化",
    "href": "posts/Ubuntu21 美化/index.html#搜索优化",
    "title": "Ubuntu21 美化",
    "section": "2、搜索优化",
    "text": "2、搜索优化\n打开Dash to dock 根据需求修改设置 打开user theams\n# 重启\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#挑选主题",
    "href": "posts/Ubuntu21 美化/index.html#挑选主题",
    "title": "Ubuntu21 美化",
    "section": "3、挑选主题",
    "text": "3、挑选主题\ngnome网站：主题网站"
  },
  {
    "objectID": "posts/java集合-- HashSet小练习/index.html",
    "href": "posts/java集合-- HashSet小练习/index.html",
    "title": "java集合– HashSet小练习",
    "section": "",
    "text": "Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你 * 如果name+birthday相同判断为统一个对象\n注意点 * birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法 \npackage cn.usts.edu.hashSet;\n\nimport java.util.HashSet;\nimport java.util.Objects;\n\n/**\n * @author ：fly\n * @description: Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你\n *                 如果name+birthday相同判断为统一个对象\n *                 \n *               注意点:\n *                     birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法\n *                 \n * @date ：2021/11/2 15:24\n */\npublic class Employee {\n    private String name;\n    private float sal;\n    private MyDate birthday;\n\n    public static void main(String[] args) {\n        Employee jack = new Employee(\"jack\", 4500.22f, new MyDate(1999, 10, 5));\n        Employee jack1 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 5));// sal 不同\n        Employee jack2 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 6));// day不同\n        Employee jack3 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 11, 5));// month不同\n        Employee jack4 = new Employee(\"jack\", 3500.22f, new MyDate(1998, 10, 5));// year不同\n\n        Employee luck = new Employee(\"luck\", 5500.22f, new MyDate(1999, 10, 5));\n        Employee luck2 = new Employee(\"luck2\", 5500.22f, new MyDate(1999, 10, 5));\n\n        HashSet set = new HashSet();\n        set.add(jack);\n        set.add(jack1);\n        set.add(jack2);\n        set.add(jack3);\n        set.add(jack4);\n        set.add(luck);\n        set.add(luck2);\n        set.forEach(obj-> System.out.println(obj));\n\n    }\n\n\n    public Employee() {\n    }\n\n    public Employee(String name, float sal, MyDate birthday) {\n        this.name = name;\n        this.sal = sal;\n        this.birthday = birthday;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getSal() {\n        return sal;\n    }\n\n    public void setSal(float sal) {\n        this.sal = sal;\n    }\n\n    public MyDate getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(MyDate birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"name='\" + name + '\\'' +\n                \", sal=\" + sal +\n                \", date=\" + birthday +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Employee employee = (Employee) o;\n        return Objects.equals(name, employee.name) && Objects.equals(birthday, employee.birthday);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, birthday);\n    }\n}\n\nclass MyDate{\n    private int year;\n    private int moth;\n    private int day;\n\n    public MyDate(int year, int moth, int day) {\n        this.year = year;\n        this.moth = moth;\n        this.day = day;\n    }\n\n    public MyDate() {\n    }\n\n    public int getYear() {\n        return year;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    public int getMoth() {\n        return moth;\n    }\n\n    public void setMoth(int moth) {\n        this.moth = moth;\n    }\n\n    public int getDay() {\n        return day;\n    }\n\n    public void setDay(int day) {\n        this.day = day;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"MyDate{\" +\n                \"year=\" + year +\n                \", moth=\" + moth +\n                \", day=\" + day +\n                '}';\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MyDate myDate = (MyDate) o;\n        return year == myDate.year && moth == myDate.moth && day == myDate.day;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(year, moth, day);\n    }\n}"
  },
  {
    "objectID": "posts/安卓7以上安装系统证书(system分区没有权限)/index.html",
    "href": "posts/安卓7以上安装系统证书(system分区没有权限)/index.html",
    "title": "安卓7以上安装系统证书(system分区没有权限)",
    "section": "",
    "text": "试验环境 小米8 已root 安卓9 system分区没有修改权限大概率是没有remount\n\n\n下载安装openssl https://jszhuanben.lanzouy.com/iPxBM0bb6gni 添加及环境变量(openssl所在目录)\n\n\n获取系统证书 - 从抓包软件中获取证书(charles,fiddler等)\n\n >- 将证书文件重新命名为hash.0\nopenssl x509 -subject_hash_old -in Charles.pem\n \n\n将文件放入系统证书目录中\n\n\n利用adb的shell进行操作\n\n# 修改system分区为可读写\nmount -o remount,rw /system\n\n# 移动文件到系统证书目录(文件已经通过拖拉放到手机上了anlink)\nmv 0c454880.0 /system/etc/security/cacerts\n \n# 修改文件权限\nchmod 644 /system/etc/security/cacerts/0c454880.0\n\n查看证书 - 可以查看到证书才算成功\n\n \n\n后续的操作就是正常的charles代理的设置, 设置wifi代理ip和端口,就不叙述了"
  },
  {
    "objectID": "posts/java多线程-- Callable接口简单应用/index.html",
    "href": "posts/java多线程-- Callable接口简单应用/index.html",
    "title": "java多线程– Callable接口简单应用",
    "section": "",
    "text": "使用callable接口的四个步骤 * 1.创建执行服务 * 2.提交执行服务 * 3.获取执行结果 * 4.关闭服务\npackage cn.usts.edu.lesson03;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.concurrent.*;\n\n/**\n * 使用callable接口\n * 1.创建执行服务\n * 2.提交执行服务\n * 3.获取执行结果\n * 4.关闭服务\n * */\n\npublic class CallableDemo implements Callable {\n    String file;\n    String url;\n    String filename;\n\n    public CallableDemo(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public Boolean call() {\n        ImageDownload imageDownload = new ImageDownload();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n        return true;\n    }\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CallableDemo t1 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        CallableDemo t2 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        CallableDemo t3 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        //        *1.创建执行服务\n        ExecutorService service = Executors.newFixedThreadPool(3);\n\n        //        * 2.提交执行服务\n        Future<Boolean> r1 = service.submit(t1);\n        Future<Boolean> r2 = service.submit(t2);\n        Future<Boolean> r3 = service.submit(t3);\n\n        //        * 3.获取执行结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //        * 4.关闭服务\n        service.shutdown();\n\n    }\n\n}\n\nclass  ImageDownload{\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html",
    "href": "posts/spring整合SSM/index.html",
    "title": "spring整合SSM",
    "section": "",
    "text": "CREATE DATABASE `ssmbuild`;\n\nUSE `ssmbuild`;\n\nDROP TABLE IF EXISTS `books`;\n\nCREATE TABLE `books` (\n`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',\n`bookName` VARCHAR(100) NOT NULL COMMENT '书名',\n`bookCounts` INT(11) NOT NULL COMMENT '数量',\n`detail` VARCHAR(200) NOT NULL COMMENT '描述',\nKEY `bookID` (`bookID`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES\n(1,'Java',1,'从入门到放弃'),\n(2,'MySQL',10,'从删库到跑路'),\n(3,'Linux',5,'从进门到进牢');"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "href": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "title": "spring整合SSM",
    "section": "2.1新建一Maven项目！ssmbuild ， 添加web的支持",
    "text": "2.1新建一Maven项目！ssmbuild ， 添加web的支持"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "href": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "title": "spring整合SSM",
    "section": "2.2导入相关的pom依赖！",
    "text": "2.2导入相关的pom依赖！\n<dependencies>\n   <!--Junit-->\n   <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>\n       <version>4.12</version>\n   </dependency>\n   <!--数据库驱动-->\n   <dependency>\n       <groupId>mysql</groupId>\n       <artifactId>mysql-connector-java</artifactId>\n       <version>5.1.47</version>\n   </dependency>\n   <!-- 数据库连接池 -->\n   <dependency>\n       <groupId>com.mchange</groupId>\n       <artifactId>c3p0</artifactId>\n       <version>0.9.5.2</version>\n   </dependency>\n\n   <!--Servlet - JSP -->\n   <dependency>\n       <groupId>javax.servlet</groupId>\n       <artifactId>servlet-api</artifactId>\n       <version>2.5</version>\n   </dependency>\n   <dependency>\n       <groupId>javax.servlet.jsp</groupId>\n       <artifactId>jsp-api</artifactId>\n       <version>2.2</version>\n   </dependency>\n   <dependency>\n       <groupId>javax.servlet</groupId>\n       <artifactId>jstl</artifactId>\n       <version>1.2</version>\n   </dependency>\n\n   <!--Mybatis-->\n   <dependency>\n       <groupId>org.mybatis</groupId>\n       <artifactId>mybatis</artifactId>\n       <version>3.5.2</version>\n   </dependency>\n   <dependency>\n       <groupId>org.mybatis</groupId>\n       <artifactId>mybatis-spring</artifactId>\n       <version>2.0.2</version>\n   </dependency>\n\n   <!--Spring-->\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-webmvc</artifactId>\n       <version>5.1.9.RELEASE</version>\n   </dependency>\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-jdbc</artifactId>\n       <version>5.1.9.RELEASE</version>\n   </dependency>\n   \n   <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.16.22</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>RELEASE</version>\n            <scope>compile</scope>\n        </dependency>\n</dependencies>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "href": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "title": "spring整合SSM",
    "section": "3、Maven资源过滤设置",
    "text": "3、Maven资源过滤设置\n静态资源没有导出记得加上\n<build>\n   <resources>\n       <resource>\n           <directory>src/main/java</directory>\n           <includes>\n               <include>**/*.properties</include>\n               <include>**/*.xml</include>\n           </includes>\n           <filtering>false</filtering>\n       </resource>\n       <resource>\n           <directory>src/main/resources</directory>\n           <includes>\n               <include>**/*.properties</include>\n               <include>**/*.xml</include>\n           </includes>\n           <filtering>false</filtering>\n       </resource>\n   </resources>\n</build>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置包",
    "href": "posts/spring整合SSM/index.html#配置包",
    "title": "spring整合SSM",
    "section": "4、配置包",
    "text": "4、配置包\ncn.usts.pojo\n\ncn.usts.dao\n\ncn.usts.service\n\ncn.usts.controller"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "title": "spring整合SSM",
    "section": "5、mybatis-config.xml",
    "text": "5、mybatis-config.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n       PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n</configuration>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "href": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "title": "spring整合SSM",
    "section": "6、applicationContext.xml",
    "text": "6、applicationContext.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "href": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "title": "spring整合SSM",
    "section": "7、数据库配置文件 database.properties",
    "text": "7、数据库配置文件 database.properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&useUnicode=true&characterEncoding=utf8\njdbc.username=root\njdbc.password=123321"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#books.class",
    "href": "posts/spring整合SSM/index.html#books.class",
    "title": "spring整合SSM",
    "section": "8、Books.class",
    "text": "8、Books.class\npackage cn.usts.edu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Books {\n    private int bookID;\n    private String bookName;\n    private int bookCounts;\n    private String detail;\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper接口",
    "href": "posts/spring整合SSM/index.html#bookmapper接口",
    "title": "spring整合SSM",
    "section": "9、bookMapper接口",
    "text": "9、bookMapper接口\npackage cn.usts.edu.dao;\n\nimport cn.usts.edu.pojo.Books;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\npublic interface bookMapper {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook(@Param(\"bookId\") int id);\n    // 根据id查询一本书\n    Books queryBook(@Param(\"bookId\") int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List<Books> queryAllBooks();\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper.xml",
    "href": "posts/spring整合SSM/index.html#bookmapper.xml",
    "title": "spring整合SSM",
    "section": "10、bookMapper.xml",
    "text": "10、bookMapper.xml\nPUBLIC “-//mybatis.org//DTD mapper 3.0//EN”别写错了\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"cn.usts.edu.dao.bookMapper\">\n    <insert id=\"addBook\" parameterType=\"Books\">\n        insert into ssmbuild.books(bookName, bookCounts, detail)\n        values(#{bookName},#{bookCounts},#{detail});\n    </insert>\n\n    <delete id=\"deleteBook\" parameterType=\"int\">\n        delete from ssmbuild.books where bookID=#{bookId};\n    </delete>\n\n    <update id=\"updateBook\" parameterType=\"Books\">\n        update ssmbuild.books\n        set bookName=#{bookName},\n            bookCounts=#{bookCounts},\n            detail=#{detail}\n        where bookID=#{bookId};\n    </update>\n\n    <select id=\"queryBook\" parameterType=\"Books\">\n        select * from ssmbuild.books\n        where bookID=#{bookId};\n    </select>\n\n    <select id=\"queryAllBooks\" parameterType=\"Books\">\n        select * from ssmbuild.books;\n    </select>\n</mapper>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "title": "spring整合SSM",
    "section": "11、绑定mapper【myBatis-config.xml】",
    "text": "11、绑定mapper【myBatis-config.xml】\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://www.mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"cn.usts.edu.pojo\" />\n    </typeAliases>\n\n<!--    绑定mapper-->\n    <mappers>\n        <mapper class=\"cn/usts/edu/dao/bookMapper.xml\"/>\n    </mappers>\n</configuration>\n\n【文件结构】"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#编写service层",
    "href": "posts/spring整合SSM/index.html#编写service层",
    "title": "spring整合SSM",
    "section": "12、编写service层",
    "text": "12、编写service层\n12.1 BookService接口\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\n\n\nimport java.util.List;\n\npublic interface BookService {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook( int id);\n    // 根据id查询一本书\n    Books queryBook( int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List<Books> queryAllBooks();\n}\n12.2 BookServiceImp.class\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\nimport cn.usts.edu.dao.bookMapper;\nimport java.util.List;\n\npublic class BookServiceImp implements BookService {\n\n    // service层调用dao层\n    private bookMapper bookMapper;\n\n    public void setBookMapper(cn.usts.edu.dao.bookMapper bookMapper) {\n        this.bookMapper = bookMapper;\n    }\n\n    @Override\n    public int addBook(Books books) {\n        return bookMapper.addBook(books);\n    }\n\n    @Override\n    public int deleteBook(int id) {\n        return bookMapper.deleteBook(id);\n    }\n\n    @Override\n    public Books queryBook(int id) {\n        return bookMapper.queryBook(id);\n    }\n\n    @Override\n    public int updateBook(Books books) {\n        return bookMapper.updateBook(books);\n    }\n\n    @Override\n    public List<Books> queryAllBooks() {\n        return bookMapper.queryAllBooks();\n    }\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "href": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "title": "spring整合SSM",
    "section": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；",
    "text": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n<!--    1、关联数据库配置-->\n    <context:property-placeholder location=\"classpath:database.properties\"/>\n    <!--    2、连接池\n            dbcp,半自动化 不能自动连接\n            c3p0,自动化操作\n            druid,hikari\n    -->\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n        <property name=\"user\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n    </bean>\n<!--    3、sqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n<!--        绑定mybatis配置文件-->\n        <property name=\"configLocation\" value=\"classpath:myBatis-config.xml\"/>\n    </bean>\n\n<!--  配置dao接口扫描包，动态的实现了dao接口可以注入到spring容器中  -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"cn.usts.edu.dao\"/>\n    </bean>\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring整合service层",
    "href": "posts/spring整合SSM/index.html#spring整合service层",
    "title": "spring整合SSM",
    "section": "14、Spring整合service层",
    "text": "14、Spring整合service层\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n<!--    包扫描-->\n    <context:component-scan base-package=\"cn.usts.edu.service\"/>\n<!--    将所有业务类，注入到spring，可以通过配置，或者注解实现-->\n    <bean id=\"BookServiceImpl\" class=\"cn.usts.edu.service.BookServiceImp\">\n        <property name=\"bookMapper\" ref=\"bookMapper\"/>\n    </bean>\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!-- 注入数据库连接池 -->\n        <property name=\"dataSource\" ref=\"dataSource\" />\n    </bean>\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#web.xml",
    "href": "posts/spring整合SSM/index.html#web.xml",
    "title": "spring整合SSM",
    "section": "15、web.xml",
    "text": "15、web.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n<!--    前端控制器-->\n    <servlet>\n        <servlet-name>srpingmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>srpingmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n<!--    编码过滤器-->\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n<!--    session过期时间 15min-->\n    <session-config>\n        <session-timeout>15</session-timeout>\n    </session-config>\n</web-app>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "href": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "title": "spring整合SSM",
    "section": "16、spring-mvc.xml",
    "text": "16、spring-mvc.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n<!--    包扫描-->\n    <context:component-scan base-package=\"cn.usts.edu.controller\"/>\n<!--    注解驱动-->\n    <mvc:annotation-driven/>\n<!--    默认静态资源过滤-->\n    <mvc:default-servlet-handler/>\n<!--    视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n</beans>\n17、Spring配置整合文件，applicationContext.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <import resource=\"classpath:spring-dao.xml\"/>\n    <import resource=\"classpath:spring-mvc.xml\"/>\n    <import resource=\"classpath:spring-service.xml\"/>\n\n\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#index.jsp",
    "href": "posts/spring整合SSM/index.html#index.jsp",
    "title": "spring整合SSM",
    "section": "18、 index.jsp",
    "text": "18、 index.jsp\n在这里插入代码片"
  },
  {
    "objectID": "posts/二分查找/index.html",
    "href": "posts/二分查找/index.html",
    "title": "二分查找",
    "section": "",
    "text": "二分查找的边界问题:\n\n[ left, right ) 左闭右开的情况 1.注意起始的右指针的位置, 因为右指针不包括, 所以是数组长度 2.指针的移动, 虽然不会影响结果, 但是有重复的区间, 所以还是尽量避开重复区间\n\nint  Search_Bin(int arr[], int length,int target){\n    int L=0;\n    int R=length;\n   \n    while(L<R){\n        int mid = (L+R)/2;                      // 获取中间元素的索引\n        if(target>arr[mid]){                    // 如果target大于mid\n           l=mid+1;                             // 将左指针右移动到mid+1的位置, 因为刚才左区已经查找过了, 所以要mid+1\n        }\n        else if(target<arr[mid]){               // 如果target小于mid\n           r=mid;                               // 将右指针左移到mid的位置, 因为右边是一个开区间,不包含,所以直接是mid的位置.\n        }\n        else{\n            return mid;                         // mid的数据为targe直接返回当前mid.\n        }\n    }\n    \n    return 0;\n}\n\n[ left, right ] 左闭右闭的情况 1.注意起始的右指针的位置, 因为右指针的位置也包括在内, 所以是数组长度-1 2.注意左右指针移动区间\n\nint  Search_Bin(int arr[], int length,int target){\n    int L=0;\n    int R=length-1;\n   \n    while(L<=R){\n        int mid = (L+R)/2;                      \n        if(target>arr[mid]){                    \n           l=mid+1;                             // 将左指针右移动到mid+1的位置, 因为刚才左区已经查找过了, 所以要mid+1\n        }\n        else if(target<arr[mid]){               \n           r=mid-1;                             // 因为右指针的位置也包含了, 所以需要将右指针移动到mid-1\n        }\n        else{\n            return mid;                         \n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "",
    "text": "cookie是一种会话管理技术，他是用来保存会话技术过程中产生的数据，然后在浏览器和服务器交互时，会使用cookie里面保存的数据。\n首次访问不会携带cookie"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html#常用api",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html#常用api",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "2、常用api",
    "text": "2、常用api\n//得到cookie对象： \nCookie cookie = new Cookie( String key, String value);\n//回写（响应）到浏览器：\n response.addCookie(cookie);\n//得到cookie 的名称 ：\nString name = cookie.getName(),\n//得到cookie 的值：   \nString value = cookie.getValue();\n//给cookie设置 生命时长： \nsetMaxAge(int sr);\n//设置cookie生命为7 天;\n例：setMaxAge(60*60*24*7)\n    分类：\n        ①会话级别cookie，浏览器关闭，cookie对象就销毁了；\n        ②持久化cookie，通过setMaxAge()这个方法设置。\n    给cookie设置路径，设置域名：\n        setPath(路径的url),setDomain(域名)；\n        例：域名就是服务器名称   如：www.baidu.com\n//得到cookie：\nCookie[] cookies = request.getCookies();"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html#cookie记录上次访问时间",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html#cookie记录上次访问时间",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "3、cookie记录上次访问时间",
    "text": "3、cookie记录上次访问时间\n默认级别cookie（浏览器关闭就会消失）\nresponse.setContentType(\"text/html;charset=utf-8\");\n        // 获取cookies\n        Cookie[] cookies = request.getCookies();\n        // 遍历cookies数组\n        String lasTime=null;\n        for(int i=0; cookies != null&& i<cookies.length;i++){\n            String name = cookies[i].getName();\n            if(\"lastAccess\".equals(name)){\n                // 获取cookie的时间\n                lasTime = cookies[i].getValue();\n            }\n        }\n        // 判断是否是首次访问，如果cookie里有时间，就不是第一次访问\n        if(lasTime == null){\n            //String time = String.format(\"%tF %<tT\", new Date());\n            //Cookie cookie = new Cookie(\"lastAccess\", time);\n            response.getWriter().print(\"您是第一次访问\");\n        }\n        else{\n            response.getWriter().print(\"您上次访问时间是：\"+lasTime);\n            //String time = String.format(\"%F %<tT\", new Date());\n            //Cookie cookie = new Cookie(\"lastAccess\", time);\n            //response.addCookie(cookie);\n        }\n        \n        String time = String.format(\"%tF %<tT\", new Date());\n        Cookie cookie = new Cookie(\"lastAccess\", time);\n        response.addCookie(cookie);\n持久化cookie\nString time = String.format(\"%tF %<tT\", new Date());\n        Cookie cookie = new Cookie(\"lastAccess\", time);\n        // 保留7天\n        cookie.setMaxAge(60*60*24*7);\n        response.addCookie(cookie);"
  },
  {
    "objectID": "posts/java多线程-- yield 线程礼让/index.html",
    "href": "posts/java多线程-- yield 线程礼让/index.html",
    "title": "java多线程– yield 线程礼让",
    "section": "",
    "text": "加上礼让大概率会让被礼让的先执行.不是一定被礼让的先执行 \npackage cn.usts.edu.lesson06;\n\n/**\n * 线程礼让\n * 礼让的线程会重新和竞争的线程再次公平竞争cpu的资源\n * 再次竞争的结果为最后结果\n * */\n\npublic class ThreadYieldDemo implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"开始\");\n        if (Thread.currentThread().getName().equals(\"线程A\")){ // 如果是线程A就礼让\n            Thread.yield();// 线程礼让\n        }\n        System.out.println(Thread.currentThread().getName()+\"执行结束\");\n    }\n\n    public static void main(String[] args) {\n        ThreadYieldDemo threadYieldDemo = new ThreadYieldDemo();\n        new Thread(threadYieldDemo,\"线程A\").start();\n        new Thread(threadYieldDemo,\"线程B\").start();\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- 文件传输/index.html",
    "href": "posts/java网络编程-- 文件传输/index.html",
    "title": "java网络编程– 文件传输",
    "section": "",
    "text": "客户端发送\npackage cn.usts.edu.lesson03;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TcpFileClientDemo {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9999);\n            OutputStream outputStream = socket.getOutputStream();\n            // 读取文件\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson03\\\\hello.txt\");\n            //FileInputStream fileInputStream = new FileInputStream(new File(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson03\\\\hello.txt\"));\n            // 写出文件\n            byte[] buffer=new byte[1024];\n            int len;\n            while ((len=fileInputStream.read(buffer))!=-1){\n                outputStream.write(buffer,0,len);\n            }\n\n            // 如果没有这句,客户端又进入了等待接收的状态,可是服务器那边没有断开文件的连接,没有办法发送东西过来,所以要先切断输出流\n            socket.shutdownOutput();\n\n            // 服务器告诉客户端的话\"文件接收完毕\"\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            InputStream inputStream = socket.getInputStream();\n            int len2;\n            byte[] buffer2=new byte[1024];\n            while ((len2=inputStream.read(buffer2))!=-1){\n                byteArrayOutputStream.write(buffer2,0,len2);\n            }\n            System.out.println(byteArrayOutputStream.toString());\n\n            //关闭\n            byteArrayOutputStream.close();\n            outputStream.close();\n            fileInputStream.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n服务端接收\npackage cn.usts.edu.lesson03;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpFileServerDemo {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(9999);\n            Socket socket = serverSocket.accept();//侦听\n            InputStream inputStream = socket.getInputStream(); // 文件输入流\n            // 读取字节流\n            FileOutputStream fileOutputStream = new FileOutputStream(\"receive.txt\");\n            int len;\n            byte[] buffer=new byte[1024];\n            while ((len=inputStream.read(buffer))!=-1){\n                fileOutputStream.write(buffer,0,len);\n            }\n\n\n            // 告诉客户端文件传输完毕\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(\"文件传输完毕\".getBytes());\n\n            // 关闭\n            outputStream.close();\n            fileOutputStream.close();\n            inputStream.close();\n            socket.close();\n            serverSocket.close();\n\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "href": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "title": "stm32F103-RT-Thread– 互斥量(mutex)",
    "section": "",
    "text": "在编码前记得打开rtconfig.h中的IPC中的mutex设置 > 互斥量访问的是同一个资源,且只可以有一个线程进行访问, 保证数据的一致性.\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\nstatic int count=0, num=0;\n\nstatic rt_mutex_t mutex = RT_NULL;\nstatic rt_thread_t mutex_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t mutex_2_thread = RT_NULL;                // semaphore thread_2 control block\nstatic rt_thread_t mutex_3_thread = RT_NULL;                // semaphore thread_2 control block\n\n\nstatic void mutex_thread_1_entry(void *parmaeter);\nstatic void mutex_thread_2_entry(void *parmaeter);\nstatic void mutex_thread_3_entry(void *parmaeter);\n\n\nint main(void)\n{\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_FIFO);\n    mutex_1_thread = rt_thread_create(\"mutex_1_thread\", mutex_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (mutex_1_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_2_thread = rt_thread_create(\"metux_2_thread\", mutex_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (mutex_2_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_2_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_3_thread = rt_thread_create(\"mutex3_thread\", mutex_thread_3_entry, RT_NULL,512, 3,20);\n    if(mutex_3_thread!=RT_NULL){\n        rt_thread_startup(mutex_3_thread);\n    }\n    else{\n        return -1;\n    }\n\n}\n\n\n\n\n/*this thread is release semaphore */\nstatic void mutex_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_1 count is [%d]\\n\",count);\n        rt_thread_delay(500);\n        num++;\n        rt_kprintf(\"thread_1 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);    \n    }\n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void mutex_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count--;\n        rt_kprintf(\"thread_2 count is [%d]\\n\",count);\n        rt_thread_delay(700);\n        num--;\n        rt_kprintf(\"thread_2 num is [%d]\\n\",num);   \n        rt_mutex_release(mutex);    \n    }\n}\n\nstatic void mutex_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_3 count is [%d]\\n\",count);\n        num++;\n        rt_kprintf(\"thread_3 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);\n    }   \n}"
  },
  {
    "objectID": "posts/linux matlab安装失败major/index.html",
    "href": "posts/linux matlab安装失败major/index.html",
    "title": "linux matlab安装失败major",
    "section": "",
    "text": "微信公众号搜索linux资源库 里面有提供破解版\nI got problems installing Matlab R2022a on Arch. Running the installer throws the following error:\nterminate called after throwing an instance of ‘std::runtime_error’ what(): Failed to launch web window with error: Unable to launch the MATLABWindow application. The exit code was: 127 fish: Job 1, ‘sudo ./install’ terminated by signal SIGABRT (Abort)\n\nI fixed it by running the following commands.\n\n安装后还需要重新执行次操作\ncd <matlab installer root directory>\ncd /bin/glnxa64\nls | grep libfreetype\nmkdir exclude\nmv libfreetype.so.6 exclude/\nmv libfreetype.so.6.16.0 exclude/\n然后报错是因为matlab指向的是自带的libtiff.so.5需将软连接重新指向 系统的libtiff.so.5\nbin/glnxa64/MATLABWindow: /home/dd21/Software/MATLAB/R2022b/bin/glnxa64/libtiff.so.5: version `LIBTIFF_4.0' not found (required by /usr/lib/libgdk_pixbuf-2.0.so.0)\n\n解决方案\n在matlab中输入,检测信息： cd(matlabroot) ! bin/glnxa64/MATLABWindow - slLibraryBrowser\n\n# matlab install path \ncd /Software/MATLAB/R2022b/bin/glnxa64 \n# create new linker\nln -s /usr/lib64/libtiff.so.5 ./libtiff.so.5\nsudo vim /usr/share/applications/matlab.desktop\n快捷方式\n[Desktop Entry]\nVersion=R2020b\nType=Application\nTerminal=false\nMimeType=text/x-matlab\nExec=/usr/local/MATLAB/R2022b/bin/matlab -desktop\nName=MATLAB\nIcon=matlab\nCategories=Development;Math;Science\nComment=Scientific computing environment\nStartupNotify=true"
  },
  {
    "objectID": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html",
    "href": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html",
    "title": "java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】",
    "section": "",
    "text": "在这里插入图片描述\n\n\n\n\n// 设置响应行状态码为 402\nresponse.setStatus(402);\n\n\n\n在这里插入图片描述\n\n\n\n\n\n// 设置404错误返回信息为 找不到states路径\nresponse.sendError(404,\"找不到states路径\");\n\n\n\n在这里插入图片描述\n\n\n\n\n\n2.1 setHeader() 只添加一个响应数据\nresponse.setHeader(\"sex\":\"0\");\nresponse.setHeader(\"sex\":\"0\");\n// 第二次设置会覆盖掉第一次设置的值\nresponse.setHeader(\"sex\":\"1\");\n2.2 addHeader() 添加多个响应数据\nresponse.addHeader(\"name\":\"hello\");\nresponse.addHeader(\"name\":\"hello\");\n// 第二次设置不会覆盖掉第一次设置的值\nresponse.addHeader(\"name\":\"hello2\");\n 2.3 setContentLength() 设置响应头长度\n// 设置响应头长度\nresponse.setContentLength(999);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI--下拉框JComboBox/index.html",
    "href": "posts/javaGUI--下拉框JComboBox/index.html",
    "title": "javaGUI–下拉框JComboBox",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JComboBoxDemo extends JFrame {\n    public JComboBoxDemo() {\n        this.setTitle(\"下拉框\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        JComboBox<Object> comboBox = new JComboBox<>();\n        comboBox.addItem(null);\n        comboBox.addItem(\"Python\");\n        comboBox.addItem(\"Java\");\n        comboBox.addItem(\"C\");\n        comboBox.addItem(\"C++\");\n\n        Container container = this.getContentPane();\n        container.add(comboBox,BorderLayout.NORTH);\n    }\n\n    public static void main(String[] args) {\n        new JComboBoxDemo();\n    }\n}"
  },
  {
    "objectID": "posts/java EE 解决请求中的缓冲区中文乱码问题/index.html",
    "href": "posts/java EE 解决请求中的缓冲区中文乱码问题/index.html",
    "title": "java EE 解决请求中的缓冲区中文乱码问题",
    "section": "",
    "text": "1、GET请求\n利用字符串构造方法，解决缓冲区中文乱码问题。\n核心处理代码\nString newString = new String(usr_name.getBytes(\"ISO8859-1\"), \"UTF-8\");\n实例：\n// 处理响应的中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 处理get请求发送过来的数据\nString usr_name = request.getParameter(\"username\");\n// 解决缓冲区中文乱码\nString newString = new String(usr_name.getBytes(\"ISO8859-1\"), \"UTF-8\");\n// 打印get缓冲区没处理的数据\nresponse.getWriter().print(\"没处理的数据：\"+usr_name+\"<br>\");\n// 打印get缓冲区处理过的数据\nresponse.getWriter().print(\"处理完的数据：\"+newString+\"<br>\");\n测试：  \n\n\n2、POST请求\npost方法发送过来的数据保存在reques缓冲区对象中，但是request对象默认使用ISO-8859-1编码方式，不支持中文，所以会导致中文乱码。 解决方案：\n// 一定要写在处理之前！！！！！\nrequest.setCharacterEncoding(\"utf-8\");\n实例：\n// 处理响应区乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 处理缓冲区乱码\nrequest.setCharacterEncoding(\"utf-8\");\n// 取到缓冲区的属性值\nString post_name = request.getParameter(\"username\");\n// 打印\nresponse.getWriter().print(post_name);\n测试："
  },
  {
    "objectID": "posts/pyqt5 --02面向对象的设计思想/index.html",
    "href": "posts/pyqt5 --02面向对象的设计思想/index.html",
    "title": "pyqt5 –02面向对象的设计思想",
    "section": "",
    "text": "import sys\nfrom PyQt5.Qt import *\n\"\"\"\n    面向对象的设计思想\n\"\"\"\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('标题名称')\n        self.resize(600,700)\n        self.func_list()\n\n    # 方法通过func_list调用\n    def func_list(self):\n        self.func1()\n        self.func2()\n\n    # 标签控件\n    def func1(self):\n        label = QLabel(self)\n        label.setText('标签上的文字')\n        label.move(100,100)\n        label.setStyleSheet('background-color:red;')\n\n    # 按钮控件\n    def func2(self):\n        btn = QPushButton(self)\n        btn.setStyleSheet('background:blue;')\n        btn.resize(100,100)\n        btn.setText('按钮文字')\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n\n    # sys.argv可以接收用户命令行启动时所输入的参数，根据参数执行不同程序\n    # qApp 为全局对象\n    print(sys.argv)\n    print(app.arguments())\n    print(qApp.arguments())\n    # 以上三个输出结果是一样的\n\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())  # 0是正常退出\n    # app.exec_()  进行循环\n    # sys.exit()   检测退出原因\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE -Session/index.html",
    "href": "posts/java EE -Session/index.html",
    "title": "java EE -Session",
    "section": "",
    "text": "session是一种会话赶礼技术，seession，用来保存会话过程中的数据，保存的数据存储到服务器端。\n\n\n\nsession是基于cookie实现的. 当session被创建时，会在服务器端开辟一块session空间，并把该空间的秘钥(JESSIONID)返回给浏览器， 用户拿到钥匙后对页面进行请求，将秘钥携带在请求头中（set-Cookie:JSEEIONID=111） ## 1.3 HttpSession API\nsession 常用方法：\n①得到session的id（JESSIONID对应的值）：getId();\n② 设置session的生命时长：setMaxInactiveInterval(int interval)\n③销毁session: invalidate();\n③得到session：HttpSession session = getSession();\nsession域对象：作用范围  一次完整的会话（包含多个请求）\n①存值：setAttribute(String key,Object obj);\n②取值：Object obj = getAttribute(String key);\n③移除值：removeAttribute(String key)\n总结域对象：\nrequest对象，session，servletContext对象，作用范围依次变大。\nrequest域对象：再用用范围是一次请求，通常和转发操作配合使用\nsession域对象：作用范围一次会话，通常和重定向配合使用\nservletContext域预想：作用范围整个项目，和重定向、转发操作、都可以配合使用。\n1.4 session超时 session对象有生命时长，他的默认存活时间是30分钟， 具体配置套tomcat软件中的conf下的文件，\n<session-timeout>30</session-timeout>\n立即销毁session对象：invalidate"
  },
  {
    "objectID": "posts/小米刷机/index.html",
    "href": "posts/小米刷机/index.html",
    "title": "小米刷机",
    "section": "",
    "text": "https://miuiver.com/how-to-flash-xiaomi-phone/"
  },
  {
    "objectID": "posts/小米刷机/index.html#右下角注意别选择第三项重新上bl锁",
    "href": "posts/小米刷机/index.html#右下角注意别选择第三项重新上bl锁",
    "title": "小米刷机",
    "section": "右下角注意别选择第三项(重新上BL锁)",
    "text": "右下角注意别选择第三项(重新上BL锁)\n # bilibili视频地址 https://www.bilibili.com/video/BV1BY4y1H7Mc?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb"
  },
  {
    "objectID": "posts/javaGUI--icon/index.html",
    "href": "posts/javaGUI--icon/index.html",
    "title": "javaGUI–icon",
    "section": "",
    "text": "在maven项目中,将图片文件放入classes文件夹下才有效!!!!!\nURL url = ImageIconDemo.class.getResource(\"csdn.png\");获取不到图片的原因.   button.setToolTipText(\"图片按钮\");// 鼠标悬停上面会提示的文字\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class ImageIconDemo extends JFrame {\n\n    public ImageIconDemo() {\n        JLabel label01 = new JLabel(\"图片icon\");\n        JButton button = new JButton();\n\n        URL url = ImageIconDemo.class.getResource(\"csdn.png\");// 获取图片位置\n        ImageIcon imageIcon = new ImageIcon(url);// 实例化新的图片icon\n\n        label01.setIcon(imageIcon);\n        label01.setHorizontalAlignment(SwingConstants.CENTER);\n\n        button.setIcon(imageIcon);\n        button.setBounds(100,100,200,100);\n        button.setToolTipText(\"图片按钮\");// 鼠标悬停上面会提示的文字\n\n        Container container = this.getContentPane();\n        container.add(button);\n        container.add(label01);\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        this.setBounds(100,100,600,600);\n        this.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new ImageIconDemo();\n    }\n}\n\n解决方案 修改pom.xml文件\n<!--所有文件复制到classes下-->\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <excludes>\n                    <exclude>**/*.java</exclude>\n                </excludes>\n            </resource>\n        </resources>\n    </build>"
  },
  {
    "objectID": "posts/南大ics基础课/index.html",
    "href": "posts/南大ics基础课/index.html",
    "title": "南大ics基础课",
    "section": "",
    "text": "视频地址: https://www.bilibili.com/video/BV1Z541127RJ/?p=2&vd_source=c0157a4afd2e47c7662431fd9d2739fb\ngitbook:https://nju-projectn.github.io/ics-pa-gitbook/ics2021/0.2.html\npdf:所在位置:http://www.why.ink:8080/ICS/2022/Main_Page"
  },
  {
    "objectID": "posts/java网络编程-- 端口/index.html",
    "href": "posts/java网络编程-- 端口/index.html",
    "title": "java网络编程– 端口",
    "section": "",
    "text": "端口是为了定位到计算机内的软件所在位置\nnetstat -an  # 查看素有端口\nnetstat -an|findstr \"5900\"  # 查看指定的端口\ntasklist|findstr \"8696\"     # 查看指定端口的进程\npackage cn.usts.edu.lesson01;\n\nimport java.net.InetSocketAddress;\n\npublic class TestSocketAddress {\n    public static void main(String[] args) {\n        InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080);\n        System.out.println(socketAddress);\n        System.out.println(socketAddress.getAddress());// 地址\n        System.out.println(socketAddress.getPort());    // 端口\n        System.out.println(socketAddress.getHostName());  // 域名//C:\\Windows\\System32\\drivers\\etc\\hosts文件中\n    }\n}"
  },
  {
    "objectID": "posts/南大ics课程/index.html",
    "href": "posts/南大ics课程/index.html",
    "title": "南大ics课程",
    "section": "",
    "text": "http://jyywiki.cn/ 该课程主要是通过手把手编写一个模拟器, 来了解计算机底层原理(编译,链接….) # P2-C语言拾遗 >总结: > - 编译链接过程 > - 预编译指令 > - 宏的使用 > - 内存模型 >\n\ngcc hello.c                             // complier c file\nvim a.out                               // see the bin file\n:%!xxd                                  // show with hex\nwe can see .ELF at the begin, this tell us this is an executeable file 我们可以看到开头的.ELF, 这表示这是一个(linux中)可执行文件  >可执行文件可以通过file打开\nfile a.out\n\n\n\n在这里插入图片描述\n\n\n\n上述过程直接通过gcc 实现了从.c到.out 的过程 上述过程拆解: - gcc -S hello.c => 生成.s汇编文件 - gcc -c hello.c => 生成.o文件,但是没有链接 - objdump -d hello.o => 将.o文件反汇编成我们可以看的懂的文件\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n#include 表示将代码复制粘贴进来\n\n\n\n\n\nhello.inc\n\nprintf(\"hello world\\n\");\n\nhello.c\n\n#include <stdio.h>    \n    \nint main(int argc, char* argv[])    \n{    \n    \n    #include \"hello.inc\"    \n    return 0;    \n} \ngcc -E hello.c\n gcc --verbose hello.c 查看include文件是否在包含的目录中\n可以看到#include \"xxx\"和#include <xxx>\"的位置  >使用#include <xxx>\"进行包含文件挥发现找不到这个文件, 系统目录中没有包含该文件. > 可以使用gcc -I./进行将目录添加到系统目录中\n问题演示  解决方案  gcc -I. --verbose hello.c查看日志中是否包含目录  gcc -m32 hello.c 将项目编译为32位机器的目标文件\n\n有趣的预编译, 因为aa和bb都没有定义所以都是NULL, NULL==NULL 得到True,所以输出yes\n\n#include <stdio.h>      \n                                                                             \nint main(int argc, char* argv[])                                             \n{                                                                            \n    #if aa == bb                                                             \n    ¦   printf(\"yes\\n\");                     \n    #else                                                                                                                     \n    ¦   printf(\"no\\n\");                            \n    #endif                                                                                                                                                                       \n}  \n gcc -E aabb.c 查看预编译后的代码.  直接放入extern int printf (const char *__restrict __format, ...);不用全部include也是可以的\nextern int printf (const char *__restrict __format, ...);     \nint main(int argc, char* argv[])    \n{                  \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n} \n编译32位项目,出现报错:https://blog.csdn.net/wzzushx/article/details/119453099\nsudo apt-get install build-essential module-assistant  \nsudo apt-get install gcc-multilib g++-multilib  \n预编译参数依旧添加进去了\nextern int printf (const char *__restrict __format, ...);    \n    \nint main(int argc, char* argv[])    \n{    \n    #ifdef __x86_64__     \n    ¦   printf(\"__x86_64__\\n\");    \n    #else    \n    ¦   printf(\"__x86__\\n\");    \n    #endif    \n    \n    \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n}  \n\n\n\nsystem.c\n  #define SYSTEM sys ## tem      \n                     \n  int main(){        \n     SYSTEM(\"echo hello world\\n\");    \n  }\ngcc system.c                        // 虽然这会报错， 但是没有影响\n./a.out\n\nhello world\n\n\n\n// 奇数行输出ture\n#define true    (__LINE__%2!=0)\n\n\n\nnames.c\n#include <stdio.h>    \n#define NAMES(X) X(TOM) X(Jerry) X(Lcc) X(Hig) X(lcu)    \n#define HELLO(M) M(Hello) M(world) M(\\n)    \n    \nint main(int argc, char* argv[])    \n{    \n    #define PRINT(x) puts(\"hello,\" #x \"!\");    \n    NAMES(PRINT)    \n    HELLO(PRINT)    \n    return 0;    \n} \ngcc -E names.c 使用gcc -E 进行查看预编译的代码。\n# 5 \"namex.c\"\nint main(int argc, char* argv[])\n{\n\n    puts(\"hello,\" \"TOM\" \"!\"); puts(\"hello,\" \"Jerry\" \"!\"); puts(\"hello,\" \"Lcc\" \"!\"); puts(\"hello,\" \"Hig\" \"!\"); puts(\"hello,\" \"lcu\" \"!\");\n    puts(\"hello,\" \"Hello\" \"!\"); puts(\"hello,\" \"world\" \"!\"); puts(\"hello,\" \"\\n\" \"!\");\n    return 0;\n}\n\n\n\n连个函数文件，一个sum.c和main.c先对这两个文件进行编译，没有链接， 然后手动指定链接，最后运行a.out同样产生相同结果。\nsum.c\nint foo(int n){                                                             \n    int sum = 0;                                                                                   \n    for(int i=0;i<=n;i++){                                                                         \n    ¦   sum+=i;                                                                                     \n    }                                                                                               \n    return sum;                                                                                     \n}\nmain.c\n#include <stdio.h>    \n    \nint foo(int n);    \n    \n    \nint main(int argc, char* argv[])    \n{    \n    printf(\"%d\\n\",foo(100));    \n    return 0;    \n}\n ### 链接\n gcc {main,sum}.o -static\n ## 内存 >总结 > - 代码存储的位置最低, 然后是只读变量(const修饰的变量), RO上面就是非零的变量, RW上边就是0变量和为被初始化的变量.上面就是堆栈. >  > 参考代码\n#include <stdio.h>\nvoid printptr(void *p){\n    printf(\"p = %p; *p = %016lx\\n\",p, *(long *)p);\n}\n \nchar bss_1[10];\n \nstatic int _static_1=65535;// ffff\nstatic int _static_2;\n \nint glab_1=65535;\nint glab_2;\nint glab_3=0;\n \nconst char _const = 'a';\nint main(int argc,char *argv[]){\n    int b;\n    static int _static_3=65535;\n    static int _static_4=0;\n    \n    printf(\"------- [code] ------\\n\");\n    printf(\"main:\\t\");\n    printptr(main); // 代码\n    printf(\"main:\\t\");\n    printptr(&main);\n \n    printf(\"------- [data] ------\\n\");\n    printf(\"_____________[data-RO]_____________\\n\");\n    printf(\"&const:\\t\");\n    printf(\"p = %p;\\n\",&_const);\n    printf(\"_____________[data-RW]_____________\\n\");\n    printf(\"stac_1:\\t\");\n    printptr(&_static_1);\n    printf(\"stac_2:\\t\");\n    printptr(&_static_2);\n    printf(\"stac_3:\\t\");\n    printptr(&_static_3);\n    printf(\"stac_4:\\t\");\n    printptr(&_static_4);\n \n    printf(\"glab_1:\\t\");\n    printptr(&glab_1); // 数据\n    printf(\"glab_2:\\t\");\n    printptr(&glab_2); // 数据\n    printf(\"glab_3:\\t\");\n    printptr(&glab_3);\n    printf(\"&bss_1:\\t\");\n    printf(\"p = %p;\\n\",&bss_1);\n    printf(\"b:\\t\");\n    printptr(&b);\n    printf(\"------- [heap] ------\\n\");\n\n    printf(\"\\n\");\n\n    printf(\"------- [stack] ------\\n\");\n    printf(\"argc:\\t\");\n    printptr(&argc); // 堆栈\n    printf(\"argv\\t\");\n    printptr(argv); \n    printf(\"&argv:\\t\");\n    printptr(&argv); \n    printf(\"argv[0:\\t\");\n    printptr(argv[0]);\n}\n # p3- C 语言拾遗(2): 编程实践 > 总结: > - 提升代码的可读性(Readable),明确代码的可维护性 > - 函数指针 > - 实战yemu(计算机系统运行原理)\n\n\n\n通过signal的例子来说明如何提升代码的可读性.\n// 这样的代码可读性就比较差(顺时针螺旋法则)\nvoid (*signal (int sig, void (*func)(int)))(int);\n优化后的代码, 大大提升了代码的可阅读性\n// 定义一个函数指针类型 sighandler_t, 表示他是一个接收参数数int的函数\ntypedef void (*sighandler_t)(int);\n// 返回值是sighandler_t类型(返回函数类型),接收参数为一个int和一个接收为int的一个函数.\nsighandler_t signal(int, sighandler_t);\n\n\nNEMU就是YEMU的增强.(通过YEMU的案例进一步说明代码的可读性和可维护性的重要性)\n\n\n第2,3位表示 rt -> register target(猜测)目标寄存器,\n第0,1位表示 rs -> register source (猜测)源寄存器\n0123 表示的是指令的位置(第0,1,2,3位,4567类似)\n0000 表示mov\n0001 表示add\n1110 表示load(默认加载到RA(R0)寄存器)\n1111 表示store(默认将RA(R0)中的数据存储到制定地址)\n\n > ## extern 将一个文件内的变量扩展到其他文件也可以使用\n.\n├── a.c    // 变量所在位置\n├── a.h\n├── a.out\n└── main.c  // 将要使用的位置\n\n\na.h\n\nvoid hello(int num);\nextern int num;  // 添加外部变量\na.c\n#include <stdio.h>\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\n\nint main(void){\n    // method 2:在头文件中声明exter所需变量 \n    // method 1: 解除下面的注释.\n    //    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\na.h\n\nvoid hello(int num);\na.c\n#include <stdio.h>\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\nint main(void){\n    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\n将变量类型组合, 公用一个结构,个人感觉有点像是一个大的结构体(但是其所占用的大小是最大的那个变量的大小),将所有类型进行组合,大大提升代码的可阅读性和可维护性.\n\n#include <stdio.h>\n\nunion data{\n    long age;\n    char ch;\n};\n\nint main(int argc, char* argv[])\n{\n      \n    union data stu1;\n    stu1.age = 18;\n    stu1.ch = 'a';\n    printf(\"union.age:%ld,sizeof:%ld\\n\",stu1.age,sizeof(stu1));\n    printf(\"union.ch:%d,sizeof:%ld\\n\",stu1.ch,sizeof(stu1));\n    return 0;\n}\n对bit位进行操作,\n#include <stdio.h>\n\ntypedef union inst{\n    //  type(int is 16bit)  part1:size, part2:size\n    struct {int a:8, b:8; } atype;\n    struct {int a:8, b:8; } btype;\n}intst_t;\n\nstruct {int a:8, b:8; } ctype;\n\nint main(int argc, char* argv[])\n{\n    ctype.a = 0b01111111;\n    ctype.b = 0b10000011;\n    printf(\"%d %d size:%ld\\n\",ctype.a,ctype.b,sizeof(ctype));   \n    return 0;\n}\n\n\n使用makefile进行文件的构建对整个项目进行托管, 提升开发效率\n\n.PHONY: run clean test\n\nCFLAGS = -Wall -Werror -std=c11 -O2\nCC = gcc\nLD = gcc\n\n# 构建yemu所需要yemu.o 和idex.o\nyemu: yemu.o idex.o\n    # 使用的命令为:gcc -Wall -Werror -std=c11 -O2 -o yemu yemu.o idex.o\n    $(LD) $(LDFLAGS) -o yemu yemu.o idex.o\n\nyemu.o: yemu.c yemu.h\n    $(CC) $(CFLAGS) -c -o yemu.o yemu.c\n\nidex.o: idex.c yemu.h\n    $(CC) $(CFLAGS) -c -o idex.o idex.c\n\n# make run\nrun: yemu\n    # @表示将该cmd不输出到终端\n    @./yemu\n# make clean\nclean:\n    # 使用make clean所执行的命令\n    rm -f test yemu *.o\n\n# make test\ntest: yemu\n    $(CC) $(CFLAGS) -o test idex.o test.c && ./test"
  },
  {
    "objectID": "posts/map作业三(集合)韩顺平/index.html",
    "href": "posts/map作业三(集合)韩顺平/index.html",
    "title": "map作业三(集合)韩顺平",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.*;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 13:06\n */\npublic class EmployeeDemo {\n    public static void main(String[] args) {\n        Map m = new HashMap();\n        m.put(\"jack\",650);\n        m.put(\"tom\",1200);\n        m.put(\"smith\",2900);\n\n        System.out.println(\"=========for遍历=========\");\n        Set keySet = m.keySet();\n        for (Object key : keySet) {\n            int sal =(int) m.get(key);\n            System.out.println(key+\"---\"+sal+\"元\");\n        }\n\n\n        // entrySet遍历\n        System.out.println(\"=========entrySet迭代器遍历=========\");\n        Set entrySet = m.entrySet();\n        Iterator iterator = entrySet.iterator();\n        while (iterator.hasNext()){\n            Map.Entry next = (Map.Entry) iterator.next();\n            System.out.println(next.getKey()+\"---\"+next.getValue()+\"元\");\n        }\n\n        System.out.println(\"=========修改jack=========\");\n        m.replace(\"jack\",2600);\n        m.forEach((key,value)-> System.out.println(key+\"---\"+value+\"元\"));\n        // m.put(\"jack\",26000);\n\n        System.out.println(\"=========+100=========\");\n        m.forEach((key,value)->{m.replace(key,(int)value+100);});\n        m.forEach((key,value)-> System.out.println(key+\"---\"+value+\"元\"));\n\n\n        System.out.println(\"=========遍历工资=========\");\n        Collection values = m.values();\n        for (Object value : values) {\n            System.out.println(\"工资:\"+value);\n        }\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 简单登陆跳转逻辑/index.html",
    "href": "posts/java EE 简单登陆跳转逻辑/index.html",
    "title": "java EE 简单登陆跳转逻辑",
    "section": "",
    "text": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n    <!--把表单内容提交到myProject工程下的login-->\n    <form action=\"/myProject/login\" method=\"post\">\n        用户名： <input type=\"text\" name=\"username\" /><br>\n        密  &nbsp;&nbsp;&nbsp;码：   <input type=\"password\" name=\"password\" /><br> \n        <input type=\"submit\" value=\"登录\" />\n    </form>\n</body>\n</html>"
  },
  {
    "objectID": "posts/java EE 简单登陆跳转逻辑/index.html#login-servlet",
    "href": "posts/java EE 简单登陆跳转逻辑/index.html#login-servlet",
    "title": "java EE 简单登陆跳转逻辑",
    "section": "2、login Servlet",
    "text": "2、login Servlet\n        //获取用户名和密码\n        String username =  request.getParameter(\"username\");\n        String password= request.getParameter(\"password\");\n        //在控制台打印\n        System.out.println(username);\n        System.out.println(password);\n        \n        //判断\n        if(username.equals(\"admin\") && password.equals(\"123\")){\n            response.sendRedirect(\"/myProject/welcom.html\");\n        }\n        else{\n            response.sendRedirect(\"/myProject/login.html\");\n        }"
  },
  {
    "objectID": "posts/java注解和反射-- 自定义注解/index.html",
    "href": "posts/java注解和反射-- 自定义注解/index.html",
    "title": "java注解和反射– 自定义注解",
    "section": "",
    "text": "使用@interface自定义注解时,自动继承了java.lang .annotation.Annotation接口\npackage cn.usts.edu.SelfDesignAnnotation;\n\nimport java.lang.annotation.*;\n\n/**\n * 自定义注解\n *      注解参数的使用\n *      类型+ 参数名() default 默认值\n * */\n\npublic class SelfAnnotation {\n\n\n    @Self\n    public void test01(){\n\n    }\n\n    @Self(name = \"test01\", age = 12,sex = \"男\",id = 15,school = {\"试验附中\"})\n    public void test02(){\n\n    }\n\n}\n\n\n@Target(value = ElementType.METHOD) // 注解生效位置,方法上\n@Retention(value = RetentionPolicy.RUNTIME) // 到那个位置还有效果\n@interface Self{\n//    类型   参数名   默认值\n    String name() default \"name1\";\n    int age() default 18;\n    String sex() default \"\";\n    int id() default -1;// 表示不存在\n    String[] school() default {\"清华\",\"北大\"};\n\n}"
  },
  {
    "objectID": "posts/pyinstaller打包程序问题总结/index.html",
    "href": "posts/pyinstaller打包程序问题总结/index.html",
    "title": "pyinstaller打包程序问题总结",
    "section": "",
    "text": "pyinstaller打包exe 程序问题总结\n1.查看报错信息: 2.文件夹: 加入 init.py 3.导包顺序 Python内置包->pip install的包->自己的包 from A.b import c => import A.b as b => b.c 4.包的版本(关键) 不行就降版本"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "",
    "text": "创建一个固件库项目 参考:野火固件库创建  >下载RT-Thread\n>安装RT-Thread >https://www.keil.com/dd2/pack/ >"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.c",
    "text": "stm32f10x_it.c\n/* 存放终端函数 */\n#include \"stm32f10x_it.h\""
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.h",
    "text": "stm32f10x_it.h\n#ifndef __STM32F10x_IT_H\n#define __STM32F10x_IT_H\n\n\n#include \"stm32f10x.h\"\n\n\n\n#endif /* __STM32F10x_IT_H */"
  },
  {
    "objectID": "posts/javaGUI--Swing [ icon ]画一个icon/index.html",
    "href": "posts/javaGUI--Swing [ icon ]画一个icon/index.html",
    "title": "javaGUI–Swing [ icon ]画一个icon",
    "section": "",
    "text": "画出一个icon icon可以放在标签上也可以放在按钮上,但是 大多数情况是放的图片\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JIconDemo extends JFrame implements Icon {\n    // 设置icon宽高\n    private int width,height;\n\n    // 全参构造\n    public JIconDemo(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    // 无参构造\n    public JIconDemo()  {\n    }\n\n    public void init(){\n        JIconDemo jIconDemo = new JIconDemo(20,20);\n        // 图标可以放按钮上也可以放标签上\n        JLabel jLabel = new JLabel(\"iconDemo\",jIconDemo,SwingConstants.CENTER);\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        Container container = this.getContentPane();\n        container.add(jLabel);\n\n    }\n\n\n    public static void main(String[] args) {\n        new JIconDemo().init();\n    }\n\n    // 画icon\n    @Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n        g.fillOval(x,y,width,height);\n    }\n\n    @Override\n    public int getIconWidth() {\n        return this.width;\n    }\n\n    @Override\n    public int getIconHeight() {\n        return this.height;\n    }\n}"
  },
  {
    "objectID": "posts/webSocket-node -- 01简单跑通/index.html",
    "href": "posts/webSocket-node -- 01简单跑通/index.html",
    "title": "webSocket-node – 01简单跑通",
    "section": "",
    "text": "简单实现架构图\n\n\n\n在这里插入图片描述\n\n\n安装webSocket\nnpm install websocket\n启动程序前配置package.json\n{\n  \"scripts\": {\n    \"start\": \"node index.js 8080\"\n  },\n  \"dependencies\": {\n    \"websocket\": \"^1.0.34\"\n  }\n}\n服务端程序: serverClient.js\nvar WebSocket = require('websocket').server\nvar http = require('http')\n\n// 创建httpServer\nvar httpServer = http.createServer().listen(8080,function (){\n    console.log('http://127.0.0.1:8080')\n})\n\n// 创建webSocketServer\nvar wsServer = new WebSocket({\n    httpServer:httpServer,\n    autoAcceptConnections:false\n})\n\nwsServer.on('request',function (request){\n    var connection = request.accept()\n    connection.on('message',function (msg){\n        console.log(msg)\n\n        // 发送给客户端\n        connection.send(msg.utf8Data)\n    })\n})\n客户端程序: Client.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"msg\"></div>\n    <input type=\"text\" id=\"text\">\n    <input type=\"submit\" value=\"发送\" onclick=\"send()\">\n\n    <script>\n        var websocket = new WebSocket('ws://localhost:8080');\n        // ws ---> http\n        // wss ---> https\n\n        websocket.readyState\n        // 0 链接还没有建立\n        // 1 连接建立成功\n        // 2 连接正在关闭\n        // 3 连接已经关闭\n        websocket.onopen = function () {\n            console.log(websocket.readyState)\n        }\n        \n        function send() {\n            var text = document.getElementById('text').value\n            websocket.send(text)\n        }\n\n        websocket.onmessage = function (backMsg){\n            console.log(backMsg.data)\n        }\n    </script>\n\n</body>\n</html>\n客户端： 服务端："
  },
  {
    "objectID": "posts/arch安装/index.html",
    "href": "posts/arch安装/index.html",
    "title": "arch安装",
    "section": "",
    "text": "参考地址:https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE"
  },
  {
    "objectID": "posts/arch安装/index.html#进入fdisk",
    "href": "posts/arch安装/index.html#进入fdisk",
    "title": "arch安装",
    "section": "进入fdisk",
    "text": "进入fdisk\np       // 打印信息\ng       // 设置disk类型为GPT\nn       // 创建一个新的分区\n设置引导分区(boot分区), > 开始位置(直接回车,从开头), 设置分区编号(1-128):默认为1 // 直接回车表示默认 > 结束位置(+512M) 如果有提示覆盖,输入Y\nn           // 创建分区\n回车          // 默认编号为1\n回车          // 默认从头开始\n+512M       // 向后512M\n设置swap分区 > 休眠, 虚拟内存 > 位置从刚才的512MB开始向后1G\nn// 创建swap分区\n3// 编号为3\n回车// 默认从头开始\n+1G // 向后1G\n设置主分区 >存储系统数据\nn       // 创建swap分区\n2       // 编号为3\n回车      // 默认从头开始\n回车      // 向后所有\n分区完成  保存设置!!!!\nw       // 保存设置\n修改文件系统格式\nmkfs.fat -F32 引导分区          // 引导分区支持fat32,\nmkfs.ext4 主分区                   // linux主分区是ext4格式 \nmkswap swap分区                   // swap分区\nswapon swap分区                   // inux swapon命令用于激活Linux系统中交换空间，Linux系统的内存管理必须使用交换区来建立虚拟内存。"
  },
  {
    "objectID": "posts/计算机组成原理--大端模式,小端模式/index.html",
    "href": "posts/计算机组成原理--大端模式,小端模式/index.html",
    "title": "计算机组成原理 – 大端模式,小端模式",
    "section": "",
    "text": "小端模式:低数据位存到低位地址 大端模式:高数据位存到低位地址 ## 小端模式 | 数值|地址 | |–|–| | 05 |0x0001\n| 06 |0x0002\n| 07 |0x0003\n| 08 |0x0004"
  },
  {
    "objectID": "posts/计算机组成原理--大端模式,小端模式/index.html#大端模式",
    "href": "posts/计算机组成原理--大端模式,小端模式/index.html#大端模式",
    "title": "计算机组成原理 – 大端模式,小端模式",
    "section": "大端模式",
    "text": "大端模式\n\n\n\n数值\n地址\n\n\n\n\n05\n0x0004\n\n\n06\n0x0003\n\n\n07\n0x0002\n\n\n08\n0x0001"
  },
  {
    "objectID": "posts/linux入门基操作/index.html",
    "href": "posts/linux入门基操作/index.html",
    "title": "linux入门基操作",
    "section": "",
    "text": "man -k xxx          // 忘记具体命令 \nwhatis xxx          // 查看具体信息,info也可\nwhatis -w \"ca*\"     // 正则表达式查找\ninfo xxx            // 同whatis\nman xxx             // 查看具体参数 \nLinux分\n(1)、用户可以操作的命令或者是可执行文件\n(2)、系统核心可调用的函数与工具等\n(3)、一些常用的函数与数据库\n(4)、设备文件的说明\n(5)、设置文件或者某些文件的格式\n(6)、游戏\n(7)、惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容\n(8)、系统管理员可用的管理条令\n(9)、与内核有关的文件\n查找程序的bin文件夹所在位置\nwhich xxxx\n查看程序的搜索路径(查看执行的是哪一个程序)\nwhereis xxx\n\n\n\n文件,文件夹基本操作\nls                          // 列出当前目录下的所有文件\ntouch xx.x                  // 创建一个文件\nmkdir xxx                   // 创建一个文件夹\nmv FILE PATH                // 移动文件到指定位置\ncp SRC  DESC                // 复制文件到那个文件(可以写路径)\ncp -r ./aaa ./bbb           // 复制文件夹\nrm -rf                      // 删除(加单粗暴的删除)          \n查看文件个数\nfind ./ |wc -l              // 官方写法,个人觉得不太方便记忆\nls | cat -n                 // 文件前面加序号\n目录切换\ncd xxx                      // 进入到xx目录\ncd -                        // 进入到场次的路径\ncd ~                        // 进入到家目录\ncd /                        // 记入到根目录\npwd                         // 显示当前路径\n列出文件\nls                          // 列出所有文件\nll                          // 列出详细信息\nls -lrt                     // 时间排序\n别名修改 修改家目录下的bachrc文件设置命令别名,想当于快捷方式\nalias lt='ls -lrt'          // 修改别名为lt \n文件查找\nfind ./ -name \"xxx\"         // 在当前目录查找xxx, xxx可以是正则表达式\n文件内容查看\ncat\nvim\nhead\nhead -10 xxx                // 看前10行\ntail -10 xxx                // 看倒数10行\ntail -f xxx                 // 动态显示文本最新信息\ndiff xx-1 xx-2              // 文件对比\n查找文件内容\negrep 'str' file            // 查找文件内容\negrep 'str' file > outFile  // 将查找到的内容输出到outFile\n权限修改\nchown user file             // 修改文件拥有者\nchmod a+x  file             // 所用用户添加可执行权限a(all) u(user) g(group) o(other)\n文件创建别名(快捷方式)\nln file-1 file-2            // 硬连接, 相当于复制\nln -s file1 file2           // 软连接, 相当于快捷方式\n管道和重定向 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&& 前面失败，则后一条执行: ||\nls ./ && echo ok || echo failed\n\nif ls ./;then echo ok; else echo failed;fi          // 和上面等同\n\n:> a.txt                                            // 清空文件\nls a.text >> a.out                                  // 重定向, 就是将原本输出到控制台的信息, 重新输出到别的地方\n环境变量设置 bashrc: 系统启动时执行的文件 profile: 用户登陆后执行的文件\nvim ~/.bashrc\nvim /etc/profile\n\n//修改其中的PATH变量\nPATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH\nbash快捷键\nCtl-U   删除光标到行首的所有字符,在某些设置下,删除全行\nCtl-K   删除光标到行尾的所有字符\nCtl-W   删除当前光标到前边的最近一个空格之间的字符\nCtl-H   backspace,删除光标前边的字符\n\nCtl-R   匹配最相近的一个执行过的命令，然后输出\nCtl-J   回车\nCtl-B   左移一个字符\nalt-B   左移一个单词(ubuntu失败)\nCtl-F   右移一个字符\nalt-F   右移一个单词(ubuntu失败)\nCtl-A   移动到最前面\nCtl-E   移动到最后面\nCtl-P   上一条指令\nCtl-N   下一条指令(执行过的指令中上翻下翻,==>上/下 键: 终于不用按上下了, 太爽了!!!)\nCtl-L   清屏(不用clear了, 解决痛点+1,爽+1)\n综合应用 查找record.log中包含AAA，但不包含BBB的记录的总数:\ncat -v record.log | grep AAA | grep -v BBB | wc -l // cat -v 显示文件原本在中的数据, 对中文字符有影响 直接翻译成acsii字符\n\n\n\n文件查找\nfind ./ -name \"*.txt\"               // 文件名查找\nfind ./ -regex \".*?.txt\"            // 正则表达式查找\nfind ./ ! -name \"*.txt\"             // 文件名反向查找\nfind . -maxdepth 1 -type f          // 指定深度查找, 深度为1 \n文件操作时间查询 -atime 访问时间 (单位是天，分钟单位则是-amin，以下类似） -mtime 修改时间 （内容被修改） -ctime 变化时间 （元数据或权限变化）\nfind ./ -atime 7 -type f            // 查找最近第7天修改的文件 f(file)\nfind ./ -atime -7 -type f           // 最近7天内\nfind ./ -atime +7 -type f           // 最近7天前 \n按照大小查询文件\nfind ./ -type f -size +2            // 查找大于2k的文件\nfind ./ -type f -size -2            // 查找小于2k的文件\n按照文件创建用户查找\nfind ./ -type f -user root          // root用户创建的文件\n删除指定条件的文件\nfind ./ -type f -name \"*.txt\" -delete                       // 删除当前目录下的xxx.txt文件\n动作执行 exec后面可以跟执行的命令, {}代表符合条件的所有文件\nfind ./ -type f -name \"*.txt\" -exec cp {} ./OtherDir \\ ;    // 将当前文件夹中的所有txt文件复制到当前目录下的OtherDir中 \n结合多个命令 如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:\n-exec ./commands.sh {} \\;\n-print的定界符 默认使用’’作为文件的定界符； -print0 使用’\\0’作为文件的定界符，这样就可以搜索包含空格的文件；\ngrep文本搜索 -o 只输出匹配的文本行 -v 只输出没有匹配的文本行 -c 统计文件中包含文本的次数 grep -c “text” filename -n 打印匹配的行号 -i 搜索时忽略大小写 -l 只打印文件名\ngrep -i -n 'hello' a.txt                        // 查找文本中hello的位置, 忽略大小写\n在多级目录中对文本递归搜索(程序员搜代码的最爱）:\ngrep \"class\" . -R -n\nxargs命令行参数转换\n-d 定义定界符 （默认为空格 多行的定界符为 n） -n 指定输出为多行 -I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时 -0：指定0为输入定界\ncat xxx.txt | xargs -n 3                        // 将内容三行在一行显示\ncat xxx.txt | xargs -i echo -{}                 // 将xx.txt中的数据按行读取,通过echo输出,并在前加 - \nsort排序 -n 按数字进行排序 VS -d 按字典序进行排序 -r 逆序排序 -k N 指定按第N列排序\nsort -n xxx.txt                                 // 默认n排序\nsort -r xxx.txt                                 // 逆序\nsort -d xxx.txt                                 // 字典排序\n\nsort xxx.txt | uniq                             // 去重\nsort xxx.txt | uniq -c                          // 每行出现次数\nsort xxx.txt | uniq -d\n文本拼接\npaste F1 F2                                     // F1和F2进行拼接, 是对应行进行拼接,不知直接拼到下面, 默认分割是以tab进行分割的\npast F1 F2 -d \",\"                               // 使用\",\"进行分割\n字数统计\nwc -l xxxx                                      // 统计行数\nwc -w xxxx                                      // 统计单词数\nwc -c xxxx                                      // 统计字符数\nwc xxx                                          // 返回[行数, 单词数, 字符数]\n文本替换 - sed\nsed 's/xxx/***/' FILE                           // 替换每行第一个匹配的字符[将FILE中的xxx替换为***]\nsed 's/xxx/***/g' FILE                          // 替换匹配到的所有的字符\nsed -i 's/xxx/***/' FILE                        // 直接修改原文[上面的写法需要将修改后的内容重定位输出到新的文件才可以保存]\nsed -i '/^$/d' FILE                             // 直接将文件中的空白行删除[文本末尾的空白行没有删除]                   \n\nstr = 9999\nsed  \"s/xx/$str/\" FILE                          // 双引号会替换变量的值, 单引号不会, 会将str替换为9999\nawk数据流处理 awk脚本结构\nawk ' BEGIN{ statements } statements2 END{ statements } '\n\n工作方式 1.执行begin中语句块； 2.从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕； 3.执行end语句块；\n\necho 123 | awk 'BEGIN {print \"Start\"}{ print } END{print \"END\"}'    // 格式很关键,标点,大小写\n print 以逗号分割时，参数以空格定界;\necho|awk '{a=1;b=2;c=\"dasdsa\";print a,b,c;}'\n print字符串拼接\necho|awk '{a=1;b=2;c=\"dasdsa\";print a\" ----***\" b\"----**   \" c;}'\n\n// 输出\n1 ----***2----**   dasdsa\nawk - 特殊变量： NR NF $0 $1 $2 NR:表示记录数量，在执行过程中对应当前行号；\ncat xxx.txt | awk '{print NR}'                          // 输出执行到的行数\ncat xxx.txt | awk '{print NF}'                          // 输出执行的当前行的单词数\ncat xxx.txt | awk '{print $2}'                          // 输出当前行的第2个单词\nNF:表示字段数量，在执行过程总对应当前行的字段数；\n$0:这个变量包含执行过程中当前行的文本内容；\n$1:第一个字段的文本内容；\n$2:第二个字段的文本内容；\n// 每行求和 -e是将转移字符输出出来\necho -e \"1\\n 2\\n 3\\n 4\\n\" |awk 'BEGIN{sum=0;}{sum+=$1;}END{print sum}'          // 输出10\nawk - 传递外部变量\nvar = 9999\necho | awk vara=$var '{print vara}'                     // 传递外部变量, 变量放前后都行,但是不能加括号, 默认来自输入\necho | awk vara=$var '{print vara}' FILE                // 个人使用失败,可能是语法哪里写错了\n用样式对awk处理的行进行过滤\nawk 'NR < 5' #行号小于5\nawk 'NR==1,NR==4 {print}' file #行号等于1和4的打印出来\nawk '/linux/' #包含linux文本的行（可以用正则表达式来指定，超级强大）\nawk '!/linux/' #不包含linux文本的行\n使用-F来设置定界符（默认为空格）\nawk -F: '{print $NF}' /etc/passwd\n\n\n\n查看磁盘大小以及使用情况 -h: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位\ndf -h                                               // 查看磁盘信息\n当前目录所占大小 -h 人性化显示 -s 递归整个目录的大小\ndu -sh                                              // 当前文件夹占用磁盘大小\n查看当前目录下所有子文件夹排序后的大小:\ndu -sh `ls`| sort                                   // 当前文件夹中的文件按照大小排序\n打包,压缩,解压缩 tar -cvf example.tar example ->将example文件夹归档变成了example.tar - c: create创建档案 - v: verbose显示详情 - f: file表示文件\ntar -cvf example.tar example                        // 只打包不压缩\ngzip xxx.tar                                        // 压缩后生成-> xxx.tar.gz\ngunzip xxx.tar.gz                                   // 解压后-> xxx.tar\ntar -xvf xxx.tar.gz                                 // 解压后-> xxx\ntar 解压参数 -z 解压gz文件 -j 解压bz2文件 -J 解压xz文件\n\n\n\n查询正在运行的进程\nps -ef                                  // 查询所有进程\nps -ef|prep root                        // 查询root用户的进程\n\npgrep -l ba                             // 查询含有ba关键字的进程->查询进程ID（适合只记得部分进程字段）\n\nps -ajx                                 // 查看所有信息的完整信息\n\ntop                                     // 实时查看进程信息 实时更新\n查看端口占用情况\nlsof -i:3306                            // 查看3306的端口占用情况\n查看用户username的进程所打开的文件\nlsof -u username\n利用进程名 查看进程使用的文件\nlsof -c mysql                           // 查看mysql进程占用的文件\n利用pid 查看进程使用的文件\nls -i 22                                // 查询占用22号端口的进程\nlsof -p 774                             // 根据进程pid号774查询 文件使用情况\n查询制定文件夹内文件夹的使用进程\nlsof +d ./                              // 查询当前文件夹内的文件使用情况(进程信息)\n结束进程\nlsof -c NAME                            // 查询进程的pid\nkill PID                                // 结束PID进程\n\nCTRL+Z挂起进程并放入后台\njobs 显示当前暂停的进程\nbg %N 使第N个任务在后台运行(%前有空格)\nfg %N 使第N个任务在前台运行 默认bg,fg不带%N时表示对最后一个进程操作! 动态查看-top P：根据CPU使用百分比大小进行排序。 M：根据驻留内存大小进行排序。 i：使top不显示任何闲置或者僵死进程。\n\ntop                                     // top之后按下p/m/i\n\n\n\n监控cpu\nsat -u 1 2                              // 查看cpu使用情况, 一秒钟采样两次, ubuntu没有sar需要安装\nvmstart 1 2                             // 和上面等效\n查看内存\nfree                                    // 硬盘使用情况\nfree -m                                 // 内存使用情况\n\n\n\n查询网络服务和端口\nnetstat -a                              // 查看所有端口\nnetstat -at                             // 列出所有tcp端口\nnetstat -au                             // 列出所有udp端口\n列出所有监听的服务 - netstat -x [ netstat ] -a 显示所有连接和侦听端口，默认不显示LISTEN相关 -b 显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。在此情况下，可执行程序的名称位于底部 [] 中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在你没有足够权限时可能失败。 -e 显示以太网统计信息。此选项可以与 -s 选项结合使用。\n-i 显示网络接口列表 -n 以数字形式显示地址和端口号。 -o 显示拥有的与每个连接关联的进程 ID。 -p proto 显示 proto 指定的协议的连接；proto可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。 -q 显示所有连接、侦听端口和绑定的非侦听 TCP 端口。绑定的非侦听端口不一定与活动连接相关联。 -r 显示路由表。 -s 显示每个协议的统计信息。默认情况下，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息;-p 选项可用于指定默认的子网。 interval 重新显示选定的统计信息，各个显示间暂停的间隔秒数。按 CTRL+C 停止重新显示统计信息。如果省略，则 netstat 将打印当前的配置信息一次。 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -c 每隔一个固定时间，执行该netstat命令，netstat 将每隔一秒输出网络信息。\nnetstat -l                              // 列出所有监听的服务\n\n\n\n添加用户\nuseradd -m xxx                          // 添加xxx用户, 单独的添加,没有任何权限 以及密码\n用户切换\nsu xxx                                  // 切换xxx用户\nsu root                                 // 切换root用户\n删除用户\nuserdel -r xxx                          // 删除用户xxx\nlsof -u xxx                             // 查询xxx用户PID \nkill -9 PID                             // 用户无法删除,显示进程占用, 先结束进程, 然后重新删除用户\n权限管理 使用chmod命令更改文件的读写权限，更改读写权限有两种方法，一种是字母方式，一种是数字方式\n分组 - u：用户 - g：组 - o：其它用户 - a：所有用户\n权限 - r:读 - w：写 - x：执行 数字方式：\n数字方式直接设置所有权限，相比字母方式，更加简洁方便；\n使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。\nchmod a+x FILE                          // 对FILE文件的所用户添加可执行程序\nchmod g+x FILE                          // 对组用户添加可执行权限\nchmod 777 FILE                          // 所有权限打开\n修改拥有者\nchown USER File                         // 修改拥有者\nchown -R USER FILE                      // 递归所有文件夹修改拥有者\n环境变量\nbashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。\n\n\n\n全局\n用户\n\n\n\n\nbashrc(不登录) / profile(登录)\nbashrc (不登录) / profile (登录)\n\n\n\n/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile ~/.bashrc用户目录下的私有环境变量设定\n\n\n\n全局\n用户\n\n\n\n\n/etc/profile，/etc/bashrc\n~/.profile ~/.bashrc\n\n\n\n当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:\n首先读入的是全局环境变量设置文件/etc/profile，然后根据其内容读取额外的文档，如/etc/profile.d和/etc/inputrc 读取当前登录用户Home目录下的文件/.bash_profile，其次读取/.bash_login，最后读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系 读取~/.bashrc /.profile与/.bashrc的区别:\n这两者都具有个性化定制功能 ~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次 ~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次\n\n\n\n查看cpu信息\ncat /etc/cpuinfo                            // 查看cpu信息\n查看内存信息\ncat /etc/meminfo                            // 查看内存信息\n查看cpu架构\narch                                        // 查案CPU架构\nipcs资源查询\nipcs    \n参考: https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html"
  },
  {
    "objectID": "posts/java注解和反射--类加的载/index.html",
    "href": "posts/java注解和反射--类加的载/index.html",
    "title": "java注解和反射–类加的载",
    "section": "",
    "text": "类的加载有三个过程:  正是由于只能有一个clinit操作,所以他们只有一个公共的Class,所以可以实现反射,从而拿到属性,方法,构造器等等"
  },
  {
    "objectID": "posts/TI_ccs修改环境变量/index.html",
    "href": "posts/TI_ccs修改环境变量/index.html",
    "title": "TI_ccs修改环境变量",
    "section": "",
    "text": "项目右键 \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java常用类--时间日期类/index.html",
    "href": "posts/java常用类--时间日期类/index.html",
    "title": "java常用类–时间日期类",
    "section": "",
    "text": "package cn.usts.edu.fly.DateAndDateFormat;\n\nimport com.sun.org.apache.xerces.internal.impl.dv.xs.YearMonthDV;\n\nimport java.time.*;\n\n/**\n * @author ：fly\n * @description: Date 类\n *                    在jdk8之前还没有time包,使用Date类,用Calendar.getInstance()获取时间对象\n *                    java.time提供了更多对时间日期的操作\n * @date ：2021/10/31 16:44\n */\npublic class DateDemo {\n    public static void main(String[] args) {\n        LocalTime time = LocalTime.now();\n        System.out.println(time);// 时间 16:51:42.206\n\n        LocalDate date = LocalDate.now();\n        System.out.println(date);//当前年月日 2021-10-31\n\n        LocalDate date1 = date.plusDays(1);\n        System.out.println(\"当前时间加1天是\"+date1);\n\n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(now);\n\n        System.out.println(\"当前年\"+Year.now());\n        System.out.println(\"当前年月\"+ YearMonth.now());//2021-10\n        System.out.println(\"当前月日\"+ MonthDay.now());// --10-31\n    }\n}"
  },
  {
    "objectID": "posts/java常用类--时间日期类/index.html#simpledateformat推荐",
    "href": "posts/java常用类--时间日期类/index.html#simpledateformat推荐",
    "title": "java常用类–时间日期类",
    "section": "SimpleDateFormat（推荐）",
    "text": "SimpleDateFormat（推荐）\npackage cn.usts.edu.fly.DateAndDateFormat;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @author ：fly\n * @description:  SimpleDateFormat()  自定义日期时间格式\n * @date ：2021/10/31 17:08\n */\npublic class SimpleDateFormatDemo {\n    public static void main(String[] args) {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"现在的时间是:yyyy-MM-dd HH:mm:ss\");\n        System.out.println(simpleDateFormat.format(new Date()));// 今天是:2021-10-31 17:11:47\n\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html",
    "href": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html",
    "title": "java常用类– String、StringBuffer（StringBuilder）",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.StringAndStringBufferDemo;\n\nimport java.util.Arrays;\n\n/**\n * @author ：fly\n * @description: String 类的常用操作\n * @date ：2021/10/31 13:28\n */\npublic class StringDemo {\n    public static void main(String[] args) {\n        String a = \"  hello world HELLO java hello fly \";\n        System.out.println( \"长度\"+a.length());// 长度\n        System.out.println(\"第0号索引位置上字符是啥\"+a.charAt(0));\n        System.out.println(\"第一次出现的位置\"+a.indexOf(\"ja\"));\n        System.out.println(\"最后一次出现\\\"he\\\"的位置\"+a.lastIndexOf(\"he\"));\n\n        System.out.println(\"是否以fly为结尾\"+a.endsWith(\"fly\"));\n        System.out.println(\"字符串是否相同\"+a.equals(\"asdfadsf\"));// 这里区分== ,== 比较的是地址值\n        System.out.println(\"字符串是否为空\"+a.isEmpty());\n        System.out.println(\"是否以..为开头\"+ a.startsWith(\"hello\"));\n        System.out.println(\"是否包含hello\"+ a.contains(\"hello\"));\n\n        System.out.println(\"将所有字符转换为大写\"+a.toUpperCase());\n        System.out.println(\"将所有字符转换为小写\"+a.toLowerCase());\n\n        System.out.println(\"将变量转换成string(字符串)\"+String.valueOf(12));\n        System.out.println(\"将字符串转换成一个字符数组\"+ Arrays.toString(a.toCharArray()));\n        char[] chars = a.toCharArray();\n        for (char aChar : chars) {\n            System.out.print(aChar+\",\");\n        }\n        System.out.println();\n\n        System.out.println(\"Hello替换掉hello-->\"+a.replace(\"hello\", \"Hello\"));\n        System.out.println(\"以空格为分割点:\"+Arrays.toString(a.split(\" \")));\n        System.out.println(a);\n        System.out.println(\"从第2号位置开始保留\"+a.substring(2));\n        System.out.println(\"保留2-7号位置\"+a.substring(2,7));\n        System.out.println(\"去掉首尾空格\"+a.trim());\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#stringbuffer常用操作",
    "href": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#stringbuffer常用操作",
    "title": "java常用类– String、StringBuffer（StringBuilder）",
    "section": "StringBuffer常用操作",
    "text": "StringBuffer常用操作\nStringBuffer的出现是为了解决String无法修改的问题，StringBuffer是一个可边长的字符串，他的内容和长度都可以改变。 #### 附加点 StringBuffer 和 StringBuilder相似(使用方法一模一样,append,insert,delete,replace….) 但是StringBuffer有线程安全,StringBuild没有,所以StringBuild的性能略高 \npackage cn.usts.edu.fly.StringAndStringBufferDemo;\n\n/**\n * @author ：fly\n * @description: StringBuffer的常见操作\n *                  StringBuffer 和 StringBuilder相似(使用方法一模一样,append,insert,delete,replace....)\n *                  但是StringBuffer有线程安全,StringBuild没有,所以StringBuild的性能略高\n * @date ：2021/10/31 14:25\n */\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(\"像sb中写入字符串\"));\n        System.out.println(sb.insert(\"像sb中写入字符串\".length(), \"6666\"));// 插入6666\n\n        System.out.println(sb.delete(9,13));// StringBuffer中删除掉指定位置的字符串\n        System.out.println(\"索引为3的是:\"+sb.charAt(3));\n        System.out.println(sb.replace(4,5,\"替换\"));// 开始,结束,替换的字符串\n        sb.setCharAt(0,'向');\n        System.out.println(sb);\n        System.out.println(\"逆序:\"+sb.reverse());\n    }\n\n    public static void add(){\n\n    }\n}"
  },
  {
    "objectID": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html",
    "href": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html",
    "title": "Linux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))",
    "section": "",
    "text": "E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)\nE: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#解决方法",
    "href": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#解决方法",
    "title": "Linux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))",
    "section": "解决方法：",
    "text": "解决方法：\n删掉这两个文件即可\nsudo rm /var/cache/apt/archives/lock  \nsudo rm /var/lib/dpkg/lock"
  },
  {
    "objectID": "posts/java多线程-- 简单实现多线程/index.html",
    "href": "posts/java多线程-- 简单实现多线程/index.html",
    "title": "java多线程– 简单实现多线程",
    "section": "",
    "text": "注意start() 和run()的区别\npackage cn.usts.edu.lesson01;\n\n/**\n * 实现多线程要\n * 1:继承Thread类,\n * 2:重写run()方法\n * 3:实现类.start()\n *\n * 【以吃馒头喝水为例】\n *  吃馒头和喝水同时进行\n *  \n *  thread.start();// 同时执行\n *  thread.run();//使用run()方法就是按顺序执行\n * */\npublic class ThreadCreateDemo01 extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            System.out.println(\"吃第\"+i+\"个馒头\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadCreateDemo01 thread = new ThreadCreateDemo01();\n        thread.start();// 同时执行\n        //thread.run();//使用run()方法就是按顺序执行\n\n        for (int i = 0; i < 20; i++) {\n            System.out.println(\"喝第\"+i+\"口水\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java GUI编程--panel/index.html",
    "href": "posts/java GUI编程--panel/index.html",
    "title": "java GUI编程–panel",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestPanel {\n\n    public static void main(String[] args) {\n\n\n        Frame frame = new Frame();\n        // 设置标题\n        frame.setTitle(\"firstFrame\");\n        // 设置布局\n        frame.setLayout(null);\n        // 设置位置\n        frame.setBounds(100,100,800,800);\n        // 设置背景色\n        frame.setBackground(Color.orange);\n        // 设置可见性\n        frame.setVisible(true);\n        \n        Panel panel01 = new Panel();\n        // 设置布局\n        panel01.setBounds(50,50,200,200);\n        panel01.setBackground(Color.PINK);\n        // 把组件添加到frame中\n        frame.add(panel01);\n        panel01.setVisible(true);\n\n\n        Panel panel02 = new Panel();\n        // 设置布局\n        panel02.setBounds(210,280,200,200);\n        panel02.setBackground(Color.BLUE);\n        panel02.setVisible(true);\n\n        // 把组件添加到frame中\n        frame.add(panel01);\n        frame.add(panel02);\n\n        // 监听事件,监听窗口关闭实践\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}"
  },
  {
    "objectID": "posts/stm32H743使用/index.html",
    "href": "posts/stm32H743使用/index.html",
    "title": "stm32H743使用",
    "section": "",
    "text": "0. 所需材料\n\n\n\n材料\n数量\n\n\n\n\nST-Link V2\n1\n\n\n战舰扩展板\n1\n\n\nstm32H743核心板\n1\n\n\n\n\n\n1. 安装仿真器驱动程序\n # 1. 安装芯片包 \n\n\n\n在这里插入图片描述\n\n\n\n\n1. 使用MX-Cube配置工程\n时钟配置  串口设置:"
  },
  {
    "objectID": "posts/arch yay安装qq/index.html",
    "href": "posts/arch yay安装qq/index.html",
    "title": "arch yay安装qq",
    "section": "",
    "text": "arch yay安装qq\n还原后再文件末尾添加!!!!!, making xxxx 需要安装base-devel"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "",
    "text": "【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】\n不正确的源会导致找不到依赖的问题\nUbuntu18.4换阿里源参考：Ubuntu18.4换阿里源 ## 1.安装build-essential 如果安装中出现资源占用参考：解决资源占用\nsudo apt-get install build-essential"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gcc",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gcc",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "2.安装gcc",
    "text": "2.安装gcc\nsudo apt-get install gcc"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gdb",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gdb",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "3.安装gdb",
    "text": "3.安装gdb\nsudo apt-get install gdb"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装vim编辑器",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装vim编辑器",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "4.安装vim编辑器",
    "text": "4.安装vim编辑器\nsudo apt-get install vim"
  },
  {
    "objectID": "posts/java多线程-- Runnable接口实现多线程网图下载/index.html",
    "href": "posts/java多线程-- Runnable接口实现多线程网图下载/index.html",
    "title": "java多线程– Runnable接口实现多线程网图下载",
    "section": "",
    "text": "Runnable接口实现多线程\npackage cn.usts.edu.lesson01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * Runnable接口实现多线程\n * 推荐使用Runnable接口,因为继承Thread的话一个类只能继承一个类\n * thread的底层就是实现了Runnable接口【class Thread implements Runnable 】\n * */\npublic class RunnableDemo implements Runnable {\n    String file;\n    String url;\n    String filename;\n\n    public RunnableDemo(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public void run() {\n        ImageDownload2 imageDownload = new ImageDownload2();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n    }\n\n    public static void main(String[] args) {\n        RunnableDemo t1 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        RunnableDemo t2 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        RunnableDemo t3 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        // 新建线程\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    }\n}\n\nclass ImageDownload2 {\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--监听器 [ 关闭按钮 ]/index.html",
    "href": "posts/javaGUI--监听器 [ 关闭按钮 ]/index.html",
    "title": "javaGUI–监听器 [ 关闭按钮 ]",
    "section": "",
    "text": "// 监听事件,监听窗口关闭实践\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });"
  },
  {
    "objectID": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "href": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "title": "springMVC-设置日期时间对象【自定义日期时间格式】",
    "section": "",
    "text": "// 返回格式化日期对象\n    @RequestMapping(\"/json4\")\n    public String json4() throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        // 不使用时间戳的方式\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf);\n        // 设置 日期格式\n        mapper.setDateFormat(sdf);\n        Date date = new Date();\n        // 设置字符串对象\n        String str = mapper.writeValueAsString(date);\n        return str;\n    }\n}"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "cat /etc/group/ | grep 查询字段\n\n\n\nadduser a\ngroupadd GroupName\nusermod -g GroupName a\n\n\n\n# 默认初始位置位改为/home/test/\nusermod -d /home/test/\n\n\n\nid 用户名"
  },
  {
    "objectID": "posts/alu整数加法_减法/index.html",
    "href": "posts/alu整数加法_减法/index.html",
    "title": "alu整数加法_减法",
    "section": "",
    "text": "加法:\n无符号: - cf 最高进位和sub位, 异或\n有符号: - of: 最高为是否相同, 符号位溢出 - 最高位进位和次高位进位 异或 1溢出,0不溢出 \n\n\n总结:\n有符号看of: 看最高位进位和次高位进行异或(相异为1)结果 为1溢出 无符号看cf: 看最高位进位和sub位(被+数是否为负的那个位), 进行异或, 结果 为1溢出"
  },
  {
    "objectID": "posts/java--gui_简单计算器/index.html",
    "href": "posts/java--gui_简单计算器/index.html",
    "title": "java–gui_简单计算器",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson02;\n\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class Calculator {\n\n    public static void main(String[] args) {\n        // 开始\n        new MyFrame01();\n    }\n}\n\nclass MyFrame01 extends Frame{\n    public MyFrame01(){\n        setLocation(400,400);\n        setVisible(true);\n        // 设置布局\n        setLayout(new FlowLayout());\n        // 设置文本框\n        TextField first = new TextField(10);    // 设置框的大小\n        TextField second = new TextField(10);\n        TextField result = new TextField(10);\n        // 按钮\n        Button button = new Button(\"=\");\n        button.addActionListener(new CalculatorActionListener(first,second,result));\n        // 添加进frame\n        add(first);\n        add(second);\n        add(button);\n        add(result);\n\n        pack();\n\n        // 点击关闭\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n\n    }\n}\n\n\n// 监听器\nclass  CalculatorActionListener implements ActionListener {\n    private TextField first,second,result;\n    public CalculatorActionListener(TextField first,TextField second,TextField result) {\n        this.first = first;\n        this.second = second;\n        this.result =result;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        // 获取字符值\n        int num1 = Integer.parseInt(first.getText());\n        int num2 = Integer.parseInt(second.getText());\n        // 进行运算\n        result.setText(\"\"+(num1+num2));\n        // 返回结果\n        first.setText(\"\");\n        second.setText(\"\");\n\n\n    }\n}"
  },
  {
    "objectID": "posts/汇编--00安装dosBox/index.html",
    "href": "posts/汇编--00安装dosBox/index.html",
    "title": "汇编–00安装dosBox",
    "section": "",
    "text": "官网下载dosBox软件后无法debug\n缺少asmtools,创建好asm文件夹,将下载的文件都放入创建的文件夹中. https://jszhuanben.lanzoui.com/i2H5dtq5qab\n配置启动时执行的命令:\n1# dosBox配置文件路径\nC:\\Users\\msi\\AppData\\Local\\DOSBox\n2# 在最后添加\nmount C: F:\\asm\nC:\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/nodejs安装--（npm安装）/index.html",
    "href": "posts/nodejs安装--（npm安装）/index.html",
    "title": "nodejs安装–（npm安装）",
    "section": "",
    "text": "nodejs下载地址https://nodejs.org/zh-cn/ ### 2、双击安装 一路next ### 3、查看是否安装成功 \n进入到安装目录：node -v  ### 4、建两个文件夹 再看看另外2个目录，npm的本地仓库跑在系统盘c盘的用户目录了(没见到npm-cache是因为没有用过， 一使用缓存目录就生成了)，我们试图把这2个目录移动回到D:  ### 5、然后运行以下2条命令\nnpm config set prefix \"D:\\nodejs\\node_global\"\nnpm config set cache \"D:\\nodejs\\node_cache\"\n ### 6、配置一个镜像站，为了提升速度\nnpm config set registry=http://registry.npm.taobao.org\n ### 7、输入命令npm config list 显示所有配置信息\n\n\n\n在这里插入图片描述\n\n\n\n注意，此时，默认的模块D:_modules 目录 将会改变为D:_global_modules 目录， 如果直接运行npm install等命令会报错的。 我们需要做1件事情： 增加环境变量NODE_PATH 内容是：D:\\nodejs\\node_global\\node_modules\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI--监听器02/index.html",
    "href": "posts/javaGUI--监听器02/index.html",
    "title": "javaGUI–监听器02",
    "section": "",
    "text": "点击 \npackage cn.usts.edu.lesson02;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestActionEvent {\n\n    public static void main(String[] args) {\n\n\n        Frame frame = new Frame(\"action Event\");\n        Button button = new Button();\n        frame.add(button,BorderLayout.CENTER);\n        frame.pack();\n        frame.setVisible(true);\n\n        // 按钮监听\n        MyActionListener myActionListener = new MyActionListener();\n        // addActionListener需要一个ActionListener于是我们创建了一个myActionListener\n        button.addActionListener(myActionListener);\n\n        // 关闭\n        myClose(frame);\n\n    }\n\n\n    // 监听关闭按钮\n    private static void myClose(Frame frame){\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n\n\nclass MyActionListener implements ActionListener{\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"监听到按钮动作\");\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--frame/index.html",
    "href": "posts/javaGUI--frame/index.html",
    "title": "javaGUI–frame",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestFrame {\n    public static void main(String[] args) {\n        // 窗口初始化\n        Frame frame = new Frame(\"我的第一个frame窗口\");\n\n        // 设置可见性\n        frame.setVisible(true);\n\n        // 设置窗口大小\n        frame.setSize(400,400);\n\n        // 设置位置\n        frame.setLocation(100,100);\n\n        // 设置背景色\n        frame.setBackground(new Color(78,145,10));\n\n\n    }\n\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html",
    "href": "posts/java注解和反射-- 反射/index.html",
    "title": "java注解和反射– 反射",
    "section": "",
    "text": "是一类在运行时可以改变其结构的语言∶例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。\n通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n主要动态语言:Object-C、C#、JavaScript、PHP、Python等。"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html#静态语言",
    "href": "posts/java注解和反射-- 反射/index.html#静态语言",
    "title": "java注解和反射– 反射",
    "section": "静态语言",
    "text": "静态语言\n与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C+ Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html#反射",
    "href": "posts/java注解和反射-- 反射/index.html#反射",
    "title": "java注解和反射– 反射",
    "section": "反射",
    "text": "反射\n通过Reflection的api操作实例化出来的对象从而获得对象内部的属性和方法,从而对对象进行操作. 反射例子 \npackage cn.usts.edu.Reflection03;\n\n/**\n * 一个类在内存中只有一个class对象唯一的\n *  反射的原理:\n *      所有的类都有一个公共的祖宗类,都是Class的子类,所以根据他的父类可以倒退找到他的子类\n *      从而调用到子类中到方法和属性\n * */\n\npublic class ReflectionDemo {\n\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        System.out.println(c1);\n        Class c2 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c3 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c4 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c5 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n\n        // 一个类在内存中只有一个class对象\n        // 一个类被加载后,类的整个结构都会被封装在class对象中,所以他们的哈希值是一样的\n        System.out.println(c1.hashCode());\n        System.out.println(c2.hashCode());\n        System.out.println(c3.hashCode());\n        System.out.println(c4.hashCode());\n        System.out.println(c5.hashCode());\n    }\n\n}\n\n\n\n// 实体类,pojo,entity\nclass User{\n    private int age;\n    private int id;\n    private String name;\n\n    public User(int age, int id, String name) {\n        this.age = age;\n        this.id = id;\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/protobuf协议-- 01使用（js简单实现）/index.html",
    "href": "posts/protobuf协议-- 01使用（js简单实现）/index.html",
    "title": "protobuf协议– 01使用（js简单实现）",
    "section": "",
    "text": "官网\n\n\n\n\n\n在这里插入图片描述\n\n\n   ### 解压完成  ### 添加环境变量 \n\n\n\n在这里插入图片描述\n\n\n .proto文件\n\nsyntax = \"proto3\";\n\nmessage Student {\n  string username = 1;\n  int32 password = 2;\n}\n\n\n\n将依赖库打包成js文件 然后直接导入这个新的js文件即可使用插件js\n# comm js\nprotoc --proto_path=D:\\code\\plug\\protocbuf\\protocMsg --js_out=import_style=commonjs,binary:D:\\code\\plug\\protocbuf\\protocMsg\\jsout Student.proto3"
  },
  {
    "objectID": "posts/javaGUI--列表框 JList/index.html",
    "href": "posts/javaGUI--列表框 JList/index.html",
    "title": "javaGUI–列表框 JList",
    "section": "",
    "text": "注意动态写入和静态写入\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.Vector;\n\npublic class JComboBoxDemo02 extends JFrame {\n    public JComboBoxDemo02() {\n        this.setBounds(100,100,400,200);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        //String[] contents = {\"1\",\"2\",\"3\"}; // 静态的写入\n        Vector<Object> contents = new Vector<>();//动态写入\n        contents.add(\"tom\");\n        contents.add(\"jack\");\n        contents.add(\"lili\");\n        contents.add(\"加载完成\");\n\n\n        JList<Object> list = new JList<>(contents);\n        Container container = this.getContentPane();\n        container.add(list);\n\n    }\n\n    public static void main(String[] args)  {\n        new JComboBoxDemo02();\n    }\n\n}"
  },
  {
    "objectID": "posts/app爬虫--持续更新/index.html",
    "href": "posts/app爬虫--持续更新/index.html",
    "title": "app爬虫–持续更新",
    "section": "",
    "text": "今天开始自己一直想做的项目:\n    - 之前稀里糊涂学了些爬虫的技术\n    - 一直没有做过像样的项目\n    - 现开始做一个可视化的项目\n# 项目技术栈\n    - qt\n    - httpx\n    - 安卓逆向\n    -"
  },
  {
    "objectID": "posts/app爬虫--持续更新/index.html#charles手机代理抓包配置",
    "href": "posts/app爬虫--持续更新/index.html#charles手机代理抓包配置",
    "title": "app爬虫–持续更新",
    "section": "charles手机代理抓包配置",
    "text": "charles手机代理抓包配置\n配置手机代理抓包参考: https://www.jianshu.com/p/551711c121f0\n存在问题:开启手机代理后, pc无法上网, 后期修复  ## 出现的原因是因为电脑没有信任charles的代理,需要为电脑安装证书\nhelp->ssl pinning root\nwin+r->mmc->添加或删除->证书->中间机构颁发->charles proxy->复制->信任证书->粘贴->重启"
  },
  {
    "objectID": "posts/南京大学ics pa实验O/index.html",
    "href": "posts/南京大学ics pa实验O/index.html",
    "title": "南京大学ics pa实验O",
    "section": "",
    "text": "https://github.com/GeeeekExplorer/NJU-ICS/blob/master/pa2018_fall/nemu/src/monitor/expr.c ># PA0 编译NEMU\n\n把项目拉下来，\n修改学号，姓名\nbug：llvm的TargetRegister.h的位置（/src/utils/distasm.cc）， 使用文件搜索locate xxx， 然后修改为查找到的位置\nmake clean –> make\n\n\nfatal error: readline/readline.h: No such file or directory\nsudo apt-get install libreadline-dev\n安装的工具\napt-get install build-essential    # build-essential packages, include binary utilities, gcc, make, and so on\napt-get install man                # on-line reference manual\napt-get install gcc-doc            # on-line reference manual for gcc\napt-get install gdb                # GNU debugger\napt-get install git                # revision control system\napt-get install libreadline-dev    # a library used later\napt-get install libsdl2-dev        # a library used later\napt-get install llvm               # llvm project, which contains libraries used later\n\n\n: error: ‘class llvm::MCInstPrinter’ has no member named ‘setPrintBranchImmAsAddress’\n修改llvm的版本\nsudo apt autoremove llvm-10\nsudo apt install llvm-12\ncd /usr/bin\nsudo ln -s /usr/lib/llvm-12/bin/llvm-config  llvm-config\n\nPA1 深入了解代码框架\n\n这里的pa是2020的isa-x86的pa\n首先是编译项目\n运行项目\n哦豁,不出意外是出意外了assert….(问题不大, 只有有报错信息问题就不大)\n\n\n\n尝试解决assert报错\n\n// 编译\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make -B\n\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n+ CC src/device/io/map.c\n+ CC src/device/io/port-io.c\n+ CC src/device/io/mmio.c\n+ CC src/device/device.c\n+ CC src/device/timer.c\n+ CC src/device/serial.c\n+ CC src/device/intr.c\n....\n+ LD build/x86-nemu-interpreter\n\n\n// 运行\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make run\n\n// 报错\nBuilding x86-nemu-interpreter\nmake -C /home/ubuntu/ics/ics2020/nemu/tools/kvm-diff \nmake[1]: Entering directory '/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff'\nmake[1]: Nothing to be done for 'app'.\nmake[1]: Leaving directory '/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff'\n./build/x86-nemu-interpreter --log=./build/nemu-log.txt --diff=/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff/build/x86-kvm-so \nx86-nemu-interpreter: src/isa/x86/reg.c:20: reg_test: Assertion `reg_w(i) == (sample[i] & 0xffff)' failed.\nmake: *** [Makefile:108: run] Aborted (core dumped)\n\n查看src/isa/x86/reg.c:20:\n\n  1 #include <isa.h>\n  2 #include <stdlib.h>\n  3 #include <time.h>\n  4 #include \"local-include/reg.h\"\n  5 \n  6 const char *regsl[] = {\"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"};\n  7 const char *regsw[] = {\"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\"};\n  8 const char *regsb[] = {\"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\"};\n  9 \n 10 void reg_test() {\n 11   srand(time(0));\n 12   word_t sample[8];\n 13   word_t pc_sample = rand();\n 14   cpu.pc = pc_sample;\n 15 \n 16   int i;\n 17   for (i = R_EAX; i <= R_EDI; i ++) {\n 18     sample[i] = rand();\n 19     reg_l(i) = sample[i];\n // 问题出在这里, 可是这几个宏有点折磨了, 盲猜是不是数据越界了\n [20]     assert(reg_w(i) == (sample[i] & 0xffff));\n 21   }\n\n看到这宏定义有点折磨, 无从下手, 想起来一个好东西gcc -E, 嘿嘿, 这下人肉展开是不可能的, 直接安排\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ gcc -E ./src/isa/x86/reg.c \n\n# 1 \"./src/isa/x86/reg.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"./src/isa/x86/reg.c\"\n./src/isa/x86/reg.c:1:10: fatal error: isa.h: No such file or directory\n    1 | #include <isa.h>\n      |          ^~~~~~~\ncompilation terminated.\n\n啊这, 我又麻了, 果然没有这么简单, 单独gcc -E是不行了, 依赖的文件都得加上才行, 可是这个脚本命令有点不会写啊, 来cat一下jyy的Makefile\n\n// -E 我们都懂的, 可是-MF是什么,google一下,这里我是废物, 我又被google到的中文结果吸引进去了\n@$(CC) $(CFLAGS) -E -MF /dev/null $< | \\\n    grep -ve '^#' | \\\n    clang-format - > $(basename $@).i\ngcc -MF $< - 看完之后我又行了, 不就是建立个文件夹, 然后把每个.c的文件都预编译成.i文件, 我又拿捏了, 走着\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make -B\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n/bin/sh: 3: clang-format: Permission denied\nmake: *** [Makefile:81: build/obj-x86-interpreter/device/audio.o] Error 127\n\n啊这,啊这. 怎么直接都无法编译了, 定睛一看, Permission denied, 这我熟, 直接掏出祖传sudo\nsudo make -B\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ sudo make -B\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n/bin/sh: 3: clang-format: not found\nmake: *** [Makefile:81: build/obj-x86-interpreter/device/audio.o] Error 127\n\n通往pa1完成的道路上充满了坎坷, 说到底还是太菜了, 好在linux的报错信息太perfect了, clang-format: not found, easy, 这种小问题还是可以的直接sudo apt-get install clang-format\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ sudo apt-get install clang-format\n\n\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nThe following NEW packages will be installed:\n  clang-format\n0 upgraded, 1 newly installed, 0 to remove and 251 not upgraded.\nNeed to get 0 B/3,272 B of archives.\nAfter this operation, 29.7 kB of additional disk space will be used.\nSelecting previously unselected package clang-format.\n(Reading database ... 143254 files and directories currently installed.)\nPreparing to unpack .../clang-format_1%3a10.0-50~exp1_amd64.deb ...\nUnpacking clang-format (1:10.0-50~exp1) ...\nSetting up clang-format (1:10.0-50~exp1) ...\nProcessing triggers for man-db (2.9.1-1) ...\n\n冲冲冲…\nsudo make -B\n又看到了熟悉的命令行信息+cc…, 奶思情况好转起来了\n直接冲到reg.i里面看看到底是个啥情况\n\n// 找到reg.i\nvim $(fzf)\nreg.i\n   1 \n   2 \n   3 typedef unsigned char __u_char;\n   4 typedef unsigned short int __u_short;\n   5 typedef unsigned int __u_int;\n   6 typedef unsigned long int __u_long;\n    ...\n  46 typedef long int __clock_t;\n  47 typedef unsigned long int __rlim_t;\n  48 typedef unsigned long int __rlim64_t;\n  49 typedef unsigned int __id_t;\n  50 typedef long int __time_t;\n\n诶,窝草,怎么满屏的定义, 不慌不慌, 直接搜索函数reg_test , 嘿嘿好起来了.又看到了熟悉的代码\n\n2066 const char *regsl[] = {\"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"};\n2067 const char *regsw[] = {\"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\"};\n2068 const char *regsb[] = {\"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\"};\n2069 \n2070 void reg_test() {\n2071   srand(time(0));\n2072   word_t sample[8];\n2073   word_t pc_sample = rand();\n2074   cpu.pc = pc_sample;\n2075 \n2076   int i;\n2077   for (i = R_EAX; i <= R_EDI; i++) {\n2078     sample[i] = rand();\n2079     (cpu.gpr[check_reg_index(i)]._32) = sample[i];\n2080 \n2081     ((void)sizeof(\n2082          ((cpu.gpr[check_reg_index(i)]._16) == (sample[i] & 0xffff)) ? 1 : 0),\n2083      __extension__({\n2084        if ((cpu.gpr[check_reg_index(i)]._16) == (sample[i] & 0xffff))\n2085          ;\n2086        else\n2087          __assert_fail(\"reg_w(i) == (sample[i] & 0xffff)\", \"src/isa/x86/reg.c\",\n2088                        20, __extension__ __PRETTY_FUNCTION__);\n2089      }));\n2090   }\n我擦, 我在搞什么飞机, 胡乱分析系统, 好家伙, jyy老师直接给出了ans. 强行分析一波. 唉, 这波说明在操作前看README的重要性.  - 好家伙， 我是真的服了我了，没有困难制造困难，代码就这么几行，我愣是没看到，只需要重新修改下就行， 我还在苦思冥想该怎么写， 怎么老是测试不过， 原来贴心的jyy老是早就猜到了我的水平，让我改改代码就完事了，大意了。\nx86.h修改如下\ntypedef struct\n{\n  union{\n    union {\n      uint32_t _32;\n      uint16_t _16;\n      uint8_t _8[2];\n    } gpr[8];\n    \n    struct{\n      rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;\n    };\n  };\n  vaddr_t pc;\n} x86_CPU_state;\n\n接着冲冲冲\nmake -B -j8 \noh oh oh oh oh….\n\n\n运行第一个客户程序\n\n\n单步执行：\n\nsi [N]\n让程序单步执行, 这里有个小bug，不过也不算小bug，需要打开调试的宏DEBUG 在common.h中， 否则无法查看单步执行后的几寄存器的效果 \n\n\nui.c\nstatic int cmd_si(char *args) {\n  // strtok is split string with specify symbol \n  // strtok(args,\"\")\n  int step;\n  \n  if(args == NULL) step=1;\n  // format string and move to a new vable  \n  else sscanf(args,\"%d\",&step);\n  \n  // excute num\n  cpu_exec(step);\n  return 0;\n}\nui.c> cmd_table\n { \"si\", \"Debug by step NEMU\", cmd_si },\n\n这个单步调试很关键哦， 后续的内存扫描需要用到这里作为校验，刚开始自己直接忽略了，吃了大亏，出来混还是的还的。  > ### 打印程序（寄存器）状态 > - 就是打印寄存器中的数据 > - 仿照上面的案例，修改cmd_table, 建立cmd_info函数\n\n这里调用了reg.c中的isa_reg_display记得导入头文件\n#include  \"memory/vaddr.h\"\n\nvoid isa_reg_display() {\n  for (int i = R_EAX; i < R_EDI; i++)\n  {\n    printf(\"$%s\\t0x%08x\\n\", regsl[i] ,reg_l(i));\n  }\n  printf(\"$pc\\t0x%08x\\n\",cpu.pc);\n}\nui.c\nstatic int cmd_info(char* args){\n  \n  // show register \n  if (args[0] == 'r') isa_reg_display();\n  \n  // show watch pointer\n  else if(args[0] == 'w') TODO();\n \n  return 0;\n}\nui.c> cmd_table\n { \"info\", \"info r-->show reg\\ninfo w-->show watch pointer memory\", cmd_info },\n\n注意这里的info是使用的info r进行测试，后面的info w暂时先搁置，先搞后面的扫描内存  >### 扫描内存(2)\n这里可有点弯弯绕，我最初的想法是通过传递进来的地址，然后直接按照16进制数进行数据的解析，好家伙， 我想的是真复杂了（好吧，我承认我又没有认真看手册，手册里面都说了，前面我们都看了内存是怎么设计的。。。。），vaddr_read 害。。\n\n - 还是熟悉的套路：\nui.c> cmd_table\n{ \"x\", \"show memory from 0xxxx\", cmd_x }\nui.c - 第一个参数是扫描的长度， 第二个参数是起始位置\nstatic int cmd_x(char* args){\n  uint32_t len;\n  uint32_t addr;\n\n  char* N    =  strtok(NULL,\" \");\n  char* EXPR =  strtok(NULL,\" \");\n\n  sscanf(N,\"%d\",&len);\n  sscanf(EXPR,\"%x\",&addr);\n\n  for(int i=addr;i<addr+(len*4);i+=4){\n    word_t value = vaddr_read(i,4);\n    printf(\"$0x%08x:\\t0x%08x\\n\", i,value);\n  }\n  \n  return 0;\n}\n\n测试：\n\n\n\n\n在这里插入图片描述\n\n\ngdb中文参考：https://wizardforcel.gitbooks.io/100-gdb-tips/content/examine-memory.html\n\n表达式求值\n\n正则表达式\nexpr.h &expr.c\n正则表达式的C语言使用\n\n\n正则表达式在线测试： https://c.runoob.com/front-end/854/\n正则表达式代码参考地址: https://www.ibm.com/docs/en/i/7.4?topic=functions-regcomp-compile-regular-expression - 正则表达式的基本使用 regcomp()\n#include <regex.h>\nint regcomp(regex_t *preg, const char *pattern, int cflags);\n\nregexec()\n参考链接： https://blog.csdn.net/weixin_46499713/article/details/125154268 https://blog.csdn.net/weixin_43877657/article/details/109068930?spm=1001.2014.3001.5502"
  },
  {
    "objectID": "posts/java和-- Collections工具类/index.html",
    "href": "posts/java和-- Collections工具类/index.html",
    "title": "java和– Collections工具类",
    "section": "",
    "text": "Collections工具类\npackage cn.usts.edu.collections;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/**\n * @author ：fly\n * @description: 集合工具类\n * @date ：2021/11/3 16:20\n */\npublic class CollectionsDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n        al.add(\"tom\");\n        al.add(\"tom\");\n        al.add(\"jack\");\n        al.add(\"al\");\n        al.add(\"swallow\");\n\n        System.out.println(\"正常顺序\");\n        System.out.println(al);\n\n        // 位置交换\n        System.out.println(\"=========0,最后 位置交换=======\");\n        Collections.swap(al,0,al.size()-1);// 0,最后 位置交换\n        System.out.println(al);\n\n        System.out.println(\"=========逆序=======\");\n        Collections.reverse(al);\n        System.out.println(\"逆序:\"+al);\n\n        // 随机排序\n        System.out.println(\"=========随机排序=======\");\n        Collections.shuffle(al);\n        System.out.println(al);\n\n        // 自然顺序\n        System.out.println(\"=========自然顺序=======\");\n        Collections.sort(al);\n        System.out.println(al);\n\n\n        // 自定义排序\n        System.out.println(\"=========自定义排序(字符大到小)=======\");\n        Collections.sort(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if(o1 instanceof String) { // 校验是否是String\n                    return ((String) o2).compareTo((String) o1);\n                }\n                return 0;\n            }\n        });\n        System.out.println(al);\n\n\n        System.out.println(\"=========自定义排序(长度大到小)=======\");\n        Collections.sort(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String) o2).length() - (((String) o1).length());\n            }\n        });\n        System.out.println(al);\n\n\n        // 自然排序最大值\n        System.out.println(\"=========自定义(长度最大)=======\");\n        Object max = Collections.max(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String) o1).length() - (((String) o2).length());\n            }\n        });\n        System.out.println(max);\n\n        // 自定义最大值\n        System.out.println(\"=========自然排序最大值=======\");\n        Comparable max1 = Collections.max(al);\n        System.out.println(max1);\n\n\n        // 同理max(),自定义也同理\n//        Collections.min();\n\n\n        // 出现次数\n        System.out.println(\"=========出现次数=======\");\n        int tomTimes = Collections.frequency(al, \"tom\");\n        System.out.println(\"tom出现:\"+tomTimes+\"次\");\n\n\n        // 复制\n        System.out.println(\"=========复制数组=======\");\n        ArrayList bal = new ArrayList();\n        for (Object o : al) {\n            bal.add(\"\"); // 新的数组默认为零,不填充空的数据,回报数组Index越界\n        }\n        Collections.copy(bal,al);\n        System.out.println(bal);\n\n        //替换\n        System.out.println(\"=========替换元素=======\");\n        Collections.replaceAll(al,\"tom\",\"汤姆\");\n        System.out.println(al);\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html",
    "href": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html",
    "title": "Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？",
    "section": "",
    "text": "## TreeSet的lambda写法个人理解"
  },
  {
    "objectID": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html#treeset提供的构造器",
    "href": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html#treeset提供的构造器",
    "title": "Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？",
    "section": "TreeSet提供的构造器",
    "text": "TreeSet提供的构造器\n这么多的构造器lambda怎么确定是Compartor的呢 一个一个点进去看,会发现只有Compartor是函数是接口  点击到Compartor中发现,里面有很多方法啊,为什么就是函数式接口了呢  有两个抽象方法,查资料才发现,equals是Object类的方法,这里不属于Compartor,所以最后定位到了compare了"
  },
  {
    "objectID": "posts/java多线程-- thread.getState() 查看线程状态/index.html",
    "href": "posts/java多线程-- thread.getState() 查看线程状态/index.html",
    "title": "java多线程– thread.getState() 查看线程状态",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\n/**\n * 一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。\n *\n * 线程状态。 线程可以处于以下状态之一：\n * NEW              尚未启动的线程处于此状态。\n * RUNNABLE         在Java虚拟机中执行的线程处于此状态。\n * BLOCKED          被阻塞等待监视器锁定的线程处于此状态。\n * WAITING          正在等待另一个线程执行特定动作的线程处于此状态。\n * TIMED_WAITING    正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\n * TERMINATED       已退出的线程处于此状态。\n *\n *\n * */\n\npublic class ThreadStateDemo implements Runnable {\n    @Override\n    public void run() {\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(\n                // lambda表达式实现的run方法.\n                ()->{\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);// 延时1s\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"------------------\");\n        });\n\n\n        System.out.println(thread.getState()); // 获取启动前的状态\n\n        // 线程启动\n        thread.start();\n        System.out.println(thread.getState());// 获取启动时的状态\n\n        while (thread.getState()!=Thread.State.TERMINATED){\n            Thread.sleep(900); // 延时100ms刷新状态\n            System.out.println(thread.getState());\n\n        }\n    }\n}"
  },
  {
    "objectID": "posts/qt--vs2022+qt5.15.2/index.html",
    "href": "posts/qt--vs2022+qt5.15.2/index.html",
    "title": "qt–vs2022+qt5.15.2",
    "section": "",
    "text": "最终效果\n项目结构 \n # demo的搭建 \n          \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击角色-添加角色",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击角色-添加角色",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "2、点击角色—->添加角色",
    "text": "2、点击角色—->添加角色\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击-下一步",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击-下一步",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "3、点击 【下一步】",
    "text": "3、点击 【下一步】\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "4、勾选DHCP",
    "text": "4、勾选DHCP\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#如果出现此情况点击取消",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#如果出现此情况点击取消",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5、如果出现此情况点击取消）",
    "text": "（5、如果出现此情况点击取消）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#执行以下操作",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#执行以下操作",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.1执行以下操作）",
    "text": "（5.1执行以下操作）\n静态ip配置如下 静态ip配置如下 静态ip配置如下\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#本地连接",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#本地连接",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.2本地连接）",
    "text": "（5.2本地连接）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#属性",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#属性",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.3属性）",
    "text": "（5.3属性）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#双击ipv4",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#双击ipv4",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.4双击iPv4）",
    "text": "（5.4双击iPv4）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.5根据需求设置）",
    "text": "（5.5根据需求设置）\n设置完确定关闭窗口，回到刚刚的DHCP安装页面\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#再次点击添加角色",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#再次点击添加角色",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "6、再次点击添加角色",
    "text": "6、再次点击添加角色\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "7、勾选DHCP",
    "text": "7、勾选DHCP\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "8、下一步",
    "text": "8、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "9、下一步",
    "text": "9、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "10、根据需求设置",
    "text": "10、根据需求设置\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-2",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-2",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "11、下一步",
    "text": "11、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#添加作用域",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#添加作用域",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "12、添加作用域",
    "text": "12、添加作用域\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#设置起始地址",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#设置起始地址",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "13、设置起始地址",
    "text": "13、设置起始地址\n 13.1下一步"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#禁用ipv6",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#禁用ipv6",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "14、禁用ipv6",
    "text": "14、禁用ipv6\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#安装",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#安装",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "15、安装",
    "text": "15、安装\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#测试",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#测试",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "16、测试",
    "text": "16、测试\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/应用视觉设计/index.html",
    "href": "posts/应用视觉设计/index.html",
    "title": "应用视觉设计",
    "section": "",
    "text": "这部分课程主要关于应用视觉设计。开始的挑战展示了一些核心的原则，代码基于一个指定的卡片布局。\nweb 内容大部分都是文本。CSS 里面的text-align属性可以控制文本的对齐方式。\ntext-align: justify;可以让除最后一行之外的文字两端对齐，即每行的左右两端都紧贴行的边缘。\ntext-align: center;可以让文本居中对齐。\ntext-align: right;可以让文本右对齐。\ntext-align: left;是text-align的默认值，它可以让文本左对齐"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-width-属性调整元素的宽度",
    "href": "posts/应用视觉设计/index.html#使用-width-属性调整元素的宽度",
    "title": "应用视觉设计",
    "section": "使用 width 属性调整元素的宽度",
    "text": "使用 width 属性调整元素的宽度\n你可以使用 CSS 里面的width属性来指定元素的宽度。属性值可以是相对单位（比如 em），绝对单位（比如 px），或者包含块（父元素）宽度的百分比。下面这个例子把图片的宽度设置为 220px：\nimg { width: 220px; } ## 使用 height 属性调整元素的高度 和width属性类似，你可以使用 CSS 里面的height属性来指定元素的高度。下面这个例子把图片的高度设置为 20px：\nimg { height: 20px; }"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-strong-标签加粗文本",
    "href": "posts/应用视觉设计/index.html#使用-strong-标签加粗文本",
    "title": "应用视觉设计",
    "section": "使用 strong 标签加粗文本",
    "text": "使用 strong 标签加粗文本\n术语：Strong => s => 加粗。\n你可以使用strong标签来加粗文字。添加了strong标签后，浏览器会自动给元素应用font-weight:bold;。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-u-标签给文本添加下划线",
    "href": "posts/应用视觉设计/index.html#使用-u-标签给文本添加下划线",
    "title": "应用视觉设计",
    "section": "使用 u 标签给文本添加下划线",
    "text": "使用 u 标签给文本添加下划线\n术语：Underline => u => 下划线。\n你可以使用u标签来给文字添加下划线。添加了u标签后，浏览器会自动给元素应用text-decoration: underline;。 ## 使用 em 标签强调文本 术语：emphasis => em => 强调。\n你可以使用em标签来强调文本。由于浏览器会自动给元素应用font-style: italic;，所以文本会显示为斜体 ## 使用 s 标签给文本添加删除线 术语：Strikethrough => s => 删除线。\n你可以用s标签来给文字添加删除线，我是明晃晃的删除线，它代表着这段文字不再有效。添加了s标签后，浏览器会自动给元素应用text-decoration: line-through;。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-hr-标签创建水平线",
    "href": "posts/应用视觉设计/index.html#使用-hr-标签创建水平线",
    "title": "应用视觉设计",
    "section": "使用 hr 标签创建水平线",
    "text": "使用 hr 标签创建水平线\n术语：Horizontal Rule => hr => 水平线。\n你可以用hr标签来创建一条宽度撑满父元素的水平线。它一般用来表示文档主题的改变，在视觉上将文档分隔成几个部分 ## 调整文本的背景色 为了让页面更美观，除了设置整个页面的背景色以及文字颜色外，你还可以单独设置文字的背景色，即在文字的父元素上添加background-color属性。在本挑战里我们将使用rgba()颜色，而不是之前学到的hex编码或者rgb()颜色。\nrgba 代表： r = red 红色 g = green 绿色 b = blue 蓝色 a = alpha 透明度 RGB 值可以在 0 到 255 之间。alpha 值可以在 0 到 1 之间，其中 0 代表完全透明，1 代表完全不透明。rgba()非常棒，因为你可以设置颜色的透明度，这意味着你可以做出一些很漂亮的半透明效果。 ## 调整标题与段落的大小 标题（h1到h6）的文字应该比的段落的文字大，这样可以让用户更直观的看到页面的布局，同时能区别出不同元素的重要程度，更方便用户捕捉关键的信息。你可以使用font-size属性来设置元素内文字的大小。 ## 给卡片元素添加 box-shadow box-shadow属性用来给元素添加阴影，该属性值是由逗号分隔的一个或多个阴影列表。\nbox-shadow属性的每个阴影依次由下面这些值描述： offset-x阴影的水平偏移量； offset-y阴影的垂直偏移量; blur-radius模糊距离； spread-radius阴影尺寸； 颜色。 其中blur-raduis和spread-raduis是可选的。\n下面是创建了多个阴影的 CSS 例子，阴影加了模糊效果，颜色是透明度很高的黑色:\nbox-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); ## 降低元素的 opactiy CSS 里的opacity属性用来设置元素的透明度。\n值 1 代表完全不透明。 值 0.5 代表半透明。 值 0 代表完全透明。 透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-text-transform-属性给文本添加大写效果",
    "href": "posts/应用视觉设计/index.html#使用-text-transform-属性给文本添加大写效果",
    "title": "应用视觉设计",
    "section": "使用 text-transform 属性给文本添加大写效果",
    "text": "使用 text-transform 属性给文本添加大写效果\nCSS 里面的text-transform属性来改变英文中字母的大小写。它通常用来统一页面里英文的显示，且无需直接改变 HTML 元素中的文本。\n下面的表格展示了text-transform的不同值对文字 “Transform me” 的影响。  ## 设置多个标题元素的 font-size 在上一个挑战里你已经设置了每个标题的font-size，接下来你将设置font-weight。\nfont-weight属性用于设置文本中所用的字体的粗细。 ## 设置段落文本的 font-size CSS 里面的font-size属性不只限于标题，它可以应用于任何包含文字的元素内。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#设置段落的-line-height",
    "href": "posts/应用视觉设计/index.html#设置段落的-line-height",
    "title": "应用视觉设计",
    "section": "设置段落的 line-height",
    "text": "设置段落的 line-height\nCSS 提供line-height属性来设置行间的距离。行高，顾名思义，用来设置每行文字所占据的垂直空间。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#调整锚点的悬停状态",
    "href": "posts/应用视觉设计/index.html#调整锚点的悬停状态",
    "title": "应用视觉设计",
    "section": "调整锚点的悬停状态",
    "text": "调整锚点的悬停状态\n本挑战将要涉及到伪类。伪类是可以添加到选择器上的关键字，用来选择元素的指定状态。\n比如，超链接可以使用:hover伪类选择器定义它的悬停状态样式。下面是悬停超链接时改变超链接颜色的 CSS：\na:hover { color: red; } ## 更改元素的相对位置 在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了 position 属性来覆盖它。\n当元素的 position 设置为relative时，它允许你通过 CSS 指定该元素在当前普通流页面下的相对偏移量。 CSS 里控制各个方向偏移量的对应的属性是left、right、top和bottom。它们代表着从原来的位置向对应的方向偏移指定的像素、百分比或者 ems。下面的例子展示了段落向上偏移 10 像素：\np { position: relative; bottom: 10px; } 把元素的 position 设置成 relative 并不会改变该元素在普通流布局所占的位置，也不会对其它元素的位置产生影响。\n注意 定位可以让你在页面布局上更灵活、高效。注意不管元素的定位是怎样，内部的 HTML 代码阅读起来应该是整洁、有意义的。这样也可以让视障人员（他们重度依赖辅助设备比如屏幕阅读软件）能够浏览你的网页。 ## 使用 CSS 偏移移动相对定位的元素 CSS 里面的top、bottom、left和right定义了元素在相应方位的偏移距离。元素将从当前位置，向属性相反的方向偏移。就像你在上一个挑战看到的，top属性使h2向下移动。left属性使元素向右移动。 h2 { position: relative;\n}\n## 绝对定位的参照物是元素的父元素\n接下来要介绍 CSSposition属性的取值选项absolute，absolute相对于其包含块定位。和relative定位不一样，absolute定位会将元素从当前的文档流里面移除，周围的元素会忽略它。可以用 CSS 的 top、bottom、left 和 right 属性来调整元素的位置。\nabsolute定位比较特殊的一点是元素的定位参照于最近的已定位祖先元素。如果它的父元素没有添加定位规则（默认是position:relative;）,浏览器会继续寻找直到默认的 body 标签。 ## 固定定位的参照物是浏览器的窗口 接下来要介绍的是fixed定位，它是一种特殊的绝对（absolute）定位，区别是其包含块是浏览器窗口。和绝对定位类似，fixed定位使用 top、bottom、left 和 right 属性来调整元素的位置，并且会将元素从当前的文档流里面移除，其它元素会忽略它的存在。\nfixed定位和absolute定位的最明显的区别是fixed定位元素不会随着屏幕滚动而移动。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-float-属性将元素左浮动或右浮动",
    "href": "posts/应用视觉设计/index.html#使用-float-属性将元素左浮动或右浮动",
    "title": "应用视觉设计",
    "section": "使用 float 属性将元素左浮动或右浮动",
    "text": "使用 float 属性将元素左浮动或右浮动\n接下来要介绍的定位机制并不是position属性的选项，它通过元素的float属性来设置。浮动元素不在文档流中，它向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。通常需要用width属性来指定浮动元素占据的水平空间。 ## 使用 z-index 属性更改重叠元素的位置 当一些元素重叠时，在 HTML 里后出现的元素会默认显示在更早出现的元素的上面。你可以使用z-index属性指定元素的堆叠次序。z-index的取值是整数，数值大的元素优先于数值小的元素显示。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-margin-属性将元素水平居中",
    "href": "posts/应用视觉设计/index.html#使用-margin-属性将元素水平居中",
    "title": "应用视觉设计",
    "section": "使用 margin 属性将元素水平居中",
    "text": "使用 margin 属性将元素水平居中\n在应用设计中经常需要把一个块级元素水平居中显示。一种常见的实现方式是把块级元素的margin值设置为auto。\n同样的，这个方法也对图片奏效。图片默认是内联元素，但是可以通过设置其display属性为block来把它变成块级元素。 ## 了解互补色 色彩理论以及设计色彩学很复杂，这里将只涉及很基础的部分。在网站设计里，颜色能让内容更醒目，能调动情绪，从而创造舒适的视觉体验。不同的颜色组合对网站的视觉效果影响很大，精妙的设计都需要适宜的颜色来美化页面内容。\n一半是科学，一半是艺术，色环是我们认识颜色关系的好工具 - 它是一个近色相邻异色相离的圆环。当两个颜色恰好在色环的两端时，这两个颜色叫做补色。绘画中两只补色在混合后会变成灰色。补色搭配能形成强列的对比效果，传达出活力、能量、兴奋等意义。\n下面是一些十六进制码（hex code）补色的例子：\n红色（#FF0000）和蓝绿色 (#00FFFF) 绿色（#00FF00）和品红色（#FF00FF） 蓝色（#0000FF）和黄色（#FFFF00） 现在很多的在线选色工具都有寻找补色的功能。\n注意 对于所有的颜色关卡： 颜色能吸引用户的注意，但不是唯一的方式，切勿喧宾夺主，过度使用会适得其反。详细会在应用无障碍章节介绍。 ## 了解三原色 电脑显示器和手机屏幕是一种加色模型，将红（R）、绿（G）、蓝（B）三原色的色光以不同的比例相加，以产生多种多样的色光。两种原色相加产生二次色：蓝绿（G+B）、品红（R+B）和黄色（R+G）。你在上一个挑战里已经见过这些颜色了。这些二次色恰好是在合成它们时未使用的原色的补色，即在色环中位于两端。例如，品红色是红色和蓝色相加产生，它是绿色的补色。\n三次色是由原色和二次色相加产生的颜色，例如红色（原色）和黄色（二次色）相加产生橙色。将这六种颜色中相邻的颜色相加，便产生了十二色色环。\n设计里面有很多种颜色搭配方法。涉及到三次色的一种配色方法是分裂补色搭配法。选定主色之后，在色环上选择与它的补色相邻的两种颜色与之搭配。此种搭配既有对比，又不失和谐。\n下面是使用分裂补色搭配法创建的三个颜色：\n ## 将各种元素的颜色调整为互补色 通过前面关卡的学习，我们知道了补色搭配能形成强列的对比效果，让内容更富生机。但是如果使用不当效果会适得其反，比如如果文字背景色和文字颜色互为补色，文字会很难看清。通常的做法是，一种颜色做为主要颜色，其补色用来装点页面 ## 调整颜色的色相 HSL 色彩空间模型是一种将 RGB 色彩模型中的点放在圆柱坐标系中的表示法，描述了色相（hue）、饱和度（saturation）、亮度（lightness）。CSS3 引入了对应的hsl()属性做为对应的颜色描述方式。\n色相是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。以颜色光谱为例，光谱左边从红色开始，移动到中间的绿色，一直到右边的蓝色，色相值就是沿着这条线的取值。在hsl()里面，色相用色环来代替光谱，色相值就是色环里面的颜色对应的从 0 到 360 度的角度值。\n饱和度是指色彩的纯度，也就是颜色里灰色的占比，越高色彩越纯，低则逐渐变灰，取0-100%的数值。\n亮度决定颜色的明暗程度，也就是颜色里白色或者黑色的占比，100% 亮度是白色， 0% 亮度是黑色，而 50% 亮度是“一般的”。\n下面是一些使用hsl()描述颜色的例子，颜色都为满饱和度，中等亮度:  ## 调整颜色的色调 hsl()使 CSS 更改色调更方便。给纯色添加白色可以创造更浅的色调，添加黑色可以创造更深的色调。另外，还可以通过给纯色添加灰色来同时改变颜色的深浅和明暗。回忆下hsl()里面的‘s’和‘l’分辨代表饱和度和亮度。饱和度代表灰色的占比，亮度代表白色和黑色的占比。这在当你有了一个基色调却需要微调时非常有用。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#创建一个-css-线性渐变",
    "href": "posts/应用视觉设计/index.html#创建一个-css-线性渐变",
    "title": "应用视觉设计",
    "section": "创建一个 CSS 线性渐变",
    "text": "创建一个 CSS 线性渐变\nHTML 元素的背景色并不局限于单色。CSS 还提供了颜色过渡，也就是渐变。可以通过background里面的linear-gradient()来实现线性渐变，下面是它的语法：\nbackground: linear-gradient(gradient_direction, 颜色 1, 颜色 2, 颜色 3, …);\n第一个参数指定了颜色过渡的方向 - 它的值是角度，90deg 代表垂直渐变，45deg 的渐变角度和反斜杠方向差不多。剩下的参数指定了渐变颜色的顺序：\n例子：\nbackground: linear-gradient(90deg, red, yellow, rgb(204, 204, 255));"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-css-线性渐变创建条纹元素",
    "href": "posts/应用视觉设计/index.html#使用-css-线性渐变创建条纹元素",
    "title": "应用视觉设计",
    "section": "使用 CSS 线性渐变创建条纹元素",
    "text": "使用 CSS 线性渐变创建条纹元素\nrepeating-linear-gradient()函数和linear-gradient()很像，主要区别是repeating-linear-gradient()重复指定的渐变。 repeating-linear-gradient()有很多参数，为了便于理解，本关只用到角度值和起止渐变颜色值。\n角度就是渐变的方向。起止渐变颜色值代表渐变颜色及其宽度值，由颜色值和起止位置组成，起止位置用百分比或者像素值表示。\n在代码编辑器的例子里，渐变开始于 0 像素位置的yellow，然后过渡到距离开始位置 40 像素的blue。由于下一个起止渐变颜色值的起止位置也是 40 像素，所以颜色直接渐变成第三个颜色值green，然后过渡到距离开始位置 80 像素的red。\n下面的代码可以帮助理解成对的起止渐变颜色值是如何过渡的。\n0px [黄色 – 过渡 – 蓝色] 40px [绿色 – 过渡 – 红色] 80px\n如果每对起止渐变颜色值的颜色都是相同的，由于是在两个相同的颜色间过渡，那么中间的过渡色也为同色，接着就是同色的过渡色和下一个起止颜色，最终产生的效果就是条纹。\n<style>\n\n  div{ \n    border-radius: 20px;\n    width: 70%;\n    height: 400px;\n    margin:  50 auto;\n    background: repeating-linear-gradient(\n      45deg,\n      yellow 0px,\n       yellow 40px,\n       black 40px,\n       black 80px\n    );\n\n  }\n\n</style>\n ## 通过添加细微图案作为背景图像来创建纹理 添加一个精致的背景图，可以增加页面的质感，让页面更美观。关键是要找到一个平衡点，抢了内容的风头，喧宾夺主可就不妙了。background属性支持使用url()函数通过链接的方式引入一个指定纹理或样式的图片。图片链接地址在括号内，一般会用引号包起来。 background:url(https://i.imgur.com/MJAkxbh.png) ## 使用 CSS Transform scale 属性可以更改元素的大小 CSS 属性transform里面的scale()函数，可以用来改变元素的显示比例。下面的例子把页面的段落元素放大了 2 倍：\np { transform:scale(2); }"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用css-transform-scale-属性在悬停时缩放元素",
    "href": "posts/应用视觉设计/index.html#使用css-transform-scale-属性在悬停时缩放元素",
    "title": "应用视觉设计",
    "section": "使用CSS Transform scale 属性在悬停时缩放元素",
    "text": "使用CSS Transform scale 属性在悬停时缩放元素\ntransform属性有很多函数，可以对元素进行调整大小、移动、旋转、翻转等操作。当使用伪类描述元素的指定状态如:hover时，transform属性可以方便的给元素添加交互。\n下面是当用户悬停段落元素时，段落大小缩放到原始大小 2.1 倍的例子：\np:hover { transform: scale(2.1); } ## 使用 CSS Transform skex 属性沿X轴倾斜元素 接下来要介绍的transform属性是skewX，skewX使选择的元素沿着 X 轴（横向）翻转指定的角度。\n下面的代码沿着 X 轴翻转段落元素 -32 度。\np { transform: skewX(-32deg); }  ## 使用 CSS 创建一个图形 术语表：blur-radius => 模糊半径，spread-radius => 辐射半径，transparent => 透明的，border-radius => 圆角边框。\n通过使用选择器选择不同的元素并改变其属性，你可以创造一些有趣的形状。比如新月。你可以使用box-shadow属性来设置元素的阴影，border-radius属性控制元素的圆角边框。\n首先你将会创建一个圆的、透明的对象，它具有模糊阴影并略微向两边递减。如你所见，这个阴影其实就是新月形狀。\n为了创建一个圆形的对象，border-radius应该被设置成 50%。\n你应该还记得之前关卡的box-shadow属性以及它的依次取值offset-x、offset-y、blur-radius、spread-radius和颜色值。其中blur-radius和spread-radius是可选的。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-css-和-html-创建更复杂的形状",
    "href": "posts/应用视觉设计/index.html#使用-css-和-html-创建更复杂的形状",
    "title": "应用视觉设计",
    "section": "使用 CSS 和 HTML 创建更复杂的形状",
    "text": "使用 CSS 和 HTML 创建更复杂的形状\n世界上最流行的形状非心形莫属了，在本关里你将用纯 CSS 创建一个心形。但是首先你需要了解:before和:after伪类。这些伪类用来在选择元素之前和之后添加一些内容。在下面的例子里，:before伪类元素用来给 class 为heart的元素添加一个正方形。\n:before和:after必须配合content来使用。这个属性通常用来给元素添加内容诸如图片或者文字。当:before和:after伪类用来添加某些形状而不是图片或文字时，content属性仍然是必需的，但是它的值可以是空字符串。\n在上面的例子里，class 为heart元素的:before伪类添加了一个黄色的长方形，长方形的height和width分别为 50px 和 70px。由于设置了其边框半径为 25%，所以长方形为圆角长方形，同时其相对位置为距离left5px，以及向top偏移 50px。\n.heart:before {\n  content: \"\";\n  background-color: yellow;\n  border-radius: 25%;\n  position: absolute;\n  height: 50px;\n  width: 70px;\n  top: -50px;\n  left: 5px;\n}\n心形图案css\n<style>\n.heart {\n  position: absolute;\n  margin: auto;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: pink;\n  height: 50px;\n  width: 50px;\n  transform:rotate(-45deg) ;\n}\n.heart:after {\n  background-color: pink;\n  content: \"\";\n  border-radius: 50%;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  top: 0px;\n  left: 25px;\n}\n.heart:before {\n  content:'' ;\n  background-color: pink;\n  border-radius: 50%;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  top: -25px;\n  left: 0px;\n} \n</style>\n<div class = \"heart\"></div>"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#了解-css-的关键帧和动画是如何工作的",
    "href": "posts/应用视觉设计/index.html#了解-css-的关键帧和动画是如何工作的",
    "title": "应用视觉设计",
    "section": "了解 CSS 的关键帧和动画是如何工作的",
    "text": "了解 CSS 的关键帧和动画是如何工作的\n如果要给元素添加动画，你需要了解animation属性以及@keyframes规则。animation属性控制动画的外观，@keyframes规则控制动画中各阶段的变化。总共有 8 个animation属性。为了便于理解，本关暂时只涉及到两个最常用的属性。\nanimation-name设置动画的名称， 也就是要绑定的选择器的@keyframes的名称。\nanimation-duration设置动画所花费的时间。\n@keyframes能够创建动画。 创建动画的原理是将一套 CSS 样式逐渐变化为另一套样式。具体是通过设置动画期间对应的“frames”的 CSS 的属性，以百分比来规定改变的时间，或者通过关键词“from”和“to”，等价于 0% 和 100%。打个比方，CSS 里面的 0% 属性就像是电影里面的开场镜头。CSS 里面的 100% 属性就是元素最后的样子，相当于电影里的演职员表或者鸣谢镜头。CSS 在对应的时间内给元素过渡添加效果。下面举例说明@keyframes和动画属性的用法：\n#anim {\n  animation-name: colorful;\n  animation-duration: 3s;\n}\n@keyframes colorful {\n  0% {\n    background-color: blue;\n  }\n  100% {\n    background-color: yellow;\n  }\n}\nid 为anim的元素，代码设置animation-name为colorful，设置animation-duration为 3 秒。然后把@keyframes引用到名为colorful的动画属性上。colorful在动画开始时（0%）设置颜色为蓝色，在动画结束时（100%）设置颜色为黄色。注意不是只有开始和结束的过渡可以设置，0% 到 100% 间的任意百分比你都可以设置。 ## 使用CSS动画更改按钮的悬停状态 你可以在按钮悬停时使用@keyframes改变按钮的颜色。\n下面是在图片悬停时改变图片宽度的例子：\n<style>\n  img:hover {\n    animation-name: width;\n    animation-duration: 500ms;\n  }\n\n  @keyframes width {\n    100% {\n      width: 40px;\n    }\n  }\n</style>\n\n<img src=\"https://bit.ly/smallgooglelogo\" alt=\"Google's Logo\" />\n注意ms代表毫秒，1000ms 等于 1s。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#修改动画的填充模式颜色保持",
    "href": "posts/应用视觉设计/index.html#修改动画的填充模式颜色保持",
    "title": "应用视觉设计",
    "section": "修改动画的填充模式颜色保持",
    "text": "修改动画的填充模式颜色保持\n太棒了，但是现在还不完美。注意动画在500ms之后重置了，所以按钮又变成了之前的颜色。而我们想要的效果是按钮在悬停时始终高亮。\n这可以通过把animation-fill-mode设置成forwards来实现。animation-fill-mode指定了在动画结束时元素的样式。你可以向这样设置它：\nanimation-fill-mode: forwards; ## 使用 CSS 动画创建运动 当元素的position被指定，如fixed或者relative时，CSS 偏移属性right、left、top和bottom可以用在动画规则里创建动作。\n就像下面的例子展示的那样，你可以在50%keyframe 处设置top属性为 50px， 在开始（0%）和最后（100%）keframe 处设置为 0px，以产生项目向下运动，然后返回的动作效果。\n@keyframes rainbow {\n  0% {\n    background-color: blue;\n    top: 0px;\n  }\n  50% {\n    background-color: green;\n    top: 50px;\n  }\n  100% {\n    background-color: yellow;\n    top: 0px;\n  }\n}"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#通过从左到右淡化元素来创建视觉方向",
    "href": "posts/应用视觉设计/index.html#通过从左到右淡化元素来创建视觉方向",
    "title": "应用视觉设计",
    "section": "通过从左到右淡化元素来创建视觉方向",
    "text": "通过从左到右淡化元素来创建视觉方向\n在本关里，你将要改变动画元素的opacity，使其在到达屏幕右侧时渐隐。\n在展示的动画里，具有渐变背景的圆形元素在 50% 标记的@keyframes规则处向右移动。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用无限的动画计数制作永不停止的动画",
    "href": "posts/应用视觉设计/index.html#使用无限的动画计数制作永不停止的动画",
    "title": "应用视觉设计",
    "section": "使用无限的动画计数制作永不停止的动画",
    "text": "使用无限的动画计数制作永不停止的动画\n之前的关卡里介绍了一些动画属性以及@keyframes规则的用法。还有一个常用的动画属性是animation-iteration-count，这个属性允许你控制动画循环的次数。下面是一个例子：\nanimation-iteration-count: 3;\n在这里动画会在运行 3 次后停止，如果想让动画一直运行，可以把值设置成 infinite。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用无限的动画计数制作-css-心跳",
    "href": "posts/应用视觉设计/index.html#使用无限的动画计数制作-css-心跳",
    "title": "应用视觉设计",
    "section": "使用无限的动画计数制作 CSS 心跳",
    "text": "使用无限的动画计数制作 CSS 心跳\n这也是一个用animation-iteration-count属性创造持续动画的例子，它基于前面关卡创建的心形。\n心跳动画的每一秒包含两个部分。heart元素（包括:before和:after）使用transform属性改变其大小，背景div使用background属性改变其颜色`\n<style>\n  .back {\n    position: fixed;\n    padding: 0;\n    margin: 0;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: white;\n    animation-name: backdiv;\n    animation-duration: 1s; \n    animation-iteration-count:infinite;\n  }\n\n  .heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n    animation-name: beat;\n    animation-duration: 1s;\n    animation-iteration-count:infinite;\n    \n  }\n  .heart:after {\n    background-color: pink;\n    content: \"\";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  .heart:before {\n    background-color: pink;\n    content: \"\";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n\n  @keyframes backdiv {\n    50% {\n      background: #ffe6f2;\n    }\n  }\n\n  @keyframes beat {\n    0% {\n      transform: scale(1) rotate(-45deg);\n    }\n    50% {\n      transform: scale(0.6) rotate(-45deg);\n    }\n  }\n\n</style>\n<div class=\"back\"></div>\n<div class=\"heart\"></div>"
  },
  {
    "objectID": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html",
    "href": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html",
    "title": "java_TreeSet和HashSet的去重原理 (作业四)",
    "section": "",
    "text": "object对象没有办法使用String中的CompareTo(),会报错, treeSet中没有滴定仪Comparator,会默认使用String中的"
  },
  {
    "objectID": "posts/web-packet --01/index.html",
    "href": "posts/web-packet --01/index.html",
    "title": "web-packet –01",
    "section": "",
    "text": "进入\nnpm -init -y\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div>\n<!--        ul>li{这是$}*9-->\n        <ul>\n            <li>这是第1个li</li>\n            <li>这是第2个li</li>\n            <li>这是第3个li</li>\n            <li>这是第4个li</li>\n            <li>这是第5个li</li>\n            <li>这是第6个li</li>\n            <li>这是第7个li</li>\n            <li>这是第8个li</li>\n            <li>这是第9个li</li>\n        </ul>\n    </div>\n</body>\n</html>\nindex.js\nimport $ from 'jquery'\n\n// 实现隔行变色\n$(function (){\n    // 奇数行\n    $('li:odd').css('backgroundColor','red')\n    // 偶数行\n    $('li:even').css('backgroundColor','red')\n})\n 安装 jQuery，webpack\nnpm install jquery -S\nnpm install webpack\n// 开发时存在\nnpm install webpack-cli -D\n创建名为 webpack.config.js 的 webpack 配置文件\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n  output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  }\n};\n在 package.json 的 scripts 节点下，新增 dev 脚本如下  ## 添加插件（修改自动同步） 安装\nnpm install webpack-dev-server -D\n配置 出现 使用webpack插件webpack-dev-server 出现Cannot GET/的解决办法\n \ndevServer: {\n        static:'./', // webpack can not GET /\n    }\nwebpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n\n    output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  },\n    devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:false,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    }\n};\n\n\n在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ * css-loader 可以打包处理 .css 相关的文件 * less-loader 可以打包处理 .less 相关的文件 * babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 ### 安准css-loader：\nnpm i style-loader@2.0.0 css-loader@5.0.1 -D\n# less-loader\nnpm i less less-loader -D\n\n\n\nmodule: {// 设置loader规则,从后往前生效\n    rules: [\n        { test: /\\.css$/, use: ['style-loader','css-loader'] },\n        { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] },\n    ],\n  },\n ### 打包处理样式表中与 url 路径相关的文件\nnpm i url-loader file-loader -D\n\nwebpack.config.js\n// 体积小于limit: 8192就会转成base64\n{ test: /\\.(png|jpg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 8192}}]},\n\n\n\n就要用到bable-loader webpack-loader配置 # 打包发布\n\"build\": \"webpack --mode production\"\n\n\n\n开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致：  ### 完成整 webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst path = require('path');\n\n// 1. 导入插件，得到构造函数\nconst HtmlPlugin = require('html-webpack-plugin')\n// 2. 创建插件的实例对象\nconst htmlPlugin = new HtmlPlugin({\n  template: './src/index.html',\n  filename: './index.html',\n})\n\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst cleanPlugin = new CleanWebpackPlugin()\n\nmodule.exports = {\n  mode: 'development', // development  production\n  // eval-source-map 仅限在开发模式下使用\n   devtool: 'eval-source-map',\n  // 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map\n  // devtool: 'nosources-source-map',\n  // devtool: 'source-map',\n  // 指定打包的入口\n  entry: path.join(__dirname, './src/index.js'),\n  // 指定打包的出口\n  output: {\n    // 表示输出文件的存放路径\n    path: path.join(__dirname, './dist'),\n    // 表示输出文件的名称\n    filename: 'js/bundle.js',\n  },\n  plugins: [htmlPlugin, cleanPlugin], // 3. 挂载插件的实例对象\n  devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:true,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    },\n  module: {\n    rules: [\n      { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n      { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n      // { test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22228' }\n      {test: /\\.jpg|png|gif$/, use: {loader: 'url-loader', options: {limit: 22228,outputPath: 'image',},},},\n      {test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: ['@babel/plugin-proposal-class-properties'],\n          },\n        },\n      },//babel-loader\n    ],\n  },\n\n};"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "href": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "title": "stm32F103-RT-Thread–信号量(semaphare)",
    "section": "",
    "text": "信号量(semaphare)\n\n主要是量这个字, 表示这个信号有一定的量, 可以是0,也可是10,也可以是任意数字, 但是当他为0的时候就表示不可以使用了, 当为非零的时候可以使用,每使用一次即-1,释放的时候+1,为0就等待释放.\n\nstatic int count = 0;\n\nstatic rt_sem_t sem = RT_NULL;                          // semaphore control block\nstatic rt_thread_t sem_1_thread = RT_NULL;              // semaphore thread_1 control block\nstatic rt_thread_t sem_2_thread = RT_NULL;              // semaphore thread_2 control block\nstatic rt_thread_t sem_3_thread = RT_NULL;              // semaphore thread_2 control block\n\nstatic void sem_thread_1_entry(void *parmaeter);\nstatic void sem_thread_2_entry(void *parmaeter);\nstatic void sem_thread_3_entry(void *parmaeter);\n\nint main(void){\n\n    /* 这里的main简化了 */\n    sem = rt_sem_create(\"sem_count_per10_++\", 0,RT_IPC_FLAG_FIFO);\n    \n    sem_1_thread = rt_thread_create(\"sem_1_thread\", sem_thread_1_entry, RT_NULL, 512, 3, 20);\n    rt_thread_startup(sem_1_thread);\n    \n    \n    sem_2_thread = rt_thread_create(\"sem_2_thread\", sem_thread_2_entry, RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_2_thread);\n    \n    \n    sem_3_thread = rt_thread_create(\"sem_3_thread\", sem_thread_3_entry,RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_3_thread);\n    \n}\n\n\nstatic void sem_thread_1_entry(void *parameter){\n    while (1)   \n    {\n        if (count <= 100)\n        {\n            count++;\n        }\n        else\n            return;\n\n        if (0 == count % 10)\n        {\n            rt_kprintf(\"thread_1 is release the semaphore %d\\n\",count);\n            rt_sem_release(sem);    // release the semaphore\n        }\n        \n    }\n    \n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void sem_thread_2_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[2] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[2]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}\n\n\nstatic void sem_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[3] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[3]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "",
    "text": "lambda表达式 就是将函数式接口直接实现 普通的实现是先new一个类实现接口,然后再通过类.方法去调用实现的方法. lambda是直接省略了new一个类去实现接口中的方法. * lambda的实现过程 * 方法1-方法4逐渐简化. * 大体的实现原理就是不通过实体类实现接口中的方法 * 注意[接口中的方法只有一个–(函数式接口)]\n接口接收实体类和类接收实体类的区别 ## 最简单的实现"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#进阶",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#进阶",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "进阶",
    "text": "进阶\n记得导入JUnit\npackage cn.usts.edu.lesson05;\n\nimport org.junit.Test;\n\npublic class LambdaSelfTest {\n    \n    @Test //导入JUnit \n    // lambda 进阶测试2\n    public void test2(){\n        ITest iTest1 = (a) -> {\n            System.out.println(\"lambda 实现\"+a);\n        };\n\n        iTest1.test1(2);\n    }\n\n    @Test\n    // lambda 进阶测试3\n    public void test3(){\n        ITest iTest1 = (a) -> System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(3);\n    }\n\n    @Test\n    // lambda 进阶测试4\n    public void test4(){\n        ITest iTest1 = a -> System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(4);\n    }\n\n    @Test\n    // lambda 进阶测试4\n    public void test5(){\n        ITest iTest1 = a -> System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(4);\n    }\n}\n\n// 函数式接口\ninterface ITest{\n    void test1(int a);\n}"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#实现原理",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#实现原理",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "实现原理",
    "text": "实现原理\npackage cn.usts.edu.lesson05;\n\n/**\n * lambda的实现过程\n * 方法1-方法4逐渐简化.\n * 大体的实现原理就是不通过实体类实现接口中的方法\n * 注意[接口中的方法只有一个--(函数式接口)]\n * */\n\npublic class LambdaTest {\n\n    // 方法2---静态内部类\n    static class Like2  implements ILike{\n        @Override\n        public void lambda() {\n            System.out.println(\"实现ILike接口2\");\n        }\n    }\n\n    public static void main(String[] args) {\n        // 实现1\n        ILike like= new Like();// 这里用的接口对象去接受实现类的地址,  只能调用接口中实现的方法;\n        // Like like= new Like();// 用类对象接收new的对象的地址,可以用类类中的所方法\n        like.lambda();\n\n        // 实现2\n        like = new Like2();\n        like.lambda();\n\n        // 方法3 局部内部类  写在方法中\n        class Like3  implements ILike{\n            @Override\n            public void lambda() {\n                System.out.println(\"实现ILike接口3\");\n            }\n\n        }\n        // 实现3\n        like = new Like3();\n        like.lambda();\n\n        // 方法4[最终实现]\n        like = ()->{\n            System.out.println(\"lambda表达式实现ILike接口4\");\n        };\n        // 实现4 [最终实现]\n        like.lambda();\n\n    }\n}\n// 定义接口\ninterface ILike{\n    void lambda();\n}\n\n// 方法1  new一个类实现接口\nclass Like implements ILike{\n    @Override\n    public void lambda() {\n        System.out.println(\"实现ILike接口\");\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI-- 鼠标监听/index.html",
    "href": "posts/javaGUI-- 鼠标监听/index.html",
    "title": "javaGUI– 鼠标监听",
    "section": "",
    "text": "通过监听鼠标位置,实现点击画点 \npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n// 鼠标监听事件\npublic class TestMouseListener {\n    public static void main(String[] args) {\n        new MouseListenerFrame(\"鼠标监听\");\n    }\n\n}\n\nclass MouseListenerFrame extends Frame{\n    ArrayList points;// 设置一个集合用来存储目鼠标点击的位置\n\n    public MouseListenerFrame(String title){\n        super(title);\n        setBounds(100,100,800,800);\n        setVisible(true);\n\n        // 记录下的点位\n        points = new ArrayList<>();\n\n        // 鼠标监听\n        this.addMouseListener(new MyMouseListener());\n        // 窗口监听\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n\n    // 重写画笔方法\n    @Override\n    public void paint(Graphics g) {\n        // 画画,监听鼠标事件\n        Iterator iterator = points.iterator(); // 转可迭代对象\n        while (iterator.hasNext()){\n            Point point = (Point)iterator.next();\n            g.setColor(Color.orange); // 设置颜色\n            g.fillOval(point.x,point.y,10,10);// 获取点的位置,每个位置画出一个10*10的实心圆\n        }\n\n    }\n\n    // 添加一个点到界面上\n    public void addPoint(Point point){\n        points.add(point);\n    }\n\n    private class MyMouseListener extends MouseAdapter{\n        @Override\n        public void mousePressed(MouseEvent e) {\n            // 获取调用鼠标资源的对象\n             MouseListenerFrame mouseListenerFrame = (MouseListenerFrame) e.getSource();\n             // 添加点的位置\n             mouseListenerFrame.addPoint(new Point(e.getX(),e.getY()));\n             // 鼠标每点击一次就刷新一次\n             mouseListenerFrame.repaint();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java--创建Tomcat服务器/index.html",
    "href": "posts/java--创建Tomcat服务器/index.html",
    "title": "java–创建Tomcat服务器",
    "section": "",
    "text": "Tomcat7.0（蓝奏云） ## 2、选择安装位置解压缩 找个合适的位置 ## 3、运行Tomcat\n①windows双击apache-tomcat-7.0.73\\bin\\startup.bat文件 ②linux就打开apache-tomcat-7.0.73\\bin\\startup.sh文件"
  },
  {
    "objectID": "posts/java--创建Tomcat服务器/index.html#用浏览器访问",
    "href": "posts/java--创建Tomcat服务器/index.html#用浏览器访问",
    "title": "java–创建Tomcat服务器",
    "section": "4、用浏览器访问",
    "text": "4、用浏览器访问\nhttp://localhost:8080/ 出现以下页面即成功"
  },
  {
    "objectID": "posts/java EE 利用Referer简单实现防盗链功能/index.html",
    "href": "posts/java EE 利用Referer简单实现防盗链功能/index.html",
    "title": "java EE 利用Referer简单实现防盗链功能",
    "section": "",
    "text": "1、原理 通过判断请求url是否包含自家服务器的名称从而来判断是否由本家发起的请求。\n        // 获取Referer请求头\n        String referer  = request.getHeader(\"Referer\");\n        // 获取服务器名称 \n            String serverName = request.getServerName();\n        // 判断referer是否包含服务器名称\n            if(referer!=null && referer.contains(serverName)){\n                response.getWriter().write(\"downloading............\");\n            }\n            else{\n                // 不是从本网站发起的请求，把用户重定向到我们的网页\n                response.sendRedirect(\"/myProject/welcom.html\");\n            }"
  },
  {
    "objectID": "posts/java常用类-- System类的常用方法, Runtime类/index.html",
    "href": "posts/java常用类-- System类的常用方法, Runtime类/index.html",
    "title": "java常用类– System类的常用方法, Runtime类",
    "section": "",
    "text": "package cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n        // 获取当前系统属性\n        Properties properties = System.getProperties();\n        System.out.println(properties);\n        // 获取系统属性的所有key(属性名),返回set对象\n        Set<String> keys = properties.stringPropertyNames();\n        for (String key : keys) {\n            String value = System.getProperty(key);\n            System.out.println(key+\"--->\"+value);\n        }\n\n    }\n}\n ### System.currentTimeMillis() * System.gc();//内存回收 * System.exit(0);// 程序结束 * System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n *\n *               System.gc();//内存回收\n *               System.exit(0);// 程序结束\n *               System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n \n        System.out.println(\"------------------------------System.currentTimeMillis()-----------------------------------\");\n        long startTime = System.currentTimeMillis();\n\n        int sum=0;\n        for (int i = 0; i < 10000000; i++) {\n            sum+=i;\n        }\n\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"程序运行时间:\"+(endTime-startTime)+\"毫秒\");      \n    }\n}\n\n\n\n          用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n          每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n          应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n          Runtime run = Runtime.getRuntime();\n\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.io.IOException;\n\n/**\n * @author ：fly\n * @description: Runtime类\n *               用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n *               每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n *               应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n *               Runtime run = Runtime.getRuntime();\n *\n *\n * @date ：2021/10/31 15:25\n */\npublic class RuntimeDemo {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Runtime runtime = Runtime.getRuntime();\n        System.out.println(\"处理器个数\" + runtime.availableProcessors()+\"核\");\n        System.out.println(\"空闲内存大小\" + runtime.freeMemory()+\"byte\");\n        System.out.println(\"最大内存大小\" + runtime.maxMemory()+\"byte\");\n        Process process = runtime.exec(\"notepad.exe\");//相当于打开cmd执行命令\n        Thread.sleep(3000);\n        process.destroy();// 3s后进程销毁;\n\n    }\n}"
  },
  {
    "objectID": "posts/计算机组成原理/index.html",
    "href": "posts/计算机组成原理/index.html",
    "title": "计算机组成原理",
    "section": "",
    "text": "定点数\n\n纯小数 0.12, 0.98, 0.22……\n纯整数: 11, 2, 3, 4…\n\n\n\n浮点数\n\nN = 2^e.M\n\n\n\n原码： 便于人类计算，但是不利于计算机，进位和移位以及异号运算复杂 反码：转换为补码的过度 补码： 将减法转换为加法 移码： 补码符号位取反， 便于比较大小\n\n移码参考视频：https://www.bilibili.com/video/BV1dL4y1a7h2/?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb\n二进制转换计算器https://cn.calcuworld.com/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97%E5%99%A8\n\nieee754：\nbook p22 ->2.9\n\n\n奇偶校验\n奇校验： - 奇数个1：校验正确， 校验位填0 - 偶数个1：校验错误， 校验位填1\n偶校验： - 奇数个1：校验错误， 校验位填1 - 偶数个1：校验正确， 校验位填0\n\n奇偶校验参考视频：https://www.bilibili.com/video/BV1n5411m7QP/?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb\n\n定点加法\n\n\n补码加法\n\n补码相加等于原码相加, 最高位进位丢掉(符号位)\n\n\n\n补码减法\n\nx-y = x+(-y)\n\n\n\n溢出概念\n\n\n正溢\n两个正数相加后得到负数就是溢出了 例如：(第一位为符号位) ~01000 +01011 =10011(符号位为1即为负,所以不对)正溢 ## 负溢 两个负数相减也是类似相减后得到一个正数\n\n\n溢出的检测方法\n\n变形补码, 通过双符号位进行表示符号\n00 代替原先的0表示正数, 如果出现10表示正溢\n11代替原先的1表示负数, 如果出现01表示负溢\n\n\n\n全加器\n\n既然说到全加器, 那肯定得谈谈半加器\n个人理解的半加器, 就是不可以输入进位, 不可以串起来, 全加器可以实现N个加法器串联, 实现多位的运算\n\n\n >异或门: 相异 => 1 与非门: 1, 1 => 0\n\n\n\n在这里插入图片描述\n\n\n仿真:https://blog.csdn.net/qq_40272978/article/details/106229002 matlab 仿真参考: https://max.book118.com/html/2019/0531/6152154012002034.shtm"
  },
  {
    "objectID": "posts/Python--Threading/index.html",
    "href": "posts/Python--Threading/index.html",
    "title": "Python–Threading",
    "section": "",
    "text": "代码位置 # 传统的dos系统是一个单进程的程序 windows系统是一个并行的系统,曹勇的是到进程的编程模式, windows进程管理器可以查看进程 ## 在多核cup出现直线的设计方式: 时间片轮转算法,保证同时执行多个进程,但是在摸一个时间点上智能执行一个进程(利用这种方式很好的压榨cpu性能和资源) ## 进程的定义 进程是一个具有一定独立能力的程序关于摸个数据集合的一次运行活动 进程是系统进行资源分配和调度和运行的基本单位 进程实体中包含有三个组成部分: \"程序\",数据,pcb(进程控制块)  服务器的硬件性能是有限的,但是对于大部分程序来说都是属于过剩的状态,如果按照传统的单进程的模式来运行,会造成硬件资源的浪费 ## 解决资源过剩的方法 不同的计算机会有不同的配置,如果想要充分发挥出程序的性能,就要可以动态的获取当前可以运行的cpu的数量,于是就出现了可以通过多进程来实现数据和资源的获取\n\n\n# 导入多进程模块\nimport multiprocessing\n\n\nprint(\"当前可用cpu数:{}\".format(multiprocessing.cpu_count()))  # 当前可用cpu数:8\n\"\"\"\n    任何进程都包含有各自的数据,也就是说不同的进程之间的数据是不可以直接互相访问的,\n我们可以通过威其他的技术进行操作  example:管道\n    进程的创建到销毁都有 \"生命周期\" \n\"\"\"\n\n\n\n ### 创建状态 系统已经为程序分配好了pcb(可以获取进程的信息),但是需要执行的进程的上下文管理器(上下文环境)未分配,所以这个程序无法被调度(运行) ### 就绪状态 该进程已经分配到了出cpu之外的资源(上下文资源(就是调用关系,所属关系)),等待cpu调度 * 例1:桌椅–>教室 * 例2:教室–>学校\n\n\n进程一切就绪,一分配到了cpu资源,开始正常执行(执行进程) ### 阻塞状态 一个程序执行不能一直占用cpu(公共资源),根据资源调度的算法,每一个进程执行一段时间后都需要交出当前cpu的资源,给其他进程执行 ### 终止状态 某一个进程达到了自然终止的状态,或者进程强行停止,那么进程将进入到终止状态,,进程将不再被执行\n\n\n\n\n多进程可以提高程序运行效率,但是传统的的多进程模式只适合并发并不多的情况:成百上千的并发进程就不适合使用了, 会造成资源过多的消耗,导致资源不足的问题,从而降低了系统性能,所以要提高资源的利用率,以及进程的可复用性"
  },
  {
    "objectID": "posts/java多线程-- 死锁模拟( synchronized )/index.html",
    "href": "posts/java多线程-- 死锁模拟( synchronized )/index.html",
    "title": "java多线程– 死锁模拟( synchronized )",
    "section": "",
    "text": "化妆需要镜子,口红\n 两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n 就造成了死锁的问题\n程序一直处于等待状态 \n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型\n *      化妆需要镜子,口红\n *      两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n *      就造成了死锁的问题\n *\n * 解决方案:\n *      不能拿对方的锁\n *\n *\n * */\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        MakeUp makeUp1 = new MakeUp(0,\"白雪公主\");\n        MakeUp makeUp2 = new MakeUp(1,\"灰姑娘\");\n        new Thread(makeUp1).start();\n        new Thread(makeUp2).start();\n    }\n}\n\n// 口红\nclass Lipstick{\n\n}\n\n// 镜子\nclass Mirror{\n\n}\n\n// 化妆\nclass MakeUp implements Runnable {\n\n    // 资源只有一份,用static修饰\n    static final Lipstick lipstick = new Lipstick();\n    static final Mirror mirror = new Mirror();\n\n    int choice;\n    String name;\n\n    MakeUp(int choice,String name){\n        // choice = 0;先拿镜子,\n        // choice = 1;先拿口红\n        this.choice = choice;\n        this.name = name;\n    }\n\n    private void makeup() throws InterruptedException {\n        if (choice==0){\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红,上了锁,别人不许用,还想要镜子\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    System.out.println(name+\"拿到了镜子的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n\n        }else {\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,别人不许用,还想要口红\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    System.out.println(name+\"拿到了口红的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n        }\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 死锁模拟( synchronized )/index.html#解决方案",
    "href": "posts/java多线程-- 死锁模拟( synchronized )/index.html#解决方案",
    "title": "java多线程– 死锁模拟( synchronized )",
    "section": "解决方案",
    "text": "解决方案\n依次获取资源, 一个目标不能同时拿到两个把锁 \npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型\n *      化妆需要镜子,口红\n *      两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n *      就造成了死锁的问题\n *\n * 解决方案:\n *      不能拿对方的锁\n *\n *\n * */\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        MakeUp makeUp1 = new MakeUp(0,\"白雪公主\");\n        MakeUp makeUp2 = new MakeUp(1,\"灰姑娘\");\n        new Thread(makeUp1).start();\n        new Thread(makeUp2).start();\n    }\n}\n\n// 口红\nclass Lipstick{\n\n}\n\n// 镜子\nclass Mirror{\n\n}\n\n// 化妆\nclass MakeUp implements Runnable {\n\n    // 资源只有一份,用static修饰\n    static final Lipstick lipstick = new Lipstick();\n    static final Mirror mirror = new Mirror();\n\n    int choice;\n    String name;\n\n    MakeUp(int choice,String name){\n        // choice = 0;先拿镜子,\n        // choice = 1;先拿口红\n        this.choice = choice;\n        this.name = name;\n    }\n\n    private void makeup() throws InterruptedException {\n        if (choice==0){\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红,上了锁\");\n                Thread.sleep(5000);\n            }\n\n            System.out.println(name+\"口红使用完了,我还想用镜子\");\n\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,我口红和镜子都用完了.化完妆了\");\n            }\n        }\n        else {\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,还想要口红\");\n                Thread.sleep(7000);\n            }\n\n            System.out.println(name+\"镜子使用完了,我还想用口红\");\n\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红的锁,别人不许用,我口红和镜子都用完了,化完妆了\");\n            }\n        }\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/qt无法输出/index.html",
    "href": "posts/qt无法输出/index.html",
    "title": "qt无法输出",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/pyqt5 --03QObje对象的使用/index.html",
    "href": "posts/pyqt5 --03QObje对象的使用/index.html",
    "title": "pyqt5 –03QObje对象的使用",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject对象学习')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        obj = QObject()\n        obj.setObjectName('第一个objectname')\n        obj.setProperty('key', 'value')\n        obj.setProperty('key2', 'value2')\n        print(obj.property('key'))\n        print(obj.objectName())  # 设置属性+set,去掉set就是获取(get)\n        print(obj.dynamicPropertyNames())  # 获取所有已经设置的键值对\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Pycharm环境配置/index.html",
    "href": "posts/Pycharm环境配置/index.html",
    "title": "Pycharm环境配置",
    "section": "",
    "text": "一、打开设置 ①file–>settings  ②File | Settings | Project: ‘项目名’| Project Interpreter \n二、找到你的Python所在位置 ①第一种：创建项目专属新环境  ②找到python.exe所在位置  ①第二种：不使用新环境，使用旧的环境（这样搞容易出问题）  ③最后点ok，pycharm基本上就ok了。"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html",
    "href": "posts/webSocket -- 03 socket.io/index.html",
    "title": "webSocket – 03 socket.io",
    "section": "",
    "text": "为什么使用socket.io 1. 简单 2. 高效：连接池的管理比自己写的要高效（通常）"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html#测试",
    "href": "posts/webSocket -- 03 socket.io/index.html#测试",
    "title": "webSocket – 03 socket.io",
    "section": "测试：",
    "text": "测试：\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java注解和反射-- 元注解/index.html",
    "href": "posts/java注解和反射-- 元注解/index.html",
    "title": "java注解和反射– 元注解",
    "section": "",
    "text": "创建注解的注解\npackage cn.usts.edu.InnerAnnotation;\n\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解\n * 用于创建注解的注解\n * */\n\n@MyAnnotation\npublic class OriginAnnotation {\n    @MyAnnotation\n    public void test(){\n    }\n}\n\n// 定义一个注解\n//@Target(value = ElementType.METHOD) // 只能在方法上生效\n@Target(value = { ElementType.METHOD, ElementType.TYPE}) // 在方法和类上都生效\n@Retention(value = RetentionPolicy.RUNTIME)//表示我们的注解在什么地方还有效   通常自己写的都是runtime   runtime>class>sources\n@Documented() // 是否将我们的注解加入到javaDoc中\n@Inherited // 子类可继承父类的注解\n    \n@interface MyAnnotation{\n\n}"
  },
  {
    "objectID": "posts/java_Fastjson的使用/index.html",
    "href": "posts/java_Fastjson的使用/index.html",
    "title": "java_Fastjson的使用",
    "section": "",
    "text": "1·导入依赖\n<dependency>\n   <groupId>com.alibaba</groupId>\n   <artifactId>fastjson</artifactId>\n   <version>1.2.60</version>\n</dependency>\n2·创建FastJsonDemo.class\npackage cn.usts.deu.controller;\n\nimport cn.usts.deu.pojo.User1;\nimport com.alibaba.fastjson.JSON;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@RestController\npublic class FastJsonController {\n    @RequestMapping(\"/fast1\")\n    public void fastJson1(){\n        User1 user2 = new User1(\"tom2\",13,\"男\");\n        User1 user3 = new User1(\"tom3\",11,\"女\");\n        User1 user4 = new User1(\"tom4\",14,\"女\");\n        User1 user5 = new User1(\"tom5\",12,\"男\");\n        User1 user6 = new User1(\"tom6\",11,\"男\");\n        List<User1> list= new ArrayList<User1>();\n        list.add(user2);\n        list.add(user3);\n        list.add(user4);\n        list.add(user5);\n        list.add(user6);\n        // Java对象 转 JSON字符串\n        String lis1 = JSON.toJSONString(list);\n        System.out.println(lis1);\n        String user = JSON.toJSONString(user2);\n        System.out.println(user);\n\n        //json 字符串转java对象\n        User1 javaProject_user = JSON.parseObject(user,User1.class);\n        \n    }\n}"
  },
  {
    "objectID": "posts/smt32-f103寄存器点灯/index.html",
    "href": "posts/smt32-f103寄存器点灯/index.html",
    "title": "smt32-f103寄存器点灯",
    "section": "",
    "text": "STM32F103寄存器点灯\n通过寄存器中的状态来设置引脚状态 LED在GPIOB的第5引脚\n// RCC_ENR RCC must be first otherwise the LED can not be lighted\n    *(unsigned int*)0x40021018 |= (1<<3);\n    // port B   base address 0x4001 0c00\n\n    // output type is pull and push\n    *(unsigned int*)0x40010C00 |= ((1)<<(4*0));\n    //*(unsigned int*)0x40010C00 |= ((1)<<(8*0));\n    \n\n    // port B odr address is base address add 0x0c  \n    *(unsigned int*)0x40010C0C &= ~(1<<0);\n    //*(unsigned int*)0x40010C0C &= ~(1<<2);\n封装GPIO\n// REG mapping \n#define PERIPH_BASE                 ((unsigned int) 0x40000000)\n    \n#define APB1_PERIPH_BASE         PERIPH_BASE\n#define APB2_PERIPH_BASE        (PERIPH_BASE+0x10000)\n#define AHB_PERIPH_BASE         (PERIPH_BASE+0x20000)\n\n#define RCC_BASE                        (AHB_PERIPH_BASE+0x1000)\n#define GPIOB_BASE                      (APB2_PERIPH_BASE +0x0C00)\n\n#define RCC_APB2ENR                     *(unsigned int*)(RCC_BASE+0x18)\n    \n#define GPIOB_CRL                       *(unsigned int*)(GPIOB_BASE+0x00)\n#define GPIOB_CRH                       *(unsigned int*)(GPIOB_BASE+0x04)\n#define GPIOB_ODR                       *(unsigned int*)(GPIOB_BASE+0x0C)\n    \n#define GPIOB_BSRR                  *(unsigned int*)(GPIOB_BASE+0x10)\n#define GPIOB_BRR                       *(unsigned int*)(GPIOB_BASE+0x14)\n#define GPIOB_LOCK                      *(unsigned int*)(GPIOB_BASE+0x18)\n\ntypedef unsigned int        uint32_t;\ntypedef unsigned short  uint16_t; \n\ntypedef struct{\n    uint32_t CRL; \n    uint32_t CRH; \n    uint32_t IDL; \n    uint32_t ODR; \n    uint32_t BSRR; \n    uint32_t BRR; \n    uint32_t LCKR;  \n}GPIO_Struct; \n\n// change the GPIO type to GPIO_Struct then can use the REG like [GPIO_Struct->RCC] \n#define GPIOB ((GPIO_Struct*)GPIOB_BASE)\n\n    RCC_APB2ENR |= (1<<3);\n\n    GPIOB->CRL |= ((1)<<(4*0));\n    \n    // open LED set 0\n    //GPIOB->ODR &= ~(1<<0);\n    // off LED set 1\n    GPIOB->ODR |= (1<<0);\n简单封装\n    RCC_APB2ENR |= (1<<3);\n\n    GPIOB_CRL |= ((1)<<(4*0));\n    \n    // open LED set 0\n    GPIOB_ODR &= ~(1<<0);\n    // off LED set 1\n    //GPIOB_ODR |= (1<<0);"
  },
  {
    "objectID": "posts/stm32芯片开发包/index.html",
    "href": "posts/stm32芯片开发包/index.html",
    "title": "stm32芯片开发包",
    "section": "",
    "text": "stm32芯片开发包\nhttps://www.keil.com/dd2/pack/#!#eula-container\n\n\n固件库\nhttps://blog.csdn.net/cbkdgq/article/details/88076843   ## RCC - 218  ODR -269"
  },
  {
    "objectID": "posts/java注解和反射-- 所有类的Class类型/index.html",
    "href": "posts/java注解和反射-- 所有类的Class类型/index.html",
    "title": "java注解和反射– 所有类的Class类型",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.theClassOfAllClasses;\n\nimport java.lang.annotation.ElementType;\n\n/**\n * @author ：fly\n * @description: 所有类的Class类型\n * @date ：2021/10/27 16:26\n */\npublic class AllClasses {\n    public static void main(String[] args) {\n        Class c1 = Object.class;\n        Class c2 = Comparable.class;\n        Class c3 = String[].class;\n        Class c4 = int[][].class;\n        Class c5 = Override.class;\n        Class c6 = ElementType.class;\n        Class c7 = Integer.class;\n        Class c8 = void.class;\n        Class c9 = Class.class;\n\n        System.out.println(c1);\n        System.out.println(c2);\n        System.out.println(c3);\n        System.out.println(c4);\n        System.out.println(c5);\n        System.out.println(c6);\n        System.out.println(c7);\n        System.out.println(c8);\n        System.out.println(c9);\n\n        int[] a = new int[10];\n        int[] b = new int[100];\n        // 如果hashcode相同就说明他们是同一个class类\n        System.out.println(a.getClass().hashCode());\n        System.out.println(b.getClass().hashCode());\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- 包装类/index.html",
    "href": "posts/java常用类-- 包装类/index.html",
    "title": "java常用类– 包装类",
    "section": "",
    "text": "package cn.usts.edu.fly.packingClass;\n\n/**\n * @author ：fly\n * @description: 包装类:\n *                     java中有8大基本数据类型,但是没有属性和和方法,于是jdk出现了包装类\n *                     byte Byte   char Char   int Integer   short    Short\n *                     long Long   float  Float  double Double  boolean  Boolean\n *\n *                     自动装箱\n *                     基本类型  --->  包装类型\n *                     int      -->    Integer   自动装箱\n *\n *\n *                     自动拆箱\n *                     基本类型  <---  包装类型\n *                     int      <--    Integer   自动拆箱\n *\n *\n *                     valueOf:返回的是个包装类\n *                     parseInt：返回的就是基本数据类型\n * @date ：2021/10/31 16:15\n */\npublic class PackingDemo {\n    public static void main(String[] args) {\n        String a = \"123\";\n        int i = Integer.parseInt(a);// 把string类型转换为int类型\n        System.out.println(i+1);\n        int b = 456;\n        System.out.println(123+String.valueOf(b)+\"789\");// int转换为字符串\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "href": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "title": "stm32F103-RT-Thread线程同步(event)",
    "section": "",
    "text": "event是不同线程间满足条件时的控制块(比较适合多flag和多线程的情况) mutex访问单独的临界资源 semaphore访问多个临界资源 > 线程1接收event,查看其中的flag是否满足设置的条件 > 线程2发送flag1,flag2\n#include \"board.h\"\n#include \"rtthread.h\"\n\n#define FLAG3  1<<3\n#define FLAG5  1<<5\nstatic rt_event_t event1 = NULL;\nstatic rt_thread_t event_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t event_2_thread = RT_NULL;                // semaphore thread_2 control block\n\n\n\nstatic void event_thread_1_entry(void *parmaeter);\nstatic void event_thread_2_entry(void *parmaeter);\n\n\n\n\nint main(void)\n{\n    event1 = rt_event_create(\"flag\", RT_IPC_FLAG_FIFO);\n\n    event_1_thread = rt_thread_create(\"event_1_thread\", event_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (event_1_thread!= RT_NULL){\n        \n        rt_thread_startup(event_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    event_2_thread = rt_thread_create(\"metux_2_thread\", event_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (event_2_thread!= RT_NULL){\n        \n        rt_thread_startup(event_2_thread);\n    }\n    else{\n        return -1;\n    }\n}\n\n\n\n\n/* receive envet thread */\nstatic void event_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_uint32_t e;\n\n        // if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        // {\n        //  rt_kprintf(\"thread1: [AND] recv event 0x%x\\n\", &e);\n        // }\n        // rt_kprintf(\"thread1: delay 1s to prepare the second event\\n\");\n        // rt_thread_delay(1000);\n\n        if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        {\n            rt_kprintf(\"thread1: [OR] recv event 0x%x\\n\", &e);\n        }\n\n        rt_kprintf(\"thread1 leave.\\n\");\n    }\n}\n\n/* send event thread */\nstatic void event_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_kprintf(\"thread_2 is send event[3]\\n\");\n        rt_event_send(event1, FLAG3);\n        rt_thread_delay(500);\n\n        rt_kprintf(\"thread_2 is send event[5]\\n\");\n        rt_thread_delay(1800);\n        rt_event_send(event1, FLAG5);\n        rt_kprintf(\"thread2 leave.\\n\");\n        }\n}"
  },
  {
    "objectID": "posts/Linux-- 查看和修改文件所在组/index.html",
    "href": "posts/Linux-- 查看和修改文件所在组/index.html",
    "title": "Linux– 查看和修改文件所在组",
    "section": "",
    "text": "查看和修改文件所在组\nls -alh\n\n4 drwxr-xr-x   2 root root 4096 Nov 23 10:15 a\n修改所有者\nchown amdin a\n4 drwxr-xr-x   2 admin root 4096 Nov 23 10:15 a"
  },
  {
    "objectID": "posts/java多线程-- 网图多线程下载/index.html",
    "href": "posts/java多线程-- 网图多线程下载/index.html",
    "title": "java多线程– 网图多线程下载",
    "section": "",
    "text": "多线程同时下载多张图片\npackage cn.usts.edu.lesson01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 练习Thread\n * 实现多线程同时下载\n * */\npublic class ThreadImageDownload extends Thread{\n    String file;\n    String url;\n    String filename;\n\n    public ThreadImageDownload(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public void run() {\n        ImageDownload imageDownload = new ImageDownload();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n    }\n\n    public static void main(String[] args) {\n        ThreadImageDownload t1 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        ThreadImageDownload t2 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        ThreadImageDownload t3 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\nclass  ImageDownload{\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/springmvc-hellomvc-02/index.html",
    "href": "posts/springmvc-hellomvc-02/index.html",
    "title": "springmvc-hellomvc-02",
    "section": "",
    "text": "1、web.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!--1.注册DispatcherServlet-->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc-servlet.xml</param-value>\n        </init-param>\n        <!--启动级别-1-->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <!--/ 匹配所有的请求；（不包括.jsp）-->\n    <!--/* 匹配所有的请求；（包括.jsp）-->\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n2、springmvc-servlet.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n\n\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n\n\n<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n\n\n        <!--视图解析器:DispatcherServlet给他的ModelAndView-->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n<!--前缀-->\n<property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n<!--后缀-->\n<property name=\"suffix\" value=\".jsp\"/>\n</bean>\n\n<!--    handler-->\n    <bean id=\"/hello\" class=\"cn.usts.edu.controller.HelloController\" />\n</beans>\n3、HelloController.java\npackage cn.usts.edu.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class HelloController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        ModelAndView mav = new ModelAndView();\n        // 封装对象\n        mav.addObject(\"msg\",\"helloMVC\");\n        // 跳转的视图名\n        mav.setViewName(\"hello\"); // 拼接前后缀\n        return  mav;\n    }\n}"
  },
  {
    "objectID": "posts/pyqt5 --04QObje对象的父子关系使用/index.html",
    "href": "posts/pyqt5 --04QObje对象的父子关系使用/index.html",
    "title": "pyqt5 –04QObje对象的父子关系使用",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject父子对象学习')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        objA = QObject()\n        objA.setObjectName('A对象')\n\n        objB = QObject()\n        objB.setObjectName('B对象')\n\n        objC = QObject()\n        objC.setObjectName('C对象')\n\n        # B--->A\n        objB.setParent(objA)\n\n        # C--->B\n        objC.setParent(objB)\n        # objC.children(objA) # 设置子类\n        \n        print('B---->',objB.parent().objectName())\n        print('C---->',objC.parent().objectName())\n        print(objA.findChild(QObject))# A的【直接】QObject类型的子类是\n        print(objA.findChildren(QObject))# A的【所有】QObject类型的子类是\n        \n\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html",
    "href": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html",
    "title": "java注解和反射– 利用反射来 实例化对象,调用功能方法,设置属性",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.setClassMethod06;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 利用反射来  实例化对象,调用功能方法,设置属性\n *                 newInstance() 的本质是利用无参构造器,构造对象的,没有无参构造器,是无法构造的\n *                 参数用private修饰的要 修改程序安全监测为ture,默认false是开启检测\n * @date ：2021/10/28 15:51\n */\npublic class SetClass {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        // 获取Class对象\n        Class<?> c1 = Class.forName(\"cn.usts.edu.setClassMethod06.User\");\n        // 反射实例化对象 Object o = c1.newInstance();\n        User user = (User) c1.newInstance();//将Object对象转化成我们的User对象\n        System.out.println(user);\n\n        // 通过构造器构造\n        Constructor<?> declaredConstructor = c1.getDeclaredConstructor(int.class,String.class);\n        User user1 = (User) declaredConstructor.newInstance(15, \"小明\");\n        System.out.println(\"反射构造器构造\"+user1);\n\n        //通过反射调用方法\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        method03.setAccessible(true); //  参数用private修改的要 修改程序安全监测为ture,默认false是开启检测\n        method03.invoke(user1,\"利用反射调用方法\");//invoke激活, (操作对象,方法中的参数)\n\n        // 通过反射设置属性\n        Field name = c1.getDeclaredField(\"name\");\n        Field age = c1.getDeclaredField(\"age\");\n        age.setAccessible(true);\n        name.setAccessible(true); // 每修改一个就要设置一个\n        name.set(user1,\"反射直接修改属性的值\");\n        age.set(user1,18);\n        System.out.println(user1.getAge());\n        System.out.println(user1.getName());\n\n\n\n    }\n}\n\n// pojo 实体类\nclass User {\n    public int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "href": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "title": "stm32F103-RT-Thread邮箱(mailbox)",
    "section": "",
    "text": "在编码前先打开rtconfig.h中的mailbox选项. > 这个程序会创建2个动态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。 数据按照制定顺序进行发送,FIFO或者priority.\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nuint8_t count = 0;\n\n/* message */\nstatic char msg_1[] = \"hello\";\nstatic char msg_2[] = \"world.\";\nstatic char msg_3[] = \"@\";\n\n\n/* mail_box control block */\nstatic rt_mailbox_t mb_1 = RT_NULL;\n\n/* thread control blcok */\nstatic rt_thread_t mb_thread_1 = RT_NULL;\nstatic rt_thread_t mb_thread_2 = RT_NULL;\n\n/* thread_1 to send msg*/\nstatic void thread_1_entry(void *parameter)\n{\n    while (count < 10)\n    {\n        count++;\n        if (count & 0x1)\n        {\n            if(RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_1)){\n                // rt_kprintf(\"-----%x++++++++++%p\\n\",(rt_uint32_t)&msg_1,&msg_1); // -----20000029++++++++++20000029\n\n                rt_kprintf(\"msg_1_send successful!!!\\n\");\n            }\n            else{\n                rt_kprintf(\"msg_1_send failed!!!\\n\");\n            }\n        }\n        //\n        else\n        {\n            if (RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_2))\n            {\n                rt_kprintf(\"msg_2_send successful!!!\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"msg_2_send failed!!!\\n\");\n            }\n        }\n\n        // thread wait 200 ticks\n        rt_thread_delay(50);\n    }\n\n    // message send [finish]\n    rt_mb_send(mb_1, (rt_uint32_t)&msg_3);\n    rt_kprintf(\"END flag is send....\");\n}\n \n/* thread_2 to receive msg */\nstatic void thread_2_entry(void *parameter){\n    char *str;\n    while (1)\n    {\n        rt_kprintf(\"thread_[2]: try reveive msg.....\\n\");\n        \n        if (rt_mb_recv(mb_1, (rt_uint32_t *)&str, RT_WAITING_FOREVER) == RT_EOK)\n        {\n            rt_kprintf(\"[%d]msg:%s\\n\",count,str);\n            if(str==msg_3){\n                rt_kprintf(\"revc END ............\\n\");\n                break;\n            }\n            rt_thread_delay(100);\n        }\n        else{\n            rt_kprintf(\"2_recv msg faild.....\\n\");\n        }\n    }\n    rt_mb_detach(mb_1);\n    \n}\n\n\n\nint main(void){\n// 这里的1,是mb_size,控制mailbox可以同时发送几个邮件\n    mb_1 = rt_mb_create(\"mb_1\",1,RT_IPC_FLAG_FIFO);\n    \n    if(mb_1!=RT_NULL){\n        rt_kprintf(\"mail_box is create\\n\");\n    }\n    else{\n        rt_kprintf(\"mail_box is create failed.\\n\");\n        return -1;\n    }\n\n    // mb_thread_1 create\n    mb_thread_1 = rt_thread_create(\"mb_thread_1\",thread_1_entry,RT_NULL,512,3,20);\n    if(mb_thread_1!=RT_NULL){\n        rt_thread_startup(mb_thread_1);\n    }   \n    // mb_thread_2 create\n    mb_thread_2 = rt_thread_create(\"mb_thread_2\", thread_2_entry, RT_NULL, 512, 3, 20);\n    if (mb_thread_2 != RT_NULL)\n    {\n        rt_thread_startup(mb_thread_2);\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/内存管理/index.html",
    "href": "posts/内存管理/index.html",
    "title": "内存管理",
    "section": "",
    "text": "一个编译完成的程序包含很多段 .text [ 代码段 ] .data [ 数据段 ] .bss [ 未初始化数据段 ]\n全局变量和static修饰的变量是在编译的时候分配空间的"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html",
    "href": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html",
    "title": "java注解和反射– 利用反射获取类的运行时结构(属性,方法,对象,构造器)",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.getClassMethod05;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 获取类的运行时结构(属性,方法,对象,构造器)\n *               方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n * @date ：2021/10/28 14:26\n */\npublic class GetClassMethod {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class<?> c1 = Class.forName(\"cn.usts.edu.getClassMethod05.User\");\n\n        // 获取报名+类名\n        System.out.println(c1.getName());\n        // 获取类的名字\n        System.out.println(c1.getSimpleName());\n\n        // 获取类的属性:\n        Field[] fields = c1.getFields();// 只能获取到public修饰的属性\n        // 遍历\n        for (Field field : fields) {\n            System.out.println(field);\n        }\n\n        // 获取指定属性的值\n        Field name = c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(\"=================\");\n        Method[] methods = c1.getMethods();// 获取包括父类的所有方法\n        for (Method method : methods) {\n            System.out.println(\"包括父类的\"+method);\n        }\n\n        Method[] declaredMethods = c1.getDeclaredMethods();// 获取当前类的方法\n        for (Method declaredMethod : declaredMethods) {\n            System.out.println(\"当前类的\"+declaredMethod);\n        }\n\n        // 获取指定方法\n        System.out.println(\"============获取指定方法=========\");\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        System.out.println(method03);\n        Method method01_int = c1.getDeclaredMethod(\"method01\", int.class);\n        System.out.println(method01_int);\n        // Method method01 = c1.getDeclaredMethod(\"method01\", null); ide 推荐null不写\n        Method method01 = c1.getDeclaredMethod(\"method01\");\n        System.out.println(method01);\n\n        // 获取构造器\n        System.out.println(\"============获取构造器=========\");\n        Constructor<?>[] constructors = c1.getConstructors();\n        System.out.println(\"所有构造器\");\n        for (Constructor<?> constructor : constructors) {\n            System.out.println(constructor);\n        }\n\n        // 获取指定构造器,因为方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n        Constructor<?> declaredConstructor = c1.getDeclaredConstructor(int.class, String.class);\n        System.out.println(\"指定构造器\");\n        System.out.println(declaredConstructor);\n    }\n}\n\n\n// pojo 实体类\nclass User {\n    public int age;\n    public String name;\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/vmware镜像站/index.html",
    "href": "posts/vmware镜像站/index.html",
    "title": "vmware镜像站",
    "section": "",
    "text": "https://softwareupdate.vmware.com/cds/vmw-desktop/ws/"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "href": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "title": "stm32F103-RT-Thread动态内存分配",
    "section": "",
    "text": "打开动态内存分配\n # 设置线程句柄\n/* 定义线程控制块 */\nstatic rt_thread_t led1_thread = RT_NULL;\n\n\n设置线程入口函数\n// 声明\nstatic void led1_thread_entry(void *parameter);\n// 实现\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\n\n设置动态内存分配并启动\n// 设置线程参数\nled1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n/* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\nmain.c\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n    }\n}\n\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include <rthw.h>\n#include <rtthread.h>\n\n\n\n\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n   \n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}"
  },
  {
    "objectID": "posts/TI_icboost+IWR6843/index.html",
    "href": "posts/TI_icboost+IWR6843/index.html",
    "title": "TI_icboost+IWR6843",
    "section": "",
    "text": "概要\nti毫米波雷达开发过程，环境搭建\n参考:https://blog.csdn.net/Tronlong_/article/details/108147255\n\n\n硬件链接\n\n对应的拨码开关以及条线配置如图\n\n\n\n\n在这里插入图片描述\n\n\n\n\nccs配置\n >## 搜索对应的开发板的项目\n > ## 分别导入项目 > - mss 和 dss\n >## 编译dss项目\n >## 编译mss项目 同样的方法编译mss  > ### 如果遇到not find xxx, 请添加对应的sdk和依赖, 若果sdk安装位置不在默认的C:TI_PRODUCT的路径 \n\ndebug\n请参考:ccs脚本自动调试"
  },
  {
    "objectID": "posts/javaGUI--Swing[JFrame]/index.html",
    "href": "posts/javaGUI--Swing[JFrame]/index.html",
    "title": "javaGUI–Swing[JFrame]",
    "section": "",
    "text": "注意JFrame中的容器\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JFrameDemo02 {\n    public static void main(String[] args) {\n        new TestJFrameDemo02().init();\n    }\n}\n\n\nclass TestJFrameDemo02 extends JFrame{\n    public void init(){\n        this.setBounds(100,100,400,300);\n        this.setVisible(true);\n        this.setTitle(\"hello\");\n        JLabel label = new JLabel(\"这是我的第二个JFrame程序\");\n        label.setHorizontalAlignment(SwingConstants.CENTER);// 水平对准\n\n        this.add(label);    // 添加组件\n\n        Container container = this.getContentPane();// 获取(内容面板)当前容器 有点awt中的getSource的味道\n        container.setBackground(Color.orange);//设置背景色\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);// 关闭按钮\n    }\n\n\n}"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "",
    "text": "这里以test2.sh为例\nvim test2.sh"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "2、主体程序",
    "text": "2、主体程序\n#!/bin/bash\n#filename:test_2\n\n# 设置文件存储路径\npath=./space/\n\n# 判断路径是否存在\nif [ -d $path ]\nthen\n        echo $path\nelse\n        mkdir $path\nfi\n\n# 程序主体\ni=1\nwhile(($i<=9))\n\n# 程序主体循环\ndo\n        # 文件名格式\n        number=$[ \"183500110\"$i\"\" ]\n        filename=$number\n        #mkdir $path/$filename\n        let \"i++\"\ndone\n\n# 避免0不占位置导致的格式不对齐\nwhile(($i<=20))\ndo\n        number=$[ \"18350011\"$i\"\" ]\n        filename=$number\n        mkdir $path/$filename\n        let \"i++\"\ndone"
  },
  {
    "objectID": "posts/java多线程-- thread.setPriority() 线程优先级/index.html",
    "href": "posts/java多线程-- thread.setPriority() 线程优先级/index.html",
    "title": "java多线程– thread.setPriority() 线程优先级",
    "section": "",
    "text": "不设置优先级,默认为 5\n\n先设置,在启动!!!!\n优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 线程优先级\n * 不设置优先级,默认为 5   \n * 先设置,在启动!!!!\n * \n * 优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n * */\npublic class ThreadPriorityDemo implements Runnable{\n    @Override\n    public void run() {\n        // 打印       线程名----线程优先级\n        System.out.println(Thread.currentThread().getName()+\"-----\"+Thread.currentThread().getPriority());\n\n    }\n\n    // 主线程\n    public static void main(String[] args) {\n        ThreadPriorityDemo threadPriorityDemo = new ThreadPriorityDemo();\n        Thread t1 = new Thread(threadPriorityDemo,\"A\");\n        Thread t2 = new Thread(threadPriorityDemo,\"B\");\n        Thread t3 = new Thread(threadPriorityDemo,\"C\");\n        Thread t4 = new Thread(threadPriorityDemo,\"D\");\n        Thread t5 = new Thread(threadPriorityDemo,\"E\");\n        Thread t6 = new Thread(threadPriorityDemo,\"F\");\n        Thread t7 = new Thread(threadPriorityDemo,\"G\");\n\n        t1.start();//不设置优先级,默认为 5   先设置,在启动!!!!\n\n        t2.setPriority(2);\n        t2.start();\n\n        t3.setPriority(3);\n        t3.start();\n\n        t4.setPriority(4);\n        t4.start();\n\n        t5.setPriority(5);\n        t5.start();\n\n        t6.setPriority(6);\n        t6.start();\n\n        t7.setPriority(Thread.MAX_PRIORITY); // MAX_PRIORITY=10\n        t7.start();\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/quarto/index.html",
    "href": "posts/quarto/index.html",
    "title": "quarto",
    "section": "",
    "text": "picgo（图床）\n    // picogo config\n    \"picgo.picBed.current\": \"github\",\n    \"picgo.picBed.github.token\": \"gxxxxxxxx\",\n    \"picgo.picBed.github.repo\": \"fly-t/blog\",\n    \"picgo.picBed.github.branch\": \"master\",\n    \"picgo.customUploadName\": \"${mdFileName}-${dateTime}${extName}\",\n    \"picgo.picBed.github.path\": \"images/\",\n    \"picgo.customOutputFormat\": \"![](${url})\",\n\n\ngithu连接问题\ngithub push不支持账号密码，使用token\n[core]\n    repositoryformatversion = 0\n    filemode = false\n    bare = false\n    logallrefupdates = true\n    ignorecase = true\n[remote \"origin\"]\n    url = https://ellisonpei:这里填access_token@github.com/项目名/项目名.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\n    remote = origin\n    merge = refs/heads/master\n[user]\n    name = aa5279aa\n    email = xxxx@qq.com\n[branch \"develop\"]\n    remote = origin\n    merge = refs/heads/develop\n[credential]\n    helper =\n\n\n这里没有反应， 关掉代理重新尝试\nquarto publish gh-pages\n\n\ngithub action 自动部署\n_quarto.yml\nexecute: \n  freeze: auto\n创建该目录并创建文件\n// 项目根目录\nmkdir .github/workflows\ncd \ntouch .github/workflows/publish.yml\n.github/workflows/publish.yml\non:\n  workflow_dispatch:\n  push:\n    branches: main\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v2\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n git config --global credential.helper store                              \n vim .gitconfig\n// close\ngit config --system --unset credential.helper\n\ngit config --global http.proxy 'http://127.0.0.1:7890'\ngit config --global https.proxy 'http://127.0.0.1:7890'\n修改上传快捷键 \n\n\n参考\n设置github push https://www.jianshu.com/p/3b4f7619999e 显示。git：https://blog.csdn.net/Mrs_chens/article/details/101191893\nQuarto 官方部署流程：https://quarto.org/docs/publishing/github-pages.html GitHub Pages: https://docs.github.com/cn/pages GitHub Actions: https://docs.github.com/cn/actions workflows 字段介绍：https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions"
  },
  {
    "objectID": "posts/java_jdk安装，配置环境（win10）/index.html",
    "href": "posts/java_jdk安装，配置环境（win10）/index.html",
    "title": "java_jdk安装，配置环境（win10）",
    "section": "",
    "text": "1.打开jdk下载官网地址  2.向下翻找到自己需要的版本   3.登陆才可以下载\n找到个免费的下载账号，短期内应该可用，（从csdn中找到的，如有侵权，联系删除）\n账号：1789936303@qq.com\n密码：Oracle123456\n 4.找到下载好的jdk安装包双击安装 推荐默认安装在固态盘，一直下一步，傻瓜安装（默认安装路径C:\\Program Files\\Java）\n 5.自此jdk安装完成，配置jdk环境\n①右键我的电脑—–>属性——->高级设置\n ②点击环境变量\n\n\n\n在这里插入图片描述\n\n\n③点击新建\n ④设置变量名和变量值\n ⑤上一步确定完，在下办框（系统变量）中找到path———–>双击\n\n\n\n在这里插入图片描述\n\n\n⑥新建——->粘贴\n%JAVA_HOME%\\bin\n ⑦创建classpath变量 变量值从点【.】号开始复制\n变量名：  classpath\n变量值：    .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n ⑧判断是否安装成功 win+r------->cmd------>java win+r------->cmd------>javac 出现以下界面为成功"
  },
  {
    "objectID": "posts/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "href": "posts/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "title": "TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析",
    "section": "",
    "text": "EDMA的数据数据搬移，这部分比较重要，对于能否清楚数据排列很关键\n\n\n\n\nACount: Array(每个切分数据)的大小\nBCount: 一共有N个Array\nCCount: N个BCount\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nsrcBidx: 源数据块的读取偏移(上面的一个array的大小), 即读取每个array偏移的大小\ndstBidx: 目的地址偏移(如果为0 表示不偏移, 最大支持0xffffH的偏移)\n下图表示的是ab同步传输模式, 在vitalsign中使用的是a同步传输\n\n\n\n\n\n在这里插入图片描述\n\n\n/**\n * EDMA_Handle handle,\n    uint8_t *srcBuff,              ADCdataBuf\n    uint8_t *dstBuff,              adcDataIn\n    uint8_t chId,                   PONG\n    bool isEventTriggered,          false\n    uint16_t shadowParamId,\n    uint16_t aCount,                100*(16*2)\n    uint16_t bCount,                Rx*numChirp\n    int16_t srcBIdx,                \n    int16_t dstBIdx,                0\n    uint8_t eventQueueId,\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg\n * */\n\n\nEDMAutil_configType1(\n    context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n    (uint8_t *)(&obj->ADCdataBuf[obj->numAdcSamples * obj->numChirpsPerChirpEvent]),\n    (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->adcDataIn[obj->numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n    MMW_EDMA_CH_1D_IN_PONG,\n    false, // 如果要在配置后启用通道，则设置为 true，否则设置为 false。\n    shadowParam++,\n    obj->numAdcSamples * BYTES_PER_SAMP_1D,\n    MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,\n    (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent,\n    0,\n    eventQueue,\n    NULL,\n    (uintptr_t) obj);\n\n\n\n通道控制器(EDMA_TPCC0_REQ_FREE_0这里vitalsign使用的是通道控制器0)\ncc0 有 2个 TC(传输控制器)\ncc1 有 1个 TC(传输控制器)\n传输控制器\n\n\nvitalSign中的EDMA配置\n/*EDMA instance used*/\n#define MMW_DATA_PATH_EDMA_INSTANCE      EDMA_INSTANCE_0\n                                         \n/* channels */                           \n#define MMW_EDMA_CH_1D_IN_PING           EDMA_TPCC0_REQ_FREE_0\n#define MMW_EDMA_CH_1D_IN_PONG           EDMA_TPCC0_REQ_FREE_1\n#define MMW_EDMA_CH_1D_OUT_PING          EDMA_TPCC0_REQ_FREE_2\n#define MMW_EDMA_CH_1D_OUT_PONG          EDMA_TPCC0_REQ_FREE_3\n#define MMW_EDMA_CH_2D_IN_PING           EDMA_TPCC0_REQ_FREE_4\n#define MMW_EDMA_CH_2D_IN_PONG           EDMA_TPCC0_REQ_FREE_5\n#define MMW_EDMA_CH_DET_MATRIX           EDMA_TPCC0_REQ_FREE_6\n#define MMW_EDMA_CH_DET_MATRIX2          EDMA_TPCC0_REQ_FREE_7\n#define MMW_EDMA_CH_3D_IN_PING           EDMA_TPCC0_REQ_FREE_8\n#define MMW_EDMA_CH_3D_IN_PONG           EDMA_TPCC0_REQ_FREE_9\n#define MMW_EDMA_CH_SIGIMG_MON           EDMA_TPCC0_REQ_FREE_10\n#define MMW_EDMA_CH_RX_SATURATION_MON    EDMA_TPCC0_REQ_FREE_11\n\n/*shadow*/\n// #define EDMA_NUM_DMA_CHANNELS (64U)\n#define MMW_EDMA_CH_1D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 0U)    \n#define MMW_EDMA_CH_1D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 1U)\n#define MMW_EDMA_CH_1D_OUT_PING_SHADOW          (EDMA_NUM_DMA_CHANNELS + 2U)\n#define MMW_EDMA_CH_1D_OUT_PONG_SHADOW          (EDMA_NUM_DMA_CHANNELS + 3U)\n#define MMW_EDMA_CH_2D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 4U)\n#define MMW_EDMA_CH_2D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 5U)\n#define MMW_EDMA_CH_DET_MATRIX_SHADOW           (EDMA_NUM_DMA_CHANNELS + 6U)\n#define MMW_EDMA_CH_DET_MATRIX2_SHADOW          (EDMA_NUM_DMA_CHANNELS + 7U)\n#define MMW_EDMA_CH_3D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 8U)\n#define MMW_EDMA_CH_3D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 9U)\n >## DMA触发方式 >- 手动触发(ESR) >- 链接触发(Link) [vitalsign使用的方式] > 用一个edma的传输结束来出发另外一个edma >- 事件触发(EER)\n这里vitalSign使用的是cc0, 所以查看cc0支持的事件表  下面的32个通道对应上面的32个事件(event), 如果我们想要通过UART0 Receice 来出发EDMA传输, 就需要配置到通道8, 这就是事件触发方式 \n\n\n每个EDMA事件对应一个paRAM, 每个paRAM存储一个EDMA配置, 每个paRAM包括8个字\n\n这里的参数对应EDMAutil_configType1里面的代码\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg)\n{\n    EDMA_channelConfig_t config;\n    int32_t errorCode = EDMA_NO_ERROR;\n\n    config.channelId = chId;\n    config.channelType = (uint8_t)EDMA3_CHANNEL_TYPE_DMA;\n    config.paramId = chId;\n    config.eventQueueId = eventQueueId;\n\n    config.paramSetConfig.sourceAddress = (uint32_t) srcBuff;\n    config.paramSetConfig.destinationAddress = (uint32_t) dstBuff;\n\n    config.paramSetConfig.aCount = aCount;\n    config.paramSetConfig.bCount = bCount;\n    config.paramSetConfig.cCount = 1U;                      // 数据只有一行\n    config.paramSetConfig.bCountReload = 0U;\n\n    config.paramSetConfig.sourceBindex = srcBIdx;\n    config.paramSetConfig.destinationBindex = dstBIdx;\n\n    config.paramSetConfig.sourceCindex = 0U;            \n    config.paramSetConfig.destinationCindex = 0U;\n\n    config.paramSetConfig.linkAddress = EDMA_NULL_LINK_ADDRESS;\n    config.paramSetConfig.transferType = (uint8_t)EDMA3_SYNC_A;     // 传输模式A同步传输模式(Array*B)\n    config.paramSetConfig.transferCompletionCode = chId;\n    config.paramSetConfig.sourceAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n    config.paramSetConfig.destinationAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n\n    /* don't care because of linear addressing modes above */\n    config.paramSetConfig.fifoWidth = (uint8_t) EDMA3_FIFO_WIDTH_8BIT;\n\n    config.paramSetConfig.isStaticSet = false;\n    config.paramSetConfig.isEarlyCompletion = false;\n    config.paramSetConfig.isFinalTransferInterruptEnabled = true;\n    config.paramSetConfig.isIntermediateTransferInterruptEnabled = true;\n    config.paramSetConfig.isFinalChainingEnabled = false;\n    config.paramSetConfig.isIntermediateChainingEnabled = false;\n    config.transferCompletionCallbackFxn = transferCompletionCallbackFxn;\n    config.transferCompletionCallbackFxnArg = transferCompletionCallbackFxnArg;\n\n    if ((errorCode = EDMA_configChannel(handle, &config, isEventTriggered)) != EDMA_NO_ERROR)\n    {\n        System_printf(\"Error: EDMA_configChannel() failed with error code = %d\\n\", errorCode);\n        goto exit;\n    }\n\n    errorCode = EDMA_setup_shadow_link(handle, chId, shadowParamId,\n        &config.paramSetConfig, config.transferCompletionCallbackFxn, transferCompletionCallbackFxnArg);\n\nexit:\n    return(errorCode);\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n链接触发\n自动触发\n没有用到所有没写\n\n\n\n\n\n主要针对dma对数据的搬移\n\n\n >### EDMA配置 > - 上图处理过程主要用到4 个EDMA > - 1D_IN_Ping , 1D_IN_Pong, 1D_OUT_Ping, 1D_OUT_Pong\n\n\n\n这个edma主要的工作时将AdcDataBuf中的数据搬移到adcDataIn中\n这里的chrip1, chirp2 …表示的是一frame内的chirp序号, 不是所有的chirp, 每次++\nchirp1 和 chirp2 的到达时间肯定是不同的, chirp2在chirp1之后, 所以edma_1d_in_ping同一时间搬移到adcDataIn里面的数据是 chrip 1 Rx 1 chrip 1 Rx 2,\nbcount=4 表示一共传输4次\n将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong , 为后面的加窗 和fft操作组成流水线做准备\nshadow表示链接触发, shadow使用和1d_in_ping的一样的配置参数, 也发送4次,刚好将数据发送完\n这的ping(adcDataBuf)pong(adcDataBuf)表示的是一帧内的chirp, 每个buff中放两个chirp, 如果大于2chrip会组成pingpong\n\n\n > 将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong > \n\n\n\n后续使用该api请参考这里\n\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n)\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj->ADCdataBuf[0]), \n        (uint8_t *)(SOC_translateAddress((uint32_t)&obj->adcDataIn[0],SOC_TranslateAddr_Dir_TO_EDMA,NULL)), \n        MMW_EDMA_CH_1D_IN_PING,\n        false,\n        shadowParam++,\n        obj->numAdcSamples * BYTES_PER_SAMP_1D,// acount\n        MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,// bcount\n        (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent, // srcbidx\n        0,                                                                         // dstbidx\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这个edma和1d_in_ping类似\n参考上面描述\n\n\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nEDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj->ADCdataBuf[obj->numAdcSamples * obj->numChirpsPerChirpEvent]),\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->adcDataIn[obj->numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        MMW_EDMA_CH_1D_IN_PONG,\n        false,\n        shadowParam++,\n        obj->numAdcSamples * BYTES_PER_SAMP_1D,\n        MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,\n        (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent,\n        0,\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这里的ping pong 表示按照发射天线进行区分, 将前面的Ping(adcDataBuf) 或者Pong(adcDataBuf) 单个Buffer中的接收数据进行全部分组, 按照发射天线进行分组\n后将数据搬移到RadarCube中\nCube中只有一帧的数据,并按照天线的奇偶进行拆分排列\n该EDMA中的配置的搬移到Cube中的数据按照配置生成, dataPathObj->numRangeBins        = MmwDemo_pow2roundup(dataPathObj->numAdcSamples); 按照满足的二次幂来设置, numAdcSamples = 100, 那么此时的numRangeBins=128, 如果numAdcSamples=64则numRangeBins=64, 所以这里的EDMA配置根据该参数自动调整\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->fftOut1D[0]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        (uint8_t *)(&obj->radarCube[0]),\n        MMW_EDMA_CH_1D_OUT_PING,\n        false,\n        shadowParam++,\n        aCount,   // 128*Rx*complex\n        obj->numChirpsPerFrame / 2, //bCount  4/2\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n对应参照 1D_OUT_Ping\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->fftOut1D[numPingOrPongSamples]),// numPingOrPongSamples:  128*Rx\n                                         SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        oneD_destinationPongAddress, // 128*4*1\n        MMW_EDMA_CH_1D_OUT_PONG,\n        false,\n        shadowParam++,\n        aCount,\n        obj->numChirpsPerFrame / 2, //bCount\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);"
  },
  {
    "objectID": "posts/java网络编程-- udp通信/index.html",
    "href": "posts/java网络编程-- udp通信/index.html",
    "title": "java网络编程– udp通信",
    "section": "",
    "text": "客户端发送\npackage cn.usts.edu.lesson04;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpClientDemo01 {\n    public static void main(String[] args) throws Exception{\n        // 建立socket连接\n        DatagramSocket socket = new DatagramSocket();\n        // 建立一个数据包\n        String msg = \"hello udp application\";\n        int port=9999;\n        InetAddress IP = InetAddress.getByName(\"127.0.0.1\");\n        // 字节数据,字节数据长度,目的ip,目的端口\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(),msg.getBytes().length,IP,port);\n        // 发送\n        socket.send(datagramPacket);\n        // 关闭\n        socket.close();\n    }\n\n}\n服务端接收\npackage cn.usts.edu.lesson04;\n\n\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UdpServerDemo01 {\n    public static void main(String[] args) throws Exception {\n        // 发放端口\n        DatagramSocket socket = new DatagramSocket(9999);\n        // 接收数据\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n        // 接收\n        socket.receive(packet);\n        // 输出\n        System.out.println(new String(packet.getData(), 0, packet.getLength()));\n        // 关闭\n        socket.close();\n\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- Math和Random/index.html",
    "href": "posts/java常用类-- Math和Random/index.html",
    "title": "java常用类– Math和Random",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.MathAndRondom;\n\n/**\n * @author ：fly\n * @description: Math类常用方法\n * @date ：2021/10/31 15:52\n */\npublic class MathDemo {\n    public static void main(String[] args) {\n        System.out.println(Math.abs(-12));\n        System.out.println(Math.sin(45));//sin cos tan ....\n        System.out.println(Math.pow(2,3));// 2^3\n        System.out.println(Math.ceil(2.6));//向下取整 最小\n        System.out.println(Math.floor(3.2));//向上取整 最大\n        System.out.println(Math.round(3.5));//四舍五入\n        System.out.println(Math.max(1.1,22.2));//最大值\n        System.out.println(Math.min(1.1,22.2));//最小值\n        System.out.println(Math.random());// 随机0-1\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- Math和Random/index.html#random类的常用方法",
    "href": "posts/java常用类-- Math和Random/index.html#random类的常用方法",
    "title": "java常用类– Math和Random",
    "section": "Random类的常用方法",
    "text": "Random类的常用方法\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.MathAndRondom;\n\nimport java.util.Random;\n\n/**\n * @author ：fly\n * @description: Random类的常用方法\n * @date ：2021/10/31 16:04\n */\npublic class RandomDemo {\n    public static void main(String[] args) {\n        Random random = new Random();\n        System.out.println(\"随机的布尔值:\"+random.nextBoolean());\n        System.out.println(\"随机的布尔值:\"+random.nextDouble());\n        System.out.println(\"随机的Float:\"+random.nextFloat());\n        System.out.println(\"随机的Int():\"+random.nextInt());\n        System.out.println(\"随机的0-10 int:\"+random.nextInt(10));\n        System.out.println(\"随机的Long值:\"+random.nextLong());\n        \n\n\n    }\n}"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html",
    "href": "posts/shell编程的简单实现/index.html",
    "title": "shell编程的简单实现",
    "section": "",
    "text": "这里以 bashscript.sh 为例\nvim bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "href": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "title": "shell编程的简单实现",
    "section": "2、在文件中编写简单的输出指令",
    "text": "2、在文件中编写简单的输出指令\n#！ /bin/bash                           // 脚本解释器程序路径\n#filename:bashscript                       // 注释\necho  “这是一个bash脚本程序。”                   // 输出指令\necho “---------------------------------------“"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#给文件赋权",
    "href": "posts/shell编程的简单实现/index.html#给文件赋权",
    "title": "shell编程的简单实现",
    "section": "3、给文件赋权",
    "text": "3、给文件赋权\nchmod u+x bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "href": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "title": "shell编程的简单实现",
    "section": "4、运行.sh文件",
    "text": "4、运行.sh文件\n执行程序bashscript.sh\n./bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行结果",
    "href": "posts/shell编程的简单实现/index.html#运行结果",
    "title": "shell编程的简单实现",
    "section": "99、运行结果",
    "text": "99、运行结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java- 贪吃蛇/index.html",
    "href": "posts/java- 贪吃蛇/index.html",
    "title": "java- 贪吃蛇",
    "section": "",
    "text": "贪吃蛇小游戏\n\n效果截图\n\n\n\n在这里插入图片描述\n\n\n\n\n过程中遇到的问题\n1、frame.setVisible(true);// 一定要放最后!!!!!!! 否则会在程序运行时出现灰色界面，需要动一下框才行。 2、食物的随机刷新就会导致食物随机刷新会刷新到蛇的身体上【还未解决】 3、maven项目的静态资源加载问题，无法让文件加载到classes文件夹中。需要修改pom.xml文件\n<!--所有文件复制到classes下-->\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <excludes>\n                    <exclude>**/*.java</exclude>\n                </excludes>\n            </resource>\n        </resources>\n    </build>\n项目上传在码云上: 项目地址"
  },
  {
    "objectID": "posts/javaGUI--文本框JTextField_密码框JPasswordField()_文本域 JTextArea/index.html",
    "href": "posts/javaGUI--文本框JTextField_密码框JPasswordField()_文本域 JTextArea/index.html",
    "title": "javaGUI–文本框JTextField_密码框JPasswordField()_文本域 JTextArea",
    "section": "",
    "text": "文本框,密码框,文本域 panel.add(scrollPane);// 加上文本域就会让之前的鼠标悬停显示没了,不知道是什么问题\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JComboBoxDemo03 extends JFrame {\n    public JComboBoxDemo03() {\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 文本框\n        JTextField field01 = new JTextField();\n        field01.setToolTipText(\"text01\");\n        JTextField field02 = new JTextField();\n        field02.setToolTipText(\"text02\");\n\n        // 密码框\n        JPasswordField passwordField01 = new JPasswordField();\n        passwordField01.setToolTipText(\"password01\");// 悬停显示\n        passwordField01.setEchoChar('*');// 设置显示的内容\n        JPasswordField passwordField02 = new JPasswordField();\n        passwordField02.setEchoChar('x');// 设置显示的内容\n        passwordField02.setToolTipText(\"password02\");// 悬停显示\n\n        // 文本域\n        JTextArea textArea = new JTextArea();\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        scrollPane.setToolTipText(\"文本域\"); \n\n        // 布局\n        Panel panel = new Panel(new GridLayout(3,2,20,20));\n        panel.add(field01);\n        panel.add(field02);\n        panel.add(passwordField01);\n        panel.add(passwordField02);\n        panel.add(scrollPane);// 加上文本域就会让之前的鼠标悬停显示没了,不知道是什么问题\n        this.add(panel);\n    }\n\n    public static void main(String[] args) {\n        new JComboBoxDemo03();\n    }\n}"
  },
  {
    "objectID": "posts/java多线程--龟兔赛跑/index.html",
    "href": "posts/java多线程--龟兔赛跑/index.html",
    "title": "java多线程–龟兔赛跑",
    "section": "",
    "text": "package cn.usts.edu.lesson03;\n\n/**\n * 龟兔赛跑多线程来实现\n * 乌龟和兔子分别在不同的线程,同时开始\n * */\n\npublic class TortoiseRabbitRace implements Runnable{\n    String winner;\n\n    @Override\n    public void run() {\n        for (int i = 1; i < 101; i++) {\n            boolean flag = gameIsOver(i);\n            System.out.println(Thread.currentThread().getName()+\"跑了\"+i+\"步\");\n\n            // 兔子会偷懒,兔子偷懒100毫秒\n            if (Thread.currentThread().getName().equals(\"兔子\")){\n                try {\n                    Thread.sleep(100);//偷懒0.1秒\n                    i+=30;// 兔子跑的快\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (flag){\n                break;\n            }\n        }\n    }\n\n    // 判断比赛是否结束\n    public boolean gameIsOver(int steps){\n        if (winner!=null){   // 没有获胜者---->gameIsOver=ture;\n            return true;\n        }else if(steps>=100) {\n             // 有人到达终点\n                winner = Thread.currentThread().getName();\n                System.out.println(\"winner is ----->\"+winner);\n                return true;\n            }\n        return false;\n    }\n\n\n    public static void main(String[] args) {\n        TortoiseRabbitRace race = new TortoiseRabbitRace();\n        new Thread(race,\"兔子\").start();\n        new Thread(race,\"乌龟\").start();\n    }\n}"
  },
  {
    "objectID": "posts/缺失的计算机课程YouTube课程/index.html",
    "href": "posts/缺失的计算机课程YouTube课程/index.html",
    "title": "缺失的计算机课程YouTube课程",
    "section": "",
    "text": "课程的目的\n一共有11节课程， 每节课有一个主题，带你熟悉计算机工具\n\n\nclass 1\n\nwhat is shell\n\nshell 就是一个接受命令，然后返回结果的一个工具，解析你的命令给计算机执行，然后将执行结果返回给用户 > how to use shell\nshell的使用就像使用魔法一样，通过像魔法一样的单词来进行操作。\n其实shell的操作也称不上是魔法，每个命令其实就是一个单独的可执行程序，能够有同的功能，这也得益于linux的开源精神，开源作者为Linux大家庭添砖加瓦\necho hello              # 将会在终端中输出一行hello\necho $PATH              # 将会在终端中输出系统环境变量每个变量用:隔开\n\ninstall tldr tldr is cleaner than man\n\nsudo apt-get install npm\nsudo Jnpm install -g tldr\n\nhow to use tldr\n\ntldr tail               # 然后显示描述和案例，非常简洁，非常奈斯\n\ntail 将打印该./目录下的文件，然后打印最后一行， 然后输出到out.txt中\n\nls -l ./ |tail -n1 > out.txt\n\ncurl grep curl 和网络相关 grep 过滤信息\n\n                                    # 过滤关键词 Date关键字这一行|裁剪用‘ ’，第2个裁剪单位\ncurl --head --silent www.google.com | grep -i Date| cut --delimiter=' ' f2\n控制键盘led灯亮灭\n# on\necho 1| sudo tee /sys/class/leds/input27::capslock/brightness\n# off\necho 0| sudo tee /sys/class/leds/input27::capslock/brightness\n\nxdg-open 能够使用适合的程序打开，html用浏览器打开，文件夹用文件管理器打开\n\nxdg-open xxx.html\nxdg-open aa.txt\n...\n\n\nclass 2(shell script)\n\n脚本语言的编写\n\n\n单引号和双引号的作用是不一样的, 单引号不做解释,原样输出,双引号进行解释\n\nfoo=bar\necho \"$foo\"\n# prints bar\necho '$foo'\n# prints $foo\n\n函数编写\n\n函数名和脚本名一致, 编写完成执行source mcd.sh即可全局使用该脚本\nmcd () {\n    # -p表示可以添加子目录(可以套娃)\n    mkdir -p \"$1\"\n    # 进入到创建的目录\n    cd \"$1\"\n}\n\n$ 的使用\n\n$0 - 脚本的名字\n$1 to $9 - 脚本的后边跟的参数\n$@ - 所有参数\n$# - 参数个数返回上一条命令的执行结果\n$$ - 当前进行的id\n$_ - 上次的执行的命令的最后一个参数\n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# cat mcd.sh \nmcd(){\n    #mkdir -p \"$1\"\n    #cd \"$1\"\n\n    # 所有参数\n    echo \"@=$@\"\n    # 参数个数\n    echo \"#=$#\"\n    # 返回上一条命令的结果\n    echo \"?=$?\"\n    # 返回当前脚本进程号\n    echo '$$'\"=$$\"\n    # \n    echo '$_'\"=$_\"\n}\n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# source mcd.sh \n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# mcd aaa bb cc dd\n@=aaa bb cc dd\n#=4\n?=0\n$$=901010\n$_=$$=901010\n\n!! - 上一条整条命令\n\n(base) root@VM-12-14-ubuntu:~# echo hello\nhello\n(base) root@VM-12-14-ubuntu:~# !!\necho hello\nhello\n(base) root@VM-12-14-ubuntu:~# ls\ncreate_variables.sh  mcd.sh\n(base) root@VM-12-14-ubuntu:~# !!\nls\ncreate_variables.sh  mcd.sh\n(base) root@VM-12-14-ubuntu:~#\n\n|| 和 && || 第一个条件是否满足, 不满足执行后一个 && 两个条件同时满足才执行.\n\n\n\n\nll\n左边参数\n右边参数\n\n\n\n\n条件\n√\n不执行\n\n\n条件\n×\n执行\n\n\n\n\n\n\n&&\n左边参数\n右边参数\n是否执行\n\n\n\n\n条件\n√\n√\n执行\n\n\n条件\n×\n√\n不执行\n\n\n\nfalse || echo \"Oops, fail\"\n# Oops, fail\n\ntrue || echo \"Will not be printed\"\n#\n\ntrue && echo \"Things went well\"\n# Things went well\n\nfalse && echo \"Will not be printed\"\n#\n\ntrue ; echo \"This will always run\"\n# This will always run\n\nfalse ; echo \"This will always run\"\n# This will always run\n\n命令参数的使用$(cmd)\n\na=$(pwd)\necho \"we are now at:$a\"\n\n拼接不同进程的信息, CMD <(CMD) <(CMD)\n\n diff <(ls .) <(ls ../)\n ls <(ls .) <(ls ../)\n cat <(ls .) <(ls ../)\n ...\n\n对比不同路径下文件的内容中是否包含hello关键字 注意$(cmd)是执行命令, $VALUE 是取值 [xxx] 和[[xxx]]的区别,前者是旧版本,后者是新版本, 前者的适配性更好,但是后者的语法更适合人类编写,参考地址:[xxx]和[[xxx]]详细对比说明\n\n#!/bin/bash    \necho \"find_diff program is excute at:$(date)\"    \n    \necho \"sh name is:$0, with $# arguements, with pid is: $$\"    \n    \n# 遍历文件夹中的文件    \nfor file in \"$@\";do    \n    # 过滤文件中的hello关键字, 输出到系统中垃圾倾倒的地方    \n    echo \"----------->$file\"    \n    grep hello  \"$file\" > /dev/null 2> /dev/null    \n    \n    # 如果上面这行执行结果不等于0 \n    #if [[ $? -ne 0 ]]; then  \n    if [ $? -ne 0 ]; then    \n       echo \"$file has no '1'\"    \n       # 在没有的文件后边追一个 # hello    \n       echo \"#hello\" >> \"$file\"    \n    fi    \ndone\n$# 表示提供到shell脚本或者函数的参数总数。\n$0 表示第一个参数。\n-ne 表示不等于。\n这是unix的shell编程语句，如果上一条命令执行后的结束代码不是0则执行下面的命令，知道fi行之前，例子：\nwho am i | grep root\nif [ $? -ne 0 ]\nthen\necho 'hello'\nfi\n另外：\n整数比较\n-eq 等于,如:if [\"$a\" -eq \"$b\" ]\n-ne 不等于,如:if [\"$a\" -ne \"$b\" ]\n-gt 大于,如:if [\"$a\" -gt \"$b\" ]\n-ge 大于等于,如:if [\"$a\" -ge \"$b\" ]\n-lt 小于,如:if [\"$a\" -lt \"$b\" ]\n-le 小于等于,如:if [\"$a\" -le \"$b\" ]\n< 小于(需要双括号),如:((\"$a\" < \"$b\"))\n<= 小于等于(需要双括号),如:((\"$a\" <= \"$b\"))\n> 大于(需要双括号),如:((\"$a\" > \"$b\"))\n>= 大于等于(需要双括号),如:((\"$a\" >= \"$b\"))\n\nls *.sh 命令过滤\n\n\n参数扩展\n\nconvert hello.jpg hello.png\nconvert hello.{jpg,png} # \n\ntouch hello.{png,jpg}\nrm *.{jpg,png}\n > find 查找文件, 名字,日期(n天内..),类型(文件,文件夹), 大小(文件大小), 额外操作(删除,对比…)\nfind . -name src -type d\nfind ./{a,b} -path '*.py' -type f\n\n1、-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件\n2、-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名\n3、-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名\n\n# Find all zip files with size in range 500k to 10M\nfind . -size +500k -size -10M -name '*.tar.gz'\n\n# 删除\n# Delete all files with .tmp extension\nfind . -name '*.tmp' -exec rm {} \\;\n# Find all PNG files and convert them to JPG\nfind . -name '*.png' -exec convert {} {}.jpg \\;\n >locate文件子串查找\n许多时候我们并不知道文件的位置,只有一些关键字, 所以通过关键字全局查找显得非常必要(有点类似windows 的everything)\nlocate hello\n\ngrep文件内容查找\n\n# 在指定文件内查找\ngrep hello xxx.sh\n# 在当前目录递归查找hello\ngrep -r hello .\n\nrg按照文件类型, 指定路径,搜索指定内容\n\nrg \"echo\" -t sh ~/projects/cs_base/\n\n# 获取前后2行(一共4行)内容\nrg \"echo\" -t sh -C 4 ~/projects/cs_base/\n\nctrl+r搜索历史, 继续按可以继续向前翻符合的命令 history展示全部命令\n\n\nfzf文件内容查找\n\ncat hello|fzf\n\n\n\n在这里插入图片描述\n\n\n\nbroot nnn # class 3 # class 4 # class 5 # class 6 # class 7 # class 8 # class 9 # class 10 # class 11 # 答疑"
  },
  {
    "objectID": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html",
    "href": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html",
    "title": "java多线程– 线程池( Executors.newFixedThreadPool() )",
    "section": "",
    "text": "执行结果 \npackage cn.usts.edu.lesson08;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n/**\n * 线程池:\n * 线程的创建和销毁很烦,于是就出现了线程池,当线程闲置的时候就放置到池子中\n * 当需要线程的时候就到池子中去取出\n * 提高线程的利用率\n * */\npublic class ThreadPoolDemo {\n    public static void main(String[] args) {\n        // 创建池子  最大线程数\n        ExecutorService service = Executors.newFixedThreadPool(10);\n\n        //启动池子\n        for (int i = 0; i < 20; i++) {\n            service.execute(new TestThread());\n        }\n\n        // 关闭池子\n        service.shutdown();\n    }\n}\n\n\nclass TestThread implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}"
  },
  {
    "objectID": "posts/app反爬/index.html",
    "href": "posts/app反爬/index.html",
    "title": "app反爬",
    "section": "",
    "text": "根据崔庆才的爬虫书练习 https://scrape.center/ https://www.sojson.com/simple_json.html # app1(简单app无爬措施) 对地址直接发送get请求即可可以获取json数据:\n# -*- coding: utf-8 -*-\n# @Time : 2022/4/17 13:42\n\nimport requests\n\ndef get(url):\n    res = requests.get(url)\n    return res\n\nif __name__ == '__main__':\n    # 数据一共100条\n    res = get(\"https://app1.scrape.center:443/api/movie/?offset=0&limit=100\")\n    print(res.text)\n # app2"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html",
    "href": "posts/Ubuntu18版本换源/index.html",
    "title": "Ubuntu18版本换源",
    "section": "",
    "text": "【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 ## 0. Ubuntu版本必须匹配 查看Ubuntu版本命令"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "href": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "title": "Ubuntu18版本换源",
    "section": "1.备份sources.list",
    "text": "1.备份sources.list\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "href": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "title": "Ubuntu18版本换源",
    "section": "2.编辑sources.list（换源）",
    "text": "2.编辑sources.list（换源）\nsudo gedit /etc/apt/sources.list"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "href": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "title": "Ubuntu18版本换源",
    "section": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。",
    "text": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#更新源",
    "href": "posts/Ubuntu18版本换源/index.html#更新源",
    "title": "Ubuntu18版本换源",
    "section": "4.更新源",
    "text": "4.更新源\nsudo apt-get update"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#完成换源",
    "href": "posts/Ubuntu18版本换源/index.html#完成换源",
    "title": "Ubuntu18版本换源",
    "section": "5.完成换源",
    "text": "5.完成换源"
  },
  {
    "objectID": "posts/powershell获取脚本执行权限/index.html",
    "href": "posts/powershell获取脚本执行权限/index.html",
    "title": "powershell获取脚本执行权限",
    "section": "",
    "text": "管理员权限执行powershell\nSet-ExecutionPolicy -ExecutionPolicy Unrestricted\n\n参考地址:https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2"
  },
  {
    "objectID": "posts/webSocket-node -- 02 聊天室/index.html",
    "href": "posts/webSocket-node -- 02 聊天室/index.html",
    "title": "webSocket-node – 02 聊天室",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/临时邮箱/index.html",
    "href": "posts/临时邮箱/index.html",
    "title": "临时邮箱",
    "section": "",
    "text": "知乎指南\nhttps://www.guerrillamail.com/"
  },
  {
    "objectID": "posts/javaGUI-- JPanel/index.html",
    "href": "posts/javaGUI-- JPanel/index.html",
    "title": "javaGUI– JPanel",
    "section": "",
    "text": "JPanel容器 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JPanelDemo extends JFrame {\n\n    public JPanelDemo() {\n        this.setTitle(\"JPanel\");\n        this.setBounds(100,100,400,400);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        this.setLayout(new GridLayout(2,2,10,20));// 后边的两个参数都是  行间距  和  列间距\n        JPanel panel01 = new JPanel(new GridLayout(1,3));\n        JPanel panel02 = new JPanel(new GridLayout(3,1));\n        JPanel panel03 = new JPanel(new GridLayout(2,3,10,10));\n        JPanel panel04 = new JPanel(new GridLayout(2,2));\n\n        JButton button1 = new JButton(\"1\");\n        JButton button2 = new JButton(\"1\");\n        JButton button3 = new JButton(\"1\");\n\n        JButton button4 = new JButton(\"2\");\n        JButton button5 = new JButton(\"2\");\n        JButton button6 = new JButton(\"2\");\n\n        JButton button7 = new JButton(\"3\");\n        JButton button8 = new JButton(\"3\");\n        JButton button9 = new JButton(\"3\");\n        JButton button10 = new JButton(\"3\");\n        JButton button11 = new JButton(\"3\");\n        JButton button12 = new JButton(\"3\");\n\n        JButton button13 = new JButton(\"4\");\n        JButton button14 = new JButton(\"4\");\n        JButton button15 = new JButton(\"4\");\n        JButton button16 = new JButton(\"4\");\n\n        panel01.add(button1);\n        panel01.add(button2);\n        panel01.add(button3);\n\n        panel02.add(button4);\n        panel02.add(button5);\n        panel02.add(button6);\n\n        panel03.add(button7);\n        panel03.add(button8);\n        panel03.add(button9);\n        panel03.add(button10);\n        panel03.add(button11);\n        panel03.add(button12);\n\n        panel04.add(button13);\n        panel04.add(button14);\n        panel04.add(button15);\n        panel04.add(button16);\n\n\n        Container container = this.getContentPane();\n        container.add(panel01);\n        container.add(panel02);\n        container.add(panel03);\n        container.add(panel04);\n\n    }\n\n    public static void main(String[] args) {\n        new JPanelDemo();\n    }\n}"
  },
  {
    "objectID": "posts/qt大小端转换/index.html",
    "href": "posts/qt大小端转换/index.html",
    "title": "qt大小端转换",
    "section": "",
    "text": "在这里插入图片描述\n\n\n以1580 0001为例\n    QByteArray b(\"15800001\");\n    qint32 a = parseValueInt32(b, 0, 8);\n    qDebug() << \"\\tseqNum:\" << a;\n32位大端解析:\nqint32 single_test::parseValueInt32(QByteArray data, int valuePos, int valueSize)\n{\n    bool ok;\n    QByteArray parseData;\n    parseData = data.mid(valuePos, valueSize);\n    QString strParseData = parseData;\n    qint32 tempInt32 = strParseData.toInt(&ok, 16);\n                            //                     0x15 80 00 01(原始数据反过来)\n    qDebug() << tempInt32; // 16810005 (十进制) --> 0x01 00 80 15(十六进制)\n    qint32 parseValueOut = qToBigEndian(tempInt32);     // Convert to Big-Endian\n    return parseValueOut;    \n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/pyqt5 --05对象类型判定和控件继承类型/index.html",
    "href": "posts/pyqt5 --05对象类型判定和控件继承类型/index.html",
    "title": "pyqt5 –05对象类型判定和控件继承类型",
    "section": "",
    "text": "print(o.inherits('QLabel'))# 是否是继承自QLabel类\n            print(o.isWidgetType())# 判断类型是否是Widget\nfrom PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject对象类型判断，子类判断')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        obj = QObject()\n        widget = QWidget()\n        label = QLabel()\n\n        li = [obj,widget,label]\n        for o in li:\n            # print(o.inherits('QLabel'))# 是否是继承自QLabel类\n            print(o.isWidgetType())# 判断类型是否是Widget\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())"
  },
  {
    "objectID": "posts/javaGUI--表格布局/index.html",
    "href": "posts/javaGUI--表格布局/index.html",
    "title": "javaGUI–表格布局",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestGridLayOut {\n    // 表格布局\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"GridLayOut\");\n        frame.setVisible(true);\n\n        // 按钮组件\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n        Button button5 = new Button(\"button5\");\n        Button button6 = new Button(\"button6\");\n\n        // 设置布局形式为表格布局\n        frame.setLayout(new GridLayout(2,3));\n\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.add(button4);\n        frame.add(button5);\n        frame.add(button6);\n\n        // 自动调整为合适大小\n        frame.pack();\n    }\n}"
  },
  {
    "objectID": "posts/Linux下_终端_终端模拟器_shell_bash的区别/index.html",
    "href": "posts/Linux下_终端_终端模拟器_shell_bash的区别/index.html",
    "title": "Linux下_终端_终端模拟器_shell_bash的区别",
    "section": "",
    "text": "总结\n\n终端: 发送并接收键盘输入, 并渲染处理后的结果 shell: 执行终端发送过来的命令, 并把结果返回给终端. 终端模拟器: 由于在图形界面上第一个终端已经运行图形界面程序了, 所以需要使用第二个终端, 于是终端模拟器的作用就是模拟终端键盘输入发送给shell,渲染返回结果, 但是终端模拟器的出现有种种原因, 速度更快, 显示更好….. bash: 实际是shell的一种实现.\n\n\n\n番外\n\n任何一个linux下都有多个终端\n切换终端ctrl+clt+F1切换别的终端进行 把F1替换为F2 ,F3….\n\n\n图形界面(xserver)的linux\n默认第一个终端运行的就是xserver(图形界面)程序\n\n\n没有xserver的Linux\n默认运行的就是一个命令行 #### shell shell接收终端发送过来的命令并解析, 然后将结果返回给终端"
  },
  {
    "objectID": "posts/多普勒原理/index.html",
    "href": "posts/多普勒原理/index.html",
    "title": "多普勒原理",
    "section": "",
    "text": "多普勒原理：\n高中知识点，麻了，选修失误， 让我和多普勒失之交臂，相见恨晚的多普勒。"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "",
    "text": "darknet框架相pyrtorch轻量化很多，将darknet和qt进行整合，大多项目都是基于单独的框架的，对于整合的工作相对来说低很多"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "创建完成记得保存",
    "text": "创建完成记得保存\n对修改完的ui文件进行编译"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "环境配置需要的文件",
    "text": "环境配置需要的文件\n\nincldue 文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nconfig文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nlib文件夹"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "链接器中附加目录中的附加依赖项",
    "text": "链接器中附加目录中的附加依赖项\nopencv版本根据自身开发环境进行配置"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "生成",
    "text": "生成\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "双击即可运行",
    "text": "双击即可运行\n点击右上角的 x 关闭只关闭了界面, 系统检测进程还是在后台运行, 需要重写closeEvent 进行关闭系统."
  },
  {
    "objectID": "posts/文件管理服务器/index.html",
    "href": "posts/文件管理服务器/index.html",
    "title": "文件管理服务器",
    "section": "",
    "text": "https://blog.laoda.de/archives/docker-compose-install-nextcloud"
  },
  {
    "objectID": "posts/linux-- 提权/index.html",
    "href": "posts/linux-- 提权/index.html",
    "title": "linux– 提权",
    "section": "",
    "text": "linux提权\nvim /ect/sudoers 修改内容如下\nroot    ALL=(ALL:ALL) ALL\n# 添加的用户\nfly     ALL=(ALL:ALL) ALL"
  },
  {
    "objectID": "posts/南大操作系统基础-ics/index.html",
    "href": "posts/南大操作系统基础-ics/index.html",
    "title": "南大操作系统基础-ics",
    "section": "",
    "text": "nes模拟器\nhttps://github.com/NJU-ProjectN/fceux-am # https://nju-projectn.github.io/ics-pa-gitbook/ics2020/1.2.html"
  },
  {
    "objectID": "posts/java多线程-- CopyOnWriteArrayList/index.html",
    "href": "posts/java多线程-- CopyOnWriteArrayList/index.html",
    "title": "java多线程– CopyOnWriteArrayList",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson07;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * 测试jdk内置的安全集合\n * */\n\npublic class CopyOnWriteArrayListDemo {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(()->{\n                list.add(Thread.currentThread().getName()   );\n            }).start();\n        }\n\n        try {\n            Thread.sleep(1000); // 等待线程结束\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());// 打印list长度\n    }\n}"
  },
  {
    "objectID": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "href": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "title": "qt移动界面无响应[ 多线程 ]",
    "section": "",
    "text": "创建子进程类\n\n普通的长时间操作界面容易卡死, 体验非常不好,为了提升体验, 所以将需要较长时间响应的事件都放到了子线程中执行, 这样主线程就不会出现假死的状态\n\n\n方法1(继承QThread):\n.h [头文件]\n#ifndef MYTHREAD_H\n#define MYTHREAD_H\n\n#include <QThread>\n\nclass Generate : public QThread\n{\n    Q_OBJECT\npublic:\n    explicit Generate(QObject* parent = nullptr);// 直接使用qt的类生成,这里没有默认的空指针,new的时候会报错,需要设置成nullptr\n\nprotected:\n    void run(); // 重写run函数\n\nsignals:\n    void curNumber(int num);// 自定义信号, 传递数据\n    void curimg(QImage* img); // 传递图片, 如果是自定义的结构, 需要注册类型:qRegisterMetaType<int>(\"int\")  [int根据自己的类型设置];\n\npublic slots:\n};\n\n#endif // MYTHREAD_H\n.c[源文件]\n#include \"mythread.h\"\n#include \"qdebug.h\"\n\nGenerate::Generate(QObject* parent) : QThread(parent)\n{\n\n}\n\nvoid Generate::run()\n{\n    qDebug() << \"current Thread id is: \" << QThread::currentThread();\n\n    int num = 0;\n    while (1)\n    {\n        emit curNumber(num++);\n        if (num == 999)\n        {\n            qDebug() << \" sub Thread is finished...\";\n            break;\n        }\n        QThread::usleep(1);\n    }\n}\nmainwindow.c主线程\n#include \"qtwidgetsapplication_thread.h\"\n#include \"MyCreate.h\"\n\n\n\n#include <qdebug.h>\n\nQtWidgetsApplication_Thread::QtWidgetsApplication_Thread(QWidget *parent)\n    : QMainWindow(parent)\n{\n    ui.setupUi(this);\n    qDebug() << \"main thread is : \" << QThread::currentThread();\n    \n    // 将刚才的创建的类实例化\n    Generate * subThread_A = new Generate ;\n   \n\n\n    // 绑定信号和槽\n    connect(subThread_A, &Generate ::curNumber, this, [=](int num) {\n        ui.label->setNum(num);\n        });\n   \n\n\n    // 启动线程\n    connect(ui.pushButton, &QPushButton::clicked, this, [=]() {\n        subThread_A->start();\n        });\n    \n   \n\n}\n\n\n\n方法二(moveToThread):\n这种方法相对来说更加灵活     打开创建类的头文件MyThread.h\n\n修改MyThread(QObject *parent);—–>MyThread(QObject *parent=nullptr);, 不修改在new的时候会报错 [类 不存在默认构造函数]\n\n 修改完成后如下\n#include <QObject>\n\nclass MyThread  : public QObject\n{\n    Q_OBJECT\n    \npublic:\n    MyThread(QObject *parent=nullptr);\n    ~MyThread();\n\n    // create working function to do sth what you want\n    void working(); //线程中执行的代码写到working中,这个函数名随意\n\nsignals:\n    // create a signal to kick the thread\n    void signal_hello(int count); // 设置一个触发信号, count为传递的变量, 将这个变量用来讲子线程和主线程之间进行传递数据.\n};\n打开创建类的源文件MyThread.cpp\n\n将刚才创建的头文件进行实现 这个程序的作用主要是将子线程中的变量发送到主线程进行显示\n\n#include \"MyThread.h\"\n\n#include \"qdebug.h\"\n#include \"qthread.h\"\n\nMyThread::MyThread(QObject *parent)\n    : QObject(parent)\n{}\n\nMyThread::~MyThread()\n{}\n\nvoid MyThread::working()\n{\n    int count = 0;\n    while (1) {\n        // kick the signal, and post the data [count] by this signal\n        emit signal_hello(++count);  // 将信号发送, 并将数据发送到主线程\n        if (count == 999) {\n            qDebug() << \"sub thread is stoped:\";\n            break;\n        }\n        qDebug() << \"current thread is:\" << QThread::currentThread;\n    }\n}\n进入到主线程进行实现mainwindow.cpp\nMyThread* work = new MyThread;\nQThread* thread_c = new QThread;\n\nwork->moveToThread(thread_c);                    // 放到新线程中\nthread_c->start();                               // 启动线程\n\nconnect(ui.pushButton, &QPushButton::clicked, work, &MyThread::working);// 按钮点击信号\nconnect(work, &MyThread::signal_hello, this, [=](int count) {\n       ui.label->setNum(count);\n       });  // 界面刷新信号"
  },
  {
    "objectID": "posts/nvim打造c语言环境/index.html",
    "href": "posts/nvim打造c语言环境/index.html",
    "title": "nvim打造c语言环境",
    "section": "",
    "text": "sudo apt update\nsudo apt -y upgrade\nsudo apt install -y neovim\nsudo apt install -y vim \n# 修改bashrc文件\nnvim ~/.bashrc\n# 修改内容如下\nalias vm='vim'\nalias nm='nvim'\nsource ~/.bashrc\n# 刷新\nsource ~/.bashrc\n\n创建配置文件夹\nmkdir ~/.config/nvim\nnvim ~/.config/nvim/init.vim"
  },
  {
    "objectID": "posts/arch安装kde/index.html",
    "href": "posts/arch安装kde/index.html",
    "title": "arch安装kde",
    "section": "",
    "text": "好多安装视频都是框框一段乱敲, 不明所以,不知道安装的是什么插件以及基本功能, 做个笔记记录下安装过程\n\nked社区:https://apps.kde.org/zh-cn/ > 进入到这个社区一下就明白了 pacman -S xxxx 的一堆桌面插件是什么了 # 时间设置\n# 设置时区\ntimedatectl set-timezone Asia/Shanghai\n\n# 打开网络更新时间\ntimedatectl set-ntp true\n\n# 查看状态\ntimedatectl status\n\n配置bash shell环境变量\n# 进入保存环境变量的目录\ncd /etc/skel\n\n# 查看所有的文件(包括隐藏文件)\nls -al  \n\n# 编辑.bashrc文件(系统启动时运行的文件),这里的编辑器根据自己的写,nvim, vim, nano....,这一句即可,其他的可以不要\nnvim .bashrc    \n    -> export EDITOR=nvim       \n\n# 其他的是颜色的显示\n\n\n\n在这里插入图片描述\n\n\n\n\n添加用户\n# 添加用户,并在home目录下创建一个和z同名的文件夹\nuseradd --create-home z\n\n# 查看用户信息\nid z\n\n# 设置密码\npasswd z\n\n# 将z用户添加到常用de用户组中\nusermod -G wheel,users,power,ld,adm,optical,storage z\n\n\n安装sudo 给普通用户提权\n# 安装\npacman -S sudo\n\n# 编辑visudo\nvisudo\n    --> 去掉图中注释\n # 修改文文字设置 本文参考https://www.bilibili.com/read/cv13858119?from=search&spm_id_from=333.337.0.0 \n  \n\n\n安装桌面\nplasma指南 安装 plasma-meta 元软件包或者 plasma 组。 关于 plasma-meta 和 plasma 两者的不同见元软件包与软件包组。若要使用 Plasma 的最小安装，请安装 plasma-desktop 包。\n\n前者是软件包组，pacman -S plasma 允许你自由选装组内软件，后者是软件包，依赖的是前者的全部软件，不能选装，一旦软件包组里有软件新加入，前者不会要求你安装，后者会。\n\npacman -S plasma \n\n\n启动管理\n# \npacman -S sddm\nsystemctl enable sddm \n# 如果切换管理器先把之前的关闭\nsystemctl disable sddm\n\n# 手动启动sddm\nsudo systemctl start sddm \npacman -S dolphin konsole kdeconnect kcalc\n\n\n\n名称\n功能\n\n\n\n\ndolphin\n文件管理\n\n\nkonsole\n命令行终端\n\n\nkdeconnect\n手机电脑互联(发送文件等)\n\n\nkcalc\n计算器"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TengFei Zhang",
    "section": "",
    "text": "Fresh graduates majoring in computer science, love life and love coding."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "TengFei Zhang",
    "section": "Education",
    "text": "Education\nSuzhou University of Science and Technology | Jun 2022"
  },
  {
    "objectID": "index.html#experience-at-school",
    "href": "index.html#experience-at-school",
    "title": "TengFei Zhang",
    "section": "Experience at school",
    "text": "Experience at school\nRanking: 5/45 | GPA: 3.24 | Teaching assistant | Scholarship x 3\nQualification Certificate of Computer and Software Technology Proficiency Of Junior"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "TengFei Zhang",
    "section": "Experience",
    "text": "Experience\nElectric Vehicle Helmet Illegal Detection System(Yolo, Ocr, Spider.. ) | Graduation Project | Feb 2022\nVideo Capture Tools (Pyqt, OpenCv, Ftplib..) | Su Zhou HighWise | Oct 2021\nLicense Management Platform (Django, Vue, Mysql..) | Su Zhou HighWise | Jan 2021\nHuman Detection (Yolo, Qt..) | Su Zhou Ravsense | Apr 2022\nRadar Raw ADC Data Capture(AWR6843, not DCA1000..) | Su Zhou Ravsense | Jul 2022\nVitalSign Algorithm Porting(RTOS, Matlab Coder, STM32H7..) | Su Zhou Ravsense | Oct 2022\nE-mail:izhangtengfei@163.com"
  },
  {
    "objectID": "article.html",
    "href": "article.html",
    "title": "Article",
    "section": "",
    "text": "javaGUI–浮动布局(FlowLayOut)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux–创建用户修改&修改密码\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n设置Caps_Lock和Esc交换\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaArrayList作业二\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– IP地址\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n中科大源\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE请求转发（转发和重定向）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程休眠(sleep)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch没有wifi\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –01简单继承关系\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 重定向的多种实现方法\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmysql8.0安装\n\n\n\n\n\n\n\nmysql\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux ssh长时间无操作断连\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt线程问题(耗时操作)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– join(线程插队,优先执行)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32–io口拉高还是拉低\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux键盘f1-f12功能键盘失效\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n三步简单解决3306端口占用问题（windows）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n算法 –0_算法是什么\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.setDaemon(true) 守护线程简单实现\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–窗口事件监听\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 静态代理(简单剖析)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 一行代码实现定时刷新，定时跳转\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n树莓派开箱点亮(无屏幕)\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程–ReentrantLock ( Lock上锁 _ 解锁 )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell脚本批量创建多个用户\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 获取请求行、请求头、请求正文\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqtQByteArry以二进制写入多n个字节\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux– linux忘记密码(修改root密码)\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n清除html和css标签自带的默认样式\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npip加速\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 内置注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程管理\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n算法– 1_递归\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_js脚本自动调试\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs studio添加include和依赖库\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt –问题总结(头文件问题,QString转换,查找组件)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 通信协议\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread 重映射串口到 rt_kprintf 函数\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing之[Dialog]弹窗\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_dsp入门-ti c660\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– URL（基本用法）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n电动车头盔检测系统(毕设)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread定时器\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nSpring简单使用（依赖注入）\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava集合– 所有\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt上位机 – 自己开发出口助手\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743+CubeMX+RtThread工程创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvue – 01安装、创建、跑通\n\n\n\n\n\n\n\nvue\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–布局练习\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n模仿网易严选(vant)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–滚动条JScrollPane\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射–通过反射获取到注解的值\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– sleep实现 ( 时间刷新 , 模拟倒计时)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaArrayList作业1\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 初识多线程的问题(简单案例)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n腾讯云简单使用-Python\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nNavicat中 int(0)表示什么【init（0）是什么意思】\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–东西南北中布局\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmanjaro install\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt多线程QThread()\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 生产者消费者\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程停止\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– URL(网络资源下载)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– Tcp聊天\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n毫米波雷达\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwin11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 得到class类的几种方式\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava冒泡排序\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs打包qt程序\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava基础知识（笔记）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 信号灯法则\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-json-乱码解决\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n中断-轮询\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Runnable简单实现(例子)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu21 美化\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava集合– HashSet小练习\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n安卓7以上安装系统证书(system分区没有权限)\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Callable接口简单应用\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspring整合SSM\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n二分查找\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 会话和会话技术 -cookie\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– yield 线程礼让\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 文件传输\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread– 互斥量(mutex)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux matlab安装失败major\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–下拉框JComboBox\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 解决请求中的缓冲区中文乱码问题\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –02面向对象的设计思想\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE -Session\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n小米刷机\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–icon\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大ics基础课\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 端口\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大ics课程\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmap作业三(集合)韩顺平\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 简单登陆跳转逻辑\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 自定义注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyinstaller打包程序问题总结\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread移植(固件库版本)-项目创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing [ icon ]画一个icon\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 01简单跑通\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch安装\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n计算机组成原理 – 大端模式,小端模式\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux入门基操作\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射–类加的载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_ccs修改环境变量\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类–时间日期类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– String、StringBuffer（StringBuilder）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 简单实现多线程\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava GUI编程–panel\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743使用\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch yay安装qq\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Runnable接口实现多线程网图下载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–监听器 [ 关闭按钮 ]\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringMVC-设置日期时间对象【自定义日期时间格式】\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux–改变用户所在组(改变登陆初始位置)\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nalu整数加法_减法\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava–gui_简单计算器\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n汇编–00安装dosBox\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnodejs安装–（npm安装）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–监听器02\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–frame\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 反射\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nprotobuf协议– 01使用（js简单实现）\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–列表框 JList\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\napp爬虫–持续更新\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南京大学ics pa实验O\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava和– Collections工具类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nJava函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.getState() 查看线程状态\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt–vs2022+qt5.15.2\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n简单的创建一个DHCP服务器（WinServ2008-2R）【图文】\n\n\n\n\n\n\n\nnetwork\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n应用视觉设计\n\n\n\n\n\n\n\ncss\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_TreeSet和HashSet的去重原理 (作业四)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nweb-packet –01\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread–信号量(semaphare)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– 鼠标监听\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava–创建Tomcat服务器\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 利用Referer简单实现防盗链功能\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– System类的常用方法, Runtime类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n计算机组成原理\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nPython–Threading\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 死锁模拟( synchronized )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt无法输出\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –03QObje对象的使用\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nPycharm环境配置\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket – 03 socket.io\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 元注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_Fastjson的使用\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nsmt32-f103寄存器点灯\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32芯片开发包\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 所有类的Class类型\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– 包装类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程同步(event)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux– 查看和修改文件所在组\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 网图多线程下载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-hellomvc-02\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –04QObje对象的父子关系使用\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 利用反射来 实例化对象,调用功能方法,设置属性\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread邮箱(mailbox)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n内存管理\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 利用反射获取类的运行时结构(属性,方法,对象,构造器)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvmware镜像站\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread动态内存分配\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_icboost+IWR6843\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing[JFrame]\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell批量创建20个指定文件名格式的文件（或文件夹）\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.setPriority() 线程优先级\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nquarto\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_jdk安装，配置环境（win10）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– udp通信\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– Math和Random\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell编程的简单实现\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava- 贪吃蛇\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–文本框JTextField_密码框JPasswordField()_文本域 JTextArea\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程–龟兔赛跑\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n缺失的计算机课程YouTube课程\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程池( Executors.newFixedThreadPool() )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\napp反爬\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu18版本换源\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npowershell获取脚本执行权限\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 02 聊天室\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n临时邮箱\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– JPanel\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt大小端转换\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –05对象类型判定和控件继承类型\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–表格布局\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux下_终端_终端模拟器_shell_bash的区别\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n多普勒原理\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt+darknet+yolo+vs2022(附加库目录lib库)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n文件管理服务器\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux– 提权\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大操作系统基础-ics\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– CopyOnWriteArrayList\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt移动界面无响应[ 多线程 ]\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnvim打造c语言环境\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch安装kde\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nMatlab Coder\n\n\n\n\n\n\n\nmatlab\n\n\n\n\n\n\n\n\n\n\n\nNov 22, 2022\n\n\ndd21\n\n\n\n\n\n\nNo matching items"
  }
]