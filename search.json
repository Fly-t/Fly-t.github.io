[
  {
    "objectID": "other/experience/index.html",
    "href": "other/experience/index.html",
    "title": "Miscellaneous talk",
    "section": "",
    "text": "Abstract\n随笔, 杂谈.\n\n\nReferance\n说话不能很随意, 不能说随便弄弄就行了, 避免泛泛而谈的感觉, 要有具体的执行方案, 让听者觉得可行, 可信.\n说话时底气得足, 不能让人从气场上觉得不可行."
  },
  {
    "objectID": "posts/infineon_MCU7_how_to_use/index.html",
    "href": "posts/infineon_MCU7_how_to_use/index.html",
    "title": "how to use infineon Radar MCU7",
    "section": "",
    "text": "infineon RadarBTG60 软件架构, 及如何移植\n该部分主要针对mcu7 进行展开"
  },
  {
    "objectID": "posts/infineon_MCU7_how_to_use/index.html#引导加载程序刷新",
    "href": "posts/infineon_MCU7_how_to_use/index.html#引导加载程序刷新",
    "title": "how to use infineon Radar MCU7",
    "section": "引导加载程序刷新",
    "text": "引导加载程序刷新\n微控制器包含一个引导加载程序。如果调试器是不可用。由于设备通常直接启动到固件而不进入引导加载程序，引导加载程序必须首先手动激活。这可以通过执行以下顺序来完成\n\n断开设备与 USB 的连接\n通过将 TP1 连接到 3.3 V 将 MCU ERASE 引脚保持在高电平（参见图 13）\n在保持 TP1 高电平的同时再次将设备连接到 USB\n松开擦除引脚 （TP1）\n设备现在处于引导加载程序模式\n\n\n一旦设备处于引导加载程序模式，就可以使用可用于从Microchip下载（Microchip，SAM-BA启动助手，2019）"
  },
  {
    "objectID": "posts/南大ics基础课/index.html",
    "href": "posts/南大ics基础课/index.html",
    "title": "南大ics基础课",
    "section": "",
    "text": "视频地址: https://www.bilibili.com/video/BV1Z541127RJ/?p=2&vd_source=c0157a4afd2e47c7662431fd9d2739fb\ngitbook:https://nju-projectn.github.io/ics-pa-gitbook/ics2021/0.2.html\npdf:所在位置:http://www.why.ink:8080/ICS/2022/Main_Page"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "href": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "title": "stm32F103-RT-Thread线程同步(event)",
    "section": "",
    "text": "event是不同线程间满足条件时的控制块(比较适合多flag和多线程的情况) mutex访问单独的临界资源 semaphore访问多个临界资源 &gt; 线程1接收event,查看其中的flag是否满足设置的条件 &gt; 线程2发送flag1,flag2\n#include \"board.h\"\n#include \"rtthread.h\"\n\n#define FLAG3  1&lt;&lt;3\n#define FLAG5  1&lt;&lt;5\nstatic rt_event_t event1 = NULL;\nstatic rt_thread_t event_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t event_2_thread = RT_NULL;                // semaphore thread_2 control block\n\n\n\nstatic void event_thread_1_entry(void *parmaeter);\nstatic void event_thread_2_entry(void *parmaeter);\n\n\n\n\nint main(void)\n{\n    event1 = rt_event_create(\"flag\", RT_IPC_FLAG_FIFO);\n\n    event_1_thread = rt_thread_create(\"event_1_thread\", event_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (event_1_thread!= RT_NULL){\n        \n        rt_thread_startup(event_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    event_2_thread = rt_thread_create(\"metux_2_thread\", event_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (event_2_thread!= RT_NULL){\n        \n        rt_thread_startup(event_2_thread);\n    }\n    else{\n        return -1;\n    }\n}\n\n\n\n\n/* receive envet thread */\nstatic void event_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_uint32_t e;\n\n        // if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        // {\n        //  rt_kprintf(\"thread1: [AND] recv event 0x%x\\n\", &e);\n        // }\n        // rt_kprintf(\"thread1: delay 1s to prepare the second event\\n\");\n        // rt_thread_delay(1000);\n\n        if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        {\n            rt_kprintf(\"thread1: [OR] recv event 0x%x\\n\", &e);\n        }\n\n        rt_kprintf(\"thread1 leave.\\n\");\n    }\n}\n\n/* send event thread */\nstatic void event_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_kprintf(\"thread_2 is send event[3]\\n\");\n        rt_event_send(event1, FLAG3);\n        rt_thread_delay(500);\n\n        rt_kprintf(\"thread_2 is send event[5]\\n\");\n        rt_thread_delay(1800);\n        rt_event_send(event1, FLAG5);\n        rt_kprintf(\"thread2 leave.\\n\");\n        }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程同步(event)/index.html#个人理解",
    "href": "posts/stm32F103-RT-Thread线程同步(event)/index.html#个人理解",
    "title": "stm32F103-RT-Thread线程同步(event)",
    "section": "",
    "text": "event是不同线程间满足条件时的控制块(比较适合多flag和多线程的情况) mutex访问单独的临界资源 semaphore访问多个临界资源 &gt; 线程1接收event,查看其中的flag是否满足设置的条件 &gt; 线程2发送flag1,flag2\n#include \"board.h\"\n#include \"rtthread.h\"\n\n#define FLAG3  1&lt;&lt;3\n#define FLAG5  1&lt;&lt;5\nstatic rt_event_t event1 = NULL;\nstatic rt_thread_t event_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t event_2_thread = RT_NULL;                // semaphore thread_2 control block\n\n\n\nstatic void event_thread_1_entry(void *parmaeter);\nstatic void event_thread_2_entry(void *parmaeter);\n\n\n\n\nint main(void)\n{\n    event1 = rt_event_create(\"flag\", RT_IPC_FLAG_FIFO);\n\n    event_1_thread = rt_thread_create(\"event_1_thread\", event_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (event_1_thread!= RT_NULL){\n        \n        rt_thread_startup(event_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    event_2_thread = rt_thread_create(\"metux_2_thread\", event_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (event_2_thread!= RT_NULL){\n        \n        rt_thread_startup(event_2_thread);\n    }\n    else{\n        return -1;\n    }\n}\n\n\n\n\n/* receive envet thread */\nstatic void event_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_uint32_t e;\n\n        // if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        // {\n        //  rt_kprintf(\"thread1: [AND] recv event 0x%x\\n\", &e);\n        // }\n        // rt_kprintf(\"thread1: delay 1s to prepare the second event\\n\");\n        // rt_thread_delay(1000);\n\n        if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        {\n            rt_kprintf(\"thread1: [OR] recv event 0x%x\\n\", &e);\n        }\n\n        rt_kprintf(\"thread1 leave.\\n\");\n    }\n}\n\n/* send event thread */\nstatic void event_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_kprintf(\"thread_2 is send event[3]\\n\");\n        rt_event_send(event1, FLAG3);\n        rt_thread_delay(500);\n\n        rt_kprintf(\"thread_2 is send event[5]\\n\");\n        rt_thread_delay(1800);\n        rt_event_send(event1, FLAG5);\n        rt_kprintf(\"thread2 leave.\\n\");\n        }\n}"
  },
  {
    "objectID": "posts/check_shell/index.html",
    "href": "posts/check_shell/index.html",
    "title": "how to set and check shell of linux",
    "section": "",
    "text": "show current shell, assign shell to user, view all shells"
  },
  {
    "objectID": "posts/check_shell/index.html#show-all",
    "href": "posts/check_shell/index.html#show-all",
    "title": "how to set and check shell of linux",
    "section": "show all",
    "text": "show all\ncat /etc/shells"
  },
  {
    "objectID": "posts/check_shell/index.html#view-current-shell",
    "href": "posts/check_shell/index.html#view-current-shell",
    "title": "how to set and check shell of linux",
    "section": "view current shell",
    "text": "view current shell\necho $SHELL"
  },
  {
    "objectID": "posts/check_shell/index.html#assign-shell-to-which-user",
    "href": "posts/check_shell/index.html#assign-shell-to-which-user",
    "title": "how to set and check shell of linux",
    "section": "assign shell to which user",
    "text": "assign shell to which user\nusermod -s /bin/zsh USERNAME"
  },
  {
    "objectID": "posts/java多线程-- Runnable接口实现多线程网图下载/index.html",
    "href": "posts/java多线程-- Runnable接口实现多线程网图下载/index.html",
    "title": "java多线程– Runnable接口实现多线程网图下载",
    "section": "",
    "text": "Runnable接口实现多线程\npackage cn.usts.edu.lesson01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * Runnable接口实现多线程\n * 推荐使用Runnable接口,因为继承Thread的话一个类只能继承一个类\n * thread的底层就是实现了Runnable接口【class Thread implements Runnable 】\n * */\npublic class RunnableDemo implements Runnable {\n    String file;\n    String url;\n    String filename;\n\n    public RunnableDemo(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public void run() {\n        ImageDownload2 imageDownload = new ImageDownload2();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n    }\n\n    public static void main(String[] args) {\n        RunnableDemo t1 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        RunnableDemo t2 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        RunnableDemo t3 = new RunnableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        // 新建线程\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    }\n}\n\nclass ImageDownload2 {\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- CopyOnWriteArrayList/index.html",
    "href": "posts/java多线程-- CopyOnWriteArrayList/index.html",
    "title": "java多线程– CopyOnWriteArrayList",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson07;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * 测试jdk内置的安全集合\n * */\n\npublic class CopyOnWriteArrayListDemo {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) {\n            new Thread(()-&gt;{\n                list.add(Thread.currentThread().getName()   );\n            }).start();\n        }\n\n        try {\n            Thread.sleep(1000); // 等待线程结束\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());// 打印list长度\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- CopyOnWriteArrayList/index.html#测试jdk内置的安全集合",
    "href": "posts/java多线程-- CopyOnWriteArrayList/index.html#测试jdk内置的安全集合",
    "title": "java多线程– CopyOnWriteArrayList",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson07;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * 测试jdk内置的安全集合\n * */\n\npublic class CopyOnWriteArrayListDemo {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) {\n            new Thread(()-&gt;{\n                list.add(Thread.currentThread().getName()   );\n            }).start();\n        }\n\n        try {\n            Thread.sleep(1000); // 等待线程结束\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());// 打印list长度\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--Swing [ icon ]画一个icon/index.html",
    "href": "posts/javaGUI--Swing [ icon ]画一个icon/index.html",
    "title": "javaGUI–Swing [ icon ]画一个icon",
    "section": "",
    "text": "画出一个icon icon可以放在标签上也可以放在按钮上,但是 大多数情况是放的图片\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JIconDemo extends JFrame implements Icon {\n    // 设置icon宽高\n    private int width,height;\n\n    // 全参构造\n    public JIconDemo(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    // 无参构造\n    public JIconDemo()  {\n    }\n\n    public void init(){\n        JIconDemo jIconDemo = new JIconDemo(20,20);\n        // 图标可以放按钮上也可以放标签上\n        JLabel jLabel = new JLabel(\"iconDemo\",jIconDemo,SwingConstants.CENTER);\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        Container container = this.getContentPane();\n        container.add(jLabel);\n\n    }\n\n\n    public static void main(String[] args) {\n        new JIconDemo().init();\n    }\n\n    // 画icon\n    @Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n        g.fillOval(x,y,width,height);\n    }\n\n    @Override\n    public int getIconWidth() {\n        return this.width;\n    }\n\n    @Override\n    public int getIconHeight() {\n        return this.height;\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- thread.setPriority() 线程优先级/index.html",
    "href": "posts/java多线程-- thread.setPriority() 线程优先级/index.html",
    "title": "java多线程– thread.setPriority() 线程优先级",
    "section": "",
    "text": "不设置优先级,默认为 5\n\n先设置,在启动!!!!\n优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 线程优先级\n * 不设置优先级,默认为 5   \n * 先设置,在启动!!!!\n * \n * 优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n * */\npublic class ThreadPriorityDemo implements Runnable{\n    @Override\n    public void run() {\n        // 打印       线程名----线程优先级\n        System.out.println(Thread.currentThread().getName()+\"-----\"+Thread.currentThread().getPriority());\n\n    }\n\n    // 主线程\n    public static void main(String[] args) {\n        ThreadPriorityDemo threadPriorityDemo = new ThreadPriorityDemo();\n        Thread t1 = new Thread(threadPriorityDemo,\"A\");\n        Thread t2 = new Thread(threadPriorityDemo,\"B\");\n        Thread t3 = new Thread(threadPriorityDemo,\"C\");\n        Thread t4 = new Thread(threadPriorityDemo,\"D\");\n        Thread t5 = new Thread(threadPriorityDemo,\"E\");\n        Thread t6 = new Thread(threadPriorityDemo,\"F\");\n        Thread t7 = new Thread(threadPriorityDemo,\"G\");\n\n        t1.start();//不设置优先级,默认为 5   先设置,在启动!!!!\n\n        t2.setPriority(2);\n        t2.start();\n\n        t3.setPriority(3);\n        t3.start();\n\n        t4.setPriority(4);\n        t4.start();\n\n        t5.setPriority(5);\n        t5.start();\n\n        t6.setPriority(6);\n        t6.start();\n\n        t7.setPriority(Thread.MAX_PRIORITY); // MAX_PRIORITY=10\n        t7.start();\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/java多线程-- thread.setPriority() 线程优先级/index.html#线程优先级",
    "href": "posts/java多线程-- thread.setPriority() 线程优先级/index.html#线程优先级",
    "title": "java多线程– thread.setPriority() 线程优先级",
    "section": "",
    "text": "不设置优先级,默认为 5\n\n先设置,在启动!!!!\n优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 线程优先级\n * 不设置优先级,默认为 5   \n * 先设置,在启动!!!!\n * \n * 优先级只是相对的,大概率下是优先级高的先执行,不是一定先执行\n * */\npublic class ThreadPriorityDemo implements Runnable{\n    @Override\n    public void run() {\n        // 打印       线程名----线程优先级\n        System.out.println(Thread.currentThread().getName()+\"-----\"+Thread.currentThread().getPriority());\n\n    }\n\n    // 主线程\n    public static void main(String[] args) {\n        ThreadPriorityDemo threadPriorityDemo = new ThreadPriorityDemo();\n        Thread t1 = new Thread(threadPriorityDemo,\"A\");\n        Thread t2 = new Thread(threadPriorityDemo,\"B\");\n        Thread t3 = new Thread(threadPriorityDemo,\"C\");\n        Thread t4 = new Thread(threadPriorityDemo,\"D\");\n        Thread t5 = new Thread(threadPriorityDemo,\"E\");\n        Thread t6 = new Thread(threadPriorityDemo,\"F\");\n        Thread t7 = new Thread(threadPriorityDemo,\"G\");\n\n        t1.start();//不设置优先级,默认为 5   先设置,在启动!!!!\n\n        t2.setPriority(2);\n        t2.start();\n\n        t3.setPriority(3);\n        t3.start();\n\n        t4.setPriority(4);\n        t4.start();\n\n        t5.setPriority(5);\n        t5.start();\n\n        t6.setPriority(6);\n        t6.start();\n\n        t7.setPriority(Thread.MAX_PRIORITY); // MAX_PRIORITY=10\n        t7.start();\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/javaGUI--Swing之[Dialog]弹窗/index.html",
    "href": "posts/javaGUI--Swing之[Dialog]弹窗/index.html",
    "title": "javaGUI–Swing之[Dialog]弹窗",
    "section": "",
    "text": "package cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class JDialogDemo extends JFrame {\n\n    JButton button01,button02,button03;\n\n    public JDialogDemo() {\n        this.setBounds(200,200,400,200);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 获取容器\n        Container container = this.getContentPane();\n        // 绝对布局\n        container.setLayout(null);\n\n        // 按钮\n        button01 = new JButton(\"点击弹出一个对话框\");\n        button01.setBounds(30,30,200,50);\n\n        // 按钮监听\n        button01.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // 弹窗\n                new MyDialogDemo();\n            }\n        });\n\n        this.add(button01);// 添加组件\n    }\n\n    public static void main(String[] args) {\n        new JDialogDemo();\n    }\n}\n\nclass MyDialogDemo extends JDialog{\n    public MyDialogDemo() {\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setTitle(\"hello\");\n        Container container = this.getContentPane();\n        container.setLayout(null);\n\n        JLabel jLabel = new JLabel(\"我的第一个弹窗\");\n        jLabel.setBounds(10,10,100,20);// label需要设置大小才能看的到\n        \n        container.add(jLabel);\n    }\n}"
  },
  {
    "objectID": "posts/jdbc-- 批处理/index.html",
    "href": "posts/jdbc-- 批处理/index.html",
    "title": "jdbc– 批处理",
    "section": "",
    "text": "## 批处理结果[效果明显]"
  },
  {
    "objectID": "posts/jdbc-- 批处理/index.html#未批处理结果",
    "href": "posts/jdbc-- 批处理/index.html#未批处理结果",
    "title": "jdbc– 批处理",
    "section": "",
    "text": "## 批处理结果[效果明显]"
  },
  {
    "objectID": "posts/jdbc-- 批处理/index.html#未进行批处理",
    "href": "posts/jdbc-- 批处理/index.html#未进行批处理",
    "title": "jdbc– 批处理",
    "section": "未进行批处理",
    "text": "未进行批处理\npublic static void main(String[] args) throws IOException, SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n        String sql = \"INSERT INTO `persons`.`admin`(`amin`, `psd`) VALUES (?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n        for (int i = 0; i &lt; 5000; i++) {\n\n            preparedStatement.setString(1,\"root\");\n            preparedStatement.setString(2,\"456456\");\n            // 执行\n            preparedStatement.executeUpdate();\n\n        }\n        // 关闭\n        preparedStatement.close();\n        connection.close();\n\n\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n\n\n    }"
  },
  {
    "objectID": "posts/jdbc-- 批处理/index.html#批处理",
    "href": "posts/jdbc-- 批处理/index.html#批处理",
    "title": "jdbc– 批处理",
    "section": "批处理",
    "text": "批处理\npublic static void main(String[] args) throws IOException, SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n        String sql = \"INSERT INTO `persons`.`admin`(`amin`, `psd`) VALUES (?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        for (int i = 0; i &lt; 5000; i++) {\n\n            preparedStatement.setString(1,\"root\");\n            preparedStatement.setString(2,\"789\");\n\n            // 添加到batch中\n            preparedStatement.addBatch();\n            if ((i+1)%1000==0){\n                preparedStatement.executeBatch();// 执行batch中的语句\n                preparedStatement.clearBatch();// 清空batch,准备下一轮的接收\n            }\n\n        }\n        // 关闭\n        preparedStatement.close();\n        connection.close();\n\n\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n\n\n    }"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "href": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "title": "stm32F103-RT-Thread动态内存分配",
    "section": "",
    "text": "打开动态内存分配\n # 设置线程句柄\n/* 定义线程控制块 */\nstatic rt_thread_t led1_thread = RT_NULL;\n\n\n设置线程入口函数\n// 声明\nstatic void led1_thread_entry(void *parameter);\n// 实现\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\n\n设置动态内存分配并启动\n// 设置线程参数\nled1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n/* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\nmain.c\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n    }\n}\n\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include &lt;rthw.h&gt;\n#include &lt;rtthread.h&gt;\n\n\n\n\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n   \n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}"
  },
  {
    "objectID": "posts/Cygwin使用：配置c环境/index.html",
    "href": "posts/Cygwin使用：配置c环境/index.html",
    "title": "Cygwin使用：配置c环境",
    "section": "",
    "text": "需要安装如下包 http://www.cygwin.com/setup-x86_64.exe 一路next，到选镜像的时候选一下 接下来安装如下包，点击next \nmingw64-i686-gcc-core 9.2.0-2 mingw64-i686-gcc-debuginfo 9.2.0-2 mingw64-i686-gcc-fortran 9.2.0-2 mingw64-i686-gcc-g++ 9.2.0-2 mingw64-i686-gcc-objc 9.2.0-2\nmingw64-x86_64-gcc-core 9.2.0-2 mingw64-x86_64-gcc-debuginfo 9.2.0-2 mingw64-x86_64-gcc-fortran 9.2.0-2 mingw64-x86_64-gcc-g++ 9.2.0-2 mingw64-x86_64-gcc-objc 9.2.0-2  参考：https://blog.csdn.net/lvsehaiyang1993/article/details/81027399"
  },
  {
    "objectID": "posts/javaGUI-- 鼠标监听/index.html",
    "href": "posts/javaGUI-- 鼠标监听/index.html",
    "title": "javaGUI– 鼠标监听",
    "section": "",
    "text": "通过监听鼠标位置,实现点击画点 \npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n// 鼠标监听事件\npublic class TestMouseListener {\n    public static void main(String[] args) {\n        new MouseListenerFrame(\"鼠标监听\");\n    }\n\n}\n\nclass MouseListenerFrame extends Frame{\n    ArrayList points;// 设置一个集合用来存储目鼠标点击的位置\n\n    public MouseListenerFrame(String title){\n        super(title);\n        setBounds(100,100,800,800);\n        setVisible(true);\n\n        // 记录下的点位\n        points = new ArrayList&lt;&gt;();\n\n        // 鼠标监听\n        this.addMouseListener(new MyMouseListener());\n        // 窗口监听\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n\n    // 重写画笔方法\n    @Override\n    public void paint(Graphics g) {\n        // 画画,监听鼠标事件\n        Iterator iterator = points.iterator(); // 转可迭代对象\n        while (iterator.hasNext()){\n            Point point = (Point)iterator.next();\n            g.setColor(Color.orange); // 设置颜色\n            g.fillOval(point.x,point.y,10,10);// 获取点的位置,每个位置画出一个10*10的实心圆\n        }\n\n    }\n\n    // 添加一个点到界面上\n    public void addPoint(Point point){\n        points.add(point);\n    }\n\n    private class MyMouseListener extends MouseAdapter{\n        @Override\n        public void mousePressed(MouseEvent e) {\n            // 获取调用鼠标资源的对象\n             MouseListenerFrame mouseListenerFrame = (MouseListenerFrame) e.getSource();\n             // 添加点的位置\n             mouseListenerFrame.addPoint(new Point(e.getX(),e.getY()));\n             // 鼠标每点击一次就刷新一次\n             mouseListenerFrame.repaint();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/设置Caps_Lock和Esc交换/index.html",
    "href": "posts/设置Caps_Lock和Esc交换/index.html",
    "title": "设置Caps_Lock和Esc交换",
    "section": "",
    "text": "设置Caps_Lock和Esc交换\nxmodmap xmodmap 的wiki\n\n\narch上直接在设置中就有, arch使用xmodmap还会冲突"
  },
  {
    "objectID": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html",
    "href": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html",
    "title": "Navicat中 int(0)表示什么【init（0）是什么意思】",
    "section": "",
    "text": "没有指定长度使用默认的设置，出现了int(0)的情况  ## 答案：\nin(0)表示的就是使用int默认的最大展示长度11位\n\n\n为什么是11位 (这里的11表示的是我们看到的11个位数)：\nMysql中int是4字节的\n有符号最大：-2,147,483,648 ~ +2,147,483,647    ( - 2^31^ ~ 2^32^-1)\n\n\n\n有符号数最小值:\n 值：   -   2   1   4   7   4   8   3   6    4   8\n 索引: [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11]    --共11位"
  },
  {
    "objectID": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html#新的问题",
    "href": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html#新的问题",
    "title": "Navicat中 int(0)表示什么【init（0）是什么意思】",
    "section": "",
    "text": "为什么是11位 (这里的11表示的是我们看到的11个位数)：\nMysql中int是4字节的\n有符号最大：-2,147,483,648 ~ +2,147,483,647    ( - 2^31^ ~ 2^32^-1)"
  },
  {
    "objectID": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html#位展示形式",
    "href": "posts/Navicat中 int(0)表示什么【init（0）是什么意思】/index.html#位展示形式",
    "title": "Navicat中 int(0)表示什么【init（0）是什么意思】",
    "section": "",
    "text": "有符号数最小值:\n 值：   -   2   1   4   7   4   8   3   6    4   8\n 索引: [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11]    --共11位"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "",
    "text": "创建一个固件库项目 参考:野火固件库创建  &gt;下载RT-Thread\n&gt;安装RT-Thread &gt;https://www.keil.com/dd2/pack/ &gt;"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.c",
    "text": "stm32f10x_it.c\n/* 存放终端函数 */\n#include \"stm32f10x_it.h\""
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.h",
    "text": "stm32f10x_it.h\n#ifndef __STM32F10x_IT_H\n#define __STM32F10x_IT_H\n\n\n#include \"stm32f10x.h\"\n\n\n\n#endif /* __STM32F10x_IT_H */"
  },
  {
    "objectID": "posts/cubeMX+RT_threa/index.html",
    "href": "posts/cubeMX+RT_threa/index.html",
    "title": "cubeMX+RT_threa",
    "section": "",
    "text": "打开调试\n # 使用外部高速时钟 \n\n\n配置时钟主频为72M\n # 添加RT-Thread   # 添加rt_thread进入工程  # 关闭系统默认时钟,默认中断\n # 配置串口输出 \n\n\n打开usart中断\n # 配置LED引脚  # 配置项目信息(Project-Manager)   # 重定向printf到串口输出  # 修改系统时钟+闪灯程序  # 配置仿真器   \n\n\n编译+烧录"
  },
  {
    "objectID": "posts/gcc_not_0x8048000_is_0x1060/index.html",
    "href": "posts/gcc_not_0x8048000_is_0x1060/index.html",
    "title": "gcc entry point is 0x1600 not 0x08048000",
    "section": "",
    "text": "Abstract\ngcc 直接链接，输出的位置是0x1060不是0x08048000\n\n\n\nReferance\ngcc 手册：man gcc\nStackOverflow： https://stackoverflow.com/questions/66361767/why-does-not-entry-point-address-start-at-0x400000\n\n\n解决方案\n该问题是 gcc默认的动态链接地址，使用gcc -no-pie 即可解决问题, 默认是64位, 可以直接通过-32指定32位"
  },
  {
    "objectID": "posts/app爬虫--持续更新/index.html",
    "href": "posts/app爬虫--持续更新/index.html",
    "title": "app爬虫–持续更新",
    "section": "",
    "text": "今天开始自己一直想做的项目:\n    - 之前稀里糊涂学了些爬虫的技术\n    - 一直没有做过像样的项目\n    - 现开始做一个可视化的项目\n# 项目技术栈\n    - qt\n    - httpx\n    - 安卓逆向\n    -"
  },
  {
    "objectID": "posts/app爬虫--持续更新/index.html#charles手机代理抓包配置",
    "href": "posts/app爬虫--持续更新/index.html#charles手机代理抓包配置",
    "title": "app爬虫–持续更新",
    "section": "charles手机代理抓包配置",
    "text": "charles手机代理抓包配置\n配置手机代理抓包参考: https://www.jianshu.com/p/551711c121f0\n存在问题:开启手机代理后, pc无法上网, 后期修复  ## 出现的原因是因为电脑没有信任charles的代理,需要为电脑安装证书\nhelp-&gt;ssl pinning root\nwin+r-&gt;mmc-&gt;添加或删除-&gt;证书-&gt;中间机构颁发-&gt;charles proxy-&gt;复制-&gt;信任证书-&gt;粘贴-&gt;重启"
  },
  {
    "objectID": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html",
    "href": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html",
    "title": "Linux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))",
    "section": "",
    "text": "E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)\nE: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#问题描述",
    "href": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#问题描述",
    "title": "Linux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))",
    "section": "",
    "text": "E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)\nE: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#解决方法",
    "href": "posts/Linux _ Ubuntu18解决(无法获得锁 _var_lib_dpkg_lock - open (11_ 资源暂时不可用))/index.html#解决方法",
    "title": "Linux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))",
    "section": "解决方法：",
    "text": "解决方法：\n删掉这两个文件即可\nsudo rm /var/cache/apt/archives/lock  \nsudo rm /var/lib/dpkg/lock"
  },
  {
    "objectID": "posts/stm32_add_dsp/index.html",
    "href": "posts/stm32_add_dsp/index.html",
    "title": "stm32 add dsp",
    "section": "",
    "text": "Abstract\nstm32 add dsp, add with 2 functions\n\nadd with cubeMx(lib)\nadd with MDK(sourceCode)\n\nrecommand function is function 2.\n\n\nReferance\ndsp api sheet: D:/environment/Arm/Packs/ARM/CMSIS/5.8.0/CMSIS/Documentation/DSP/html/index.html\nvideo\narticle\n\n\ncreate project whit cubeMx\ncreate base configure then open with keil\n\n\nadd dsp\n\n then you need to remove this item\n\nif you not delete this you will see like this\n\ntoo many errors\n\n\nthen add the arm_math.h to which file you want to add . don't need to add Macro ARM_MATH_CMx can use is directly. this time reduced about 34% than matlab coder.\n// arm 通过输入的参数类型将fft分为2大类[real,complex]分别对应的函数名为:\n// arm_rfft_xxxx\n// arm_cfft_xxxx\n\nfloat32_t output[128];\nfloat32_t input[128];\n\n// 初始化FFT状态\narm_rfft_fast_instance_f32 fft_inst;\narm_rfft_fast_init_f32(&fft_inst, 128);\n\n// 执行FFT\narm_rfft_fast_f32(&fft_inst, input, output,0);\n\n\nOther\n Wrong method, don’t see below this line \n\n\n\nadd macro\n,ARM_MATH_CM4//H7是CM7，F4是CM4，F1是CM3\n\n\nuse dsp\n#include \"arm_math.h\"\n#include \"arm_const_structs.h\"\n\n\nbuild\nyou need to  rebuild  not build\nif you see like this means you succesfull\n\nthere are many warnings, don’t care this this means lack of an empty line"
  },
  {
    "objectID": "posts/java多线程-- join(线程插队,优先执行)/index.html",
    "href": "posts/java多线程-- join(线程插队,优先执行)/index.html",
    "title": "java多线程– join(线程插队,优先执行)",
    "section": "",
    "text": "使用join方法\n测试再main主线程执行的过程中 强行插入B线程\n测试结果是 main线程执行过程中,添加B线程,等待B线程执行完毕后,main线程接着执行\n一定要是这个顺序,\nthread.start();\nthread.join();\n注意start()和join的位置.很关键 \n\npackage cn.usts.edu.lesson06;\n\n/**\n * 使用join方法\n * 测试再main主线程执行的过程中  强行插入B线程\n *\n * 测试结果是 main线程执行过程中,添加B线程,等待B线程执行完毕后,main线程接着执行\n * \n * 一定要是这个顺序,\n * thread.start();\n * thread.join();\n * 注意start()和join的位置.很关键\n * */\n\npublic class ThreadJoinDemo implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 20; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadJoinDemo threadJoinDemo = new ThreadJoinDemo();\n        Thread thread = new Thread(threadJoinDemo,\"B线程\");\n\n        for (int i = 0; i &lt; 200; i++) {\n            if (i==100){\n                    thread.start();// 线程启动\n                    thread.join();// 线程加入,main线程阻塞.等待B线程执行结束\n            }\n            System.out.println(\"main线程\"+i);\n        }\n    }\n}"
  },
  {
    "objectID": "posts/nb_iot_bc26_tencent_ali/index.html",
    "href": "posts/nb_iot_bc26_tencent_ali/index.html",
    "title": "how to use bc26 with tencent&ali iot platform",
    "section": "",
    "text": "Abstract\nThis is a topic related to the Internet of Things and related technologies. NB-IoT is a low-power, wide-area coverage communication technology for the Internet of Things, while the BC260 module is a hardware device that supports NB-IoT communication. Tencent IoT Platform and Alibaba Cloud IoT Platform are two major IoT cloud platforms that provide functions such as IoT device access, data storage, and processing. With these keywords, it can be seen that the topic is discussing how to connect NB-IoT devices to IoT cloud platforms to achieve IoT applications.\n\n\nReferance\nBC260Y MQTT 指令 腾讯云 (发送的数据格式)物模型协议 BC260Y-CN AT 命令手册 善学坊温湿度采集教程 善学坊nb-iot教程\n\n\nhow to read the AT datasheet\nAT+QMTCONN=&lt;TCP_connectID&gt;,&lt;clientID&gt;[,&lt;username&gt;[,&lt;password&gt;]]\n\n- []内的参数为可选参数, 可以填也可以不填写\n\nEp:\n    AT+QMTCONN= &lt;TCP_connectID&gt;,   &lt;clientID&gt;    [,&lt;username&gt;                                      [,&lt;password&gt;]]        \n    AT+QMTCONN=       0,           \"device22\",\n    AT+QMTCONN=       0,           \"sensor01\",   \"03P1H9CN2Esensor01;12010126;6PD93;1970357231\",     \"0a79340c5ccf7121b4e49b3f2089adf259b579ebc10ee9fa8a36202d15b86399;hmacsha256\"\n\n\ntest script\nqcom可以去善学坊的资料里面找 &gt;https://pan.baidu.com/s/1oFpSJltDWPtv1Uuszk37Zg 密码：3n8u\n测试模块能否连接到网络, 其实默认会连接到网络, 如果有IP地址返回就说明可以联网, 但是测试卡除外,测试卡过期了依旧可以获取到ip地址,但是返回的网络连接结果是0,7 查看手册也不知道这个是什么结果.\n# 测试bc260是否和pc连接成功\nATI\n# 关闭睡眠模式\nAT+QSCLK=0\n# 查看是否打开全功能 1 表示打开\nAT+CFUN?\n# 查看手机卡号, 如果没有卡返回ERROR\nAT+CIMI\n# 查看绑定的运营商 3,5,8 联通, 电信, 移动\nAT+QBAND?\n# 设置所有频率3,5,8都扫描一遍, 这样就不用设置卡了, 连接可能有点慢\nAT+QBAND=0\n# 查看网络附着情况\nAT+CGATT?\n# 网络附着\nAT+CGATT=1\n# 查看IP地址\nAT+CGPADDR?\n# 查看网络获取的结果\nAT+CEREG?\n使用Qcom或者普通的串口助手都行.\n\n\n\nconfig Tencent-iot Platform\nhttps://console.cloud.tencent.com/iotexplorer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nauto update data\n\n\n\n可选: 虚拟设备调试\n\n\n打开腾讯连连或者微信扫码\n\n点击上报之前 \n点击上报之后\n\n\n到此软件模拟测试都ok, 接下来使用bc260y发送数据\n使用Qcom或者普通的串口助手发送AT指令\n\n新建设备 \n\n这里使用善学坊提供的mqtt 用户名和密码生成工具 也可以使用 腾讯官方脚本示范\n\n\n 将对应的数据填写到对应的位置, 点击生成后残生username和password待会发送的时候使用. \n一共发送5条指令\nAT+QMTOPEN=0,\"DN2HGX3J4C.iotcloud.tencentdevices.com\",1883\nAT+QMTCONN=0,\"device00\",\"DN2HGX3J4Cdevice00;12010126;VO8NZ;1970364699\",\"91dc0e02b637ba9771d0046da6b16f21b753ec6aaabcb63bc2901ff594c7ae14;hmacsha256\"\nAT+QMTPUB=0,1,1,0,\"$thing/up/property/DN2HGX3J4C/device00\"\n\n{\"method\":\"report\",\"clientToken\":\"123\",\"timestamp\":1628646783,\"params\":{\"temp\":25}}\n\n# 使用qcom的时候ctrl+z表示按照二进制发送和发送0x1a效果一致\n0x1a\nmqtt.c mqtt.h\n\n\n注意要点\n使用腾讯连连进行公众号消息推送时务必保证发送的数据格式正确，错误的数据格式可能会有显示，但是后台记录中会有报错信息，这将会导致公众号消息无法推送，使用虚拟设备调试没有问题。"
  },
  {
    "objectID": "posts/JDBC操作数据(以mysql为例)的5种常用方法/index.html",
    "href": "posts/JDBC操作数据(以mysql为例)的5种常用方法/index.html",
    "title": "JDBC操作数据(以mysql为例)的5种常用方法",
    "section": "",
    "text": "@description: jdbc的使用步骤\n             1.加载数据库驱动\n             2.通过DriverManager获取数据库连接\n             3.执行sql\n             4.释放连接\n\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: jdbc的使用步骤\n *                  1.加载数据库驱动\n *                  2.通过DriverManager获取数据库连接\n *                  3.执行sql\n *                  4.释放连接\n * @date ：2021/11/4 14:58\n */\npublic class JdbcDemo {\n    // 数据库连接方式1\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        // 1.加载数据库驱动\n        //Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver = new Driver();\n        // 2.获取数据库连接\n        // (1) jdbc:mysql 表示规定好的协议, 通过jdbc方式连接mysql\n        // (2) 3306: 表示数据库端口号\n        // (3) 127.0.0.1: 表示主机ip\n        // (4) mybatis: 表示mysql中的哪一个数据库\n        // (5) 数据库的本质连接就是socket连接\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        // (6) 用户名密码user和password是规定好的,不能写别的\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n\n        //3.执行sql\n        String sql = \"insert into persons.per value ('小明',2,18)\";\n        // 执行需要创建statement\n        Statement statement = connect.createStatement();\n        int rows = statement.executeUpdate(sql);// 返回生效行数\n        System.out.println(rows&gt;0 ? \"成功\":\"失败\");\n\n        //4.释放连接\n        statement.close();\n        connect.close();\n    }\n\n    // 数据库连接方式2   动态加载更灵活\n    @Test\n    public void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");// 动态加载类\n        Driver driver = (Driver)aClass.newInstance();\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n        System.out.println(\"方式2\"+connect);\n\n    }\n\n    // 方式3    DriverManager统一管理驱动\n    @Test\n    public void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);//注册驱动\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接3==\"+connection);\n        connection.close();\n    }\n\n    // 方式4    DriverManager统一管理驱动\n    @Test\n    public void connect04() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接4==\"+connection);\n        connection.close();\n    }\n\n    // 方式5    DriverManager统一管理驱动\n    @Test\n    public void connect05() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n//        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");  // jdbc4+ 和 mysql5.1.6+ 就会自动到驱动包里自动加载驱动名,不过还是建议加上!!!\n//        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接5==\"+connection);\n        connection.close();\n    }\n}"
  },
  {
    "objectID": "posts/JDBC操作数据(以mysql为例)的5种常用方法/index.html#jdbc操作数据以mysql为例的5种常用方法",
    "href": "posts/JDBC操作数据(以mysql为例)的5种常用方法/index.html#jdbc操作数据以mysql为例的5种常用方法",
    "title": "JDBC操作数据(以mysql为例)的5种常用方法",
    "section": "",
    "text": "@description: jdbc的使用步骤\n             1.加载数据库驱动\n             2.通过DriverManager获取数据库连接\n             3.执行sql\n             4.释放连接\n\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: jdbc的使用步骤\n *                  1.加载数据库驱动\n *                  2.通过DriverManager获取数据库连接\n *                  3.执行sql\n *                  4.释放连接\n * @date ：2021/11/4 14:58\n */\npublic class JdbcDemo {\n    // 数据库连接方式1\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        // 1.加载数据库驱动\n        //Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver = new Driver();\n        // 2.获取数据库连接\n        // (1) jdbc:mysql 表示规定好的协议, 通过jdbc方式连接mysql\n        // (2) 3306: 表示数据库端口号\n        // (3) 127.0.0.1: 表示主机ip\n        // (4) mybatis: 表示mysql中的哪一个数据库\n        // (5) 数据库的本质连接就是socket连接\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        // (6) 用户名密码user和password是规定好的,不能写别的\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n\n        //3.执行sql\n        String sql = \"insert into persons.per value ('小明',2,18)\";\n        // 执行需要创建statement\n        Statement statement = connect.createStatement();\n        int rows = statement.executeUpdate(sql);// 返回生效行数\n        System.out.println(rows&gt;0 ? \"成功\":\"失败\");\n\n        //4.释放连接\n        statement.close();\n        connect.close();\n    }\n\n    // 数据库连接方式2   动态加载更灵活\n    @Test\n    public void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");// 动态加载类\n        Driver driver = (Driver)aClass.newInstance();\n        String url = \"jdbc:mysql://localhost:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connect = driver.connect(url, properties);\n        System.out.println(\"方式2\"+connect);\n\n    }\n\n    // 方式3    DriverManager统一管理驱动\n    @Test\n    public void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);//注册驱动\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接3==\"+connection);\n        connection.close();\n    }\n\n    // 方式4    DriverManager统一管理驱动\n    @Test\n    public void connect04() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接4==\"+connection);\n        connection.close();\n    }\n\n    // 方式5    DriverManager统一管理驱动\n    @Test\n    public void connect05() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n//        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");  // jdbc4+ 和 mysql5.1.6+ 就会自动到驱动包里自动加载驱动名,不过还是建议加上!!!\n//        Driver driver =(Driver) aClass.newInstance();\n        // DriverManager.registerDriver(driver);//注册驱动  可以不用注册驱动,Driver的底层静态方法里有默认执行的注册\n\n        String url = \"jdbc:mysql://127.0.0.1:3306/persons\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"123321\");\n\n        Connection connection = DriverManager.getConnection(url, properties);// 建立连接\n        System.out.println(\"连接5==\"+connection);\n        connection.close();\n    }\n}"
  },
  {
    "objectID": "posts/stm32--io口拉高还是拉低/index.html",
    "href": "posts/stm32--io口拉高还是拉低/index.html",
    "title": "stm32–io口拉高还是拉低",
    "section": "",
    "text": "https://zhuanlan.zhihu.com/p/458067480\n1.2GPIO_Mode_IPD (Pull-down):\n输入下拉就是把电压拉低，拉到GND。与上拉原理相似。\n\n简单的说，如果你希望你的引脚平时处于高电平用于检测低电平，你就使用Pull-up。\n\n如果你希望你的引脚平时处于低电平用于检测高电平，你就使用Pull-down。\n\n按键未按下时端口接低电平，即低电平 0 状态---0v\n\n按键按下时端口接高电平，即高电平 1 状态------3.3v"
  },
  {
    "objectID": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "href": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "title": "win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）",
    "section": "",
    "text": "问题描述：\n直接点击了删除账户，导致系统无用户存在，重启系统完发现之前账户依旧存在，但是输入密码无法进入系统。 # 解决方案（进入windows自带的启动修复） 登录页面点击电源按钮（关机，重启，注销）选择重启（①在点击重启的同时点击键盘上的shift按键） ，将会进入到下面的界面 ### ①在点击重启的同时点击键盘上的shift按键 ### ②选择系统还原\n ### ③选择还原点\n ### ④windows11需要输入硬盘密码（登录微软账户查询密码：https://account.microsoft.com/devices/recoverykey?refd=account.microsoft.com）  ### 输入以上密钥后系统将进入还原点进行还原，等待系统重启即可恢复。"
  },
  {
    "objectID": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "href": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "title": "springMVC-设置日期时间对象【自定义日期时间格式】",
    "section": "",
    "text": "// 返回格式化日期对象\n    @RequestMapping(\"/json4\")\n    public String json4() throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        // 不使用时间戳的方式\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf);\n        // 设置 日期格式\n        mapper.setDateFormat(sdf);\n        Date date = new Date();\n        // 设置字符串对象\n        String str = mapper.writeValueAsString(date);\n        return str;\n    }\n}"
  },
  {
    "objectID": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html#如2021-08-12-225856",
    "href": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html#如2021-08-12-225856",
    "title": "springMVC-设置日期时间对象【自定义日期时间格式】",
    "section": "",
    "text": "// 返回格式化日期对象\n    @RequestMapping(\"/json4\")\n    public String json4() throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        // 不使用时间戳的方式\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf);\n        // 设置 日期格式\n        mapper.setDateFormat(sdf);\n        Date date = new Date();\n        // 设置字符串对象\n        String str = mapper.writeValueAsString(date);\n        return str;\n    }\n}"
  },
  {
    "objectID": "posts/charles安装激活/index.html",
    "href": "posts/charles安装激活/index.html",
    "title": "charles安装激活",
    "section": "",
    "text": "激活地址:https://www.charles.ren/ 打开防火墙, 否则会出现无法下载证书的问题"
  },
  {
    "objectID": "posts/webSocket-node -- 02 聊天室/index.html",
    "href": "posts/webSocket-node -- 02 聊天室/index.html",
    "title": "webSocket-node – 02 聊天室",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/webSocket-node -- 02 聊天室/index.html#聊天室架构",
    "href": "posts/webSocket-node -- 02 聊天室/index.html#聊天室架构",
    "title": "webSocket-node – 02 聊天室",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/spring整合SSM/index.html",
    "href": "posts/spring整合SSM/index.html",
    "title": "spring整合SSM",
    "section": "",
    "text": "CREATE DATABASE `ssmbuild`;\n\nUSE `ssmbuild`;\n\nDROP TABLE IF EXISTS `books`;\n\nCREATE TABLE `books` (\n`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',\n`bookName` VARCHAR(100) NOT NULL COMMENT '书名',\n`bookCounts` INT(11) NOT NULL COMMENT '数量',\n`detail` VARCHAR(200) NOT NULL COMMENT '描述',\nKEY `bookID` (`bookID`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES\n(1,'Java',1,'从入门到放弃'),\n(2,'MySQL',10,'从删库到跑路'),\n(3,'Linux',5,'从进门到进牢');"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#创建一个存放书籍数据的数据库表",
    "href": "posts/spring整合SSM/index.html#创建一个存放书籍数据的数据库表",
    "title": "spring整合SSM",
    "section": "",
    "text": "CREATE DATABASE `ssmbuild`;\n\nUSE `ssmbuild`;\n\nDROP TABLE IF EXISTS `books`;\n\nCREATE TABLE `books` (\n`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',\n`bookName` VARCHAR(100) NOT NULL COMMENT '书名',\n`bookCounts` INT(11) NOT NULL COMMENT '数量',\n`detail` VARCHAR(200) NOT NULL COMMENT '描述',\nKEY `bookID` (`bookID`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES\n(1,'Java',1,'从入门到放弃'),\n(2,'MySQL',10,'从删库到跑路'),\n(3,'Linux',5,'从进门到进牢');"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "href": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "title": "spring整合SSM",
    "section": "2.1新建一Maven项目！ssmbuild ， 添加web的支持",
    "text": "2.1新建一Maven项目！ssmbuild ， 添加web的支持"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "href": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "title": "spring整合SSM",
    "section": "2.2导入相关的pom依赖！",
    "text": "2.2导入相关的pom依赖！\n&lt;dependencies&gt;\n   &lt;!--Junit--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;junit&lt;/groupId&gt;\n       &lt;artifactId&gt;junit&lt;/artifactId&gt;\n       &lt;version&gt;4.12&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;!--数据库驱动--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;mysql&lt;/groupId&gt;\n       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n       &lt;version&gt;5.1.47&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;!-- 数据库连接池 --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;com.mchange&lt;/groupId&gt;\n       &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n       &lt;version&gt;0.9.5.2&lt;/version&gt;\n   &lt;/dependency&gt;\n\n   &lt;!--Servlet - JSP --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n       &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;\n       &lt;version&gt;2.5&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;\n       &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;\n       &lt;version&gt;2.2&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n       &lt;artifactId&gt;jstl&lt;/artifactId&gt;\n       &lt;version&gt;1.2&lt;/version&gt;\n   &lt;/dependency&gt;\n\n   &lt;!--Mybatis--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n       &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n       &lt;version&gt;3.5.2&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n       &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n       &lt;version&gt;2.0.2&lt;/version&gt;\n   &lt;/dependency&gt;\n\n   &lt;!--Spring--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n       &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n       &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;\n   \n   &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.16.22&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;RELEASE&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n&lt;/dependencies&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "href": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "title": "spring整合SSM",
    "section": "3、Maven资源过滤设置",
    "text": "3、Maven资源过滤设置\n静态资源没有导出记得加上\n&lt;build&gt;\n   &lt;resources&gt;\n       &lt;resource&gt;\n           &lt;directory&gt;src/main/java&lt;/directory&gt;\n           &lt;includes&gt;\n               &lt;include&gt;**/*.properties&lt;/include&gt;\n               &lt;include&gt;**/*.xml&lt;/include&gt;\n           &lt;/includes&gt;\n           &lt;filtering&gt;false&lt;/filtering&gt;\n       &lt;/resource&gt;\n       &lt;resource&gt;\n           &lt;directory&gt;src/main/resources&lt;/directory&gt;\n           &lt;includes&gt;\n               &lt;include&gt;**/*.properties&lt;/include&gt;\n               &lt;include&gt;**/*.xml&lt;/include&gt;\n           &lt;/includes&gt;\n           &lt;filtering&gt;false&lt;/filtering&gt;\n       &lt;/resource&gt;\n   &lt;/resources&gt;\n&lt;/build&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置包",
    "href": "posts/spring整合SSM/index.html#配置包",
    "title": "spring整合SSM",
    "section": "4、配置包",
    "text": "4、配置包\ncn.usts.pojo\n\ncn.usts.dao\n\ncn.usts.service\n\ncn.usts.controller"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "title": "spring整合SSM",
    "section": "5、mybatis-config.xml",
    "text": "5、mybatis-config.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration\n       PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n\n&lt;/configuration&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "href": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "title": "spring整合SSM",
    "section": "6、applicationContext.xml",
    "text": "6、applicationContext.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;/beans&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "href": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "title": "spring整合SSM",
    "section": "7、数据库配置文件 database.properties",
    "text": "7、数据库配置文件 database.properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&useUnicode=true&characterEncoding=utf8\njdbc.username=root\njdbc.password=123321"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#books.class",
    "href": "posts/spring整合SSM/index.html#books.class",
    "title": "spring整合SSM",
    "section": "8、Books.class",
    "text": "8、Books.class\npackage cn.usts.edu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Books {\n    private int bookID;\n    private String bookName;\n    private int bookCounts;\n    private String detail;\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper接口",
    "href": "posts/spring整合SSM/index.html#bookmapper接口",
    "title": "spring整合SSM",
    "section": "9、bookMapper接口",
    "text": "9、bookMapper接口\npackage cn.usts.edu.dao;\n\nimport cn.usts.edu.pojo.Books;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\npublic interface bookMapper {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook(@Param(\"bookId\") int id);\n    // 根据id查询一本书\n    Books queryBook(@Param(\"bookId\") int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List&lt;Books&gt; queryAllBooks();\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper.xml",
    "href": "posts/spring整合SSM/index.html#bookmapper.xml",
    "title": "spring整合SSM",
    "section": "10、bookMapper.xml",
    "text": "10、bookMapper.xml\nPUBLIC “-//mybatis.org//DTD mapper 3.0//EN”别写错了\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"cn.usts.edu.dao.bookMapper\"&gt;\n    &lt;insert id=\"addBook\" parameterType=\"Books\"&gt;\n        insert into ssmbuild.books(bookName, bookCounts, detail)\n        values(#{bookName},#{bookCounts},#{detail});\n    &lt;/insert&gt;\n\n    &lt;delete id=\"deleteBook\" parameterType=\"int\"&gt;\n        delete from ssmbuild.books where bookID=#{bookId};\n    &lt;/delete&gt;\n\n    &lt;update id=\"updateBook\" parameterType=\"Books\"&gt;\n        update ssmbuild.books\n        set bookName=#{bookName},\n            bookCounts=#{bookCounts},\n            detail=#{detail}\n        where bookID=#{bookId};\n    &lt;/update&gt;\n\n    &lt;select id=\"queryBook\" parameterType=\"Books\"&gt;\n        select * from ssmbuild.books\n        where bookID=#{bookId};\n    &lt;/select&gt;\n\n    &lt;select id=\"queryAllBooks\" parameterType=\"Books\"&gt;\n        select * from ssmbuild.books;\n    &lt;/select&gt;\n&lt;/mapper&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "title": "spring整合SSM",
    "section": "11、绑定mapper【myBatis-config.xml】",
    "text": "11、绑定mapper【myBatis-config.xml】\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://www.mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;typeAliases&gt;\n        &lt;package name=\"cn.usts.edu.pojo\" /&gt;\n    &lt;/typeAliases&gt;\n\n&lt;!--    绑定mapper--&gt;\n    &lt;mappers&gt;\n        &lt;mapper class=\"cn/usts/edu/dao/bookMapper.xml\"/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n\n【文件结构】"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#编写service层",
    "href": "posts/spring整合SSM/index.html#编写service层",
    "title": "spring整合SSM",
    "section": "12、编写service层",
    "text": "12、编写service层\n12.1 BookService接口\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\n\n\nimport java.util.List;\n\npublic interface BookService {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook( int id);\n    // 根据id查询一本书\n    Books queryBook( int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List&lt;Books&gt; queryAllBooks();\n}\n12.2 BookServiceImp.class\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\nimport cn.usts.edu.dao.bookMapper;\nimport java.util.List;\n\npublic class BookServiceImp implements BookService {\n\n    // service层调用dao层\n    private bookMapper bookMapper;\n\n    public void setBookMapper(cn.usts.edu.dao.bookMapper bookMapper) {\n        this.bookMapper = bookMapper;\n    }\n\n    @Override\n    public int addBook(Books books) {\n        return bookMapper.addBook(books);\n    }\n\n    @Override\n    public int deleteBook(int id) {\n        return bookMapper.deleteBook(id);\n    }\n\n    @Override\n    public Books queryBook(int id) {\n        return bookMapper.queryBook(id);\n    }\n\n    @Override\n    public int updateBook(Books books) {\n        return bookMapper.updateBook(books);\n    }\n\n    @Override\n    public List&lt;Books&gt; queryAllBooks() {\n        return bookMapper.queryAllBooks();\n    }\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "href": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "title": "spring整合SSM",
    "section": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；",
    "text": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n&lt;!--    1、关联数据库配置--&gt;\n    &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt;\n    &lt;!--    2、连接池\n            dbcp,半自动化 不能自动连接\n            c3p0,自动化操作\n            druid,hikari\n    --&gt;\n    &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;\n        &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt;\n        &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt;\n        &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n    &lt;/bean&gt;\n&lt;!--    3、sqlSessionFactory--&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;!--        绑定mybatis配置文件--&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:myBatis-config.xml\"/&gt;\n    &lt;/bean&gt;\n\n&lt;!--  配置dao接口扫描包，动态的实现了dao接口可以注入到spring容器中  --&gt;\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;\n        &lt;property name=\"basePackage\" value=\"cn.usts.edu.dao\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring整合service层",
    "href": "posts/spring整合SSM/index.html#spring整合service层",
    "title": "spring整合SSM",
    "section": "14、Spring整合service层",
    "text": "14、Spring整合service层\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n&lt;!--    包扫描--&gt;\n    &lt;context:component-scan base-package=\"cn.usts.edu.service\"/&gt;\n&lt;!--    将所有业务类，注入到spring，可以通过配置，或者注解实现--&gt;\n    &lt;bean id=\"BookServiceImpl\" class=\"cn.usts.edu.service.BookServiceImp\"&gt;\n        &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt;\n    &lt;/bean&gt;\n    &lt;!-- 配置事务管理器 --&gt;\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n        &lt;!-- 注入数据库连接池 --&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#web.xml",
    "href": "posts/spring整合SSM/index.html#web.xml",
    "title": "spring整合SSM",
    "section": "15、web.xml",
    "text": "15、web.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\"&gt;\n&lt;!--    前端控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;srpingmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;srpingmvc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;!--    编码过滤器--&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;/param-name&gt;\n            &lt;param-value&gt;utf-8&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n&lt;!--    session过期时间 15min--&gt;\n    &lt;session-config&gt;\n        &lt;session-timeout&gt;15&lt;/session-timeout&gt;\n    &lt;/session-config&gt;\n&lt;/web-app&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "href": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "title": "spring整合SSM",
    "section": "16、spring-mvc.xml",
    "text": "16、spring-mvc.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;\n&lt;!--    包扫描--&gt;\n    &lt;context:component-scan base-package=\"cn.usts.edu.controller\"/&gt;\n&lt;!--    注解驱动--&gt;\n    &lt;mvc:annotation-driven/&gt;\n&lt;!--    默认静态资源过滤--&gt;\n    &lt;mvc:default-servlet-handler/&gt;\n&lt;!--    视图解析器--&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;\n        &lt;property name=\"suffix\" value=\".jsp\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n17、Spring配置整合文件，applicationContext.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n    &lt;import resource=\"classpath:spring-dao.xml\"/&gt;\n    &lt;import resource=\"classpath:spring-mvc.xml\"/&gt;\n    &lt;import resource=\"classpath:spring-service.xml\"/&gt;\n\n\n&lt;/beans&gt;"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#index.jsp",
    "href": "posts/spring整合SSM/index.html#index.jsp",
    "title": "spring整合SSM",
    "section": "18、 index.jsp",
    "text": "18、 index.jsp\n在这里插入代码片"
  },
  {
    "objectID": "posts/LNK1104错误_无法打开文件_xxx_lib/index.html",
    "href": "posts/LNK1104错误_无法打开文件_xxx_lib/index.html",
    "title": "LNK1104错误_无法打开文件xxx.lib_和查看所有宏定义$xxxx",
    "section": "",
    "text": "## 查看所有宏定义$xxxx"
  },
  {
    "objectID": "posts/LNK1104错误_无法打开文件_xxx_lib/index.html#vs-参数调整-lnk1104错误-无法打开文件xxx.lib",
    "href": "posts/LNK1104错误_无法打开文件_xxx_lib/index.html#vs-参数调整-lnk1104错误-无法打开文件xxx.lib",
    "title": "LNK1104错误_无法打开文件xxx.lib_和查看所有宏定义$xxxx",
    "section": "",
    "text": "## 查看所有宏定义$xxxx"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html",
    "href": "posts/shell脚本批量创建多个用户/index.html",
    "title": "shell脚本批量创建多个用户",
    "section": "",
    "text": "执行以下命令\nvim adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#创建.sh文件",
    "href": "posts/shell脚本批量创建多个用户/index.html#创建.sh文件",
    "title": "shell脚本批量创建多个用户",
    "section": "",
    "text": "执行以下命令\nvim adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "href": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "title": "shell脚本批量创建多个用户",
    "section": "2、编写shell代码",
    "text": "2、编写shell代码\n#! /bin/bash\n#filename:add_user\ni=1\ngroupadd user1\nwhile [ $i -le 20 ]\ndo\n        if [ $i -le 9 ]; then\n                USERNAME=student0${i}\n        else\n                USERNAME=student${i}\n        fi\n        useradd $USERNAME\n        mkdir /home/$USERNAME\n        chown -R $USERNAME /home/$USERNAME\n        chgrp -R user1 /home/$USERNAME\n        i=$(($i+1))\ndone"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "href": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "title": "shell脚本批量创建多个用户",
    "section": "3、赋权",
    "text": "3、赋权\nchmod u+x adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#执行",
    "href": "posts/shell脚本批量创建多个用户/index.html#执行",
    "title": "shell脚本批量创建多个用户",
    "section": "4、执行",
    "text": "4、执行\n创建用户需要管理员权限，需要加上sudo\nsudo ./adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "href": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "title": "shell脚本批量创建多个用户",
    "section": "99、运行结果",
    "text": "99、运行结果\n查看是否创建成功\ncat /etc/passwd\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html",
    "href": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html",
    "title": "java_TreeSet和HashSet的去重原理 (作业四)",
    "section": "",
    "text": "object对象没有办法使用String中的CompareTo(),会报错, treeSet中没有滴定仪Comparator,会默认使用String中的"
  },
  {
    "objectID": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html#treeset和hashset的去重原理-作业四",
    "href": "posts/java_TreeSet和HashSet的去重原理 (作业四)/index.html#treeset和hashset的去重原理-作业四",
    "title": "java_TreeSet和HashSet的去重原理 (作业四)",
    "section": "",
    "text": "object对象没有办法使用String中的CompareTo(),会报错, treeSet中没有滴定仪Comparator,会默认使用String中的"
  },
  {
    "objectID": "posts/linux ssh长时间无操作断连/index.html",
    "href": "posts/linux ssh长时间无操作断连/index.html",
    "title": "linux ssh长时间无操作断连",
    "section": "",
    "text": "修改 vim /etc/ssh/sshd_config\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "href": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "title": "stm32F103-RT-Thread– 互斥量(mutex)",
    "section": "",
    "text": "在编码前记得打开rtconfig.h中的IPC中的mutex设置 &gt; 互斥量访问的是同一个资源,且只可以有一个线程进行访问, 保证数据的一致性.\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\nstatic int count=0, num=0;\n\nstatic rt_mutex_t mutex = RT_NULL;\nstatic rt_thread_t mutex_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t mutex_2_thread = RT_NULL;                // semaphore thread_2 control block\nstatic rt_thread_t mutex_3_thread = RT_NULL;                // semaphore thread_2 control block\n\n\nstatic void mutex_thread_1_entry(void *parmaeter);\nstatic void mutex_thread_2_entry(void *parmaeter);\nstatic void mutex_thread_3_entry(void *parmaeter);\n\n\nint main(void)\n{\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_FIFO);\n    mutex_1_thread = rt_thread_create(\"mutex_1_thread\", mutex_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (mutex_1_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_2_thread = rt_thread_create(\"metux_2_thread\", mutex_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (mutex_2_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_2_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_3_thread = rt_thread_create(\"mutex3_thread\", mutex_thread_3_entry, RT_NULL,512, 3,20);\n    if(mutex_3_thread!=RT_NULL){\n        rt_thread_startup(mutex_3_thread);\n    }\n    else{\n        return -1;\n    }\n\n}\n\n\n\n\n/*this thread is release semaphore */\nstatic void mutex_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_1 count is [%d]\\n\",count);\n        rt_thread_delay(500);\n        num++;\n        rt_kprintf(\"thread_1 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);    \n    }\n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void mutex_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count--;\n        rt_kprintf(\"thread_2 count is [%d]\\n\",count);\n        rt_thread_delay(700);\n        num--;\n        rt_kprintf(\"thread_2 num is [%d]\\n\",num);   \n        rt_mutex_release(mutex);    \n    }\n}\n\nstatic void mutex_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_3 count is [%d]\\n\",count);\n        num++;\n        rt_kprintf(\"thread_3 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);\n    }   \n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html#互斥量mutex",
    "href": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html#互斥量mutex",
    "title": "stm32F103-RT-Thread– 互斥量(mutex)",
    "section": "",
    "text": "在编码前记得打开rtconfig.h中的IPC中的mutex设置 &gt; 互斥量访问的是同一个资源,且只可以有一个线程进行访问, 保证数据的一致性.\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\nstatic int count=0, num=0;\n\nstatic rt_mutex_t mutex = RT_NULL;\nstatic rt_thread_t mutex_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t mutex_2_thread = RT_NULL;                // semaphore thread_2 control block\nstatic rt_thread_t mutex_3_thread = RT_NULL;                // semaphore thread_2 control block\n\n\nstatic void mutex_thread_1_entry(void *parmaeter);\nstatic void mutex_thread_2_entry(void *parmaeter);\nstatic void mutex_thread_3_entry(void *parmaeter);\n\n\nint main(void)\n{\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_FIFO);\n    mutex_1_thread = rt_thread_create(\"mutex_1_thread\", mutex_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (mutex_1_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_2_thread = rt_thread_create(\"metux_2_thread\", mutex_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (mutex_2_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_2_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_3_thread = rt_thread_create(\"mutex3_thread\", mutex_thread_3_entry, RT_NULL,512, 3,20);\n    if(mutex_3_thread!=RT_NULL){\n        rt_thread_startup(mutex_3_thread);\n    }\n    else{\n        return -1;\n    }\n\n}\n\n\n\n\n/*this thread is release semaphore */\nstatic void mutex_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_1 count is [%d]\\n\",count);\n        rt_thread_delay(500);\n        num++;\n        rt_kprintf(\"thread_1 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);    \n    }\n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void mutex_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count--;\n        rt_kprintf(\"thread_2 count is [%d]\\n\",count);\n        rt_thread_delay(700);\n        num--;\n        rt_kprintf(\"thread_2 num is [%d]\\n\",num);   \n        rt_mutex_release(mutex);    \n    }\n}\n\nstatic void mutex_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_3 count is [%d]\\n\",count);\n        num++;\n        rt_kprintf(\"thread_3 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);\n    }   \n}"
  },
  {
    "objectID": "posts/github全局加速下载/index.html",
    "href": "posts/github全局加速下载/index.html",
    "title": "github全局加速下载",
    "section": "",
    "text": "git config –global url.”https://gitclone.com/“.insteadOf https://"
  },
  {
    "objectID": "posts/汇编--00安装dosBox/index.html",
    "href": "posts/汇编--00安装dosBox/index.html",
    "title": "汇编–00安装dosBox",
    "section": "",
    "text": "官网下载dosBox软件后无法debug\n缺少asmtools,创建好asm文件夹,将下载的文件都放入创建的文件夹中. https://jszhuanben.lanzoui.com/i2H5dtq5qab\n配置启动时执行的命令:\n1# dosBox配置文件路径\nC:\\Users\\msi\\AppData\\Local\\DOSBox\n2# 在最后添加\nmount C: F:\\asm\nC:\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/git_advance/index.html",
    "href": "posts/git_advance/index.html",
    "title": "git advanced operate",
    "section": "",
    "text": "Abstract\nlearn some advanced operate of git, make manage code easily\n\n\nReferance\nhttps://learngitbranching.js.org/\n\n\nHEAD\nthis can jump to which commit, you can get the log of per commit log.\ngit log\n\ngit checkout HASH\n\n# previous one of HEAD\ngit checkout HEAD^\n\n# previous x of HEAD\ngit checkout ~n\n\n\nrevert &reset\nrevert is for  remot \ngit revert BRANCH\ngit revert HEAD\nreset is for  local \ngit reset HEAD~1\ngit reset BRANCH^\n\n\ncherry-pick\ncopy the select scope commit to current BRANCH(HEAD)\ngit cherry-pick HASH_1 HASH_2\n\ngit cherry-pick c1 c2\n\n\ninteractive rebase\nyou can choose rebase branch with ui\nreabse default to current branch(HEAD)\ngit rebase -i HEAD~4\n\n\nforced to change branch\ngit branch -f xxxx\n\n\ndevelop demo\nwe need to branch\n\n\n\nbranch\ndescription\n\n\n\n\nmaster\ndevelop branch\n\n\nbugFix\nbugFix branch\n\n\n\nwhen we develop at master branch, bug we want to test or debug somethig.\nwe need checkout to bugFix branch to test something, when we test over we checkout to master.\n# ------------------------ first times to fix bug --------------------------------\n\n# first time, create and checkout to bugFix branch\ngit checkout -b bugFix\n\n#do something on bugFix branch\n....\n\n# we want to update the fixthing to master\ngit checkout master \ngit merge bugFix\n# ------------------------ n times to fix bug --------------------------------\n\n# second time to test some thing, we still nedd to checkout bugFix branch\n#  if excute this command\ngit checkout bugFix\ngit merge master\n# you will see something like this\n\n\"\"\"\nAuto-merging index.txt\nCONFLICT (content): Merge conflict in index.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n\"\"\n\n# the right command like this\n\n# siwtch to bugFix then merge the branch what you wanto test or debug\ngit checkout bugFix\n# -f means forced to excute \ngit branch -f master\n\n# then you can test on debug branch\n....\n\n# when we test over \ngit checkout master \ngit merge bugFix\n\n\nwhat difference between HEAD~ and HEAD^\nhttps://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git\nHEAD~ is\n- Use most of the time — to go back a number of generations, usually what you want~ - Use on merge commits — because they have two or more (immediate) parents ^\nG   H   I   J\n \\ /     \\ /\n  D   E   F\n   \\  |  / \\\n    \\ | /   |\n     \\|/    |\n      B     C\n       \\   /\n        \\ /\n         A\nA =      = A^0\nB = A^   = A^1     = A~1\nC = A^2\nD = A^^  = A^1^1   = A~2\nE = B^2  = A^^2\nF = B^3  = A^^3\nG = A^^^ = A^1^1^1 = A~3\nH = D^2  = B^^2    = A^^^2  = A~2^2\nI = F^   = B^3^    = A^^3^\nJ = F^2  = B^3^2   = A^^3^2"
  },
  {
    "objectID": "posts/三步简单解决3306端口占用问题（windows）/index.html",
    "href": "posts/三步简单解决3306端口占用问题（windows）/index.html",
    "title": "三步简单解决3306端口占用问题（windows）",
    "section": "",
    "text": "一、查看占用3306端口的进程\n其他端口参照3306\nnetstat  -aon|findstr 3306\n二、记住这个pid号 三、ctrl +shift+esc调出任务管理器\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/jdbc-- 结果集ResultSet/index.html",
    "href": "posts/jdbc-- 结果集ResultSet/index.html",
    "title": "jdbc– 结果集ResultSet",
    "section": "",
    "text": "// 结果集ResultSet\n    @Test\n    public void resultSetTest() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"src/cn/usts/edu/config/db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        String sql =\"select * from per\";\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        // 获取结果\n        while (resultSet.next()){ // 判断有没有下一row行        (列索引从1开始)\n            System.out.print(\"name:\"+resultSet.getString(1));\n            System.out.print(\"\\tid:\"+resultSet.getInt(2));\n            System.out.print(\"\\tage:\"+resultSet.getInt(3)+\"\\n\");\n        }\n\n        // 切断链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n\n    }\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 利用Referer简单实现防盗链功能/index.html",
    "href": "posts/java EE 利用Referer简单实现防盗链功能/index.html",
    "title": "java EE 利用Referer简单实现防盗链功能",
    "section": "",
    "text": "1、原理 通过判断请求url是否包含自家服务器的名称从而来判断是否由本家发起的请求。\n        // 获取Referer请求头\n        String referer  = request.getHeader(\"Referer\");\n        // 获取服务器名称 \n            String serverName = request.getServerName();\n        // 判断referer是否包含服务器名称\n            if(referer!=null && referer.contains(serverName)){\n                response.getWriter().write(\"downloading............\");\n            }\n            else{\n                // 不是从本网站发起的请求，把用户重定向到我们的网页\n                response.sendRedirect(\"/myProject/welcom.html\");\n            }"
  },
  {
    "objectID": "posts/java常用类--时间日期类/index.html",
    "href": "posts/java常用类--时间日期类/index.html",
    "title": "java常用类–时间日期类",
    "section": "",
    "text": "package cn.usts.edu.fly.DateAndDateFormat;\n\nimport com.sun.org.apache.xerces.internal.impl.dv.xs.YearMonthDV;\n\nimport java.time.*;\n\n/**\n * @author ：fly\n * @description: Date 类\n *                    在jdk8之前还没有time包,使用Date类,用Calendar.getInstance()获取时间对象\n *                    java.time提供了更多对时间日期的操作\n * @date ：2021/10/31 16:44\n */\npublic class DateDemo {\n    public static void main(String[] args) {\n        LocalTime time = LocalTime.now();\n        System.out.println(time);// 时间 16:51:42.206\n\n        LocalDate date = LocalDate.now();\n        System.out.println(date);//当前年月日 2021-10-31\n\n        LocalDate date1 = date.plusDays(1);\n        System.out.println(\"当前时间加1天是\"+date1);\n\n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(now);\n\n        System.out.println(\"当前年\"+Year.now());\n        System.out.println(\"当前年月\"+ YearMonth.now());//2021-10\n        System.out.println(\"当前月日\"+ MonthDay.now());// --10-31\n    }\n}"
  },
  {
    "objectID": "posts/java常用类--时间日期类/index.html#date-类",
    "href": "posts/java常用类--时间日期类/index.html#date-类",
    "title": "java常用类–时间日期类",
    "section": "",
    "text": "package cn.usts.edu.fly.DateAndDateFormat;\n\nimport com.sun.org.apache.xerces.internal.impl.dv.xs.YearMonthDV;\n\nimport java.time.*;\n\n/**\n * @author ：fly\n * @description: Date 类\n *                    在jdk8之前还没有time包,使用Date类,用Calendar.getInstance()获取时间对象\n *                    java.time提供了更多对时间日期的操作\n * @date ：2021/10/31 16:44\n */\npublic class DateDemo {\n    public static void main(String[] args) {\n        LocalTime time = LocalTime.now();\n        System.out.println(time);// 时间 16:51:42.206\n\n        LocalDate date = LocalDate.now();\n        System.out.println(date);//当前年月日 2021-10-31\n\n        LocalDate date1 = date.plusDays(1);\n        System.out.println(\"当前时间加1天是\"+date1);\n\n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(now);\n\n        System.out.println(\"当前年\"+Year.now());\n        System.out.println(\"当前年月\"+ YearMonth.now());//2021-10\n        System.out.println(\"当前月日\"+ MonthDay.now());// --10-31\n    }\n}"
  },
  {
    "objectID": "posts/java常用类--时间日期类/index.html#simpledateformat推荐",
    "href": "posts/java常用类--时间日期类/index.html#simpledateformat推荐",
    "title": "java常用类–时间日期类",
    "section": "SimpleDateFormat（推荐）",
    "text": "SimpleDateFormat（推荐）\npackage cn.usts.edu.fly.DateAndDateFormat;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @author ：fly\n * @description:  SimpleDateFormat()  自定义日期时间格式\n * @date ：2021/10/31 17:08\n */\npublic class SimpleDateFormatDemo {\n    public static void main(String[] args) {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"现在的时间是:yyyy-MM-dd HH:mm:ss\");\n        System.out.println(simpleDateFormat.format(new Date()));// 今天是:2021-10-31 17:11:47\n\n    }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程管理/index.html",
    "href": "posts/stm32F103-RT-Thread线程管理/index.html",
    "title": "stm32F103-RT-Thread线程管理",
    "section": "",
    "text": "系统总共支持 256 个优先 (0 ~ 255，数值越小的优先级越高，0 为最高优先级，255 分配给空闲线程使用,默认优先级32个，一般用户不使用)。\n\n在一些资源比较紧张的系统中，可以根据实,际情况选择只支持 8 个或 32 个优先级的系统配置。\n\n\n在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行\n\n\nRT-Thread 内核中也允许创建相同优先级的线程。相同优先级的线程采用时间片轮转方式进行调 度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪线程存在 的情况下才有效。\n\n\n\n/*********************key1挂起线程,key2恢复线程*********************/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;               // thread1 control block\nstatic rt_thread_t led2_thread = RT_NULL;               // thread2 control block\nstatic rt_thread_t pause_thread = RT_NULL;              // thread3 control block\n\nstatic rt_thread_t send_thread = RT_NULL;               // message queue send thread\nstatic rt_thread_t receive_thread = RT_NULL;            // messge queue receive thread\n\nint count = 0;\n\n\n\n\n\n\n\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\nstatic void pause_thread_entry(void *parameter);\n\n/*\n*************************************************************************\n*                             main ����\n*************************************************************************\n*/\n/**\n * @brief  ������\n * @param  ��\n * @retval ��\n */\nint main(void)\n{\n    \n    // if (led1_thread != RT_NULL)\n    //  rt_thread_startup(led1_thread);\n    // else\n    //  return -1;\n\n\n\n    // thread 2\n    // led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    // if (led2_thread != RT_NULL)\n    //  rt_thread_startup(led2_thread);\n    // else\n    //  return -1;\n\n    // thread 3 [pause thread]\n    pause_thread = rt_thread_create(\"pause\", pause_thread_entry,RT_NULL,512,2,20);\n    if(pause_thread != RT_NULL){\n        rt_thread_startup(pause_thread);\n    }\n    else{\n        return -1;\n    }\n    \n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED1_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[1], Red  --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[2], Green --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void pause_thread_entry(void *parameter)\n{\n    rt_err_t uwRet_1 = RT_EOK; // monitor the status\n\n    while (1)\n    {\n        \n        if (Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_suspend(led1_thread); /* �0�1�0�6�0�4�0�8LED1�0�3�0�8�0�6�0�0 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[suspend-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[suspend-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n\n        \n\n        if (Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_resume(led1_thread); /* �0�3�0�0�0�0�0�7LED1�0�3�0�8�0�6�0�0�0�5�0�3 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[resume-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[resume-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n      rt_thread_delay(20);\n    }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程管理/index.html#main.c",
    "href": "posts/stm32F103-RT-Thread线程管理/index.html#main.c",
    "title": "stm32F103-RT-Thread线程管理",
    "section": "",
    "text": "/*********************key1挂起线程,key2恢复线程*********************/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;               // thread1 control block\nstatic rt_thread_t led2_thread = RT_NULL;               // thread2 control block\nstatic rt_thread_t pause_thread = RT_NULL;              // thread3 control block\n\nstatic rt_thread_t send_thread = RT_NULL;               // message queue send thread\nstatic rt_thread_t receive_thread = RT_NULL;            // messge queue receive thread\n\nint count = 0;\n\n\n\n\n\n\n\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\nstatic void pause_thread_entry(void *parameter);\n\n/*\n*************************************************************************\n*                             main ����\n*************************************************************************\n*/\n/**\n * @brief  ������\n * @param  ��\n * @retval ��\n */\nint main(void)\n{\n    \n    // if (led1_thread != RT_NULL)\n    //  rt_thread_startup(led1_thread);\n    // else\n    //  return -1;\n\n\n\n    // thread 2\n    // led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    // if (led2_thread != RT_NULL)\n    //  rt_thread_startup(led2_thread);\n    // else\n    //  return -1;\n\n    // thread 3 [pause thread]\n    pause_thread = rt_thread_create(\"pause\", pause_thread_entry,RT_NULL,512,2,20);\n    if(pause_thread != RT_NULL){\n        rt_thread_startup(pause_thread);\n    }\n    else{\n        return -1;\n    }\n    \n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED1_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[1], Red  --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[2], Green --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void pause_thread_entry(void *parameter)\n{\n    rt_err_t uwRet_1 = RT_EOK; // monitor the status\n\n    while (1)\n    {\n        \n        if (Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_suspend(led1_thread); /* �0�1�0�6�0�4�0�8LED1�0�3�0�8�0�6�0�0 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[suspend-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[suspend-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n\n        \n\n        if (Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_resume(led1_thread); /* �0�3�0�0�0�0�0�7LED1�0�3�0�8�0�6�0�0�0�5�0�3 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[resume-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[resume-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n      rt_thread_delay(20);\n    }\n}"
  },
  {
    "objectID": "posts/Django-管理平台/index.html",
    "href": "posts/Django-管理平台/index.html",
    "title": "Django-管理平台",
    "section": "",
    "text": "用户表（User）：\n\n\n\n字段\n类型\n长度\n描述\n\n\n\n\nid\nbigint\n\n编号\n\n\nusername\nvarchar\n32\n用户名\n\n\npassword\nvarchar\n64\n密码\n\n\nis_admin\nint\n\n是否管理员\n\n\n\n\n\n客户表（Customer）：\n\n\n\n字段\n类型\n长度\n描述\n\n\n\n\nid\nbigint\n\n编号\n\n\nname\nvarchar\n64\n用户名\n\n\ncity\nvarchar\n64\n城市\n\n\ncooperation_time\ndatetime\n\n合作时间\n\n\ntype\nint\n\n类型\n\n\n\n\n参数：\n\n\n\ntype\n描述\n\n\n\n\n1\n医院\n\n\n2\n代理\n\n\n\n\n\n\n设备表（Device）：\n\n\n\n字段\n类型\n长度\n描述\n\n\n\n\nid\nbigint\n\nid\n\n\ndevice_code\nvarchar\n64\n设备编号\n\n\napplication_code\nvarchar\n64\n软件id\n\n\nrecord_id\nint\n64\n记录id\n\n\ncustomer_id\nint\n\n客户id\n\n\nopr_room\nint\n\n设备所在手术室id\n\n\noption\nint\n\n功能选项\n\n\n\n\n参数：\n\n\n\noption\n描述\n\n\n\n\n1\n肠\n\n\n2\n胃\n\n\n3\n肠+胃\n\n\n\n\n\n\n记录表（Record）：\n\n\n\n字段\n类型\n长度\n描述\n\n\n\n\nid\nbigint\n\n编号\n\n\nactivate_code\nvarchar\n128\n激活码\n\n\nstart_time\ndatetime\n\n激活码开始时间\n\n\nend_time\ndatetime\n\n激活码结束时间\n\n\noperator_id\nint\n\n操作人员id"
  },
  {
    "objectID": "posts/南京大学ics pa实验O/index.html",
    "href": "posts/南京大学ics pa实验O/index.html",
    "title": "南京大学ics pa实验O",
    "section": "",
    "text": "https://github.com/GeeeekExplorer/NJU-ICS/blob/master/pa2018_fall/nemu/src/monitor/expr.c &gt;# PA0 编译NEMU\n\n把项目拉下来，\n修改学号，姓名\nbug：llvm的TargetRegister.h的位置（/src/utils/distasm.cc）， 使用文件搜索locate xxx， 然后修改为查找到的位置\nmake clean –&gt; make\n\n\nfatal error: readline/readline.h: No such file or directory\nsudo apt-get install libreadline-dev\n安装的工具\napt-get install build-essential    # build-essential packages, include binary utilities, gcc, make, and so on\napt-get install man                # on-line reference manual\napt-get install gcc-doc            # on-line reference manual for gcc\napt-get install gdb                # GNU debugger\napt-get install git                # revision control system\napt-get install libreadline-dev    # a library used later\napt-get install libsdl2-dev        # a library used later\napt-get install llvm               # llvm project, which contains libraries used later\n\n\n: error: ‘class llvm::MCInstPrinter’ has no member named ‘setPrintBranchImmAsAddress’\n修改llvm的版本\nsudo apt autoremove llvm-10\nsudo apt install llvm-12\ncd /usr/bin\nsudo ln -s /usr/lib/llvm-12/bin/llvm-config  llvm-config\n\nPA1 深入了解代码框架\n\n这里的pa是2020的isa-x86的pa\n首先是编译项目\n运行项目\n哦豁,不出意外是出意外了assert….(问题不大, 只有有报错信息问题就不大)\n\n\n\n尝试解决assert报错\n\n// 编译\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make -B\n\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n+ CC src/device/io/map.c\n+ CC src/device/io/port-io.c\n+ CC src/device/io/mmio.c\n+ CC src/device/device.c\n+ CC src/device/timer.c\n+ CC src/device/serial.c\n+ CC src/device/intr.c\n....\n+ LD build/x86-nemu-interpreter\n\n\n// 运行\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make run\n\n// 报错\nBuilding x86-nemu-interpreter\nmake -C /home/ubuntu/ics/ics2020/nemu/tools/kvm-diff \nmake[1]: Entering directory '/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff'\nmake[1]: Nothing to be done for 'app'.\nmake[1]: Leaving directory '/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff'\n./build/x86-nemu-interpreter --log=./build/nemu-log.txt --diff=/home/ubuntu/ics/ics2020/nemu/tools/kvm-diff/build/x86-kvm-so \nx86-nemu-interpreter: src/isa/x86/reg.c:20: reg_test: Assertion `reg_w(i) == (sample[i] & 0xffff)' failed.\nmake: *** [Makefile:108: run] Aborted (core dumped)\n\n查看src/isa/x86/reg.c:20:\n\n  1 #include &lt;isa.h&gt;\n  2 #include &lt;stdlib.h&gt;\n  3 #include &lt;time.h&gt;\n  4 #include \"local-include/reg.h\"\n  5 \n  6 const char *regsl[] = {\"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"};\n  7 const char *regsw[] = {\"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\"};\n  8 const char *regsb[] = {\"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\"};\n  9 \n 10 void reg_test() {\n 11   srand(time(0));\n 12   word_t sample[8];\n 13   word_t pc_sample = rand();\n 14   cpu.pc = pc_sample;\n 15 \n 16   int i;\n 17   for (i = R_EAX; i &lt;= R_EDI; i ++) {\n 18     sample[i] = rand();\n 19     reg_l(i) = sample[i];\n // 问题出在这里, 可是这几个宏有点折磨了, 盲猜是不是数据越界了\n [20]     assert(reg_w(i) == (sample[i] & 0xffff));\n 21   }\n\n看到这宏定义有点折磨, 无从下手, 想起来一个好东西gcc -E, 嘿嘿, 这下人肉展开是不可能的, 直接安排\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ gcc -E ./src/isa/x86/reg.c \n\n# 1 \"./src/isa/x86/reg.c\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 31 \"&lt;command-line&gt;\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"&lt;command-line&gt;\" 2\n# 1 \"./src/isa/x86/reg.c\"\n./src/isa/x86/reg.c:1:10: fatal error: isa.h: No such file or directory\n    1 | #include &lt;isa.h&gt;\n      |          ^~~~~~~\ncompilation terminated.\n\n啊这, 我又麻了, 果然没有这么简单, 单独gcc -E是不行了, 依赖的文件都得加上才行, 可是这个脚本命令有点不会写啊, 来cat一下jyy的Makefile\n\n// -E 我们都懂的, 可是-MF是什么,google一下,这里我是废物, 我又被google到的中文结果吸引进去了\n@$(CC) $(CFLAGS) -E -MF /dev/null $&lt; | \\\n    grep -ve '^#' | \\\n    clang-format - &gt; $(basename $@).i\ngcc -MF $&lt; - 看完之后我又行了, 不就是建立个文件夹, 然后把每个.c的文件都预编译成.i文件, 我又拿捏了, 走着\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ make -B\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n/bin/sh: 3: clang-format: Permission denied\nmake: *** [Makefile:81: build/obj-x86-interpreter/device/audio.o] Error 127\n\n啊这,啊这. 怎么直接都无法编译了, 定睛一看, Permission denied, 这我熟, 直接掏出祖传sudo\nsudo make -B\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ sudo make -B\n\nBuilding x86-nemu-interpreter\n+ CC src/device/audio.c\n/bin/sh: 3: clang-format: not found\nmake: *** [Makefile:81: build/obj-x86-interpreter/device/audio.o] Error 127\n\n通往pa1完成的道路上充满了坎坷, 说到底还是太菜了, 好在linux的报错信息太perfect了, clang-format: not found, easy, 这种小问题还是可以的直接sudo apt-get install clang-format\n\nubuntu@VM-12-14-ubuntu:~/ics/ics2020/nemu$ sudo apt-get install clang-format\n\n\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nThe following NEW packages will be installed:\n  clang-format\n0 upgraded, 1 newly installed, 0 to remove and 251 not upgraded.\nNeed to get 0 B/3,272 B of archives.\nAfter this operation, 29.7 kB of additional disk space will be used.\nSelecting previously unselected package clang-format.\n(Reading database ... 143254 files and directories currently installed.)\nPreparing to unpack .../clang-format_1%3a10.0-50~exp1_amd64.deb ...\nUnpacking clang-format (1:10.0-50~exp1) ...\nSetting up clang-format (1:10.0-50~exp1) ...\nProcessing triggers for man-db (2.9.1-1) ...\n\n冲冲冲…\nsudo make -B\n又看到了熟悉的命令行信息+cc…, 奶思情况好转起来了\n直接冲到reg.i里面看看到底是个啥情况\n\n// 找到reg.i\nvim $(fzf)\nreg.i\n   1 \n   2 \n   3 typedef unsigned char __u_char;\n   4 typedef unsigned short int __u_short;\n   5 typedef unsigned int __u_int;\n   6 typedef unsigned long int __u_long;\n    ...\n  46 typedef long int __clock_t;\n  47 typedef unsigned long int __rlim_t;\n  48 typedef unsigned long int __rlim64_t;\n  49 typedef unsigned int __id_t;\n  50 typedef long int __time_t;\n\n诶,窝草,怎么满屏的定义, 不慌不慌, 直接搜索函数reg_test , 嘿嘿好起来了.又看到了熟悉的代码\n\n2066 const char *regsl[] = {\"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"};\n2067 const char *regsw[] = {\"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\"};\n2068 const char *regsb[] = {\"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\"};\n2069 \n2070 void reg_test() {\n2071   srand(time(0));\n2072   word_t sample[8];\n2073   word_t pc_sample = rand();\n2074   cpu.pc = pc_sample;\n2075 \n2076   int i;\n2077   for (i = R_EAX; i &lt;= R_EDI; i++) {\n2078     sample[i] = rand();\n2079     (cpu.gpr[check_reg_index(i)]._32) = sample[i];\n2080 \n2081     ((void)sizeof(\n2082          ((cpu.gpr[check_reg_index(i)]._16) == (sample[i] & 0xffff)) ? 1 : 0),\n2083      __extension__({\n2084        if ((cpu.gpr[check_reg_index(i)]._16) == (sample[i] & 0xffff))\n2085          ;\n2086        else\n2087          __assert_fail(\"reg_w(i) == (sample[i] & 0xffff)\", \"src/isa/x86/reg.c\",\n2088                        20, __extension__ __PRETTY_FUNCTION__);\n2089      }));\n2090   }\n我擦, 我在搞什么飞机, 胡乱分析系统, 好家伙, jyy老师直接给出了ans. 强行分析一波. 唉, 这波说明在操作前看README的重要性.  - 好家伙， 我是真的服了我了，没有困难制造困难，代码就这么几行，我愣是没看到，只需要重新修改下就行， 我还在苦思冥想该怎么写， 怎么老是测试不过， 原来贴心的jyy老是早就猜到了我的水平，让我改改代码就完事了，大意了。\nx86.h修改如下\ntypedef struct\n{\n  union{\n    union {\n      uint32_t _32;\n      uint16_t _16;\n      uint8_t _8[2];\n    } gpr[8];\n    \n    struct{\n      rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;\n    };\n  };\n  vaddr_t pc;\n} x86_CPU_state;\n\n接着冲冲冲\nmake -B -j8 \noh oh oh oh oh….\n\n\n运行第一个客户程序\n\n\n单步执行：\n\nsi [N]\n让程序单步执行, 这里有个小bug，不过也不算小bug，需要打开调试的宏DEBUG 在common.h中， 否则无法查看单步执行后的几寄存器的效果 \n\n\nui.c\nstatic int cmd_si(char *args) {\n  // strtok is split string with specify symbol \n  // strtok(args,\"\")\n  int step;\n  \n  if(args == NULL) step=1;\n  // format string and move to a new vable  \n  else sscanf(args,\"%d\",&step);\n  \n  // excute num\n  cpu_exec(step);\n  return 0;\n}\nui.c&gt; cmd_table\n { \"si\", \"Debug by step NEMU\", cmd_si },\n\n这个单步调试很关键哦， 后续的内存扫描需要用到这里作为校验，刚开始自己直接忽略了，吃了大亏，出来混还是的还的。  &gt; ### 打印程序（寄存器）状态 &gt; - 就是打印寄存器中的数据 &gt; - 仿照上面的案例，修改cmd_table, 建立cmd_info函数\n\n这里调用了reg.c中的isa_reg_display记得导入头文件\n#include  \"memory/vaddr.h\"\n\nvoid isa_reg_display() {\n  for (int i = R_EAX; i &lt; R_EDI; i++)\n  {\n    printf(\"$%s\\t0x%08x\\n\", regsl[i] ,reg_l(i));\n  }\n  printf(\"$pc\\t0x%08x\\n\",cpu.pc);\n}\nui.c\nstatic int cmd_info(char* args){\n  \n  // show register \n  if (args[0] == 'r') isa_reg_display();\n  \n  // show watch pointer\n  else if(args[0] == 'w') TODO();\n \n  return 0;\n}\nui.c&gt; cmd_table\n { \"info\", \"info r--&gt;show reg\\ninfo w--&gt;show watch pointer memory\", cmd_info },\n\n注意这里的info是使用的info r进行测试，后面的info w暂时先搁置，先搞后面的扫描内存  &gt;### 扫描内存(2)\n这里可有点弯弯绕，我最初的想法是通过传递进来的地址，然后直接按照16进制数进行数据的解析，好家伙， 我想的是真复杂了（好吧，我承认我又没有认真看手册，手册里面都说了，前面我们都看了内存是怎么设计的。。。。），vaddr_read 害。。\n\n - 还是熟悉的套路：\nui.c&gt; cmd_table\n{ \"x\", \"show memory from 0xxxx\", cmd_x }\nui.c - 第一个参数是扫描的长度， 第二个参数是起始位置\nstatic int cmd_x(char* args){\n  uint32_t len;\n  uint32_t addr;\n\n  char* N    =  strtok(NULL,\" \");\n  char* EXPR =  strtok(NULL,\" \");\n\n  sscanf(N,\"%d\",&len);\n  sscanf(EXPR,\"%x\",&addr);\n\n  for(int i=addr;i&lt;addr+(len*4);i+=4){\n    word_t value = vaddr_read(i,4);\n    printf(\"$0x%08x:\\t0x%08x\\n\", i,value);\n  }\n  \n  return 0;\n}\n\n测试：\n\n\n\n\n在这里插入图片描述\n\n\ngdb中文参考：https://wizardforcel.gitbooks.io/100-gdb-tips/content/examine-memory.html\n\n表达式求值\n\n正则表达式\nexpr.h &expr.c\n正则表达式的C语言使用\n\n\n正则表达式在线测试： https://c.runoob.com/front-end/854/\n正则表达式代码参考地址: https://www.ibm.com/docs/en/i/7.4?topic=functions-regcomp-compile-regular-expression - 正则表达式的基本使用 regcomp()\n#include &lt;regex.h&gt;\nint regcomp(regex_t *preg, const char *pattern, int cflags);\n\nregexec()\n参考链接： https://blog.csdn.net/weixin_46499713/article/details/125154268 https://blog.csdn.net/weixin_43877657/article/details/109068930?spm=1001.2014.3001.5502"
  },
  {
    "objectID": "posts/git--回退版本(两个版本之间来回切)/index.html",
    "href": "posts/git--回退版本(两个版本之间来回切)/index.html",
    "title": "git – 回退版本(两个版本之间来回切)",
    "section": "",
    "text": "查看历史记录\n\ngit log --oneline\n &gt; 选择一个回退的版本\ngit reset --hard 0611ffc\n &gt; 再切换回去\n# 查看历史操作记录\ngit reflog\n\n# 查看上次操作的版本号, 回退上次版本号\ngit reset --hard 1f36fbb \n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/jdbc-- 测试PreparedStatement/index.html",
    "href": "posts/jdbc-- 测试PreparedStatement/index.html",
    "title": "jdbc– 测试PreparedStatement",
    "section": "",
    "text": "测试PreparedStatement\n\n@description: 测试PreparedStatement\n            对sql注入的解决\n            以及常用方法\n\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n/**\n * @author ：fly\n * @description:  测试PreparedStatement\n *                 对sql注入的解决\n *                 以及常用方法\n * @date ：2021/11/5 16:06\n */\npublic class PreparedStatementDemo {\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");\n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n        String sql =\"select admin.amin,admin.psd from admin where amin=? and psd=?\";\n        // ? 占位符\n\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setString(1,name); // 占位符位置\n        preparedStatement.setString(2,psd);\n        ResultSet resultSet = preparedStatement.executeQuery();// 这里不用在给sql了\n\n        // 获取结果\n        if (resultSet.next()){ // 查询到结果才会有记录\n            System.out.print(\"登陆成功\");\n        }else{\n            System.out.print(\"登陆失败\");\n        }\n\n\n        // 切断链接\n        resultSet.close();\n        preparedStatement.close();\n        connection.close();\n\n\n    }\n\n}\n控制住了sql注入问题\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI--下拉框JComboBox/index.html",
    "href": "posts/javaGUI--下拉框JComboBox/index.html",
    "title": "javaGUI–下拉框JComboBox",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JComboBoxDemo extends JFrame {\n    public JComboBoxDemo() {\n        this.setTitle(\"下拉框\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        JComboBox&lt;Object&gt; comboBox = new JComboBox&lt;&gt;();\n        comboBox.addItem(null);\n        comboBox.addItem(\"Python\");\n        comboBox.addItem(\"Java\");\n        comboBox.addItem(\"C\");\n        comboBox.addItem(\"C++\");\n\n        Container container = this.getContentPane();\n        container.add(comboBox,BorderLayout.NORTH);\n    }\n\n    public static void main(String[] args) {\n        new JComboBoxDemo();\n    }\n}"
  },
  {
    "objectID": "posts/arch没有wifi/index.html",
    "href": "posts/arch没有wifi/index.html",
    "title": "arch没有wifi",
    "section": "",
    "text": "确定自己安装了plasma-nm 1 #pacman -S networkmanager plasma-nm 2 #systemctl start NetworkManager 3 #systemctl enable NetworkManager"
  },
  {
    "objectID": "posts/TI_icboost+IWR6843/index.html",
    "href": "posts/TI_icboost+IWR6843/index.html",
    "title": "TI_icboost+IWR6843",
    "section": "",
    "text": "概要\nti毫米波雷达开发过程，环境搭建\n参考:https://blog.csdn.net/Tronlong_/article/details/108147255\n\n\n硬件链接\n\n对应的拨码开关以及条线配置如图\n\n\n\n\n在这里插入图片描述\n\n\n\n\nccs配置\n &gt;## 搜索对应的开发板的项目\n &gt; ## 分别导入项目 &gt; - mss 和 dss\n &gt;## 编译dss项目\n &gt;## 编译mss项目 同样的方法编译mss  &gt; ### 如果遇到not find xxx, 请添加对应的sdk和依赖, 若果sdk安装位置不在默认的C:TI_PRODUCT的路径 \n\ndebug\n请参考:ccs脚本自动调试"
  },
  {
    "objectID": "posts/HTML基础/index.html",
    "href": "posts/HTML基础/index.html",
    "title": "HTML基础",
    "section": "",
    "text": "lz也是从知乎上看到这个这个网站，很不错，边学边敲。 网址：https://www.freecodecamp.one/ 这个算是自己做个小笔记（cv大法）吧，看一点敲一点，cv一点。"
  },
  {
    "objectID": "posts/HTML基础/index.html#标题标签",
    "href": "posts/HTML基础/index.html#标题标签",
    "title": "HTML基础",
    "section": "标题标签",
    "text": "标题标签\nHTML 是英文 Hyper Text Markup Language（超文本标记语言）的缩写。\n大部分 HTML 元素都有一个开始标记和一个结束标记。\n\n开始标记像这样：&lt;h1&gt;\n\n结束标记像这样：&lt;/h1&gt;\n\n开始标记和结束标记的唯一区别就是结束标记多了一个/。\n&lt;h1&gt;Hello World&lt;/h1&gt;\n这些元素用来告诉浏览器，网站的结构是什么样子。h1元素通常被用作主标题，h2元素通常被用作副标题，还有h3、h4、h5、h6元素，它们分别用作不同级别的标题。\n&lt;h2&gt;Hello World&lt;/h2&gt;\n&lt;h3&gt;Hello World&lt;/h3&gt;\n&lt;h4&gt;Hello World&lt;/h4&gt;\n&lt;h5&gt;Hello World&lt;/h5&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#段落标签",
    "href": "posts/HTML基础/index.html#段落标签",
    "title": "HTML基础",
    "section": "段落标签",
    "text": "段落标签\np是paragraph的缩写，通常被用来创建一个段落，就和你写作文一样。\n你可以像这样创建一个段落：\n&lt;p&gt;I'm a p tag!&lt;/p&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#占位符",
    "href": "posts/HTML基础/index.html#占位符",
    "title": "HTML基础",
    "section": "占位符",
    "text": "占位符\nWeb 开发者通常用lorem ipsum text来做占位符，占位符就是占着位置的一些文字，没有实际意义。\n为什么叫lorem ipsum text呢?是因为lorem ipsum是古罗马西塞罗谚语的前两个单词。\n从公元16世纪开始lorem ipsum text就被当做占位符了，这种传统延续到了互联网时代。与此同时，孙悟空也在五指山下被压了500年，然后就进化成程序猿了，是不是很巧合。^_^"
  },
  {
    "objectID": "posts/HTML基础/index.html#给-html-添加注释",
    "href": "posts/HTML基础/index.html#给-html-添加注释",
    "title": "HTML基础",
    "section": "给 HTML 添加注释",
    "text": "给 HTML 添加注释\n注释的开始标记是&lt;!--，结束标记是--&gt;。\n\n&lt;!--我是注释的内容，代码不执行--&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#html5-元素介绍",
    "href": "posts/HTML基础/index.html#html5-元素介绍",
    "title": "HTML基础",
    "section": "HTML5 元素介绍",
    "text": "HTML5 元素介绍\nHTML5 引入了很多更具描述性的 HTML 元素，例如：header、footer、nav、video、article、section等等。\n这些元素让 HTML 更易读，同时有助于搜索引擎优化和无障碍访问。\nmain元素让搜索引擎和开发者瞬间就能找到网页的主要内容。"
  },
  {
    "objectID": "posts/HTML基础/index.html#给网站添加图片img标签",
    "href": "posts/HTML基础/index.html#给网站添加图片img标签",
    "title": "HTML基础",
    "section": "给网站添加图片：img标签",
    "text": "给网站添加图片：img标签\n用img元素来为你的网站添加图片，其中src属性指向一个图片的地址。\n例如：\n&lt;img src=\"https://www.your-image-source.com/your-image.jpg\"&gt;\n注意：img元素是没有结束标记的。\n所有的img元素必须有alt属性，alt属性的文本是当图片无法加载时显示的替代文本，这对于通过屏幕阅读器来浏览网页的用户非常重要。\n注意：如果图片是纯装饰性的，用一个空的alt是最佳实践。\n理想情况下，alt属性不应该包含特殊字符，除非需要。"
  },
  {
    "objectID": "posts/HTML基础/index.html#用锚点实现网页间的跳转",
    "href": "posts/HTML基础/index.html#用锚点实现网页间的跳转",
    "title": "HTML基础",
    "section": "用锚点实现网页间的跳转",
    "text": "用锚点实现网页间的跳转\n你可以用a锚点（Anchor，简写 a）来实现网页间的跳转。\n锚点需要一个href属性指向目的地，它还需要有锚点文本，例如：\n&lt;a href=\"https://freecodecamp.one\"&gt;传送至 freecodecamp.one&lt;/a&gt;\n然后你的浏览器会显示一个可以点击的文本，点击该文本就会跳转到https://freecodecamp.one。"
  },
  {
    "objectID": "posts/HTML基础/index.html#用锚点实现网页内部跳转",
    "href": "posts/HTML基础/index.html#用锚点实现网页内部跳转",
    "title": "HTML基础",
    "section": "用锚点实现网页内部跳转",
    "text": "用锚点实现网页内部跳转\n锚点同样也可以用来在网页内不同区域的跳转。\n设置锚点的href属性值为井号#加上想跳转区域对应的id属性值，这样就可以创建一个内部跳转。id是用来描述网页元素的一个属性，它的值在整个页面中唯一。\n下面是用来创建内部锚点的例子：\n&lt;a href=\"#contacts-header\"&gt;Contacts&lt;/a&gt;\n...\n&lt;h2 id=\"contacts-header\"&gt;Contacts&lt;/h2&gt;\n当用户点击了Contacts链接，页面就会跳转到网页的Contacts区域。"
  },
  {
    "objectID": "posts/HTML基础/index.html#将锚点嵌套在段落中",
    "href": "posts/HTML基础/index.html#将锚点嵌套在段落中",
    "title": "HTML基础",
    "section": "将锚点嵌套在段落中",
    "text": "将锚点嵌套在段落中\n你可以在其他文本元素内嵌套链接。\n&lt;p&gt;\nHere's a &lt;a target=\"_blank\" href=\"http://freecodecamp.one\"&gt; link to freecodecamp.one&lt;/a&gt; for you to follow.\n&lt;/p&gt;\n让我们来分解这个例子： 通常，文本是被包裹在p段落内：\n&lt;p&gt; Here's a ... for you to follow. &lt;/p&gt;\n接下来是anchor锚点&lt;a&gt;（需要结束标记 &lt;/a&gt;）:\n&lt;a&gt; ... &lt;/a&gt;\ntarget 是锚点的一个属性，它指定了会以什么方式来打开链接，属性值 **“_blank”的意思是链接会在新元素页打开**。\nhref是锚点的另一个属性：它指定了链接的 URL 地址：\n&lt;a href=\"http://freecodecamp.one\"&gt; ... &lt;/a&gt;\n锚点元素内的文本：“link to freecodecamp.one”，会显示为一个可以点击的链接：\n&lt;a href=\" ... \"&gt;link to freecodecamp.one&lt;/a&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#用-号来创建固定链接",
    "href": "posts/HTML基础/index.html#用-号来创建固定链接",
    "title": "HTML基础",
    "section": "用 # 号来创建固定链接",
    "text": "用 # 号来创建固定链接\n有时你想为网站添加一个锚点，但如果你还不确定要将它链接到哪儿，这时可以使用固定链接。\nhref属性的当前值是指向 “http://freecatphotoapp.com”，将href属性的值替换为#，也称为井号，就可以创建固定链接。\n例如: href=\"#\""
  },
  {
    "objectID": "posts/HTML基础/index.html#给图片添加链接",
    "href": "posts/HTML基础/index.html#给图片添加链接",
    "title": "HTML基础",
    "section": "给图片添加链接",
    "text": "给图片添加链接\n你可以通过把元素嵌套进锚点里使其变成一个链接。\n把你的图片嵌套进锚点。举例如下：\n&lt;a href=\"#\"&gt;&lt;img src=\"http://cdn.chenzhicheng.com/running-cats.jpg\" alt=\"三只萌萌的小猫\"&gt;&lt;/a&gt;\n把锚点的href属性设置为#，就可以创建固定链接。"
  },
  {
    "objectID": "posts/HTML基础/index.html#创建一个无序列表",
    "href": "posts/HTML基础/index.html#创建一个无序列表",
    "title": "HTML基础",
    "section": "创建一个无序列表",
    "text": "创建一个无序列表\nHTML 有一个特定的元素用于创建无序列表unordered lists（缩写 ul）。\n无序列表以&lt;ul&gt;开始，中间包含一个或多个&lt;li&gt;元素，最后以&lt;/ul&gt;结尾。\n例如:\n&lt;ul&gt;\n  &lt;li&gt;牛奶&lt;/li&gt;\n  &lt;li&gt;奶酪&lt;/li&gt;\n&lt;/ul&gt;\n将会创建一个包含牛奶和奶酪的无序列表。 ## 创建一个有序列表\nHTML 有一个特定的元素用于创建有序列表ordered lists（缩写 ol）。\n有序列表以&lt;ol&gt;开始，中间包含一个或多个&lt;li&gt;元素，最后以&lt;/ol&gt;结尾。\n例如:\n&lt;ol&gt;\n  &lt;li&gt;加菲猫&lt;/li&gt;\n  &lt;li&gt;哆啦A梦&lt;/li&gt;\n&lt;/ol&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#创建一个输入框",
    "href": "posts/HTML基础/index.html#创建一个输入框",
    "title": "HTML基础",
    "section": "创建一个输入框",
    "text": "创建一个输入框\n现在让我们来创建一个form表单。\ninput输入框可以让你轻松获得用户的输入。\n你可以像这样创建一个文本输入框：\n&lt;input type=\"text\"&gt;\n注意：input输入框是没有结束标记的 ## 给输入框添加占位符文本(在输入框位置显示提示信息) Placeholder占位符是用户在input输入框中输入任何东西前的预定义文本。\n你可以像这样创建一个占位符：&lt;input type=\"text\" placeholder=\"this is placeholder text\"&gt; 效果："
  },
  {
    "objectID": "posts/HTML基础/index.html#创建一个表单",
    "href": "posts/HTML基础/index.html#创建一个表单",
    "title": "HTML基础",
    "section": "创建一个表单",
    "text": "创建一个表单\n通过给form表单添加一个action属性，你可以使用纯 HTML 来构建向服务器提交数据的 Web 表单。\n例如: &lt;form action=\"/url-where-you-want-to-submit-form-data\"&gt;&lt;/form&gt; 在input输入框外层创建一个form表单，然后设置表单的action属性为\"/submit-cat-photo\"。 ## 给表单添加提交按钮\n让我们来给表单添加一个submit提交按钮，当点击提交按钮时，表单中的数据将会被发送到action属性指定的地址上。\n例如： &lt;button type=\"submit\"&gt;this button submits the form&lt;/button&gt; 效果：   ## 给表单添加一个必填字段\n当你设计表单时，你可以指定某些字段为必填项(required)，只有当用户填写了该字段后，才可以提交表单。\n如果你想把文本输入框设置为必填项，在input元素中加上required属性就可以了，例如：&lt;input type=\"text\" required&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#创建一组单选按钮",
    "href": "posts/HTML基础/index.html#创建一组单选按钮",
    "title": "HTML基础",
    "section": "创建一组单选按钮",
    "text": "创建一组单选按钮\nradio buttons（单选按钮）就好比单项选择题，正确答案只有一个。\n单选按钮只是input输入框的一种类型。\n每一个单选按钮都应该嵌套在它自己的label（标签）元素中。\n所有关联的单选按钮应该拥有相同的name属性。\n下面是一个单选按钮的例子：\n&lt;label&gt;\n  &lt;input type=\"radio\" name=\"indoor-outdoor\"&gt;Indoor\n&lt;/label&gt;\n最佳实践是在label元素上设置for属性，让其值与单选按钮的id属性值相等，这样就在label元素和它的子元素单选按钮之间创建了一种链接关系。例如：\n&lt;label for=\"indoor\"&gt;\n  &lt;input id=\"indoor\" type=\"radio\" name=\"indoor-outdoor\"&gt;Indoor\n&lt;/label&gt;\n效果："
  },
  {
    "objectID": "posts/HTML基础/index.html#创建一组复选框",
    "href": "posts/HTML基础/index.html#创建一组复选框",
    "title": "HTML基础",
    "section": "创建一组复选框",
    "text": "创建一组复选框\nheckboxes（复选框）就好比多项选择题，正确答案有多个。\n复选框是input输入框的另一种类型。\n每一个复选框都应该嵌套在它自己的label（标签）元素中。\n所有关联的复选框应该拥有相同的name属性。\n最佳实践是在label元素上设置for属性，让其值与复选框的id属性值相等，这样就在label元素和它的子元素复选框之间创建了一种链接关系。例如：\n下面是一个复选框的例子： &lt;label for=\"loving\"&gt;&lt;input id=\"loving\" type=\"checkbox\" name=\"personality\"&gt; Loving&lt;/label&gt;\n效果：  ## 给单选按钮和复选框添加默认选中项 通过添加checked属性，你可以设置某个单选按钮或多选按钮被默认选中。\n为此，只需给input元素添加 “checked” 属性。 例如:\n&lt;input type=\"radio\" name=\"test-name\" checked&gt;\n效果：  ## 元素嵌套 将其他元素都包含在内，形成一个大整体\ndiv元素，也叫division（层）元素，是一个盛装其他元素的通用容器。\n它也是 HTML 中出现频率最高的元素。\n和其他普通元素一样，你可以用&lt;div&gt;来标记一个div元素的开始，用&lt;/div&gt;来标记一个div元素的结束。"
  },
  {
    "objectID": "posts/HTML基础/index.html#声明-html-文档的文档类型",
    "href": "posts/HTML基础/index.html#声明-html-文档的文档类型",
    "title": "HTML基础",
    "section": "声明 HTML 文档的文档类型",
    "text": "声明 HTML 文档的文档类型\n到目前为止，我们学习了一些特定的 HTML 标签，还有一些标签是用来组成网页的总体结构，并且它们在每个 HTML 文档中都能看到。\n在文档的顶部，你需要告诉浏览器你的网页用的 HTML 哪个版本。 HTML 是一个不停进化的语言，大部分浏览器都支持 HTML 的最新标准，也就是 HTML5。但是一些陈旧的网页可能使用的是 HTML 的旧版本。\n你可以通过&lt;!DOCTYPE ...&gt;来告诉浏览器你使用的是 HTML 的哪个版本，“...” 部分就是版本的数字信息。&lt;!DOCTYPE html&gt;对应的就是 HTML5。\n!和大写的DOCTYPE是很重要的，特别是对于老的浏览器。但html大写小写都可以。\n接下来，所有的 HTML 代码都必须位于html标签中。其中&lt;html&gt;位于&lt;!DOCTYPE html&gt;的后面，\n\n位于网页的结尾。\n这是网页结构一个例子：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;!-- Your HTML code goes here --&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/HTML基础/index.html#定义-html-文档的标题和正文",
    "href": "posts/HTML基础/index.html#定义-html-文档的标题和正文",
    "title": "HTML基础",
    "section": "定义 HTML 文档的标题和正文",
    "text": "定义 HTML 文档的标题和正文\nhtml的结构主要分为两大部分：head、body。关于网页的描述都应该放入head标签，网页的内容都应该放入body标签。\n比如link、meta、title和style都应该放入head标签。\n这是网页布局的一个例子：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- metadata elements --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- page contents --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html",
    "href": "posts/java集合-- 所有/index.html",
    "title": "java集合– 所有",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#java-集合类",
    "href": "posts/java集合-- 所有/index.html#java-集合类",
    "title": "java集合– 所有",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#arraylist集合的常规操作",
    "href": "posts/java集合-- 所有/index.html#arraylist集合的常规操作",
    "title": "java集合– 所有",
    "section": "ArrayList集合的常规操作",
    "text": "ArrayList集合的常规操作\n\n             ArrayList长度可变,会随数组元素的增加分配更大的内存,\n             因此可以把ArrayList看做是一个可变长的数组\n             由于ArrayList的底层是数组,所以在 增加所删除指定位置元素时会创建新的数组\n             所以效率会比较低,所以不适合做大量的增删操作\n\npackage cn.usts.edu.arrayList;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: ArrayList集合的常规操作\n *                  ArrayList长度可变,会随数组元素的增加分配更大的内存,\n *                  因此可以把ArrayList看做是一个可变长的数组\n *                  由于ArrayList的底层是数组,所以在 增加所删除指定位置元素时会创建新的数组\n *                  所以效率会比较低,所以不适合做大量的增删操作\n *\n * @date ：2021/11/1 9:40\n */\npublic class ArrayListDemo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n        boolean student1 = al.add(\"student1\");\n        boolean student2 = al.add(\"student2\");\n        al.add(\"student3\");\n\n        System.out.println(student1);\n        System.out.println(student2);\n\n        System.out.println(\"集合的长度:\"+al.size());\n        System.out.println(\"第二个元素是:\"+al.get(2));\n        System.out.println(\"第最后一个元素是:\"+al.get(al.size()-1));\n    }\n}\n ## LinkedList 的基本操作 * ArrayList的查询很快,但是在增删的时候效率就慢了,于是出现了LinkedList * 链表中每个元素都用引用方式记住前一个和后一个元素,这样在增删的时候效率就会大大提高\npackage cn.usts.edu.linkedList;\n\nimport java.util.LinkedList;\n\n/**\n * @author ：fly\n * @description: LinkedList 的基本操作\n *                  ArrayList的查询很快,但是在增删的时候效率就慢了,于是出现了LinkedList\n *                  链表中每个元素都用引用方式记住前一个和后一个元素,这样在增删的时候效率就会大大提高\n *\n * @date ：2021/11/1 10:00\n */\npublic class LinkedListDemo {\n    public static void main(String[] args) {\n        LinkedList ll = new LinkedList();\n\n        // 添加\n        ll.add(\"stu1\");\n        ll.add(\"stu2\");\n        ll.add(\"stu3\");\n        ll.add(\"stu4\");\n\n        System.out.println(ll);\n\n        ll.offer(\"stu99\");// 集合尾部追加\n        System.out.println(ll);\n\n        ll.push(\"stu00\");// 集合头部追加\n        System.out.println(ll);\n\n        // 获取\n        Object peek = ll.peek();// 获取集合第一个元素\n        System.out.println(peek);\n\n        // 删除\n\n        System.out.println(\"删除了\"+ll.removeFirst());// 删除第一个元素\n        System.out.println(ll);\n        System.out.println(\"删除了\"+ll.removeLast());// 删除最后一个元素\n        System.out.println(ll);\n        System.out.println(\"删除了\"+ll.remove(2));// 删除index=2的元素\n        System.out.println(ll);\n    }\n}\n ## Iterator的使用方法 * Iterator是java集合框架中的一员, * 主要用于迭代访问(即遍历)Collection中的元素, * 因此Iterator对象也被称为迭代器.\npackage cn.usts.edu.iterator;\n\nimport com.sun.deploy.security.BadCertificateDialog;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description: Iterator的使用方法\n *                  Iterator是java集合框架中的一员,\n *                  主要用于迭代访问(即遍历)Collection中的元素,\n *                  因此Iterator对象也被称为迭代器.\n *\n * @date ：2021/11/1 10:16\n */\npublic class IteratorDemo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        Iterator iterator = al.iterator();// 获取迭代器对象\n\n        // hasNext()判断集合中是否存在下一个对象\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());// next()取出对象\n        }\n\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#foreach增强for循环遍历集合",
    "href": "posts/java集合-- 所有/index.html#foreach增强for循环遍历集合",
    "title": "java集合– 所有",
    "section": "ForEach(增强for循环)遍历集合",
    "text": "ForEach(增强for循环)遍历集合\nForEach的出现就是为了解决Iterator写起来太繁琐的问题\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: ForEach(增强for循环)遍历集合\n *                  ForEach的出现就是为了解决Iterator写起来太繁琐的问题\n * @date ：2021/11/1 10:32\n */\npublic class ForEachDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        for (Object o : al) {\n            System.out.println(o);// 打印元素\n        }\n    }\n}\n ## 迭代器注意点\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description: ForEach(增强for循环)遍历集合\n *                  ForEach的出现就是为了解决Iterator写起来太繁琐的问题\n * @date ：2021/11/1 10:32\n */\npublic class ForEachDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        for (Object o : al) {\n            System.out.println(o);// 打印元素\n            if (o.equals(\"stu2\")){\n                al.remove(o);\n\n                break;// 如果不加上的话,迭代器会报错,就是把这个元素删除掉了,迭代器下一个元素找不到了,用break跳出循环\n                /*\n                Exception in thread \"main\" java.util.ConcurrentModificationException\n                at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)\n                at java.util.ArrayList$Itr.next(ArrayList.java:861)\n                at cn.usts.edu.iterator.ForEachDemo.main(ForEachDemo.java:22)\n\n                * */\n                \n                \n            }\n        }\n        System.out.println(al);\n        \n        // 方法二\n        Iterator iterator = al.iterator();\n        while (iterator.hasNext()){\n            if (iterator.next().equals(\"stu2\")){\n                iterator.remove();\n            }\n        }\n        System.out.println(al);\n    }\n}"
  },
  {
    "objectID": "posts/java集合-- 所有/index.html#jdk8新加的foreach遍历集合",
    "href": "posts/java集合-- 所有/index.html#jdk8新加的foreach遍历集合",
    "title": "java集合– 所有",
    "section": "JDK8新加的forEach遍历集合",
    "text": "JDK8新加的forEach遍历集合\npackage cn.usts.edu.iterator;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: JDK8新加的forEach遍历集合\n * @date ：2021/11/1 10:58\n */\npublic class ForEachJdk8Demo {\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        al.forEach(obj-&gt; System.out.println(\"迭代集合元素\"+obj));\n    }\n}\n ## Iterator实现的遍历结果\n@Test\n    public void iteratorMethod(){\n        ArrayList al = new ArrayList();\n\n        al.add(\"stu1\");\n        al.add(\"stu2\");\n        al.add(\"stu3\");\n        al.add(\"stu4\");\n        al.add(\"stu5\");\n\n        Iterator iterator = al.iterator();\n        iterator.forEachRemaining(obj-&gt; System.out.println(\"遍历出来的元素\"+obj));\n    }\n ## HashSet\npackage cn.usts.edu.hashSet;\n\nimport java.util.HashSet;\n\n/**\n * @author ：fly\n * @description: HashSet的常规操作\n * @date ：2021/11/1 17:17\n */\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        HashSet hs = new HashSet();\n        hs.add(\"hello1\");\n        hs.add(\"hello2\");\n\n        hs.add(\"hello3\"); // 添加重复元素\n        hs.add(\"hello3\");\n        hs.add(\"hello3\");\n\n        hs.add(\"hello4\");\n\n        hs.forEach(obj-&gt; System.out.println(obj));// 遍历\n    }\n}\n # HashSet自定义obj类型,存储到haset中去重.\npackage cn.usts.edu.hashSet;\n\nimport org.junit.Test;\n\nimport java.util.HashSet;\n\n/**\n * @author ：fly\n * @description: HashSet的常规操作\n*                自己创建的对象要重写hashCode()和equals()方法 \n *\n * @date ：2021/11/1 17:17\n */\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        HashSet hs = new HashSet();\n        hs.add(\"hello1\");\n        hs.add(\"hello2\");\n\n        hs.add(\"hello3\"); // 添加重复元素\n        hs.add(\"hello3\");\n        hs.add(\"hello3\");\n\n        hs.add(\"hello4\");\n\n        hs.forEach(obj-&gt; System.out.println(obj));// 遍历\n    }\n\n\n\n    // 重写hashCode方法,针对自定义存储对象\n    @Test\n    public void test02(){\n        Student stu1 = new Student(1,\"Jack\");\n        Student stu2 = new Student(1,\"Jack\");\n\n        HashSet set = new HashSet();\n        set.add(stu1);\n        set.add(stu2);\n        set.forEach(obj-&gt; System.out.println(obj));\n        //System.out.println(set);\n\n\n\n    }\n}\n\n// pojo\nclass Student{\n    private int id;\n    private String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Student() {\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();//返回name的hash值\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj){//比较地址值,是否是同一个对象\n            return true;\n        }\n        if (!(obj instanceof Student)){// 不是学生的子类\n            return false;\n        }\n        Student student = (Student) obj;// 是学生的子类,且不是本身\n        boolean equals = this.name.equals(student.name);// 判断当前类的名字是否和传进来的name一致\n        return equals;\n    }\n}\n # TreeSet的使用\npackage cn.usts.edu.hashSet;\n\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description: TreeSet常规操作\n *               TreeSet的出现解决了HashSet无法排序的问题,\n * @date ：2021/11/1 17:50\n */\npublic class TreeSetDemo {\n\n    public static void main(String[] args) {\n        TreeSet ts = new TreeSet();\n        ts.add(1);\n        ts.add(82);\n        ts.add(33);\n        ts.add(74);\n        ts.add(5);\n        ts.add(16);\n        ts.add(26);\n        ts.add(36);\n        ts.add(22);\n        System.out.println(ts);\n\n        System.out.println(\"第一个是:\"+ts.first());\n        System.out.println(\"最后一个是:\"+ts.last());\n\n        System.out.println(\"集合中小于或等于26的最大的一个元素是:\"+ts.floor(26));\n        System.out.println(\"集合中大于30的最小的一个元素是:\"+ts.floor(30));// 没有返回null\n\n        System.out.println(\"删除第一个\"+ts.pollFirst());// 删除第一个\n        System.out.println(\"删除最后一个\"+ts.pollLast());// 删除最后一个\n        System.out.println(ts);\n\n    }\n}\n\n\n\n在这里插入图片描述\n\n\n# HashMap的常用操作和遍历 遍历: * 遍历值 - 增强for / 迭代器 * 遍历value - 增强for / 迭代器 * 遍历entrySet - 转换MapEntry对象 - 增强for / 迭代器\npackage cn.usts.edu.map.hashMap;\n\nimport java.util.*;\n\n/**\n * @author ：fly\n * @description: HashMap 的基本操作\n *               hashMap是  Key:Value的形式\n *               put()添加\n *               get()获取\n *               size()大小\n *               isEmpty()判空\n *               clear()清空\n *               remove()删除\n *               constainsKey()查找键是否存在\n *\n *               键不可以重复,key可以为空,value可以重复\n *               key相同会覆盖\n *               多数情况是String类型的key,value  Object类型都可以\n *\n *\n * @date ：2021/11/2 17:23\n */\n\n//@SuppressWarnings(\"all\")\npublic class HashMapDemo {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"小红\",\"95\");\n        map.put(\"小名\",\"85\");\n        map.put(\"小名\",\"85\");// 重复不添加\n        map.put(\"tom\",\"75\");\n        map.put(\"lucy\",79);\n        map.put(\"小军\",null);\n        map.put(\"小网\",null);\n        map.put(null,null);\n        map.put(null,\"小华\");//替换掉上面的null\n        System.out.println(map);\n\n        System.out.println(\"tom的value=\"+map.get(\"tom\"));\n        System.out.println(\"lucy的value=\"+map.get(\"lucy\"));\n\n        Set keySet = map.keySet();// 获取到所有键的集合\n        System.out.println(keySet);\n\n        System.out.println(\"小网是否存在:\"+map.containsKey(\"小网\"));\n        System.out.println(\"小王是否存在:\"+map.containsKey(\"小王\"));\n\n        System.out.println(\"是否包含(int)79:\"+map.containsValue(79));\n        System.out.println(\"是否包含79:\"+map.containsValue(\"79\"));\n\n        Collection values = map.values();\n        System.out.println(\"所有的值=\"+values);\n\n        System.out.println(\"------------遍历1-------------\");\n\n        // 方法1通过for循环和get遍历\n        for (Object key : keySet) {\n            System.out.println(key + \":\" + map.get(key));\n        }\n\n        System.out.println(\"------------遍历2-------------\");\n        // 方法2 迭代器\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext()){\n            String item =(String) iterator.next();// 遍历key\n            System.out.println(item+\":\"+map.get(item));\n        }\n\n        // 方法3  获取所有values 遍历\n        System.out.println(\"------------遍历3-------------\");\n        Collection value = map.values();\n        for (Object val : value) {\n            System.out.println(val);\n        }\n\n        // 方法4  通过获取值迭代器遍历\n        System.out.println(\"------------遍历4-------------\");\n        Iterator iterValue = value.iterator();\n        while (iterValue.hasNext()){\n            System.out.println(iterValue.next());\n        }\n        // 方法5 entrySet获取k-v\n        System.out.println(\"------------遍历5-------------\");\n        Set entrySet = map.entrySet();\n        for (Object o : entrySet) {\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey()+ \":\" + entry.getValue());\n        }\n\n        // 方法6   entrySet用迭代器 遍历\n        System.out.println(\"------------遍历6-------------\");\n        Iterator entryIterator = entrySet.iterator();\n        while (entryIterator.hasNext()){\n            Object next = entryIterator.next();\n            Map.Entry keyValue = (Map.Entry) next;\n            System.out.println(keyValue.getKey()+\":\"+keyValue.getValue());\n        }\n\n    }\n}\n\n\n ## TreeSet排序 Comparator()\npackage cn.usts.edu.collection.set.treeSet;\n\n\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description:  TreeSet 可以排序,但是要重写compare方法\n * @date ：2021/11/3 15:19\n */\npublic class TreeSetDemo {\n    public static void main(String[] args) {\n        TreeSet treeSet = new TreeSet(new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n\n                System.out.println(((String) o1).compareTo((String) o2));\n                // compareTo返回比较结果int,然后传入TreeMap中\n                // TreeMap中的put方法会调用重写compare方法,比较大小,大的放右节点,小的放左节点.\n                // return ((String) o1).compareTo((String) o2);// 字符串的compareTo方法比较\n                return ((String) o2).length() - ((String) o1).length();// 长度比较\n            }\n        });\n        treeSet.add(\"a\");\n        treeSet.add(\"swallow\");\n        treeSet.add(\"tree\");\n        treeSet.add(\"hello\");\n        treeSet.add(\"hello1\");\n        System.out.println(treeSet);// 直接 输出并不会排序,需要重写compare()\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/smt32-f103寄存器点灯/index.html",
    "href": "posts/smt32-f103寄存器点灯/index.html",
    "title": "smt32-f103寄存器点灯",
    "section": "",
    "text": "STM32F103寄存器点灯\n通过寄存器中的状态来设置引脚状态 LED在GPIOB的第5引脚\n// RCC_ENR RCC must be first otherwise the LED can not be lighted\n    *(unsigned int*)0x40021018 |= (1&lt;&lt;3);\n    // port B   base address 0x4001 0c00\n\n    // output type is pull and push\n    *(unsigned int*)0x40010C00 |= ((1)&lt;&lt;(4*0));\n    //*(unsigned int*)0x40010C00 |= ((1)&lt;&lt;(8*0));\n    \n\n    // port B odr address is base address add 0x0c  \n    *(unsigned int*)0x40010C0C &= ~(1&lt;&lt;0);\n    //*(unsigned int*)0x40010C0C &= ~(1&lt;&lt;2);\n封装GPIO\n// REG mapping \n#define PERIPH_BASE                 ((unsigned int) 0x40000000)\n    \n#define APB1_PERIPH_BASE         PERIPH_BASE\n#define APB2_PERIPH_BASE        (PERIPH_BASE+0x10000)\n#define AHB_PERIPH_BASE         (PERIPH_BASE+0x20000)\n\n#define RCC_BASE                        (AHB_PERIPH_BASE+0x1000)\n#define GPIOB_BASE                      (APB2_PERIPH_BASE +0x0C00)\n\n#define RCC_APB2ENR                     *(unsigned int*)(RCC_BASE+0x18)\n    \n#define GPIOB_CRL                       *(unsigned int*)(GPIOB_BASE+0x00)\n#define GPIOB_CRH                       *(unsigned int*)(GPIOB_BASE+0x04)\n#define GPIOB_ODR                       *(unsigned int*)(GPIOB_BASE+0x0C)\n    \n#define GPIOB_BSRR                  *(unsigned int*)(GPIOB_BASE+0x10)\n#define GPIOB_BRR                       *(unsigned int*)(GPIOB_BASE+0x14)\n#define GPIOB_LOCK                      *(unsigned int*)(GPIOB_BASE+0x18)\n\ntypedef unsigned int        uint32_t;\ntypedef unsigned short  uint16_t; \n\ntypedef struct{\n    uint32_t CRL; \n    uint32_t CRH; \n    uint32_t IDL; \n    uint32_t ODR; \n    uint32_t BSRR; \n    uint32_t BRR; \n    uint32_t LCKR;  \n}GPIO_Struct; \n\n// change the GPIO type to GPIO_Struct then can use the REG like [GPIO_Struct-&gt;RCC] \n#define GPIOB ((GPIO_Struct*)GPIOB_BASE)\n\n    RCC_APB2ENR |= (1&lt;&lt;3);\n\n    GPIOB-&gt;CRL |= ((1)&lt;&lt;(4*0));\n    \n    // open LED set 0\n    //GPIOB-&gt;ODR &= ~(1&lt;&lt;0);\n    // off LED set 1\n    GPIOB-&gt;ODR |= (1&lt;&lt;0);\n简单封装\n    RCC_APB2ENR |= (1&lt;&lt;3);\n\n    GPIOB_CRL |= ((1)&lt;&lt;(4*0));\n    \n    // open LED set 0\n    GPIOB_ODR &= ~(1&lt;&lt;0);\n    // off LED set 1\n    //GPIOB_ODR |= (1&lt;&lt;0);"
  },
  {
    "objectID": "posts/boom/index.html",
    "href": "posts/boom/index.html",
    "title": "binary bomb",
    "section": "",
    "text": "do some practise of asm and disasm, analazy the elf file and do some revserse things"
  },
  {
    "objectID": "posts/boom/index.html#浮点数实验",
    "href": "posts/boom/index.html#浮点数实验",
    "title": "binary bomb",
    "section": "浮点数实验",
    "text": "浮点数实验\n查看反汇编结果 phase_1\n0804949f &lt;phase_1&gt;:\n 804949f:       55                      push   %ebp\n 80494a0:       89 e5                   mov    %esp,%ebp\n 80494a2:       83 ec 28                sub    $0x28,%esp\n 80494a5:       c7 45 f4 f6 cc 4e 1a    movl   $0x1a4eccf6,-0xc(%ebp)  // 将立即数压栈到ebp-0xc的位置\n 80494ac:       db 45 f4                fildl  -0xc(%ebp)   // 将ebp中的值加载到浮点计算器栈顶\n 80494af:       dd 5d e8                fstpl  -0x18(%ebp)  // 将浮点寄存器的栈顶数据出栈放到ebp-0x18的位置上\n 80494b2:       8d 45 e0                lea    -0x20(%ebp),%eax // eax 压栈\n 80494b5:       50                      push   %eax\n 80494b6:       8d 45 e4                lea    -0x1c(%ebp),%eax\n 80494b9:       50                      push   %eax\n 80494ba:       68 bd a1 04 08          push   $0x804a1bd\n 80494bf:       ff 75 08                push   0x8(%ebp)\n 80494c2:       e8 09 fc ff ff          call   80490d0 &lt;__isoc99_sscanf@plt&gt;\n 80494c7:       83 c4 10                add    $0x10,%esp\n 80494ca:       83 f8 02                cmp    $0x2,%eax // 判断是否输入的是两个数\n 80494cd:       74 0c                   je     80494db &lt;phase_1+0x3c&gt;  // 如果等于 就跳转到80494db\n 80494cf:       e8 6b 09 00 00          call   8049e3f &lt;explode_bomb&gt;  // 不相等\n 80494d4:       b8 00 00 00 00          mov    $0x0,%eax\n 80494d9:       eb 2c                   jmp    8049507 &lt;phase_1+0x68&gt;\n 80494db:       8d 45 e8                lea    -0x18(%ebp),%eax\n 80494de:       8b 10                   mov    (%eax),%edx\n 80494e0:       8b 45 e4                mov    -0x1c(%ebp),%eax\n 80494e3:       39 c2                   cmp    %eax,%edx\n 80494e5:       75 0f                   jne    80494f6 &lt;phase_1+0x57&gt;\n 80494e7:       8d 45 e8                lea    -0x18(%ebp),%eax\n 80494ea:       83 c0 04                add    $0x4,%eax\n 80494ed:       8b 10                   mov    (%eax),%edx\n 80494ef:       8b 45 e0                mov    -0x20(%ebp),%eax\n 80494f2:       39 c2                   cmp    %eax,%edx\n 80494f4:       74 0c                   je     8049502 &lt;phase_1+0x63&gt;\n 80494f6:       e8 44 09 00 00          call   8049e3f &lt;explode_bomb&gt;\n 80494fb:       b8 00 00 00 00          mov    $0x0,%eax\n 8049500:       eb 05                   jmp    8049507 &lt;phase_1+0x68&gt;\n 8049502:       b8 01 00 00 00          mov    $0x1,%eax\n 8049507:       c9                      leave\n 8049508:       c3                      ret\nThe bomb has blown up. -167772160 1102728908 Phase 1 defused. How about the next one?"
  },
  {
    "objectID": "posts/jdbc-- druid/index.html",
    "href": "posts/jdbc-- druid/index.html",
    "title": "jdbc– druid",
    "section": "",
    "text": "在访问量很大的情况下,明显看出druid和c3p0的区别\npackage cn.usts.edu.jdbc.druid;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: druid数据库连接池\n * @date ：2021/11/6 14:53\n */\npublic class DruidDemo {\n    public static void main(String[] args) throws Exception {\n        FileInputStream fileInputStream = new FileInputStream(\"src/druid-config.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n        for (int i = 0; i &lt; 500000; i++) {\n            Connection connection = dataSource.getConnection();\n            connection.close();\n        }\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n}"
  },
  {
    "objectID": "posts/jdbc-- druid/index.html#druid",
    "href": "posts/jdbc-- druid/index.html#druid",
    "title": "jdbc– druid",
    "section": "",
    "text": "在访问量很大的情况下,明显看出druid和c3p0的区别\npackage cn.usts.edu.jdbc.druid;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: druid数据库连接池\n * @date ：2021/11/6 14:53\n */\npublic class DruidDemo {\n    public static void main(String[] args) throws Exception {\n        FileInputStream fileInputStream = new FileInputStream(\"src/druid-config.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n        for (int i = 0; i &lt; 500000; i++) {\n            Connection connection = dataSource.getConnection();\n            connection.close();\n        }\n\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n}"
  },
  {
    "objectID": "posts/jdbc-- druid/index.html#配置文件",
    "href": "posts/jdbc-- druid/index.html#配置文件",
    "title": "jdbc– druid",
    "section": "配置文件",
    "text": "配置文件\ndruid-config.properties 放src下\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/persons?characterEncoding=UTF-8\nusername=root\npassword=123321\n# 初始化连接数\ninitialSize=5\n#最大连接数\nmaxActive=10\n#超时时间\nmaxWait=3000"
  },
  {
    "objectID": "posts/javaGUI--icon/index.html",
    "href": "posts/javaGUI--icon/index.html",
    "title": "javaGUI–icon",
    "section": "",
    "text": "在maven项目中,将图片文件放入classes文件夹下才有效!!!!!\nURL url = ImageIconDemo.class.getResource(\"csdn.png\");获取不到图片的原因.   button.setToolTipText(\"图片按钮\");// 鼠标悬停上面会提示的文字\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class ImageIconDemo extends JFrame {\n\n    public ImageIconDemo() {\n        JLabel label01 = new JLabel(\"图片icon\");\n        JButton button = new JButton();\n\n        URL url = ImageIconDemo.class.getResource(\"csdn.png\");// 获取图片位置\n        ImageIcon imageIcon = new ImageIcon(url);// 实例化新的图片icon\n\n        label01.setIcon(imageIcon);\n        label01.setHorizontalAlignment(SwingConstants.CENTER);\n\n        button.setIcon(imageIcon);\n        button.setBounds(100,100,200,100);\n        button.setToolTipText(\"图片按钮\");// 鼠标悬停上面会提示的文字\n\n        Container container = this.getContentPane();\n        container.add(button);\n        container.add(label01);\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        this.setBounds(100,100,600,600);\n        this.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new ImageIconDemo();\n    }\n}\n\n解决方案 修改pom.xml文件\n&lt;!--所有文件复制到classes下--&gt;\n    &lt;build&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;**/*.java&lt;/exclude&gt;\n                &lt;/excludes&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;"
  },
  {
    "objectID": "posts/计算机组成原理--大端模式,小端模式/index.html",
    "href": "posts/计算机组成原理--大端模式,小端模式/index.html",
    "title": "计算机组成原理 – 大端模式,小端模式",
    "section": "",
    "text": "小端模式:低数据位存到低位地址 大端模式:高数据位存到低位地址 ## 小端模式 | 数值|地址 | |–|–| | 05 |0x0001\n| 06 |0x0002\n| 07 |0x0003\n| 08 |0x0004"
  },
  {
    "objectID": "posts/计算机组成原理--大端模式,小端模式/index.html#大端模式",
    "href": "posts/计算机组成原理--大端模式,小端模式/index.html#大端模式",
    "title": "计算机组成原理 – 大端模式,小端模式",
    "section": "大端模式",
    "text": "大端模式\n\n\n\n数值\n地址\n\n\n\n\n05\n0x0004\n\n\n06\n0x0003\n\n\n07\n0x0002\n\n\n08\n0x0001"
  },
  {
    "objectID": "posts/microChirpCreateProject/index.html",
    "href": "posts/microChirpCreateProject/index.html",
    "title": "Micro Chirp Create Project",
    "section": "",
    "text": "infineon 60 Ghz Radar SDK Guide, 现在手中只有infineonMCU760Ghz雷达Demo板, 所以, 按照现有方案进行开发.\nMCU7 + sensor-xensiv-bgt60trxx\n主控MCU: atmel ATSAMS70Q21\nAtmel 被MicroChip 在MicroChip 中现在是asm系列, 两条产品线互为补充\n\n主要分为两部分 - 设置microChip工程创建 - infineon雷达配置"
  },
  {
    "objectID": "posts/microChirpCreateProject/index.html#普通的工程创建-不推荐",
    "href": "posts/microChirpCreateProject/index.html#普通的工程创建-不推荐",
    "title": "Micro Chirp Create Project",
    "section": "普通的工程创建( 不推荐 )",
    "text": "普通的工程创建( 不推荐 )\n项目创建的很简单, 适合小型项目"
  },
  {
    "objectID": "posts/microChirpCreateProject/index.html#工程创建-推荐",
    "href": "posts/microChirpCreateProject/index.html#工程创建-推荐",
    "title": "Micro Chirp Create Project",
    "section": "工程创建( 推荐 )",
    "text": "工程创建( 推荐 )\n进入到atmel工程创建地址, 搜索对应的芯片, 选择后进入相关配置.\n\n对项目具体时钟, 引脚进行配置"
  },
  {
    "objectID": "posts/microChirpCreateProject/index.html#工程配置导出",
    "href": "posts/microChirpCreateProject/index.html#工程配置导出",
    "title": "Micro Chirp Create Project",
    "section": "工程配置导出",
    "text": "工程配置导出\n将当前的芯片配置进行导出成工程文件, 根据所需项目进行导出.\n\n点击Download之后会看到一个.atzip文件"
  },
  {
    "objectID": "posts/microChirpCreateProject/index.html#ide导入配置完成的工程文件",
    "href": "posts/microChirpCreateProject/index.html#ide导入配置完成的工程文件",
    "title": "Micro Chirp Create Project",
    "section": "ide导入配置完成的工程文件",
    "text": "ide导入配置完成的工程文件\n打开ide, 拖拉放入ide界面,弹出配置, 点击ok即可\n\n\nBuild\n编译项目\n\n编译完成, 到此项目创建完成, 下面进行雷达的相关配置."
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html",
    "title": "create env of esp32 s3 with IDF",
    "section": "",
    "text": "his article provides a brief overview of setting up the development environment for the ESP32-S3 chip using the ESP-IDF framework. The ESP32-S3 is a powerful Wi-Fi and Bluetooth Low Energy SoC. The setup involves installing the ESP-IDF toolchain, configuring variables, selecting a development board, and establishing a serial port connection. With this environment, developers can leverage the ESP-IDF’s API and components for application development in IoT and embedded systems."
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#安装依赖",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#安装依赖",
    "title": "create env of esp32 s3 with IDF",
    "section": "1. 安装依赖",
    "text": "1. 安装依赖\n1.1安装环境依赖\narch LINUX\nsudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb\n1.2安装Python3\npython2也可以， 还是推荐Python3\n查看Python版本\npython3 --version"
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#获取-esp-idf",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#获取-esp-idf",
    "title": "create env of esp32 s3 with IDF",
    "section": "2.获取 ESP-IDF",
    "text": "2.获取 ESP-IDF\nmkdir -p ~/esp\ncd ~/esp\ngit clone -b v5.0.2 --recursive https://github.com/espressif/esp-idf.git"
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#设置工具",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#设置工具",
    "title": "create env of esp32 s3 with IDF",
    "section": "3.设置工具",
    "text": "3.设置工具\n除了 ESP-IDF 本身，您还需要为支持 ESP32-S3 的项目安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等。\n\n默认安装位置`$HOME/.espressif\n\ncd ~/esp/esp-idf\n./install.sh esp32s3"
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#设置环境变量",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#设置环境变量",
    "title": "create env of esp32 s3 with IDF",
    "section": "4.设置环境变量",
    "text": "4.设置环境变量\n此时，您刚刚安装的工具尚未添加至 PATH 环境变量，无法通过“命令窗口”使用这些工具。因此，必须设置一些环境变量。这可以通过 ESP-IDF 提供的另一个脚本进行设置。\n. $HOME/esp/esp-idf/export.sh\n需要经常运行 ESP-IDF，您可以为执行 export.sh 创建一个别名, 这样做可以使得每个terminal环境隔离，不需要idf环境的时候开一个新的terminal即可。\n如果需要idf环境直接执行get_idf即可。\nalias get_idf='. $HOME/esp/esp-idf/export.sh'"
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#使用idf",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#使用idf",
    "title": "create env of esp32 s3 with IDF",
    "section": "5. 使用IDF",
    "text": "5. 使用IDF\n复制项目到自定义目录\ncd YOUR_PATH\ncp -r $IDF_PATH/examples/get-started/hello_world .\n设置目标芯片， 目前支持的芯片esp32|esp32s2|esp32c3|esp32s3|esp32c2|linux|esp32h2\ncd hello_world\nidf.py set-target esp32s3 \nidf.py menuconfig \nidf.py build\nidf.py flash"
  },
  {
    "objectID": "posts/esp32_s3_dev_create_env_linux/index.html#vscode-env",
    "href": "posts/esp32_s3_dev_create_env_linux/index.html#vscode-env",
    "title": "create env of esp32 s3 with IDF",
    "section": "vscode env",
    "text": "vscode env\n安装esp插件，然后选第三个选项，配置好之后，点击报错信息fix.., 修改c_cpp_properties.json 文件, 解决波浪线。\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"/home/dd21/esp/esp-idf/components/driver/include\",\n                \"/home/dd21/esp/esp-idf/components/esp_common/include\"\n                \n            ],\n            \"defines\": [],\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++14\",\n            \"intelliSenseMode\": \"linux-clang-x64\",\n            \"configurationProvider\": \"ms-vscode.cmake-tools\",\n            \"compilerPath\": \"/usr/bin/arm-none-eabi-gcc\"\n        }\n    ],\n    \"version\": 4\n}\n修改usb权限\n创建文件 sudo nvim /etc/udev/rules.d/10-usb-serial.rules\nKERNEL==\"ttyUSB[0-9]*\", MODE=\"0666\"\n重新加载udev规则以使更改生效：\nsudo udevadm control --reload-rules && sudo udevadm trigger"
  },
  {
    "objectID": "posts/Eclipse国内镜像快速下载/index.html",
    "href": "posts/Eclipse国内镜像快速下载/index.html",
    "title": "Eclipse国内镜像快速下载",
    "section": "",
    "text": "http://mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/"
  },
  {
    "objectID": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html",
    "href": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html",
    "title": "java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）",
    "section": "",
    "text": "字节流：可以输出字符、图片、声音及其他二进制数据 不设置【可能】会出现乱码情况 字符流：只可以输出字符 不设置会出现 ‘’？？？？？？’  中文变【问号】情况 \n处理乱码的方案：让浏览器和服务器端的编码方式一致\n\n\n        String outString = \"服务器编码设置UTF-8\";\n        \n        ServletOutputStream out  = response.getOutputStream();\n        // 服务器编码设置UTF-8\n        \n        // 输出到浏览器\n        out.write(outString.getBytes(\"utf-8\"));\n\n\n\n方法一：（简便写法）\nresponse.setContentType(\"text/html;charset=utf-8\");\n方法二：\nresponse.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");"
  },
  {
    "objectID": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字节流getoutputstream向浏览器输出中文出现乱码解决方案",
    "href": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字节流getoutputstream向浏览器输出中文出现乱码解决方案",
    "title": "java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）",
    "section": "",
    "text": "字节流：可以输出字符、图片、声音及其他二进制数据 不设置【可能】会出现乱码情况 字符流：只可以输出字符 不设置会出现 ‘’？？？？？？’  中文变【问号】情况 \n处理乱码的方案：让浏览器和服务器端的编码方式一致\n\n\n        String outString = \"服务器编码设置UTF-8\";\n        \n        ServletOutputStream out  = response.getOutputStream();\n        // 服务器编码设置UTF-8\n        \n        // 输出到浏览器\n        out.write(outString.getBytes(\"utf-8\"));\n\n\n\n方法一：（简便写法）\nresponse.setContentType(\"text/html;charset=utf-8\");\n方法二：\nresponse.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");"
  },
  {
    "objectID": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字符流getwriter向浏览器输出中文出现乱码解决方案",
    "href": "posts/java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）/index.html#字符流getwriter向浏览器输出中文出现乱码解决方案",
    "title": "java EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）",
    "section": "1.2字符流(getWriter())向浏览器输出中文出现乱码解决方案：",
    "text": "1.2字符流(getWriter())向浏览器输出中文出现乱码解决方案：\n方法一：\nresponse.setContentType(\"text/html;charset=utf-8\");\n方法二：\n        // 设置服务器编码\n        response.setCharacterEncoding(\"utf-8\");\n        // 设置浏览器编码格式\n        response.setHeader(\"content-type\", \"text/html;charset=utf-8\");"
  },
  {
    "objectID": "posts/ubuntu_create_pico_env/index.html",
    "href": "posts/ubuntu_create_pico_env/index.html",
    "title": "create env on ubuntu",
    "section": "",
    "text": "config rp2040 on ubuntu with daplink. use picolab debuger."
  },
  {
    "objectID": "posts/ubuntu_create_pico_env/index.html#minicom",
    "href": "posts/ubuntu_create_pico_env/index.html#minicom",
    "title": "create env on ubuntu",
    "section": "minicom",
    "text": "minicom\n\nttyACM0 是一个 Linux 系统中的串行设备节点，它通常用于连接 USB 模拟串行设备，例如 Arduino 开发板、3D 打印机或其他类似设备。ACM 代表“Abstract Control Model”，是指通常用于模拟串行通信的 USB 设备类型。\n\n\n当 Linux 系统检测到一个 USB 模拟串行设备时，它会将其分配给 ttyACM0 节点。通过这个节点，用户可以与设备进行串口通信，例如通过命令行工具或编程语言（如 C/C++、Python 等）读取和写入数据。\n\n\n值得注意的是，如果有多个 USB 模拟串行设备连接到 Linux 系统，那么它们可能会分配给不同的 ttyACM 节点，例如 ttyACM1、ttyACM2 等\n\nminicom -s =&gt; serial port config =&gt; device /dev/ttyACM0\nsudo minicom    // startup\nCtl + a  =&gt; e  // open warp\nCtl + a  =&gt; x  // exit"
  },
  {
    "objectID": "posts/fmcw/index.html",
    "href": "posts/fmcw/index.html",
    "title": "FMCW",
    "section": "",
    "text": "Abstract\nbasic knowledge of mmwave radar\n\n\nReferance\nzhihu\n\n\n调频连续波雷达（FMCW radar）\n调频连续波集各种雷达优点。\n发射频率随着时间的变化而线性变化， \n\n合成器发生线性调频信号\n通过发射天线发射出该信号\n接收天线接收回波信号\n通过混频器进行将回波信号和当前合成器的信号进行混频\n混频后产生中频信号（if）\n\n\n\n单个物体距离检测\n接收的回波信号即是发射信号的副本，由于时间原因发生了偏移。\n\n从发射到接收到回波信号一共花费时间为τ，频率的变化为Sτ。 混频器的输出IF信号为将两信号重合区（即图(a)中垂直虚线之间的时段）内的两信号相减即可。因为这两个信号是相同的，所以该中频信号只有一个单音频率。\n所以该频率为：f = τ*S(频率=时间*斜率) = 2d/c*S=2dS/c\n\n\n频率分辨率\n是指将两个相邻谱峰分开的能力。在实际应用中是指分辨两个不同频率信号的最小间隔，观察窗越长越好，可以更准确的分辨不同频率  一般来说，观察时长为T的一个观察窗可以分离相隔超过1/T Hz的频率分量 \n\n\n距离分辨率\n距离分辨率是雷达在距离维度上辨别两个或更多物体的能力(发射垂直方向【正前方上的距离】)。当两个物体相对于雷达的距离近到某个特定值时，雷达便不能再将二者区分开，将两个物体分辨为同一个物体。\n\n雷达探测到多个目标，接收天线会接收到多个回波信号，即会有多个if（中频信号），经过fft后就是多个峰，"
  },
  {
    "objectID": "posts/jdbc--事务/index.html",
    "href": "posts/jdbc--事务/index.html",
    "title": "jdbc–事务",
    "section": "",
    "text": "事务\n事务的出现是为了防止一个由两个人交互的事情,出现不同的结果,把两个或多个步骤看成一个步骤, 如果有任意一方没有满足,则视为事务终止=没做\n\n执行前\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n执行后\n ## 为了防止这样的事情发生出现了事务\npackage cn.usts.edu.jdbc.rollback;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * @author ：fly\n * @description: 事务操作\n *                  B转钱给A100块\n * @date ：2021/11/6 12:13\n */\npublic class RollbackDemo {\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        try {\n            DriverManager.registerDriver(driver);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection((String) properties.get(\"url\"), (String) properties.get(\"user\"), (String) properties.get(\"password\"));\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        String sql1 = \"UPDATE `persons`.`money` SET `money` = 1400+100 WHERE `name` = 'A'\";\n        String sql2 = \"UPDATE `persons`.`money` SET `money` = 1400-100 WHERE `name` = 'B'\";\n\n\n        PreparedStatement preparedStatement = null;\n        PreparedStatement preparedStatement1 = null;\n        try {\n            connection.setAutoCommit(false);// 默认自动提交,我们设置不自动提交\n\n            preparedStatement = connection.prepareStatement(sql1);\n            preparedStatement.executeUpdate();\n\n            int i=1/0;\n\n            preparedStatement1 = connection.prepareStatement(sql2);\n            preparedStatement1.executeUpdate();\n\n            //提交事务\n            connection.commit();\n        } catch (SQLException e) {\n            System.out.println(\"事务回滚了\");\n            connection.rollback();//回滚\n\n        }\n\n        // 关闭\n        try {\n            preparedStatement.close();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n}\n\n关闭自动提交 connection.setAutoCommit(false)\n捕获异常 try catch\n最后提交 connection.commit();\n回滚 connection.rollback();//回滚"
  },
  {
    "objectID": "posts/java多线程-- 生产者消费者/index.html",
    "href": "posts/java多线程-- 生产者消费者/index.html",
    "title": "java多线程– 生产者消费者",
    "section": "",
    "text": "有一家店,有很多人来,为了提升顾客体验,前台可以放10份餐,不足10份后厨就会通知后厨补上,如果到10份就停止生产.,只要前台有餐就通知顾客取餐,没有餐让顾客等待.\n代码有问题,希望大佬指点下 (已找到, 把else去掉就好了) \n进程会一直卡在这里 \npackage cn.usts.edu.lesson08;\n\nimport cn.usts.util.Utils;\n\n\n/**\n * 生产者消费之\n * 一个资源被需要,才会被创建,\n * 在生产者和消费者中间还有一个容器作为缓冲,作为一个生产的标志\n *\n *\n * 逻辑没有问题,代码有问题.\n * */\n\npublic class ProductorConsumerDemo {\n    public static void main(String[] args) {\n        Container1 container = new Container1();\n        Productor productor = new Productor(container);\n        Consumer consumer = new Consumer(container);\n        productor.start();\n        consumer.start();\n    }\n\n\n}\n\n// 生产者\nclass Productor extends Thread{\n    Container1 container;\n\n    public Productor(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 生产100只鸡\n        for (int i = 0; i &lt; 100; i++) {\n            container.push(new Chicken(i));\n            System.out.println(\"生产了第\"+i+\"只鸡\");\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread{\n    Container1 container;\n\n    public Consumer(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 消费100只鸡\n        for (int i = 0; i &lt; 100; i++) {\n            Chicken chicken = container.pop();\n            System.out.println(\"消费了第--------\"+chicken.id+\"只鸡\");\n        }\n    }\n}\n\n\n// 生产的产品\nclass Chicken{\n    int id;// 产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n\n// 容器 缓冲\nclass Container1 extends Utils {\n\n    // 容器\n    Chicken[]  chickens = new Chicken[10];//默认可以放10只鸡\n\n    int count=0;//用来计数\n    int index=1;\n\n    // 把鸡放到容器中\n    public synchronized void push(Chicken chicken){\n        // 如果数量达到容器的最大数量,停止生产\n        if (chickens.length==count){\n            try {\n                System.out.println(count+\"---------------------\");\n                this.wait();// 容器满了通知生产者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 如果没有达到容器数量,就生产\n        \n            chickens[count] = chicken;//把鸡放到容器中\n            count++;//容器数量加1\n\n            this.notifyAll();//全都唤醒\n        \n    }\n\n    // 消费者消费鸡\n    public synchronized Chicken pop(){\n        // 判断容器中有么有鸡\n        if (count==0){\n            try {\n                this.wait(); // 通知消费者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 有鸡\n        count--;\n        Chicken chicken = chickens[count]; // 有bug\n        this.notify();//通知消费者消费\n        return chicken;\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/java多线程-- 生产者消费者/index.html#生产者消费者问题",
    "href": "posts/java多线程-- 生产者消费者/index.html#生产者消费者问题",
    "title": "java多线程– 生产者消费者",
    "section": "",
    "text": "有一家店,有很多人来,为了提升顾客体验,前台可以放10份餐,不足10份后厨就会通知后厨补上,如果到10份就停止生产.,只要前台有餐就通知顾客取餐,没有餐让顾客等待.\n代码有问题,希望大佬指点下 (已找到, 把else去掉就好了) \n进程会一直卡在这里 \npackage cn.usts.edu.lesson08;\n\nimport cn.usts.util.Utils;\n\n\n/**\n * 生产者消费之\n * 一个资源被需要,才会被创建,\n * 在生产者和消费者中间还有一个容器作为缓冲,作为一个生产的标志\n *\n *\n * 逻辑没有问题,代码有问题.\n * */\n\npublic class ProductorConsumerDemo {\n    public static void main(String[] args) {\n        Container1 container = new Container1();\n        Productor productor = new Productor(container);\n        Consumer consumer = new Consumer(container);\n        productor.start();\n        consumer.start();\n    }\n\n\n}\n\n// 生产者\nclass Productor extends Thread{\n    Container1 container;\n\n    public Productor(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 生产100只鸡\n        for (int i = 0; i &lt; 100; i++) {\n            container.push(new Chicken(i));\n            System.out.println(\"生产了第\"+i+\"只鸡\");\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread{\n    Container1 container;\n\n    public Consumer(Container1 container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        // 消费100只鸡\n        for (int i = 0; i &lt; 100; i++) {\n            Chicken chicken = container.pop();\n            System.out.println(\"消费了第--------\"+chicken.id+\"只鸡\");\n        }\n    }\n}\n\n\n// 生产的产品\nclass Chicken{\n    int id;// 产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n\n// 容器 缓冲\nclass Container1 extends Utils {\n\n    // 容器\n    Chicken[]  chickens = new Chicken[10];//默认可以放10只鸡\n\n    int count=0;//用来计数\n    int index=1;\n\n    // 把鸡放到容器中\n    public synchronized void push(Chicken chicken){\n        // 如果数量达到容器的最大数量,停止生产\n        if (chickens.length==count){\n            try {\n                System.out.println(count+\"---------------------\");\n                this.wait();// 容器满了通知生产者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 如果没有达到容器数量,就生产\n        \n            chickens[count] = chicken;//把鸡放到容器中\n            count++;//容器数量加1\n\n            this.notifyAll();//全都唤醒\n        \n    }\n\n    // 消费者消费鸡\n    public synchronized Chicken pop(){\n        // 判断容器中有么有鸡\n        if (count==0){\n            try {\n                this.wait(); // 通知消费者等待\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 有鸡\n        count--;\n        Chicken chicken = chickens[count]; // 有bug\n        this.notify();//通知消费者消费\n        return chicken;\n\n\n\n    }\n\n}"
  },
  {
    "objectID": "posts/文件管理服务器/index.html",
    "href": "posts/文件管理服务器/index.html",
    "title": "文件管理服务器",
    "section": "",
    "text": "https://blog.laoda.de/archives/docker-compose-install-nextcloud"
  },
  {
    "objectID": "posts/java多线程-- 死锁模拟( synchronized )/index.html",
    "href": "posts/java多线程-- 死锁模拟( synchronized )/index.html",
    "title": "java多线程– 死锁模拟( synchronized )",
    "section": "",
    "text": "化妆需要镜子,口红\n 两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n 就造成了死锁的问题\n程序一直处于等待状态 \n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型\n *      化妆需要镜子,口红\n *      两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n *      就造成了死锁的问题\n *\n * 解决方案:\n *      不能拿对方的锁\n *\n *\n * */\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        MakeUp makeUp1 = new MakeUp(0,\"白雪公主\");\n        MakeUp makeUp2 = new MakeUp(1,\"灰姑娘\");\n        new Thread(makeUp1).start();\n        new Thread(makeUp2).start();\n    }\n}\n\n// 口红\nclass Lipstick{\n\n}\n\n// 镜子\nclass Mirror{\n\n}\n\n// 化妆\nclass MakeUp implements Runnable {\n\n    // 资源只有一份,用static修饰\n    static final Lipstick lipstick = new Lipstick();\n    static final Mirror mirror = new Mirror();\n\n    int choice;\n    String name;\n\n    MakeUp(int choice,String name){\n        // choice = 0;先拿镜子,\n        // choice = 1;先拿口红\n        this.choice = choice;\n        this.name = name;\n    }\n\n    private void makeup() throws InterruptedException {\n        if (choice==0){\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红,上了锁,别人不许用,还想要镜子\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    System.out.println(name+\"拿到了镜子的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n\n        }else {\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,别人不许用,还想要口红\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    System.out.println(name+\"拿到了口红的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n        }\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 死锁模拟( synchronized )/index.html#死锁模拟",
    "href": "posts/java多线程-- 死锁模拟( synchronized )/index.html#死锁模拟",
    "title": "java多线程– 死锁模拟( synchronized )",
    "section": "",
    "text": "化妆需要镜子,口红\n 两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n 就造成了死锁的问题\n程序一直处于等待状态 \n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型\n *      化妆需要镜子,口红\n *      两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n *      就造成了死锁的问题\n *\n * 解决方案:\n *      不能拿对方的锁\n *\n *\n * */\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        MakeUp makeUp1 = new MakeUp(0,\"白雪公主\");\n        MakeUp makeUp2 = new MakeUp(1,\"灰姑娘\");\n        new Thread(makeUp1).start();\n        new Thread(makeUp2).start();\n    }\n}\n\n// 口红\nclass Lipstick{\n\n}\n\n// 镜子\nclass Mirror{\n\n}\n\n// 化妆\nclass MakeUp implements Runnable {\n\n    // 资源只有一份,用static修饰\n    static final Lipstick lipstick = new Lipstick();\n    static final Mirror mirror = new Mirror();\n\n    int choice;\n    String name;\n\n    MakeUp(int choice,String name){\n        // choice = 0;先拿镜子,\n        // choice = 1;先拿口红\n        this.choice = choice;\n        this.name = name;\n    }\n\n    private void makeup() throws InterruptedException {\n        if (choice==0){\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红,上了锁,别人不许用,还想要镜子\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    System.out.println(name+\"拿到了镜子的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n\n        }else {\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,别人不许用,还想要口红\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    System.out.println(name+\"拿到了口红的锁,别人不许用,现在我都拿到,化完妆了\");\n                }\n            }\n        }\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 死锁模拟( synchronized )/index.html#解决方案",
    "href": "posts/java多线程-- 死锁模拟( synchronized )/index.html#解决方案",
    "title": "java多线程– 死锁模拟( synchronized )",
    "section": "解决方案",
    "text": "解决方案\n依次获取资源, 一个目标不能同时拿到两个把锁 \npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型\n *      化妆需要镜子,口红\n *      两个人分别拿到镜子和口红,谁都不让谁,都想拿到对方手里的资源\n *      就造成了死锁的问题\n *\n * 解决方案:\n *      不能拿对方的锁\n *\n *\n * */\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        MakeUp makeUp1 = new MakeUp(0,\"白雪公主\");\n        MakeUp makeUp2 = new MakeUp(1,\"灰姑娘\");\n        new Thread(makeUp1).start();\n        new Thread(makeUp2).start();\n    }\n}\n\n// 口红\nclass Lipstick{\n\n}\n\n// 镜子\nclass Mirror{\n\n}\n\n// 化妆\nclass MakeUp implements Runnable {\n\n    // 资源只有一份,用static修饰\n    static final Lipstick lipstick = new Lipstick();\n    static final Mirror mirror = new Mirror();\n\n    int choice;\n    String name;\n\n    MakeUp(int choice,String name){\n        // choice = 0;先拿镜子,\n        // choice = 1;先拿口红\n        this.choice = choice;\n        this.name = name;\n    }\n\n    private void makeup() throws InterruptedException {\n        if (choice==0){\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红,上了锁\");\n                Thread.sleep(5000);\n            }\n\n            System.out.println(name+\"口红使用完了,我还想用镜子\");\n\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,我口红和镜子都用完了.化完妆了\");\n            }\n        }\n        else {\n            synchronized (mirror){\n                System.out.println(name+\"拿到了镜子,上了锁,还想要口红\");\n                Thread.sleep(7000);\n            }\n\n            System.out.println(name+\"镜子使用完了,我还想用口红\");\n\n            synchronized (lipstick){\n                System.out.println(name+\"拿到了口红的锁,别人不许用,我口红和镜子都用完了,化完妆了\");\n            }\n        }\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- Tcp聊天/index.html",
    "href": "posts/java网络编程-- Tcp聊天/index.html",
    "title": "java网络编程– Tcp聊天",
    "section": "",
    "text": "客户端\npackage cn.usts.edu.lesson02;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TcpClientDemo01 {\n    public static void main(String[] args) {\n        Socket socket=null;\n        OutputStream os = null;\n\n        // 1*要知道服务器的地址\n        try {\n            InetAddress ServerIP = InetAddress.getByName(\"127.0.0.1\");\n            int port=9999;\n            socket = new Socket(ServerIP, port);//建立一个插座\n            os = socket.getOutputStream();\n            os.write(\"第一个tcp聊天室\".getBytes());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n        if (socket!=null){\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (os!=null){\n            try {\n                os.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n服务端\npackage cn.usts.edu.lesson02;\n\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpServerDemo01 {\n    public static void main(String[] args) {\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream byteArrayOutputStream = null;\n\n        // 1*首先得先有一个地址,让被人连过来\n        try {\n            // serverSocket默认开启服务的主机,当前的ip地址为服务器地址,所以只需要个端口号\n            serverSocket = new ServerSocket(9999);\n            while (true){\n                socket = serverSocket.accept();// 监听  监听接受到socket就是连接上来的socket\n                inputStream = socket.getInputStream();\n                // 读取消息\n            /*  获取超过1024个字节的中文就容易产生乱码\n            InputStream inputStream = socket.getInputStream();\n            byte[] buffer =new byte[1024];\n            int len;\n            // 从输入流读取一些字节数，并将它们存储到缓冲区b 。 实际读取的字节数作为整数返回。\n            while ((len=inputStream.read(buffer))!=-1){\n                String msg = new String(buffer, 0, len);\n                System.out.println(msg);\n            }  */\n                byteArrayOutputStream = new ByteArrayOutputStream();\n                int len;\n                byte[] buffer = new byte[1024];\n                while ((len=inputStream.read(buffer))!=-1){\n                    byteArrayOutputStream.write(buffer,0,len);\n                }\n                System.out.println(byteArrayOutputStream.toString());\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        if (byteArrayOutputStream!=null){\n            try {\n                byteArrayOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream!=null){\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (socket!=null){\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverSocket!=null){\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- URL(网络资源下载)/index.html",
    "href": "posts/java网络编程-- URL(网络资源下载)/index.html",
    "title": "java网络编程– URL(网络资源下载)",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * 利用URL进行网络文件下载\n * */\npublic class URLDownload {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"https://img-home.csdnimg.cn/images/20211019040101.gif\");\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();//打开连接,对链接进行访问;\n        InputStream inputStream = urlConnection.getInputStream();\n        FileOutputStream fileOutputStream = new FileOutputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\" +\n                \"\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson06\\\\download.gif\");\n        byte[] buffer = new byte[1024];\n        int len;\n        while ((len=inputStream.read(buffer))!=-1){\n            fileOutputStream.write(buffer,0,len);\n        }\n        fileOutputStream.close();\n        inputStream.close();\n        System.out.println(\"下载完成\");\n    }\n}"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html",
    "href": "posts/mmwave_getting_started/index.html",
    "title": "getting started with mmwave radar",
    "section": "",
    "text": "This article provides an introduction to getting started with mmWave radar. mmWave radar is a powerful sensing technology used for measuring, detecting, and tracking target objects. The article focuses on the principles and operation of mmWave radar, as well as the methods for obtaining the necessary hardware and software resources. Basic hardware connections and configuration settings for launching an mmWave radar system are further discussed. Lastly, resources and references for further exploring mmWave radar are provided.\nKeywords: mmWave radar, principles, operation, hardware resources, software resources, hardware connections, configuration settings, research resources, references."
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#距离解析",
    "href": "posts/mmwave_getting_started/index.html#距离解析",
    "title": "getting started with mmwave radar",
    "section": "1. 距离解析",
    "text": "1. 距离解析\n\n1.1 什么是混频器(MIXER)\n混频器, 有2个输入一个输出, 并且有两个特性 - 输出的瞬时频率 等于 两个输入正弦波的瞬时 频率的差值 - 输出正弦波的起始相位等于两个 输入正弦波的 起始相位差值\n\n总结: 混频器输出 相位等于两个输入的起始相位的差 () 混频器输出 频率等于两个输入的瞬时频率差 (所以他们之间的频率差都是相等的)\n\nφ: 相位 w: 频率\n\\[input_1:  x_1 = sin(w_1𝑡 + φ1) \\] \\[input_2 :  𝑥2 = sin(w_2𝑡 + φ2) \\]\n\\[output = input_1+input_2  = sin((w_2-w_1)𝑡 + (φ2-φ1))\\]\n\n单目标测距原理\n\n中频信号 = 斜率 x 时延.\nIF = S*τ\nIF = S*(2d/c) d:传播距离 c:光速\nd = IF*c/2S\n\n\n\n距离分辨率, 区分多目标\n\n通过FFT将时域信号转换为频域信号, 所表现出来的是多个目标的频域信号会出现多个峰, 两个脉冲相差小于一个周期则无法很明显观察到峰, 观测时间越长, 峰越清晰\n观察时长为T的一个观察窗可以分离相隔超过1/T Hz的频率分量(个人理解应该是带宽B/T的频率分量)????\n观察窗口长度为 的 IF 信号能将间距为 的谱峰分开。故通过增加 IF 信号的长度（观察期）来可以改善距离分辨率。而信号长度的增加会使信号带宽 随之变宽，因此，也可以说增加 IF 信号的带宽可以改善距离分辨率。\n\n\n &gt; ## 相关应用的个人推测 &gt; - 因为观察窗时间加长, 所以带宽B也线性增加. &gt; - 所以斜率对于应用的影响非常关键 &gt; - 如果是短距离的目标距离分辨, 那合理推测斜率应该是比较大, 这样可以区分出近距离的不同目标, 且可以使得观察窗T的周期尽可能缩短. &gt; - 如果是远距离的物体, 那斜率应该尽可能的小,这样可以检测到远处目标的反射信号, &gt; - 那这样的话, ti的vitalSign的项目就是斜率比较高的配置\n\n区分多个目标–总结\n\n区分多个目标的原理,就是将两个相距为△d的目标映射到频率差为△f的两个峰\n最小分辨率: c/2B\n\n\n推导:\n\\[\n{△f&gt;}{1\\over T }\n\\]\n\\[\n{2△dS\\over c}&gt;{1\\over T }\n\\] \\[\n{△d}&gt;{c\\over 2ST }\n\\] 又因为: B=ST \\[\n{△d}&gt;{c\\over 2B }\n\\]"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#距离分辨率计算",
    "href": "posts/mmwave_getting_started/index.html#距离分辨率计算",
    "title": "getting started with mmwave radar",
    "section": "距离分辨率计算:",
    "text": "距离分辨率计算:\n扫频带宽 B = 4G 距离分辨率 $ {△d} = {c2B }={310^8 (m/s)4*10^9(Hz)}$ = 0.0375m\n距离越远, (中频信号)频率越高, 距离和(中频信号)频率成正比, 因发射的脉冲, 遇到物体返回的时间越长(τ越大), 对应的图上的Sτ就越大(即中频信号的频率就越大)."
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#问题-同样的扫频带宽-但是斜率不一样-哪一个的距离分辨率好",
    "href": "posts/mmwave_getting_started/index.html#问题-同样的扫频带宽-但是斜率不一样-哪一个的距离分辨率好",
    "title": "getting started with mmwave radar",
    "section": "问题: 同样的扫频带宽, 但是斜率不一样, 哪一个的距离分辨率好",
    "text": "问题: 同样的扫频带宽, 但是斜率不一样, 哪一个的距离分辨率好\nchirpA好于chirpB, 为什么因为前面推理过, 观测时间窗越长分辨效果越好, A的持续时间更长, 所以A具有更好的距离分辨率.\n\n对于上面的问题, 如果我们必须使用较短的持续时间, 且需要较好的距离分辨率, 那该如何解决.\n雷达倾向于使用大距离小斜率, 这样的话可以缓解ADC的压力, 受限制于目前的技术ADC的采样速度有限, 所以尽可能的降低ADC采样速度. &gt; 对应公式来看, 那么当斜率较高时(f_IFmax), d_max(最大探测距离)也比较大, 斜率S较小d_max也较小.\n\\[\nf_{IFmax}={2S d_{max}\\over c}\n\\]\n\n最远探测距离\nIF信号通常经过数字化处理（LPF + ADC），才在DSP上进行进一步处理，因此，中频信号的大小取决于ADC采样频率（FS）。\n\n\\[\nFs&gt;f_{IFmax}=S2d_{max}/c\n\\]\n因此最大距离为： \\[\nd_{max} = {F_s{c} \\over 2S}\n\\]\n例子:\nADC配置: 默认最大采样率25Mhz\nprofileCfg 0 77 7 7 114.4 0 0  33.71 1 256 2500 0 0 48\n最大距离 ADC有效采样率 = 0.9 * ADC采样率 2500kps =&gt; 2.5Mhz 为什么是33.71*10^12 因为S为33.71Mhz/us =&gt; 33.71*10^6Hz/us =&gt; 33.71*10^6*10^6Hz/s =&gt; 33.71*10^12Hz/s \\[\nRmax = {0.9*2.5*10^{6}*3*10^{8}\\over 2*33.71*10^{12}} = 10.011865...m\n\\]"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#中频信号的相位",
    "href": "posts/mmwave_getting_started/index.html#中频信号的相位",
    "title": "getting started with mmwave radar",
    "section": "中频信号的相位",
    "text": "中频信号的相位\n雷达将Tx信号发出, 经过△t时间后接收到返回信号Rx(B), 接收到的Rx信号为Tx信号的副本信号(B开始的灰色段), 但是物体由于自身的运动, 第二次的回波信号(E)和第一次的回波信号(B)产生了偏移(BE), 该段相位偏移导致了,中频信号(IF)的相位也发生了偏移(混频器), 并且他们的偏移量都是一样的, 所以可以通过相位的变化来反应时间(△τ)的变化, 因为电磁波传播的速度是不变的, 所以通过时间反推出距离的变化(△d=△τ/c).\n由上面的推理可以将CF之间的相位变化转换为BE之间的相位变化, 同理BE之间的相位变化转换为AD之间的相位变化, D处的相位是基于A处的相位变化的,\n\n波长和频率的关系: λ = c/f m λ = c/f =3/77 = 0.003896m\n\n\n\n\\[\nΔΦ=2πf_c Δτ= {4πΔd\\overλ}\n\\]\n推导:\n\\[\nΔτ= {{2Δd}\\over c} \\\\\n{λ= fc}, \\space \\space f={c\\overλ}\\\\\n2πf_c Δτ =\\space 2π {c\\overλ} {{2Δd}\\over c} = {4πΔd\\overλ}\n\\]\n举例:\n雷达系统配置:\n\n雷达前方的物体移动1mm，相位的变化为(1/4)*λ, 相位变化很大\n\\[\n\\Delta \\phi= \\frac{4\\pi \\Delta d}{\\lambda} = \\pi = 180\\degree\n\\]\n频率变化, \\[\nΔf= {S2Δd\\over c}=    {{50∗10^{12}∗2∗1∗10^{−3}}\\over{3∗10^8}}=333Hz\n\\]\n333Mhz对于77G来说太小了, 分辨比较困难. \\[\nΔfT_c=333∗40∗10^{−6}=0.013cycles\n\\]"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#速度测量原理",
    "href": "posts/mmwave_getting_started/index.html#速度测量原理",
    "title": "getting started with mmwave radar",
    "section": "速度测量原理",
    "text": "速度测量原理\n\n\n发送两个时间间隔为Tc 的 chirp\n对接收回来的信号做range-FFTs会在相位的位置产生峰值，但是有不同的相位\n相位差(ω)对应于物体移动的距离(d=vt)d=v*Tc，v是物体的速度，Tc是时间\n\n\\[\nω= {4πvTc\\overλ}\n​\\]\n推导\n\\[\nv= {ωλ\\over4πTc}\n\\]\n因此两个连续的chirp可以用来估计一个目标的速度\n​物体微小位移和震动检测 假设运动幅度非常小，因此物体的最大位移 是波长的一小部分（例如，一毫米或更小）。如果我们在这个振荡物体的前面放置一个雷达并发射一串等距的线性调频信号，则这些线性调频信号中的每一个都会产生反射线性调频信号，而处理后的 IF 信号将产生距离 FFT 中的峰值。这些峰值的频率不会发生太大变化，但是峰值的相位将响应物体的振荡运动\n\n下图为相位-时间图\n\n故相位的时间演化可用于估计振动的幅度和周期性。"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#速度估计",
    "href": "posts/mmwave_getting_started/index.html#速度估计",
    "title": "getting started with mmwave radar",
    "section": "速度估计",
    "text": "速度估计\n这里章节TI的字幕有误\n参考 xiaojie\n有一个离散信号(数字采样的信号)，该向量以每个样本ω弧度的恒定速率旋转，如下图：\n\n这些采样点在经过FFT后会在ω的位置产生一个峰值\n\n假设一个信号是两个相位之和，则经过FFT后会产生两个峰值(每个相位中的每个样本点的旋转角频率分别为ω1 和ω2) &gt; A1: 频率 &gt; ω: 相位\n\n当  ω1 = 0 , ω2 = π/N , 经过N个采样点后，第二个相位比第一个相位多半个周期(π rads)，这个变化在频域上不足以区分这两个物体.\n\nω1对应下图中的1, ω2 -&gt; 2 …\n\n\n当经过2N个采样点后，第二个相位比第一个相位多一个周期(2π rads)，这个变换在频域上就可以区分这两个物体\n\n该部分的前提条件都是  在一个信号周期(2π)内该值固定  当采样点为2N的时候, 离散角频率的分辨率为2 π / N  因为信号周期为2π固定不变, 所以为了提高分辨率需要提高采样点数, 但是该参数和硬件ADC性能有关\n\n\n序列长度越长，分辨率越高，一般来说，一个长度为N的序列可以分离出超过2 π / N以上的角频率\n比较连续和离散信号在频域分辨率的标准\n连续信号：时间轴上的信号是连续的.\n该种情况下, 只有当频率变化大于1/T(秒s)才可以被捕捉到.\n\\[\nΔf= {1\\over T} cycles/sec\n\\]\n离散信号: 在时间轴上的取值是离散的信号\n只要两个离散信号的频率间隔差值ω大于2 π / N,即可区分出两种频率\n\\[\nΔω={2 π \\over N}radians/sample = {1\\over N}cycles/sample \\space ( 1cycles= 2π {\\space}radians)\n\\] 一种情况是分辨率与观测时间T表示的长度成反比，另一种情况是分辨率与观测样本数N表示的长度成反比"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#雷达如何估计一个物体的速度",
    "href": "posts/mmwave_getting_started/index.html#雷达如何估计一个物体的速度",
    "title": "getting started with mmwave radar",
    "section": "雷达如何估计一个物体的速度",
    "text": "雷达如何估计一个物体的速度\n使用两个chirp来进行速度的测量\n\n发送两个时间间隔为Tc 的chirp\n每个chirp的range-FFT在相同的位置会出现峰值，但是会有不同的起始相位\n测量的相位差对应于物体的移动距离(vTc)\n\n\n相位差：\n\\[\nω =\\space 2π {c\\overλ} {{2Δd}\\over c} = {4πΔd\\overλ} = {4πvTc\\overλ}\n​\\]\n推导出\n\\[\nv = {ωλ\\over4πTc}\n​\\]\n在两个连续的chirps的相位差可以用来估计物体的速度"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#雷达的最大可测量速度",
    "href": "posts/mmwave_getting_started/index.html#雷达的最大可测量速度",
    "title": "getting started with mmwave radar",
    "section": "雷达的最大可测量速度",
    "text": "雷达的最大可测量速度\n物体远离雷达，此时ω &gt; 0.\n\n物体靠近雷达，此时ω &lt; 0\n\n如果ω大于180° 那样就不能分清楚是旋转了角度a还是角度b\n\n因此，最大的无模糊速度测量是∣ω∣ &lt; π\n可推导出\n\\[\n{4πvTc\\overλ}&lt; π\n\\]\n\\[\nv&lt;{λ\\over 4Tc}\n\\]\n最大的可测量速度举例: Tc = 40us\n\\[\nV_{max} = {λ\\over4Tc} = {4*10^{-3}m\\over4*40*10^{-6}s} = 25m/s\n\\]\n更高的速度需要更近的chirp(Tc尽可能的小)\n这里所描述的都是单个物体的情况."
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#相同距离不同速度的多个物体怎么测速",
    "href": "posts/mmwave_getting_started/index.html#相同距离不同速度的多个物体怎么测速",
    "title": "getting started with mmwave radar",
    "section": "相同距离不同速度的多个物体怎么测速",
    "text": "相同距离不同速度的多个物体怎么测速\n两个物体, 距离相同, 速度不同\n\n解决问题的方法是让雷达发射N个等间隔的chirp\n\n先做range-fft, 得到相同位置的峰. \n在range-fft的基础上，再做一次fft，这个fft叫做doppler-fft，这样会得到第一次fft的相位的两个分量(这个分量的数量取决于被测物体的数量)\n\n对应的速度分别为 \\[\nV_{1} = {λω_1\\over4πTc} \\space\nV_{2} = {λω_2\\over4πTc}\n\\] &gt; 他们在做完range-fft之后将会拥有相同的位置, 和相同的峰值.  但是该位置处相对应的离散值(相位值),由两个(取决于物体数量)旋转向量ω1,ω2组成, 他们分别以频率ω1,ω2进行旋转,分别对应两个速度v1 和 v2, 所以测量处ω1,ω2后我们即可计算出v1,v2 这个过程就是多普勒FFT, 那么多普勒FFT的速度分辨率怎么样(换个说法, v1和v2最小间隔多少可以分辨为2个峰)\n\n多目标速度分辨率(多普勒fft分辨率)推导\n\\[\n△ω = {4π△vTc\\overλ}\n\\] 又因为, 只要两个离散信号的频率间隔差值△ω大于2 π / N,即可区分出两种频率,N为一个frame中chirp的个数\n\\[\n△ω &gt;{2 π \\over N}\n\\]\n\nTc: T_chirp Tf: T_frame\n\n\\[\n{4π△vTc\\overλ} &gt; {2 π \\over N}\\\\\n\\space \\\\\n{△vTc\\overλ} &gt; {2 π \\over N4π} (= {1\\over N})\\\\\n\\space \\\\\nΔv&gt; {λ\\over2NTc}\\\\\n\\] 所以 \\[\nΔv&gt; {λ\\over2Tf}\n\\]\n\n总结 假设雷达前方有两个物体，两个物体离雷达的距离不一样，前面通过两个chirp来测相位差的方法还可以用，但是如果两个物体距的雷达的距离相等，经过range-FFT后，只有一个峰值，因此，峰值处的相位就会有两个分量，这样，通过相位比较的方法就不再适用.\n\n速度分辨率举例:"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#一些系统设计的话题",
    "href": "posts/mmwave_getting_started/index.html#一些系统设计的话题",
    "title": "getting started with mmwave radar",
    "section": "一些系统设计的话题",
    "text": "一些系统设计的话题\n\nrange-FFT\n雷达处理接收天线接收回来的数据，对每一个接收回来的chirp做range-fft，然后range-fft处理后的数据按行存储到L3或DDR中，由于range-fft对应的频率，距离与中频成正比，因此可以将x轴绘制为距离轴，如下图：\n\n在上面的图中，在距离维度上的range=3和range=8的距离处有物体，但是有几个物体不知道，只是知道雷达前方有物体，\n\n有待考证: 在大多数雷达的实现中，range-fft是在将ADC样本存储到内存之前完成的\n\n\n\ndoppler-FFT\n在执行完range-fft之后，要在chirp index方向上做doppler-fft，做doppler-fft的时候，要将数据从L3或DDR内存中取出，然后再执行doppler-fft，由于dopper-fft对应离散角频率，离散角频率与速度成正比，因此可以将y轴绘制为速度轴。\n\n对做了range-fft的数据做doppler-fft，会发现在距离为range=3处有两个物体，速度分别为1和4，在range=8处有三个物体，速度分别为1、3和5。\n\n注意: 只有一个frame中的全部chirp做了range-fft之后才可以执行doppler-fft，因此系统中必须有足够的存储器来存储执行range-fft之后的数据\n\n\n\n设计chirp的参数要求(雷达系统设计依据)\n最大速度:\n\\[\nV_{max} = {λ\\over4Tc} \\rArr {Tc = {λ\\over 4V_{max}}}\n\\]\n速度分辨率：\n\\[\nVres = {λ\\over2Tf}\\rArr {Tf = {λ\\over 2 Vres}}\n\\]\n距离分辨率： △d =&gt; d_res \\[\n{d_{res}}={c\\over 2B } \\rArr B = {c\\over 2d_{res} }\n\\]\n\n\n\n设备的限制\n\n设备的最大中频带宽有限制, 所以F_if_max为固定值, 则需要在S和d_max之间进行取舍, 因为c是常量, S(斜率)大, d_max(最大探测距离)就得小\n设备的频率提升(斜率)性能有限制(最短时间内能变换的频率是有限制的),\n对于相邻chirp之间的空闲时间限制(防止相邻chirp之间的干扰,需要空闲时间进行chirp隔离).\n\n\n\n设备的存储空间要求, 因为对于数据处理来说, 每个frame的数据量是相当庞大的,将fft数据全部存储后才能做多普勒fft, 设备的存储空间也是有限的.\n\n\n\n\n速度优先的应用(chirp场景配置依据)\n对于速度优先的场景, Tc越小, 可以测速度范围越大, 所以根据场景我们将Tc固定下来了.\n接下来需要考虑S(斜率)的问题, 因为F_if(中频信号)受限制于设备, 所以有上限(即为确定值), 所以我们需要在S和d_max之间进行取舍, S越大, d_max越小,\n\nS(斜率)越大表示相同时间内跨越的带宽越大, 所以分辨率越高, 但是d_max会变小.反之S越小, 相同时间内跨越的带宽越小, 分辨率越差, 但是d_max(最大探测距离)会增大(这里是理论上最佳最大探测距离, 实际最大探测距离受限制于ADC性能,以及物体的反射功率). 长距离雷达: 斜率较小, 距离较大, 分辨率较差 短距离雷达: 斜率较高, 距离较短, 分辨率较高\n\n\n\n\n雷达距离公式\n之前了解到雷达最大探测距离受限制于最大ADC采样频率, 其实还有一个决定最大探测距离的重要因素最大距离物体的信号反射强度, 要有足够的反射强度才能被检测到.\n决定物体反射强度的因素\n信号从发出时的功率(pt)随着距离的平方不断衰减, 如下公式,\n\n调整为具有更佳增益的天线可增加功率密度从而改善衰减.\n通常的做法是: 调整天线的方向性, 从而来提高天线的增益. (在更窄的视野中探测更远,或者在更宽阔的视野中探测较近的距离)\n\n\n\nPt: 设备输出功率 G_tx/tx: 发送/接收天线增益 σ: 雷达反射截面积(Radar Cross Section of the Target，RCS) A_RX: RX天线的有效孔径面积(Effective aperture area of RX antenna)接收天线尽可能捕获反射回的信号能力的度量\n\n设备原始情况下, 辐射功率密度 \\[\nRadiated \\space Power \\space Density = {{P_t}\\over 4π{d^2}} W/m^2\n\\]\n天线增益情况下, 辐射功率密度 \\[\nRadiated \\space Power \\space Density = {{P_tG_{TX}}\\over 4π{d^2}}W/m^2\n\\]\n当信号碰到物体，反射的功率为 \\[\nPower\\space reflected \\space by \\space object = {{P_tG_{TX}σ}\\over 4π{d^2}}W\n\\]\n经过反射回到接收天线处(不是接收到的), 辐射功率密度\n\\[\nPower \\space density \\space at \\space RX \\space ant = {{P_tG_{TX}σ}\\over {(4π)}^2{(d^2)}^2}W/m^2\n\\]\n在接收天线捕获的功率为\n\\[\nPower \\space captured \\space at \\space RX \\space ant = {{P_tG_{TX}σ}A_{RX}\\over {(4π)}^2{d^4}}W\n\\]\n带入上式 &gt; 接收天线尽可能捕获反射回的信号能力的度量 &gt; 根据接收天线的增益G_Rx和工作波长λ\n\\[\nA_{RX} = {{G_{RX}λ^2}\\over 4π}\n\\]\n根据该公式可以得出 - 接收功率 - 和发射功率,发射天线增益,接收天线增益成正比. - 和到目标距离的4次方(d^4)成反比\n\\[\nPower \\space captured \\space at \\space RX \\space ant = {{P_tG_{TX}σ}G_{RX}λ^2 \\over {(4π)}^3{d^4}}W\n\\]\n接收器(雷达)是否可以看到目标不仅取决于接收到的信号的功率还取决于信号能量和噪声能量的比率(信噪比,SNR).\n信噪比计算公式, 信噪比概念\n\nk 天线噪声系数, 和天线的物理特性有关. F 接收器噪声系数, 雷达内部引入的额外噪声. T_means总的测量时间(Tc*N)N表示有多少个chirp，T_c是说明每个chirp持续的时间\n\n\n在测量中存在检测目标所需的最小信噪比（SNR_min），SNR_min的选择为漏检概率与虚警概率之间的权衡，典型数字在15dB-20dB范围内。若给定一个确定的SNR_min，雷达可探测的距离为：\n\\[\nd_{max} = ({σP_tG_{TX}G_{RX}λ^2T_{means}\\over (4π)^3SNR_{min}kTF})^{1\\over 4}\n\\] &gt; 信噪比越大越好 &gt; 信噪比会因为T_means的时间(NTc)增加而提高, 这是因为采样越多, 噪声越趋于某个平均值. &gt; - 但是SNR_min 配置的越大, 可能导致可能性较低的目标丢失 &gt; - SNR_min配置较小, 可能会有误报的情况, 所以需要根据应用来调整"
  },
  {
    "objectID": "posts/mmwave_getting_started/index.html#角度估计",
    "href": "posts/mmwave_getting_started/index.html#角度估计",
    "title": "getting started with mmwave radar",
    "section": "角度估计",
    "text": "角度估计\n单个物体判断角度位置\n\n两个物体, 距离相同, 速度相同, 怎么区分\n\n雷达最大可视角度\n\n角度分辨率\n\n\n角度测量原理\nxiaojie csdn开MINI的工科男 知乎过路人毫米波雷达基础\n目标距离的微小变化会导致range-FFT峰值的相位变化。角度估计至少需要2个RX天线。 从目标到每个天线的差分距离 Δ d 导致FFT峰值发生相位变化，该相位变化用于估计到达角。\n\n发射天线发送一个chirp，经过物体发射后信号，信号分别被第一根天线和第二根天线接收，第一根天线接收的距离为d dd，第二根天线接收的距离为d + Δd，额外的距离会产生相位差，ω = 2πΔd/λ ​\n\n 上图中右部分的图中的d和左图中的d不是同一个代指, 二者无关联. \n\n假设两根天线接收回来的信号是平行的, Rx2接收到的信号,比Rx1接收的信号传播距离多出△d, 反应在相位变化上.\n\nL是在硬件设计的时候就固定好的天线间距. Δd = L*sin(θ)\n\n\n由于相位变化与距离间的关系为： \\[\nω = { 2πΔd\\over λ}\n\\]\n又因为\n\\[\nΔd = L*sin(θ)\n\\]\n所以\n\\[\nω = { 2πLsin(θ)\\over λ}\n\\]\n所以 \\[\n{ωλ\\over2πL} = { sin(θ) }\n\\space \\\\\nθ = sin^{-1}({ωλ\\over2πL})\n\\] #### 角度测量的准确性\n\n 在ω (sin(θ))和θ 之间的关系不是线性的 \n在这个图中，当θ 趋近于0时，sin(θ)对θ 的变化是非常敏感的，θ 的微小变化可能会导致sin(θ)的同等大小的变化，但是sin(θ)的敏感性会随θ的增大的敏感性减小，当θ 接近于90°时，sin(θ)对θ 的变化是变得非常不敏感，因此随着θ角度的增加，角度的估算就会更容易产生误差\n\n的敏感度sin(θ)（变化速率）随着θ 的增大降低,在 θ=0时，ω对θ的变化最为敏感（在 θ=90°时变为0(无法测量)）\n\n因此，角度测量值的准确度取决于到达角AoA (θ)，且在 AoA值越小时越准确。\n\n\n\n雷达的最大角视场\n物体在雷达的左边，向量逆时针转 \n物体在雷达的右边，向量顺时针转 \n当向量转的角度超过180度时，就会产生模糊，不知道物体是在雷达的左侧还是在雷达的右侧, \n因此，角度的最大无模糊为： ∣ω∣&lt;180° &gt; L: 接收天线距离\n\\[\nω = { 2πLsin(θ)\\over λ} \\rArr {θ = sin^{-1}({λ\\over 2L})}\n\\]\n因此雷达的最大角视场可能为−90° ~ +90°\n\n\n测量雷达前方多个距离和速度相同的物体\n雷达前方有两个物体，他们的距离和速度相同，这样两个物体将处于2D-FFT中相同位置的距离速度单元，如下图所示.\n\n\n之前简单的相位比较就不再适用\n\n解决方案是：将RX天线的数量从两个增加到N个\n\n经过FFT(angle-FFT)后，得到下图\n\nω1和ω2分别对应于两个物体之间的接收天线的相位差\n\\[\nθ1 = sin^{-1}({ω1λ\\over2πL})\n\\space \\\\\n\\space \\\\\nθ2 = sin^{-1}({ω2λ\\over2πL})\n\\]\n得到结果是弧度，最后还应该乘以180度，得到角度\n\n\n角度分辨率\n角度分辨率(θ _res)是两个物体在ange-FFT中作为单独峰值出现的最小角度的问题\n\n\\[\nω1 = { 2πLsin(θ)\\over λ}\n\\space \\\\\nω2 = { 2πLsin(θ)\\over λ}\n\\space \\\\\n△ω = ω2-ω1 \\rArr { {2πL\\over λ}{sin((θ+△θ)-sin(θ))}}\n\\]\n又因为\n\n所以\n\\[\n△ω = { {2πL\\over λ}{cos(θ)△θ}}\n\\]\n又因为傅里叶特性, 分辨两个峰值, 需要&gt;2π/N. N为FFT的样本输入数量, 在该例中即是接收天线的数量.\n\\[\n△ω = { {2πL\\over λ}{cos(θ)△θ}} &gt; {2π \\over N}\n\\space \\\\\n\\space \\\\\n\\rArr △θ &gt; {λ\\over NLcos(θ)}\n\\]\n所以角度分辨率\n\\[\nθ_{res}  = {λ\\over NLcos(θ)}\n\\]\n通常假设L = λ/2,θ = 0,得：\n\\[\nθ_{res} = {2\\over N}\n\\]\n所以角度分辨率和天线数量成正比."
  },
  {
    "objectID": "posts/c_string_h/index.html",
    "href": "posts/c_string_h/index.html",
    "title": "opcrating string of c with <string.h>",
    "section": "",
    "text": "Abstract\nC language string operations of segmentation, extraction, and concatenation\n\n\nReferance\nhttps://www.runoob.com/cprogramming/c-function-sprintf.html\n\n\nstrtok()\n将字符串分割成若干个子串, 类似split的操作. 但是这里分割是将分割符的地方替换为\\0,从而实现字符串的分割.\n\n#include &lt;string.h&gt; char strtok(char str, const char *delim) - str: 要被分割的字符串 - delim: 分割符\n\n第一次传递数据的时候将即将被分割的原始数据通过str传递, 分割符用delim传递.\n第一次分割返回第一个分隔符之前的数据.\n// raw: [ 2023/05/30,05:17:32+32 ]\nchar *first = strtok((char*)receive_buff,\"/\");  /* first is: 2023 */\n// second is transmit NULL, means split the same data.\nchar *second = strtok(NULL,\"/\");                /* second: 05 */\n\nchar *thrid = strtok(NULL,\"/\");                 /* second: 30 */\n分割完所有数据\n/* 获取第一个子字符串 */\n   token = strtok(str, s);\n   \n   /* 继续获取其他的子字符串 */\n   while( token != NULL ) {\n      printf( \"%s\\n\", token );\n    \n      token = strtok(NULL, s);\n   }\n\n\nsscanf()\n按照对应格式, 从字符串中提取出所需数据, 有点类似正则表达式的提取.\n\n#include &lt;stdio.h&gt; int sscanf(const char str, const char format, …) - str: 原始字符串，是函数检索数据 - format: 提取的格式 - …: 被提取到的位置\n\n将字符串日期数据, 按照int类型提取并存储.\nint year, moth, day, hour, minute, second;\nchar time_c[20] = \"2023/05/30,05:17:32\"\n\nsscanf(time_c, \"%d/%d/%d,%d:%d:%d\",&year,&moth,&day,&hour,&minute,&second);\n\n\nsprintf()\n数据的拼接, 拼接完存储到字符串变量中.\n\n#include &lt;stdio.h&gt; int sprintf(char str, const char format, …) - str: 用来存放拼接完的数据 - format: 存储的格式 - …: 需要拼接的数据\n\nchar str[20];\n\nsprintf(str, \"Pi 的值 = %f\", 3.1415926);\nprintf(\"%s\",str);  /* Pi 的值 = 3.1415926 */"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "href": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "title": "stm32F103-RT-Thread–信号量(semaphare)",
    "section": "",
    "text": "信号量(semaphare)\n\n主要是量这个字, 表示这个信号有一定的量, 可以是0,也可是10,也可以是任意数字, 但是当他为0的时候就表示不可以使用了, 当为非零的时候可以使用,每使用一次即-1,释放的时候+1,为0就等待释放.\n\nstatic int count = 0;\n\nstatic rt_sem_t sem = RT_NULL;                          // semaphore control block\nstatic rt_thread_t sem_1_thread = RT_NULL;              // semaphore thread_1 control block\nstatic rt_thread_t sem_2_thread = RT_NULL;              // semaphore thread_2 control block\nstatic rt_thread_t sem_3_thread = RT_NULL;              // semaphore thread_2 control block\n\nstatic void sem_thread_1_entry(void *parmaeter);\nstatic void sem_thread_2_entry(void *parmaeter);\nstatic void sem_thread_3_entry(void *parmaeter);\n\nint main(void){\n\n    /* 这里的main简化了 */\n    sem = rt_sem_create(\"sem_count_per10_++\", 0,RT_IPC_FLAG_FIFO);\n    \n    sem_1_thread = rt_thread_create(\"sem_1_thread\", sem_thread_1_entry, RT_NULL, 512, 3, 20);\n    rt_thread_startup(sem_1_thread);\n    \n    \n    sem_2_thread = rt_thread_create(\"sem_2_thread\", sem_thread_2_entry, RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_2_thread);\n    \n    \n    sem_3_thread = rt_thread_create(\"sem_3_thread\", sem_thread_3_entry,RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_3_thread);\n    \n}\n\n\nstatic void sem_thread_1_entry(void *parameter){\n    while (1)   \n    {\n        if (count &lt;= 100)\n        {\n            count++;\n        }\n        else\n            return;\n\n        if (0 == count % 10)\n        {\n            rt_kprintf(\"thread_1 is release the semaphore %d\\n\",count);\n            rt_sem_release(sem);    // release the semaphore\n        }\n        \n    }\n    \n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void sem_thread_2_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[2] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[2]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}\n\n\nstatic void sem_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[3] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[3]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}"
  },
  {
    "objectID": "posts/vscode_swap_esc/index.html",
    "href": "posts/vscode_swap_esc/index.html",
    "title": "vsdoe fix can not swap esc and caps lock",
    "section": "",
    "text": "Abstract\nswap the esc and capsLock in system but can not work in vscode, we need to config something\n\n\nReferance\nadd this to setings that swap can work in vscode\n    \"keyboard.dispatch\": \"keyCode\""
  },
  {
    "objectID": "posts/TI_js脚本自动调试/index.html",
    "href": "posts/TI_js脚本自动调试/index.html",
    "title": "TI_js脚本自动调试",
    "section": "",
    "text": "脚本执行\n手动创建调试器1642.xml 修改执行脚本ccsdebug.js - 修改脚本中的工作区 - 修改脚本中的项目位置, 和编译后的img位置\n\n\n\n\n在这里插入图片描述\n\n\nccsdebug.js\n// Import the DSS packages into our namespace to save on typing\n\nimportPackage(Packages.com.ti.debug.engine.scripting);\n\nimportPackage(Packages.com.ti.ccstudio.scripting.environment);\n\nimportPackage(Packages.java.lang);\n\nimportPackage(Packages.java.io);\n\n\n\nfunction run_test(){\n//*******User must specify WORKSPACE_DIR***********\n\nvar WORKSPACE_DIR = \"D:/project/board/workspace_v10/\";\n\n//*******User must specify WORKSPACE_DIR***********\n\nvar PROJECT_DIR = WORKSPACE_DIR+\"sdk_demo/\";\n\nvar R4F_OUT_FILE_PATH = PROJECT_DIR+\"mmw_mss_16xx/Debug/xwr16xx_mmw_mss.xer4f\";\n\nvar DSS_OUT_FILE_PATH = PROJECT_DIR+\"mmw_dss_16xx/Debug/xwr16xx_mmw_dss.xe674\";\n\nvar CCS_TARGET_CONFIGURATION_FILE = \"AWR1642.ccxml\";\n\nvar script = ScriptingEnvironment.instance();\n\n//script.traceBegin(\"BreakpointsTestLog.xml\", \"DefaultStylesheet.xsl\");\n//script.traceSetConsoleLevel(TraceLevel.ALL);\n//script.traceSetFileLevel(TraceLevel.ALL);\n\n\nscript.setCurrentDirectory(PROJECT_DIR);\ndebugServer = script.getServer(\"DebugServer.1\");\n\n\ndebugServer.setConfig(CCS_TARGET_CONFIGURATION_FILE);\n\n\n// debug session R4F\nprint(\"Debug session R4F...\");\ndebugSession_MSS = debugServer.openSession(\"*\",\"Cortex_R4_0\");\nprint(\"Connecting to R4F Core...\");\ndebugSession_MSS.target.connect();\ndebugSession_MSS.target.reset();\nprint(\"Done.\");\n\n\n\n\n// debug session C674x\nprint(\"Debug session C674x...\");\ndebugSession_DSS = debugServer.openSession(\"*\",\"C674X_0\");\nprint(\"Connecting to C674x Core...\");\ndebugSession_DSS.target.connect();\ndebugSession_DSS.target.reset();\nprint(\"Done.\");\n\n\n// Loading program - R4F...\nprint(\"Loading program - R4F...\");\ndebugSession_MSS.memory.loadProgram(R4F_OUT_FILE_PATH);\nprint(\"load R4F Done.\");\n\n// Loading program - C674x...\nprint(\"Loading program - C674x...\");\ndebugSession_DSS.memory.loadProgram(DSS_OUT_FILE_PATH);\nprint(\"Loading C674x Done.\");\n\n// run target\nvar dsArray = new Array();\ndsArray[0] = debugSession_MSS;\ndsArray[1] = debugSession_DSS;\n\n//debugServer.simultaneous.run(dsArray); // Run CPUs 1 and 2\nprint(\"please click run...\");\n//debugServer.stop();\n\n//script.traceEnd();\n}\n\nhotmenu.addJSFunction(\"Run Test\",\"run_test()\");\n\nView -&gt;Scripting Console\n\n\n在终端中输入以下指令,根据脚本所在位置填写脚本\n// 脚本位置\nloadJSFile \"D:\\project\\board\\workspace_v10\\sdk_demo\\ccsdebug.js\"\n &gt;## 点击script,然后运行脚本 \n\n程序启动需手动点击run按钮\n\n &gt; ## 断点调试 &gt; 需要设置hardware breakpoint, 普通的断点无法在mss上停止. 然后就可查看到变量和单步调试了\n 稍微高级点的用法可以查看tools里面的工具"
  },
  {
    "objectID": "posts/esp8266--01点亮一个LED/index.html",
    "href": "posts/esp8266--01点亮一个LED/index.html",
    "title": "esp8266–01点亮一个LED",
    "section": "",
    "text": "espb266\nLED\n\n\n\n\nD0\n电阻+\n\n\nG\n负极\n\n\n\n在线路上串联上一个电阻,防止过载 ## 2.程序\n// 设置程序信息\nvoid setup() {\n // 设置gpio输入针脚为16号\n  pinMode(16, OUTPUT);\n}\n\n// void loop() 程序中重复执行\nvoid loop() {\n  digitalWrite(16, HIGH);   // turn the LED on (HIGH is the voltage level)\n  //delay(1000);                       // 延迟1s\n  //digitalWrite(16, LOW);    // turn the LED off by making the voltage LOW\n  //delay(1000);                       // wait for a second\n}"
  },
  {
    "objectID": "posts/esp8266--01点亮一个LED/index.html#接线",
    "href": "posts/esp8266--01点亮一个LED/index.html#接线",
    "title": "esp8266–01点亮一个LED",
    "section": "",
    "text": "espb266\nLED\n\n\n\n\nD0\n电阻+\n\n\nG\n负极\n\n\n\n在线路上串联上一个电阻,防止过载 ## 2.程序\n// 设置程序信息\nvoid setup() {\n // 设置gpio输入针脚为16号\n  pinMode(16, OUTPUT);\n}\n\n// void loop() 程序中重复执行\nvoid loop() {\n  digitalWrite(16, HIGH);   // turn the LED on (HIGH is the voltage level)\n  //delay(1000);                       // 延迟1s\n  //digitalWrite(16, LOW);    // turn the LED off by making the voltage LOW\n  //delay(1000);                       // wait for a second\n}"
  },
  {
    "objectID": "posts/frida的typescript环境搭建/index.html",
    "href": "posts/frida的typescript环境搭建/index.html",
    "title": "frida的typescript环境搭建",
    "section": "",
    "text": "安装nodejs\n\n\n安装vscode\n\n\n安装typescript\n\n在vs中打开终端\n\nnpm install ts-node\nnpm install typescript -g --save-dev\nnpx tsc --init\n\noutDir = \"./js/\"\n获取脚本执行权限https://editor.csdn.net/md/?articleId=126796769"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "",
    "text": "lambda表达式 就是将函数式接口直接实现 普通的实现是先new一个类实现接口,然后再通过类.方法去调用实现的方法. lambda是直接省略了new一个类去实现接口中的方法. * lambda的实现过程 * 方法1-方法4逐渐简化. * 大体的实现原理就是不通过实体类实现接口中的方法 * 注意[接口中的方法只有一个–(函数式接口)]\n接口接收实体类和类接收实体类的区别 ## 最简单的实现"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#进阶",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#进阶",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "进阶",
    "text": "进阶\n记得导入JUnit\npackage cn.usts.edu.lesson05;\n\nimport org.junit.Test;\n\npublic class LambdaSelfTest {\n    \n    @Test //导入JUnit \n    // lambda 进阶测试2\n    public void test2(){\n        ITest iTest1 = (a) -&gt; {\n            System.out.println(\"lambda 实现\"+a);\n        };\n\n        iTest1.test1(2);\n    }\n\n    @Test\n    // lambda 进阶测试3\n    public void test3(){\n        ITest iTest1 = (a) -&gt; System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(3);\n    }\n\n    @Test\n    // lambda 进阶测试4\n    public void test4(){\n        ITest iTest1 = a -&gt; System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(4);\n    }\n\n    @Test\n    // lambda 进阶测试4\n    public void test5(){\n        ITest iTest1 = a -&gt; System.out.println(\"lambda 实现\"+a);\n        iTest1.test1(4);\n    }\n}\n\n// 函数式接口\ninterface ITest{\n    void test1(int a);\n}"
  },
  {
    "objectID": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#实现原理",
    "href": "posts/java多线程-- lambda表达式(实现原理, 4行代码 最简单的实现 )/index.html#实现原理",
    "title": "java多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )",
    "section": "实现原理",
    "text": "实现原理\npackage cn.usts.edu.lesson05;\n\n/**\n * lambda的实现过程\n * 方法1-方法4逐渐简化.\n * 大体的实现原理就是不通过实体类实现接口中的方法\n * 注意[接口中的方法只有一个--(函数式接口)]\n * */\n\npublic class LambdaTest {\n\n    // 方法2---静态内部类\n    static class Like2  implements ILike{\n        @Override\n        public void lambda() {\n            System.out.println(\"实现ILike接口2\");\n        }\n    }\n\n    public static void main(String[] args) {\n        // 实现1\n        ILike like= new Like();// 这里用的接口对象去接受实现类的地址,  只能调用接口中实现的方法;\n        // Like like= new Like();// 用类对象接收new的对象的地址,可以用类类中的所方法\n        like.lambda();\n\n        // 实现2\n        like = new Like2();\n        like.lambda();\n\n        // 方法3 局部内部类  写在方法中\n        class Like3  implements ILike{\n            @Override\n            public void lambda() {\n                System.out.println(\"实现ILike接口3\");\n            }\n\n        }\n        // 实现3\n        like = new Like3();\n        like.lambda();\n\n        // 方法4[最终实现]\n        like = ()-&gt;{\n            System.out.println(\"lambda表达式实现ILike接口4\");\n        };\n        // 实现4 [最终实现]\n        like.lambda();\n\n    }\n}\n// 定义接口\ninterface ILike{\n    void lambda();\n}\n\n// 方法1  new一个类实现接口\nclass Like implements ILike{\n    @Override\n    public void lambda() {\n        System.out.println(\"实现ILike接口\");\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- 通信协议/index.html",
    "href": "posts/java网络编程-- 通信协议/index.html",
    "title": "java网络编程– 通信协议",
    "section": "",
    "text": "通信协议就像是信封上（数据包内）约定好的地址（通信）格式，按照指定的格式填写信息就能将信件准确的送达到你想送达的地址，否则邮递员（计算机）无法识别。 【协议】≈【约定】 理想化的7层模型，现实中用的4层模型  主要的还是TCP/IP协议簇 TCP/IP协议簇：是一组协议\n\nTCP：用户传输协议\nUDP：无连接的传输协议\nIP：网络互联协议\n\ntcp：稳定，三次握手，四次挥手 【打电话】 三次握手 |铁蛋(主机A)|翠花 (主机B) | |–|–| | 谁是翠花 | | || 我是翠花，是铁蛋在叫我吗 | | 是的 | | 四次挥手 |主机A| 主机B | |–|–| | 我要拔网线了 | | | | 行 | | | 我也要拔网线了 | |行 | | udp：响应快 【发短信】"
  },
  {
    "objectID": "posts/javaGUI--窗口事件监听/index.html",
    "href": "posts/javaGUI--窗口事件监听/index.html",
    "title": "javaGUI–窗口事件监听",
    "section": "",
    "text": "窗口事件监听 常用的就是窗口激活和窗口关闭,两个事件的监听.\n写法1:(推荐)匿名内部类\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindowsListener {\n    public static void main(String[] args) {\n        new WindowsListenerFrame();\n    }\n}\n\n\nclass WindowsListenerFrame extends Frame{\n    public WindowsListenerFrame() {\n        setBounds(200,200,400,200);\n        setVisible(true);\n        // 匿名内部类\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                setVisible(false);// 隐藏窗口\n            }\n        });\n\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowActivated(WindowEvent e) {\n                WindowsListenerFrame windowsListenerFrame = (WindowsListenerFrame) e.getSource();\n                windowsListenerFrame.setTitle(\"被激活了\");\n            }\n        });\n\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowDeactivated(WindowEvent e) {\n                WindowsListenerFrame source = (WindowsListenerFrame) e.getSource();\n                source.setTitle(\"没有被激活\");\n            }\n        });\n    }\n\n}\n写法2:内部类\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindowsListener {\n    public static void main(String[] args) {\n        new WindowsListenerFrame();\n    }\n}\n\n\nclass WindowsListenerFrame extends Frame{\n    public WindowsListenerFrame() {\n        setBounds(200,200,200,200);\n        setVisible(true);\n        addWindowListener(new MyWindowsListenerFrame());\n    }\n    \n    // 内部类\n    class MyWindowsListenerFrame extends WindowAdapter{\n        @Override\n        public void windowClosing(WindowEvent e) {\n            setVisible(false);// 点击关闭窗口就是隐藏了,不是结束程序,程序还在后台运行\n            //System.exit(0);  // 正常的点击x结束程序的语句\n        }\n    }\n}"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html",
    "href": "posts/DNS图文步骤配置/index.html",
    "title": "DNS图文步骤配置",
    "section": "",
    "text": "DNS及(DNS辅助区详细创建) # 1、网络拓扑图：\n开始前一定要将防火墙关闭！！！(否则可能会出现ping不通的情况) 开始前一定要将防火墙关闭！！！ 开始前一定要将防火墙关闭！！！"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#配置静态ip",
    "href": "posts/DNS图文步骤配置/index.html#配置静态ip",
    "title": "DNS图文步骤配置",
    "section": "2.1 配置静态ip",
    "text": "2.1 配置静态ip\n参照步骤5.1中的静态ip配置"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#section",
    "href": "posts/DNS图文步骤配置/index.html#section",
    "title": "DNS图文步骤配置",
    "section": "2.2",
    "text": "2.2\n\n\n\n开始—&gt;服务器管理设置—–&gt;"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#添加角色",
    "href": "posts/DNS图文步骤配置/index.html#添加角色",
    "title": "DNS图文步骤配置",
    "section": "2.3 添加角色",
    "text": "2.3 添加角色\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#勾选dns",
    "href": "posts/DNS图文步骤配置/index.html#勾选dns",
    "title": "DNS图文步骤配置",
    "section": "2.4 勾选DNS",
    "text": "2.4 勾选DNS\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#下一步",
    "href": "posts/DNS图文步骤配置/index.html#下一步",
    "title": "DNS图文步骤配置",
    "section": "2.5 下一步",
    "text": "2.5 下一步\n ## 2.6 安装"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#关闭",
    "href": "posts/DNS图文步骤配置/index.html#关闭",
    "title": "DNS图文步骤配置",
    "section": "2.7 关闭",
    "text": "2.7 关闭\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#设置正向查找",
    "href": "posts/DNS图文步骤配置/index.html#设置正向查找",
    "title": "DNS图文步骤配置",
    "section": "2.8 设置正向查找",
    "text": "2.8 设置正向查找\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#右键新建分许",
    "href": "posts/DNS图文步骤配置/index.html#右键新建分许",
    "title": "DNS图文步骤配置",
    "section": "2.9 右键新建分许",
    "text": "2.9 右键新建分许\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#下一步-1",
    "href": "posts/DNS图文步骤配置/index.html#下一步-1",
    "title": "DNS图文步骤配置",
    "section": "2.10 下一步",
    "text": "2.10 下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#主要分区",
    "href": "posts/DNS图文步骤配置/index.html#主要分区",
    "title": "DNS图文步骤配置",
    "section": "2.11 主要分区",
    "text": "2.11 主要分区\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#设置域名",
    "href": "posts/DNS图文步骤配置/index.html#设置域名",
    "title": "DNS图文步骤配置",
    "section": "2.12 设置域名，",
    "text": "2.12 设置域名，\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#下一步-2",
    "href": "posts/DNS图文步骤配置/index.html#下一步-2",
    "title": "DNS图文步骤配置",
    "section": "2.13 下一步",
    "text": "2.13 下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#下一步-3",
    "href": "posts/DNS图文步骤配置/index.html#下一步-3",
    "title": "DNS图文步骤配置",
    "section": "2.14 下一步",
    "text": "2.14 下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#完成",
    "href": "posts/DNS图文步骤配置/index.html#完成",
    "title": "DNS图文步骤配置",
    "section": "2.15 完成",
    "text": "2.15 完成\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#abc.com右键-新建主机a或aaa",
    "href": "posts/DNS图文步骤配置/index.html#abc.com右键-新建主机a或aaa",
    "title": "DNS图文步骤配置",
    "section": "2.16 abc.com右键 新建主机（A或AAA）",
    "text": "2.16 abc.com右键 新建主机（A或AAA）\n图片看不清可以在图片上右键—–在新标签中打开 查看大图"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#设置主机名和ip地址",
    "href": "posts/DNS图文步骤配置/index.html#设置主机名和ip地址",
    "title": "DNS图文步骤配置",
    "section": "2.17 设置主机名和IP地址",
    "text": "2.17 设置主机名和IP地址\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#创建反向查找",
    "href": "posts/DNS图文步骤配置/index.html#创建反向查找",
    "title": "DNS图文步骤配置",
    "section": "2.18 创建反向查找",
    "text": "2.18 创建反向查找\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#一直-点-下一步-直到出现以下窗口",
    "href": "posts/DNS图文步骤配置/index.html#一直-点-下一步-直到出现以下窗口",
    "title": "DNS图文步骤配置",
    "section": "2.19 一直 点 下一步 直到出现以下窗口",
    "text": "2.19 一直 点 下一步 直到出现以下窗口\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#一直点击下一步直到完成",
    "href": "posts/DNS图文步骤配置/index.html#一直点击下一步直到完成",
    "title": "DNS图文步骤配置",
    "section": "2.20 一直点击下一步直到完成",
    "text": "2.20 一直点击下一步直到完成\n完成后找到反向区域—–&gt;新建指针\n\n\n\n在这里插入图片描述\n\n\n ## 测试"
  },
  {
    "objectID": "posts/DNS图文步骤配置/index.html#dns辅助区域",
    "href": "posts/DNS图文步骤配置/index.html#dns辅助区域",
    "title": "DNS图文步骤配置",
    "section": "3、DNS辅助区域",
    "text": "3、DNS辅助区域"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html",
    "href": "posts/vue -- 01安装、创建、跑通/index.html",
    "title": "vue – 01安装、创建、跑通",
    "section": "",
    "text": "查看版本\n\nvue/cli --version\n\n查看2.xx版本\n\nnpm view vue-cli versions --json\n\nvue init webpack vue2xx\n\n查看3.xx以上版本\n\nnpm view @vue/cli versions --json\n\nvue create my-project\n\n卸载\n\nnpm uninstall -g @vue/cli\n\n安装指定版本（2.xx）\n\nnpm install -g vue-cli@2.9.6\n\n安装指定版本（3.xx）\n\nnpm install -g @vue/cli@3.9.3\n\n安装最新版本\n\nnpm install -g @vue/cli\n\n作者：铁有情\n链接：https://www.jianshu.com/p/cd5dc9aad773\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "href": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "title": "vue – 01安装、创建、跑通",
    "section": "scss",
    "text": "scss"
  },
  {
    "objectID": "posts/计算机组成原理/index.html",
    "href": "posts/计算机组成原理/index.html",
    "title": "计算机组成原理",
    "section": "",
    "text": "定点数\n\n纯小数 0.12, 0.98, 0.22……\n纯整数: 11, 2, 3, 4…\n\n\n\n浮点数\n\nN = 2^e.M\n\n\n\n原码： 便于人类计算，但是不利于计算机，进位和移位以及异号运算复杂 反码：转换为补码的过度 补码： 将减法转换为加法 移码： 补码符号位取反， 便于比较大小\n\n移码参考视频：https://www.bilibili.com/video/BV1dL4y1a7h2/?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb\n二进制转换计算器https://cn.calcuworld.com/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97%E5%99%A8\n\nieee754：\nbook p22 -&gt;2.9\n\n\n奇偶校验\n奇校验： - 奇数个1：校验正确， 校验位填0 - 偶数个1：校验错误， 校验位填1\n偶校验： - 奇数个1：校验错误， 校验位填1 - 偶数个1：校验正确， 校验位填0\n\n奇偶校验参考视频：https://www.bilibili.com/video/BV1n5411m7QP/?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb\n\n定点加法\n\n\n补码加法\n\n补码相加等于原码相加, 最高位进位丢掉(符号位)\n\n\n\n补码减法\n\nx-y = x+(-y)\n\n\n\n溢出概念\n\n\n正溢\n两个正数相加后得到负数就是溢出了 例如：(第一位为符号位) ~01000 +01011 =10011(符号位为1即为负,所以不对)正溢 ## 负溢 两个负数相减也是类似相减后得到一个正数\n\n\n溢出的检测方法\n\n变形补码, 通过双符号位进行表示符号\n00 代替原先的0表示正数, 如果出现10表示正溢\n11代替原先的1表示负数, 如果出现01表示负溢\n\n\n\n全加器\n\n既然说到全加器, 那肯定得谈谈半加器\n个人理解的半加器, 就是不可以输入进位, 不可以串起来, 全加器可以实现N个加法器串联, 实现多位的运算\n\n\n &gt;异或门: 相异 =&gt; 1 与非门: 1, 1 =&gt; 0\n\n\n\n在这里插入图片描述\n\n\n仿真:https://blog.csdn.net/qq_40272978/article/details/106229002 matlab 仿真参考: https://max.book118.com/html/2019/0531/6152154012002034.shtm"
  },
  {
    "objectID": "posts/CSS_基础/index.html",
    "href": "posts/CSS_基础/index.html",
    "title": "CSS_基础",
    "section": "",
    "text": "lz也是从知乎上看到这个这个网站，很不错，边学边敲。 网址：https://www.freecodecamp.one/\n这个算是自己做个小笔记（cv大法）吧，看一点敲一点，cv一点。 ## 更改文本的颜色 现在让我们来修改一下文本的颜色。\n我们通过修改h2元素的style属性的color值来改变文本颜色。\n以下是改变h2元素为蓝色的方法：\n请注意行内style最好以;来结束。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#使用元素选择器来设置元素的样式",
    "href": "posts/CSS_基础/index.html#使用元素选择器来设置元素的样式",
    "title": "CSS_基础",
    "section": "使用元素选择器来设置元素的样式",
    "text": "使用元素选择器来设置元素的样式\n在 CSS 中，页面样式的属性有几百个，但常用的不过几十个。\n通过行内样式&lt;h2 style=\"color: red;\"&gt;CatPhotoApp&lt;/h2&gt;，就可以修改h2元素的颜色为红色。\n当我们只需要改变元素的某个样式时，行内样式最简单直观。当我们需要同时改变元素的很多样式时，层叠样式表往往是一个更好的选择。\n在代码的顶部，创建一个style声明区域，如下方所示：\n&lt;style&gt;\n&lt;/style&gt;\n在style样式声明区域内，可以创建一个元素选择器，应用于所有的h2元素。例如，如果你想所有h2元素变成红色，可以添加下方的样式规则：\n&lt;style&gt;\n  h2 {color: red;}\n&lt;/style&gt;\n注意，在每个元素的样式声明区域里，左右花括号（{和 }）一定要写全。你需要确保所有样式规则位于花括号之间，并且每条样式规则都以分号结束。 ## 使用 class 选择器设置单个元素的样式 CSS 的class具有可重用性，可应用于各种 HTML 元素。\n一个 CSSclass声明示例，如下所示：\n&lt;style&gt;\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n可以看到，我们在&lt;style&gt;样式声明区域里，创建了一个名为blue-text的class选择器。\n你可以将 CSSclass选择器应用到一个HTML元素里，如下所示：\n&lt;h2 class=\"blue-text\"&gt;CatPhotoApp&lt;/h2&gt;\n注意：在style样式区域声明里，class需以.开头。而在 HTML 元素里，class属性的前面不能添加.。 ## 使用 class 选择器设置多个元素的样式  ## 更改元素的字体大小 字体大小由font-size属性控制，如下所示：\nh1 {\n  font-size: 30px;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#设置元素的字体家族",
    "href": "posts/CSS_基础/index.html#设置元素的字体家族",
    "title": "CSS_基础",
    "section": "设置元素的字体家族",
    "text": "设置元素的字体家族\n通过font-family属性，可以设置元素里面的字体样式。\n如果你想设置h2元素的字体为sans-serif，你可以用以下的 CSS 规则：\nh2 {\n  font-family: sans-serif;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#引入谷歌字体",
    "href": "posts/CSS_基础/index.html#引入谷歌字体",
    "title": "CSS_基础",
    "section": "引入谷歌字体",
    "text": "引入谷歌字体\n除了大多数系统提供的默认字体以外，我们也可以使用自定义字体。网络上有各种各样的字体，不过在这个例子中，我们将会尝试使用Google字体库。\nGoogle 字体是一个免费的字体库，可以通过在 CSS 里面设置字体的 URL 来引用。\n因此，下一步，我们将引入和使用Google字体。\n引入Google字体，你需要复制Google字体的 URL，并粘贴到你的 HTML 里面。在这个挑战中，我们需要引入Lobster字体。因此，请复制以下代码段，并粘贴到代码编辑器顶部，即放到style标签之前。\n&lt;link href=\"https://fonts.googleapis.com/css?family=Lobster\" rel=\"stylesheet\" type=\"text/css\"&gt;\n现在你可以设置font-family属性为Lobster，来使用Lobster字体。例子如下：\nfont-family: FAMILY_NAME, GENERIC_NAME;#第二个是备用字体\nGENERIC_NAME是可选的，其他字体不可用时便作为后备字体，在下一个挑战中可以得到体现。\n字体名区分大小写，并且如果字体名含有空格，需要用引号括起来。例如，使用”Open Sans“字体需要添加引号，而Lobster字体则不需要。\n通过id属性，你可以做一些很酷的事情，例如，就像 class 一样，你可以使用 CSS 来设置他们的样式\n可是，id不可以重用，只应用于一个元素上。同时，在 CSS 里，id的优先级要高于class，如果一个元素同时应用了class和id，并设置样式有冲突，会优先应用id的样式。\n选择id为cat-photo-element的元素，并设置它的背景样式为green，可以在你的style标签里这样写：\n#cat-photo-element {\n  background-color: green;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础调整元素的内边距",
    "href": "posts/CSS_基础/index.html#css-基础调整元素的内边距",
    "title": "CSS_基础",
    "section": "CSS 基础：调整元素的内边距",
    "text": "CSS 基础：调整元素的内边距\n我们先暂时把猫咪图片放在一边，让我们去学习更多 HTML 相关样式。\n你可能已经注意到了，所有的 HTML 元素基本都是以矩形为基础。\n每个 HTML 元素周围的矩形空间由三个重要的属性来控制：padding（内边距），margin（外边距）和border（边框）。\npadding控制着元素内容与border之间的空隙大小。\n在这里，我们可以看到蓝色盒子和红色盒子都在黄色盒子里面。可以发现，红色盒子比蓝色盒子有着更多的padding填充空间。\n当你增加蓝色盒子的padding值，文本内容与边框的距离会逐渐拉大。\n  .red-box {\n    background-color: crimson;\n    color: #fff;\n    padding: 20px;\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础给元素添加负外边距",
    "href": "posts/CSS_基础/index.html#css-基础给元素添加负外边距",
    "title": "CSS_基础",
    "section": "CSS 基础：给元素添加负外边距",
    "text": "CSS 基础：给元素添加负外边距\n可设置为负值 元素的margin（外边距）控制元素边框与其他周围元素之间的距离大小。\n如果你设置元素margin为负值，元素会变得更大。\n.blue-box {\n    background-color: blue;\n    color: #fff;\n    padding: 20px;\n    margin: -15px;\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础给元素的每一侧添加不同的内边距",
    "href": "posts/CSS_基础/index.html#css-基础给元素的每一侧添加不同的内边距",
    "title": "CSS_基础",
    "section": "CSS 基础：给元素的每一侧添加不同的内边距",
    "text": "CSS 基础：给元素的每一侧添加不同的内边距\n有时候，你会想给一个元素每个方向的padding都设置成一个特定的值\nCSS 允许你使用padding-top，padding-right， padding-bottom和padding-left属性来设置四个不同方向的padding值。\n.blue-box {\n    background-color: blue;\n    color: #fff;\n    padding-top:40px;\n    padding-right:20px;\n    padding-left:40px;\n    padding-bottom:20px;\n    \n\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础给元素的每一侧添加不同的外边距",
    "href": "posts/CSS_基础/index.html#css-基础给元素的每一侧添加不同的外边距",
    "title": "CSS_基础",
    "section": "CSS 基础：给元素的每一侧添加不同的外边距",
    "text": "CSS 基础：给元素的每一侧添加不同的外边距\n有时候，你会想给一个元素每个方向的margin都设置成一个特定的值。\nCSS 允许你使用margin-top，margin-right，margin-bottom和margin-left属性来设置四个不同方向的margin值。\n.red-box {\n    background-color: crimson;\n    color: #fff;\n    margin-top: 40px;\n    margin-right: 20px;\n    margin-bottom: 20px;\n    margin-left: 40px;\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用顺时针方向指定元素的内边距",
    "href": "posts/CSS_基础/index.html#css-基础使用顺时针方向指定元素的内边距",
    "title": "CSS_基础",
    "section": "CSS 基础：使用顺时针方向指定元素的内边距",
    "text": "CSS 基础：使用顺时针方向指定元素的内边距\n如果不想每次都要分别声明padding-top，padding-right，padding-bottom和padding-left属性，可以把它们汇总在padding属性里面声明，如下：\npadding: 10px 20px 10px 20px;\n这四个值按顺时针排序：上，右，下，左，并且设置的效果等同于特定声明每一个方向的padding。\n  .blue-box {\n    background-color: blue;\n    color: #fff;\n    margin: 40px 20px 20px 40px;\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用顺时针方向指定元素的外边距",
    "href": "posts/CSS_基础/index.html#css-基础使用顺时针方向指定元素的外边距",
    "title": "CSS_基础",
    "section": "CSS 基础：使用顺时针方向指定元素的外边距",
    "text": "CSS 基础：使用顺时针方向指定元素的外边距\n让我们再试一次，不过这一次轮到margin了。\n同样，每个方向的外边距值可以在margin属性里面汇总声明，来代替分别声明margin-top，margin-right，margin-bottom和margin-left属性的方式，代码如下：\nmargin: 10px 20px 10px 20px;\n这四个值按顺时针排序：上，右，下，左，并且设置的效果等同于特定声明每一个方向的margin。\n.blue-box {\n    background-color: blue;\n    color: #fff;\n    margin:40px 20px 20px 40px\n  }"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用属性选择器来设置元素的样式",
    "href": "posts/CSS_基础/index.html#css-基础使用属性选择器来设置元素的样式",
    "title": "CSS_基础",
    "section": "CSS 基础：使用属性选择器来设置元素的样式",
    "text": "CSS 基础：使用属性选择器来设置元素的样式\n你已经通过设置元素的id和class，来显示你想要的样式，而它们也被分别叫做 ID 选择器和 Class 选择器。另外，也还有其他的 CSS 选择器，可以让我们给特定的元素设置样式。\n让我们再次通过猫咪图片项目来练习 CSS 选择器。\n在这个挑战里，你会使用[attr=value]属性选择器修改复选框的样式。这个选择器使用特定的属性值来匹配和设置元素样式。例如，下面的代码会改变所有type为radio的元素的外边距。\n[type='radio'] {\n  margin: 20px 0px 20px 0px;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础理解绝对单位与相对单位",
    "href": "posts/CSS_基础/index.html#css-基础理解绝对单位与相对单位",
    "title": "CSS_基础",
    "section": "CSS 基础：理解绝对单位与相对单位",
    "text": "CSS 基础：理解绝对单位与相对单位\n最近的几个挑战都是设置元素的内边距和外边距的px值。像素px是一种长度单位，来告诉浏览器应该如何调整元素大小和空间大小。其实除了像素，CSS 也有其他不同的长度单位供我们使用。\n单位长度的类型可以分成 2 种，一种是相对的，一种是绝对的。例如，in和mm分别代表着英寸和毫米。绝对长度单位会接近屏幕上的实际测量值，不过不同屏幕的分辨率会存在差异，可能会导致一些误差。\n相对单位长度，就像em和rem，它们会依赖其他长度的值。就好像em的大小基于元素的字体的font-size值，如果你使用em单位来设置font-size值，它的值会跟随父元素的font-size值来改变。\n注意： 有些单位长度选项是相对视窗大小来改变值的，符合了响应式 web 的设计原则。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础现在让我们来讨论一下-css-继承",
    "href": "posts/CSS_基础/index.html#css-基础现在让我们来讨论一下-css-继承",
    "title": "CSS_基础",
    "section": "CSS 基础：现在让我们来讨论一下 CSS 继承。",
    "text": "CSS 基础：现在让我们来讨论一下 CSS 继承。\n每一个 HTML 页面都含有一个body元素。\n我们可以通过设置background-color为black，来证明body元素的存在。\n添加以下的代码到style标签里面：\nbody {\n  background-color: black;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础从-body-元素继承样式",
    "href": "posts/CSS_基础/index.html#css-基础从-body-元素继承样式",
    "title": "CSS_基础",
    "section": "CSS 基础：从 Body 元素继承样式",
    "text": "CSS 基础：从 Body 元素继承样式\n我们已经证明每一个 HTML 页面都含有body元素，body元素也可以使用 CSS 样式。\n设置body元素的样式的方式跟设置其他 HTML 元素的样式一样，并且其他元素也会继承到body设置的样式。\n首先，创建一个文本内容为Hello World的h1标签元素。\n接着，在bodyCSS 规则里面添加一句color: green;，改变页面其他元素的字体颜色为green（绿色）。\n最后，同样在bodyCSS 规则里面添加font-family: monospace;，设置其他元素字体为font-family: monospace;。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础样式中的优先级有时候你的-html-元素的样式会跟其他样式发生冲突",
    "href": "posts/CSS_基础/index.html#css-基础样式中的优先级有时候你的-html-元素的样式会跟其他样式发生冲突",
    "title": "CSS_基础",
    "section": "CSS 基础：样式中的优先级有时候，你的 HTML 元素的样式会跟其他样式发生冲突。",
    "text": "CSS 基础：样式中的优先级有时候，你的 HTML 元素的样式会跟其他样式发生冲突。\n就像，你的h1元素也不能同时设置green和pink两种样式。\n让我们尝试创建一个字体颜色为pink的 class，并应于用其中一个元素中。猜一猜，它会覆盖body元素设置的color: green;CSS 属性吗？\n ## CSS 基础：Class 选择器的优先级高于继承样式 \"pink-text\"class 覆盖了body元素的 CSS 声明。\n我们刚刚证明了我们的 class 会覆盖body的 CSS 样式。那么，下一个问题是，我们要怎么样才能覆盖我们的pink-textclass？ 创建一个字体颜色为blue的blue-textCSS class，并确保它在pink-text下方声明。\n在这里插入代码片\n在含有pink-textclass 的h1元素里面，再添加一个blue-textclass，这时候，我们将能看到到底是谁获胜。\nHTML 同时应用多个 class 属性需以空格来间隔，例子如下:\nclass=\"class1 class2\"\n注意：HTML 元素里应用的 class 的先后顺序无关紧要。\n但是，在&lt;style&gt;标签里面声明的class顺序十分重要。第二个声明始终优于第一个声明。因为.blue-text在.pink-text的后面声明，所以.blue-text会覆盖.pink-text的样式。\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础id-选择器优先级高于-class-选择器",
    "href": "posts/CSS_基础/index.html#css-基础id-选择器优先级高于-class-选择器",
    "title": "CSS_基础",
    "section": "CSS 基础：ID 选择器优先级高于 Class 选择器",
    "text": "CSS 基础：ID 选择器优先级高于 Class 选择器\n我们刚刚证明了浏览器读取 CSS 是由上到下的。这就意味着，如果发生冲突，浏览器将会应用最后声明的样式。\n不过我们还没结束，还有其他方法来覆盖 CSS 样式。你还记得 id 属性吗？\n通过给h1元素添加 id 属性，来覆盖 class 属性定义的同名样式。\n给h1元素添加 id 属性，属性值为orange-text。设置方式如下：\n&lt;h1 id=\"orange-text\"&gt;\nh1元素继续保留blue-text和pink-textclass。\n在style元素中创建名为orange-text的 id 选择器。例子如下：\n#orange-text {\n  color: orange;\n}\n注意：无论在pink-textclass 的上面或者下面声明，id 选择器的优先级总是会高于 class 选择器。  ## CSS 基础：内联样式的优先级高于 ID 选择器 我们刚刚证明了，id 选择器无论在style标签哪里声明，都会覆盖 class 声明的样式，\n其实还有其他方法可以覆盖重写 CSS 样式。你还记得行内样式吗？\n使用行内样式尝试让h1的字体颜色变白。像下面这样使用：\n&lt;h1 style=\"color: green\"&gt;\n你的h1元素需继续保留blue-text和pink-textclass。  ## CSS 基础：Important 的优先级最高 我们刚刚又证明了行内样式会覆盖style标签里面所有的 CSS 声明。\n不过，还有一种方式可以覆盖重新 CSS 样式。这是所有方法里面最强大的一个。在此之前，我们要考虑清楚，为什么我们需要覆盖 CSS 样式。\n在很多时候，你使用 CSS 库，有时候它们声明的样式会意外的覆盖你的 CSS 样式。当你需要保证你的 CSS 样式不受影响，你可以使用!important。\n让我们回到pink-textclass 声明之中，它已经被随其后的 class 声明，id 声明，以及行内样式所覆盖。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用十六进制编码获得指定颜色",
    "href": "posts/CSS_基础/index.html#css-基础使用十六进制编码获得指定颜色",
    "title": "CSS_基础",
    "section": "CSS 基础：使用十六进制编码获得指定颜色",
    "text": "CSS 基础：使用十六进制编码获得指定颜色\n你知道在 CSS 里面还有其他方式来代表颜色吗？其中一个方法叫做十六进制编码，简称hex。\n我们日常使用最多的计数方法，基于十进制，使用 0 到 9 数字来表示。而十六进制编码（hex）基于 16 位数字，它含有 16 种不同字符。十六进制与十进制一样，0-9 表示着 0 到 9 的值，不同的是，A，B，C，D，E，F 表示着十六进制 10 到 15 的值。总的来说，0 到 F 在十六进制里代表着数字，提供了 16 种可能性。你可以在这里找到更多的相关信息。\n在 CSS 里面，我们可以用使用 6 个十六进制的数字来代表颜色，每两个数字控制一种颜色，分别是红（R），绿（G），蓝（B）。例如，#000000代表着黑色，同时也是最小的值。你可以在这里找到更多的相关信息。\nbody {\n  color: #000000;\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用十六进制编码混合颜色",
    "href": "posts/CSS_基础/index.html#css-基础使用十六进制编码混合颜色",
    "title": "CSS_基础",
    "section": "CSS 基础：使用十六进制编码混合颜色",
    "text": "CSS 基础：使用十六进制编码混合颜色\n回顾一下，hex使用 6 个十六进制编码来表示颜色，2 个一组，分别代表着红（R），绿（G），蓝（B）。\n通过三原色，我们可以创建 1600 万种不同颜色！\n例如，橘色是纯红色混合一些绿色而成的，没有蓝色的参与。在十六进制编码里面，它被转译为#FFA500。\n0是十六进制里面最小的数字，表示着没有颜色。\nF是十六进制里面最大的数字，表示着最高的亮度。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用缩写的十六进制编码",
    "href": "posts/CSS_基础/index.html#css-基础使用缩写的十六进制编码",
    "title": "CSS_基础",
    "section": "CSS 基础：使用缩写的十六进制编码",
    "text": "CSS 基础：使用缩写的十六进制编码\n许多人对超过 1600 万种颜色的可能性感到不知所措，并且很难记住十六进制编码。幸运的是，它也提供缩写的方法。\n例如，红色的#FF0000十六进制编码可以缩写成#F00。在这种缩写形式里，三个数字分别代表着红（R），绿（G），蓝（B）颜色。\n这样，颜色的可能性减少到了大约 4000 种。且在浏览器里#FF0000和#F00完全是同一种颜色。\n  ## CSS 基础：使用 RGB 值为元素上色 另一种可以在 CSS 中表示颜色的方法是使用 RGB 值。\n黑色的 RGB 值声明如下：\nrgb(0, 0, 0)\n白色的 RGB 值声明如下：\nrgb(255, 255, 255)\nRGB 不像十六进制编码，并不需要用到 6 位十六进制数字。在 RGB 里，你只需要指定每种颜色的亮度大小，从 0 到 255。\n在数学的角度来看，如果将十六进制的一种颜色的两位数字相乘，16 乘以 16 也等于 256。所以，从 0 到 255 计算的 RGB 值的具有十六进制编码相同的颜色可能性。\n下面是通过使用 RGB 值设置背景颜色为橘色的例子：\nbody {\n  background-color: rgb(255, 165, 0);\n}"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础使用-rgb-混合颜色",
    "href": "posts/CSS_基础/index.html#css-基础使用-rgb-混合颜色",
    "title": "CSS_基础",
    "section": "CSS 基础：使用 RGB 混合颜色",
    "text": "CSS 基础：使用 RGB 混合颜色\n就像使用十六进制编码一样，你可以通过不同值的组合，来混合得到不同的 RGB 颜色。   ## CSS 基础：使用 CSS 变量一次更改多个元素 CSS 变量是一种仅更改一个值，来一次性更改多个 CSS 样式属性的强大方法。\n按照下面指示的来做，我们只需要改变三个值，多个样式将会同时被修改。 ## CSS 基础：创建一个自定义的 CSS 变量 创建一个 CSS 变量，你只需要在变量名前添加两个破折号，并为其赋值，例子如下：\n--penguin-skin: gray;\n这样会创建一个--penguin-skin变量并赋值为gray（灰色）。\n现在，其他元素可通过该变量来设置为gray（灰色）。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础引用一个自定义的-css-变量",
    "href": "posts/CSS_基础/index.html#css-基础引用一个自定义的-css-变量",
    "title": "CSS_基础",
    "section": "CSS 基础：引用一个自定义的 CSS 变量",
    "text": "CSS 基础：引用一个自定义的 CSS 变量\n创建变量后，CSS 属性可以通过引用变量名来使用它的值。\nbackground: var(--penguin-skin);\n因为引用了--penguin-skin变量的值，使用了这个样式的元素背景颜色会是灰色。\n注意：如果变量名不匹配，样式不会生效。"
  },
  {
    "objectID": "posts/CSS_基础/index.html#css-基础给-css-变量附加回退值",
    "href": "posts/CSS_基础/index.html#css-基础给-css-变量附加回退值",
    "title": "CSS_基础",
    "section": "CSS 基础：给 CSS 变量附加回退值",
    "text": "CSS 基础：给 CSS 变量附加回退值\n使用变量来作为 CSS 属性值的时候，可以设置一个备用值来防止由于某些原因导致变量不生效的情况。\n或许有些人正在使用着不支持 CSS 变量的旧浏览器，又或者，设备不支持你设置的变量值。为了防止这种情况出现，那么你可以这样写：\nbackground: var(--penguin-skin, black);\n这样，当你的变量有问题的时候，它会设置你的背景颜色为黑色。\n提示：这对调试会很有帮助。\n未完成，学习ing"
  },
  {
    "objectID": "posts/毫米波雷达/index.html",
    "href": "posts/毫米波雷达/index.html",
    "title": "毫米波雷达",
    "section": "",
    "text": "知乎: https://zhuanlan.zhihu.com/p/416269210 TI官方:https://training.ti.com/intro-mmwave-sensing-fmcw-radars-module-1-range-estimation?context=1128486-1139153-1128542\nTI教程\n&gt; ## 相关应用的个人推测 &gt; - 因为观察窗时间加长, 所以带宽B也线性增加. &gt; - 所以斜率对于应用的影响非常关键 &gt; - 如果是短距离的目标距离分辨, 那合理推测斜率应该是比较大, 这样可以区分出近距离的不同目标, 且可以使得观察窗T的周期尽可能缩短. &gt; - 如果是远距离的物体, 那斜率应该尽可能的小,这样可以检测到远处目标的反射信号, &gt; - 那这样的话, ti的vitalSign的项目就是斜率比较高的配置\n推导:\n\\[\n{△f&gt;}{1\\over T }\n\\]\n\\[\n{2△dS\\over c}&gt;{1\\over T }\n\\] \\[\n{△d}&gt;{c\\over 2ST }\n\\] 又因为: B=ST \\[\n{△d}&gt;{c\\over 2B }\n\\]"
  },
  {
    "objectID": "posts/毫米波雷达/index.html#距离分辨率计算",
    "href": "posts/毫米波雷达/index.html#距离分辨率计算",
    "title": "毫米波雷达",
    "section": "距离分辨率计算:",
    "text": "距离分辨率计算:\n扫频带宽 B = 4G 距离分辨率 $ {△d} = {3*1084109}$ = 0.0375m"
  },
  {
    "objectID": "posts/毫米波雷达/index.html#问题-同样的扫频带宽-但是斜率不一样-哪一个的距离分辨率好",
    "href": "posts/毫米波雷达/index.html#问题-同样的扫频带宽-但是斜率不一样-哪一个的距离分辨率好",
    "title": "毫米波雷达",
    "section": "问题: 同样的扫频带宽, 但是斜率不一样, 哪一个的距离分辨率好",
    "text": "问题: 同样的扫频带宽, 但是斜率不一样, 哪一个的距离分辨率好\nchirpA好于chirpB, 为什么因为前面推理过, 观测时间窗越长分辨效果越好, A的持续时间更长, 所以A具有更好的距离分辨率.\n\n对于上面的问题, 如果我们必须使用较短的持续时间, 且需要较好的距离分辨率, 那该如何解决.\n雷达倾向于使用大距离小小斜率."
  },
  {
    "objectID": "posts/Ubuntu18版本换源/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "href": "posts/Ubuntu18版本换源/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "title": "TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析",
    "section": "",
    "text": "EDMA的数据数据搬移，这部分比较重要，对于能否清楚数据排列很关键\n\n\n\n\nACount: Array(每个切分数据)的大小\nBCount: 一共有N个Array\nCCount: N个BCount\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nsrcBidx: 源数据块的读取偏移(上面的一个array的大小), 即读取每个array偏移的大小\ndstBidx: 目的地址偏移(如果为0 表示不偏移, 最大支持0xffffH的偏移)\n下图表示的是ab同步传输模式, 在vitalsign中使用的是a同步传输\n\n\n\n\n\n在这里插入图片描述\n\n\n/**\n * EDMA_Handle handle,\n    uint8_t *srcBuff,              ADCdataBuf\n    uint8_t *dstBuff,              adcDataIn\n    uint8_t chId,                   PONG\n    bool isEventTriggered,          false\n    uint16_t shadowParamId,\n    uint16_t aCount,                100*(16*2)\n    uint16_t bCount,                Rx*numChirp\n    int16_t srcBIdx,                \n    int16_t dstBIdx,                0\n    uint8_t eventQueueId,\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg\n * */\n\n\nEDMAutil_configType1(\n    context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n    (uint8_t *)(&obj-&gt;ADCdataBuf[obj-&gt;numAdcSamples * obj-&gt;numChirpsPerChirpEvent]),\n    (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;adcDataIn[obj-&gt;numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n    MMW_EDMA_CH_1D_IN_PONG,\n    false, // 如果要在配置后启用通道，则设置为 true，否则设置为 false。\n    shadowParam++,\n    obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,\n    MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,\n    (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent,\n    0,\n    eventQueue,\n    NULL,\n    (uintptr_t) obj);\n\n\n\n通道控制器(EDMA_TPCC0_REQ_FREE_0这里vitalsign使用的是通道控制器0)\ncc0 有 2个 TC(传输控制器)\ncc1 有 1个 TC(传输控制器)\n传输控制器\n\n\nvitalSign中的EDMA配置\n/*EDMA instance used*/\n#define MMW_DATA_PATH_EDMA_INSTANCE      EDMA_INSTANCE_0\n                                         \n/* channels */                           \n#define MMW_EDMA_CH_1D_IN_PING           EDMA_TPCC0_REQ_FREE_0\n#define MMW_EDMA_CH_1D_IN_PONG           EDMA_TPCC0_REQ_FREE_1\n#define MMW_EDMA_CH_1D_OUT_PING          EDMA_TPCC0_REQ_FREE_2\n#define MMW_EDMA_CH_1D_OUT_PONG          EDMA_TPCC0_REQ_FREE_3\n#define MMW_EDMA_CH_2D_IN_PING           EDMA_TPCC0_REQ_FREE_4\n#define MMW_EDMA_CH_2D_IN_PONG           EDMA_TPCC0_REQ_FREE_5\n#define MMW_EDMA_CH_DET_MATRIX           EDMA_TPCC0_REQ_FREE_6\n#define MMW_EDMA_CH_DET_MATRIX2          EDMA_TPCC0_REQ_FREE_7\n#define MMW_EDMA_CH_3D_IN_PING           EDMA_TPCC0_REQ_FREE_8\n#define MMW_EDMA_CH_3D_IN_PONG           EDMA_TPCC0_REQ_FREE_9\n#define MMW_EDMA_CH_SIGIMG_MON           EDMA_TPCC0_REQ_FREE_10\n#define MMW_EDMA_CH_RX_SATURATION_MON    EDMA_TPCC0_REQ_FREE_11\n\n/*shadow*/\n// #define EDMA_NUM_DMA_CHANNELS (64U)\n#define MMW_EDMA_CH_1D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 0U)    \n#define MMW_EDMA_CH_1D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 1U)\n#define MMW_EDMA_CH_1D_OUT_PING_SHADOW          (EDMA_NUM_DMA_CHANNELS + 2U)\n#define MMW_EDMA_CH_1D_OUT_PONG_SHADOW          (EDMA_NUM_DMA_CHANNELS + 3U)\n#define MMW_EDMA_CH_2D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 4U)\n#define MMW_EDMA_CH_2D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 5U)\n#define MMW_EDMA_CH_DET_MATRIX_SHADOW           (EDMA_NUM_DMA_CHANNELS + 6U)\n#define MMW_EDMA_CH_DET_MATRIX2_SHADOW          (EDMA_NUM_DMA_CHANNELS + 7U)\n#define MMW_EDMA_CH_3D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 8U)\n#define MMW_EDMA_CH_3D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 9U)\n &gt;## DMA触发方式 &gt;- 手动触发(ESR) &gt;- 链接触发(Link) [vitalsign使用的方式] &gt; 用一个edma的传输结束来出发另外一个edma &gt;- 事件触发(EER)\n这里vitalSign使用的是cc0, 所以查看cc0支持的事件表  下面的32个通道对应上面的32个事件(event), 如果我们想要通过UART0 Receice 来出发EDMA传输, 就需要配置到通道8, 这就是事件触发方式 \n\n\n每个EDMA事件对应一个paRAM, 每个paRAM存储一个EDMA配置, 每个paRAM包括8个字\n\n这里的参数对应EDMAutil_configType1里面的代码\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg)\n{\n    EDMA_channelConfig_t config;\n    int32_t errorCode = EDMA_NO_ERROR;\n\n    config.channelId = chId;\n    config.channelType = (uint8_t)EDMA3_CHANNEL_TYPE_DMA;\n    config.paramId = chId;\n    config.eventQueueId = eventQueueId;\n\n    config.paramSetConfig.sourceAddress = (uint32_t) srcBuff;\n    config.paramSetConfig.destinationAddress = (uint32_t) dstBuff;\n\n    config.paramSetConfig.aCount = aCount;\n    config.paramSetConfig.bCount = bCount;\n    config.paramSetConfig.cCount = 1U;                      // 数据只有一行\n    config.paramSetConfig.bCountReload = 0U;\n\n    config.paramSetConfig.sourceBindex = srcBIdx;\n    config.paramSetConfig.destinationBindex = dstBIdx;\n\n    config.paramSetConfig.sourceCindex = 0U;            \n    config.paramSetConfig.destinationCindex = 0U;\n\n    config.paramSetConfig.linkAddress = EDMA_NULL_LINK_ADDRESS;\n    config.paramSetConfig.transferType = (uint8_t)EDMA3_SYNC_A;     // 传输模式A同步传输模式(Array*B)\n    config.paramSetConfig.transferCompletionCode = chId;\n    config.paramSetConfig.sourceAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n    config.paramSetConfig.destinationAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n\n    /* don't care because of linear addressing modes above */\n    config.paramSetConfig.fifoWidth = (uint8_t) EDMA3_FIFO_WIDTH_8BIT;\n\n    config.paramSetConfig.isStaticSet = false;\n    config.paramSetConfig.isEarlyCompletion = false;\n    config.paramSetConfig.isFinalTransferInterruptEnabled = true;\n    config.paramSetConfig.isIntermediateTransferInterruptEnabled = true;\n    config.paramSetConfig.isFinalChainingEnabled = false;\n    config.paramSetConfig.isIntermediateChainingEnabled = false;\n    config.transferCompletionCallbackFxn = transferCompletionCallbackFxn;\n    config.transferCompletionCallbackFxnArg = transferCompletionCallbackFxnArg;\n\n    if ((errorCode = EDMA_configChannel(handle, &config, isEventTriggered)) != EDMA_NO_ERROR)\n    {\n        System_printf(\"Error: EDMA_configChannel() failed with error code = %d\\n\", errorCode);\n        goto exit;\n    }\n\n    errorCode = EDMA_setup_shadow_link(handle, chId, shadowParamId,\n        &config.paramSetConfig, config.transferCompletionCallbackFxn, transferCompletionCallbackFxnArg);\n\nexit:\n    return(errorCode);\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n链接触发\n自动触发\n没有用到所有没写\n\n\n\n\n\n主要针对dma对数据的搬移\n\n\n &gt;### EDMA配置 &gt; - 上图处理过程主要用到4 个EDMA &gt; - 1D_IN_Ping , 1D_IN_Pong, 1D_OUT_Ping, 1D_OUT_Pong\n\n\n\n这个edma主要的工作时将AdcDataBuf中的数据搬移到adcDataIn中\n这里的chrip1, chirp2 …表示的是一frame内的chirp序号, 不是所有的chirp, 每次++\nchirp1 和 chirp2 的到达时间肯定是不同的, chirp2在chirp1之后, 所以edma_1d_in_ping同一时间搬移到adcDataIn里面的数据是 chrip 1 Rx 1 chrip 1 Rx 2,\nbcount=4 表示一共传输4次\n将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong , 为后面的加窗 和fft操作组成流水线做准备\nshadow表示链接触发, shadow使用和1d_in_ping的一样的配置参数, 也发送4次,刚好将数据发送完\n这的ping(adcDataBuf)pong(adcDataBuf)表示的是一帧内的chirp, 每个buff中放两个chirp, 如果大于2chrip会组成pingpong\n\n\n &gt; 将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong &gt; \n\n\n\n后续使用该api请参考这里\n\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n)\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj-&gt;ADCdataBuf[0]), \n        (uint8_t *)(SOC_translateAddress((uint32_t)&obj-&gt;adcDataIn[0],SOC_TranslateAddr_Dir_TO_EDMA,NULL)), \n        MMW_EDMA_CH_1D_IN_PING,\n        false,\n        shadowParam++,\n        obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,// acount\n        MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,// bcount\n        (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent, // srcbidx\n        0,                                                                         // dstbidx\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这个edma和1d_in_ping类似\n参考上面描述\n\n\n\n\n\n\n\n\n\nEDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj-&gt;ADCdataBuf[obj-&gt;numAdcSamples * obj-&gt;numChirpsPerChirpEvent]),\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;adcDataIn[obj-&gt;numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        MMW_EDMA_CH_1D_IN_PONG,\n        false,\n        shadowParam++,\n        obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,\n        MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,\n        (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent,\n        0,\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这里的ping pong 表示按照发射天线进行区分, 将前面的Ping(adcDataBuf) 或者Pong(adcDataBuf) 单个Buffer中的接收数据进行全部分组, 按照发射天线进行分组\n后将数据搬移到RadarCube中\nCube中只有一帧的数据,并按照天线的奇偶进行拆分排列\n该EDMA中的配置的搬移到Cube中的数据按照配置生成, dataPathObj-&gt;numRangeBins        = MmwDemo_pow2roundup(dataPathObj-&gt;numAdcSamples); 按照满足的二次幂来设置, numAdcSamples = 100, 那么此时的numRangeBins=128, 如果numAdcSamples=64则numRangeBins=64, 所以这里的EDMA配置根据该参数自动调整\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n\n\n\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;fftOut1D[0]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        (uint8_t *)(&obj-&gt;radarCube[0]),\n        MMW_EDMA_CH_1D_OUT_PING,\n        false,\n        shadowParam++,\n        aCount,   // 128*Rx*complex\n        obj-&gt;numChirpsPerFrame / 2, //bCount  4/2\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n对应参照 1D_OUT_Ping\n\n\n\n\n\n\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;fftOut1D[numPingOrPongSamples]),// numPingOrPongSamples:  128*Rx\n                                         SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        oneD_destinationPongAddress, // 128*4*1\n        MMW_EDMA_CH_1D_OUT_PONG,\n        false,\n        shadowParam++,\n        aCount,\n        obj-&gt;numChirpsPerFrame / 2, //bCount\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html#源数据块描述",
    "href": "posts/Ubuntu18版本换源/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html#源数据块描述",
    "title": "TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析",
    "section": "",
    "text": "ACount: Array(每个切分数据)的大小\nBCount: 一共有N个Array\nCCount: N个BCount\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nsrcBidx: 源数据块的读取偏移(上面的一个array的大小), 即读取每个array偏移的大小\ndstBidx: 目的地址偏移(如果为0 表示不偏移, 最大支持0xffffH的偏移)\n下图表示的是ab同步传输模式, 在vitalsign中使用的是a同步传输\n\n\n\n\n\n在这里插入图片描述\n\n\n/**\n * EDMA_Handle handle,\n    uint8_t *srcBuff,              ADCdataBuf\n    uint8_t *dstBuff,              adcDataIn\n    uint8_t chId,                   PONG\n    bool isEventTriggered,          false\n    uint16_t shadowParamId,\n    uint16_t aCount,                100*(16*2)\n    uint16_t bCount,                Rx*numChirp\n    int16_t srcBIdx,                \n    int16_t dstBIdx,                0\n    uint8_t eventQueueId,\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg\n * */\n\n\nEDMAutil_configType1(\n    context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n    (uint8_t *)(&obj-&gt;ADCdataBuf[obj-&gt;numAdcSamples * obj-&gt;numChirpsPerChirpEvent]),\n    (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;adcDataIn[obj-&gt;numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n    MMW_EDMA_CH_1D_IN_PONG,\n    false, // 如果要在配置后启用通道，则设置为 true，否则设置为 false。\n    shadowParam++,\n    obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,\n    MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,\n    (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent,\n    0,\n    eventQueue,\n    NULL,\n    (uintptr_t) obj);\n\n\n\n通道控制器(EDMA_TPCC0_REQ_FREE_0这里vitalsign使用的是通道控制器0)\ncc0 有 2个 TC(传输控制器)\ncc1 有 1个 TC(传输控制器)\n传输控制器\n\n\nvitalSign中的EDMA配置\n/*EDMA instance used*/\n#define MMW_DATA_PATH_EDMA_INSTANCE      EDMA_INSTANCE_0\n                                         \n/* channels */                           \n#define MMW_EDMA_CH_1D_IN_PING           EDMA_TPCC0_REQ_FREE_0\n#define MMW_EDMA_CH_1D_IN_PONG           EDMA_TPCC0_REQ_FREE_1\n#define MMW_EDMA_CH_1D_OUT_PING          EDMA_TPCC0_REQ_FREE_2\n#define MMW_EDMA_CH_1D_OUT_PONG          EDMA_TPCC0_REQ_FREE_3\n#define MMW_EDMA_CH_2D_IN_PING           EDMA_TPCC0_REQ_FREE_4\n#define MMW_EDMA_CH_2D_IN_PONG           EDMA_TPCC0_REQ_FREE_5\n#define MMW_EDMA_CH_DET_MATRIX           EDMA_TPCC0_REQ_FREE_6\n#define MMW_EDMA_CH_DET_MATRIX2          EDMA_TPCC0_REQ_FREE_7\n#define MMW_EDMA_CH_3D_IN_PING           EDMA_TPCC0_REQ_FREE_8\n#define MMW_EDMA_CH_3D_IN_PONG           EDMA_TPCC0_REQ_FREE_9\n#define MMW_EDMA_CH_SIGIMG_MON           EDMA_TPCC0_REQ_FREE_10\n#define MMW_EDMA_CH_RX_SATURATION_MON    EDMA_TPCC0_REQ_FREE_11\n\n/*shadow*/\n// #define EDMA_NUM_DMA_CHANNELS (64U)\n#define MMW_EDMA_CH_1D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 0U)    \n#define MMW_EDMA_CH_1D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 1U)\n#define MMW_EDMA_CH_1D_OUT_PING_SHADOW          (EDMA_NUM_DMA_CHANNELS + 2U)\n#define MMW_EDMA_CH_1D_OUT_PONG_SHADOW          (EDMA_NUM_DMA_CHANNELS + 3U)\n#define MMW_EDMA_CH_2D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 4U)\n#define MMW_EDMA_CH_2D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 5U)\n#define MMW_EDMA_CH_DET_MATRIX_SHADOW           (EDMA_NUM_DMA_CHANNELS + 6U)\n#define MMW_EDMA_CH_DET_MATRIX2_SHADOW          (EDMA_NUM_DMA_CHANNELS + 7U)\n#define MMW_EDMA_CH_3D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 8U)\n#define MMW_EDMA_CH_3D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 9U)\n &gt;## DMA触发方式 &gt;- 手动触发(ESR) &gt;- 链接触发(Link) [vitalsign使用的方式] &gt; 用一个edma的传输结束来出发另外一个edma &gt;- 事件触发(EER)\n这里vitalSign使用的是cc0, 所以查看cc0支持的事件表  下面的32个通道对应上面的32个事件(event), 如果我们想要通过UART0 Receice 来出发EDMA传输, 就需要配置到通道8, 这就是事件触发方式 \n\n\n每个EDMA事件对应一个paRAM, 每个paRAM存储一个EDMA配置, 每个paRAM包括8个字\n\n这里的参数对应EDMAutil_configType1里面的代码\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg)\n{\n    EDMA_channelConfig_t config;\n    int32_t errorCode = EDMA_NO_ERROR;\n\n    config.channelId = chId;\n    config.channelType = (uint8_t)EDMA3_CHANNEL_TYPE_DMA;\n    config.paramId = chId;\n    config.eventQueueId = eventQueueId;\n\n    config.paramSetConfig.sourceAddress = (uint32_t) srcBuff;\n    config.paramSetConfig.destinationAddress = (uint32_t) dstBuff;\n\n    config.paramSetConfig.aCount = aCount;\n    config.paramSetConfig.bCount = bCount;\n    config.paramSetConfig.cCount = 1U;                      // 数据只有一行\n    config.paramSetConfig.bCountReload = 0U;\n\n    config.paramSetConfig.sourceBindex = srcBIdx;\n    config.paramSetConfig.destinationBindex = dstBIdx;\n\n    config.paramSetConfig.sourceCindex = 0U;            \n    config.paramSetConfig.destinationCindex = 0U;\n\n    config.paramSetConfig.linkAddress = EDMA_NULL_LINK_ADDRESS;\n    config.paramSetConfig.transferType = (uint8_t)EDMA3_SYNC_A;     // 传输模式A同步传输模式(Array*B)\n    config.paramSetConfig.transferCompletionCode = chId;\n    config.paramSetConfig.sourceAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n    config.paramSetConfig.destinationAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n\n    /* don't care because of linear addressing modes above */\n    config.paramSetConfig.fifoWidth = (uint8_t) EDMA3_FIFO_WIDTH_8BIT;\n\n    config.paramSetConfig.isStaticSet = false;\n    config.paramSetConfig.isEarlyCompletion = false;\n    config.paramSetConfig.isFinalTransferInterruptEnabled = true;\n    config.paramSetConfig.isIntermediateTransferInterruptEnabled = true;\n    config.paramSetConfig.isFinalChainingEnabled = false;\n    config.paramSetConfig.isIntermediateChainingEnabled = false;\n    config.transferCompletionCallbackFxn = transferCompletionCallbackFxn;\n    config.transferCompletionCallbackFxnArg = transferCompletionCallbackFxnArg;\n\n    if ((errorCode = EDMA_configChannel(handle, &config, isEventTriggered)) != EDMA_NO_ERROR)\n    {\n        System_printf(\"Error: EDMA_configChannel() failed with error code = %d\\n\", errorCode);\n        goto exit;\n    }\n\n    errorCode = EDMA_setup_shadow_link(handle, chId, shadowParamId,\n        &config.paramSetConfig, config.transferCompletionCallbackFxn, transferCompletionCallbackFxnArg);\n\nexit:\n    return(errorCode);\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n链接触发\n自动触发\n没有用到所有没写\n\n\n\n\n\n主要针对dma对数据的搬移\n\n\n &gt;### EDMA配置 &gt; - 上图处理过程主要用到4 个EDMA &gt; - 1D_IN_Ping , 1D_IN_Pong, 1D_OUT_Ping, 1D_OUT_Pong\n\n\n\n这个edma主要的工作时将AdcDataBuf中的数据搬移到adcDataIn中\n这里的chrip1, chirp2 …表示的是一frame内的chirp序号, 不是所有的chirp, 每次++\nchirp1 和 chirp2 的到达时间肯定是不同的, chirp2在chirp1之后, 所以edma_1d_in_ping同一时间搬移到adcDataIn里面的数据是 chrip 1 Rx 1 chrip 1 Rx 2,\nbcount=4 表示一共传输4次\n将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong , 为后面的加窗 和fft操作组成流水线做准备\nshadow表示链接触发, shadow使用和1d_in_ping的一样的配置参数, 也发送4次,刚好将数据发送完\n这的ping(adcDataBuf)pong(adcDataBuf)表示的是一帧内的chirp, 每个buff中放两个chirp, 如果大于2chrip会组成pingpong\n\n\n &gt; 将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong &gt; \n\n\n\n后续使用该api请参考这里\n\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n)\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj-&gt;ADCdataBuf[0]), \n        (uint8_t *)(SOC_translateAddress((uint32_t)&obj-&gt;adcDataIn[0],SOC_TranslateAddr_Dir_TO_EDMA,NULL)), \n        MMW_EDMA_CH_1D_IN_PING,\n        false,\n        shadowParam++,\n        obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,// acount\n        MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,// bcount\n        (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent, // srcbidx\n        0,                                                                         // dstbidx\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这个edma和1d_in_ping类似\n参考上面描述\n\n\n\n\n\n\n\n\n\nEDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj-&gt;ADCdataBuf[obj-&gt;numAdcSamples * obj-&gt;numChirpsPerChirpEvent]),\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;adcDataIn[obj-&gt;numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        MMW_EDMA_CH_1D_IN_PONG,\n        false,\n        shadowParam++,\n        obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D,\n        MAX(obj-&gt;numRxAntennas / 2, 1) * obj-&gt;numChirpsPerChirpEvent,\n        (obj-&gt;numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj-&gt;numChirpsPerChirpEvent,\n        0,\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这里的ping pong 表示按照发射天线进行区分, 将前面的Ping(adcDataBuf) 或者Pong(adcDataBuf) 单个Buffer中的接收数据进行全部分组, 按照发射天线进行分组\n后将数据搬移到RadarCube中\nCube中只有一帧的数据,并按照天线的奇偶进行拆分排列\n该EDMA中的配置的搬移到Cube中的数据按照配置生成, dataPathObj-&gt;numRangeBins        = MmwDemo_pow2roundup(dataPathObj-&gt;numAdcSamples); 按照满足的二次幂来设置, numAdcSamples = 100, 那么此时的numRangeBins=128, 如果numAdcSamples=64则numRangeBins=64, 所以这里的EDMA配置根据该参数自动调整\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n\n\n\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;fftOut1D[0]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        (uint8_t *)(&obj-&gt;radarCube[0]),\n        MMW_EDMA_CH_1D_OUT_PING,\n        false,\n        shadowParam++,\n        aCount,   // 128*Rx*complex\n        obj-&gt;numChirpsPerFrame / 2, //bCount  4/2\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n对应参照 1D_OUT_Ping\n\n\n\n\n\n\n    EDMAutil_configType1(context-&gt;edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj-&gt;fftOut1D[numPingOrPongSamples]),// numPingOrPongSamples:  128*Rx\n                                         SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        oneD_destinationPongAddress, // 128*4*1\n        MMW_EDMA_CH_1D_OUT_PONG,\n        false,\n        shadowParam++,\n        aCount,\n        obj-&gt;numChirpsPerFrame / 2, //bCount\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);"
  },
  {
    "objectID": "posts/vscode_icon_abnormal/index.html",
    "href": "posts/vscode_icon_abnormal/index.html",
    "title": "vscode icon abnormal",
    "section": "",
    "text": "Abstract\nvscode terminal icon abnormal, shown as box.to fix this problem we nedd to set this font family as the terminal font.\n\n\nReferance\ntexthttps://arch.icekylin.online/advanced/beauty-3.html#_2-1-powerlevel10k\ncheck the terminal font\nksonl –&gt; 设置 –&gt; 管理配色方案 –&gt; 外观 –&gt; font\n\nset the font same as terminal\n\nthen you will see successful"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#选中服务器管理器",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#选中服务器管理器",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击角色-添加角色",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击角色-添加角色",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "2、点击角色—->添加角色",
    "text": "2、点击角色—-&gt;添加角色\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击-下一步",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#点击-下一步",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "3、点击 【下一步】",
    "text": "3、点击 【下一步】\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "4、勾选DHCP",
    "text": "4、勾选DHCP\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#如果出现此情况点击取消",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#如果出现此情况点击取消",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5、如果出现此情况点击取消）",
    "text": "（5、如果出现此情况点击取消）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#执行以下操作",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#执行以下操作",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.1执行以下操作）",
    "text": "（5.1执行以下操作）\n静态ip配置如下 静态ip配置如下 静态ip配置如下\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#本地连接",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#本地连接",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.2本地连接）",
    "text": "（5.2本地连接）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#属性",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#属性",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.3属性）",
    "text": "（5.3属性）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#双击ipv4",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#双击ipv4",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.4双击iPv4）",
    "text": "（5.4双击iPv4）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "（5.5根据需求设置）",
    "text": "（5.5根据需求设置）\n设置完确定关闭窗口，回到刚刚的DHCP安装页面\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#再次点击添加角色",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#再次点击添加角色",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "6、再次点击添加角色",
    "text": "6、再次点击添加角色\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#勾选dhcp-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "7、勾选DHCP",
    "text": "7、勾选DHCP\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "8、下一步",
    "text": "8、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "9、下一步",
    "text": "9、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置-1",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#根据需求设置-1",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "10、根据需求设置",
    "text": "10、根据需求设置\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-2",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#下一步-2",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "11、下一步",
    "text": "11、下一步\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#添加作用域",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#添加作用域",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "12、添加作用域",
    "text": "12、添加作用域\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#设置起始地址",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#设置起始地址",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "13、设置起始地址",
    "text": "13、设置起始地址\n 13.1下一步"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#禁用ipv6",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#禁用ipv6",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "14、禁用ipv6",
    "text": "14、禁用ipv6\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#安装",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#安装",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "15、安装",
    "text": "15、安装\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#测试",
    "href": "posts/简单的创建一个DHCP服务器（WinServ2008-2R）【图文】/index.html#测试",
    "title": "简单的创建一个DHCP服务器（WinServ2008-2R）【图文】",
    "section": "16、测试",
    "text": "16、测试\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaArrayList作业二/index.html",
    "href": "posts/javaArrayList作业二/index.html",
    "title": "javaArrayList作业二",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 12:40\n */\npublic class CarDemo {\n\n    public static void main(String[] args) {\n        Car car1 = new Car(\"宝马\", 4000000);\n        Car car2 = new Car(\"宾利\", 5000000);\n\n        ArrayList&lt;Car&gt; cars = new ArrayList&lt;&gt;();\n        cars.add(car1);\n        cars.add(car2);\n        System.out.println(cars);\n\n        cars.remove(car2);// 删除\n        System.out.println(cars.contains(car1));\n\n        System.out.println(cars.size());//长度\n        System.out.println(cars.isEmpty());//判断空\n        cars.clear();// 清空\n        System.out.println(cars);\n\n        ArrayList&lt;Car&gt; cars1 = new ArrayList&lt;&gt;();\n        cars1.add(new Car(\"大众\",150000));\n        cars1.add(new Car(\"法拉利\",150000));\n        cars.addAll(cars1);// 添加多个\n        cars.addAll(cars1);\n        System.out.println(cars);\n\n        cars.add(car1);\n        System.out.println(cars);\n\n        System.out.println(cars.containsAll(cars1));// 包含多个\n\n        //cars.removeAll(cars1);// 删除列表中的所有\n        //System.out.println(cars);\n\n        // for遍历\n        System.out.println(\"=================for遍历=============\");\n        for (Car car : cars) {\n            System.out.println(car);\n        }\n\n        \n        System.out.println(\"=================迭代器遍历=============\");\n        // 迭代器遍历\n        Iterator&lt;Car&gt; iterator = cars.iterator();\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n\n    }\n}\n\nclass Car{\n    private String name;\n    private double price;\n\n    public Car() {\n    }\n\n    public Car(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaArrayList作业二/index.html#arraylist作业二",
    "href": "posts/javaArrayList作业二/index.html#arraylist作业二",
    "title": "javaArrayList作业二",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 12:40\n */\npublic class CarDemo {\n\n    public static void main(String[] args) {\n        Car car1 = new Car(\"宝马\", 4000000);\n        Car car2 = new Car(\"宾利\", 5000000);\n\n        ArrayList&lt;Car&gt; cars = new ArrayList&lt;&gt;();\n        cars.add(car1);\n        cars.add(car2);\n        System.out.println(cars);\n\n        cars.remove(car2);// 删除\n        System.out.println(cars.contains(car1));\n\n        System.out.println(cars.size());//长度\n        System.out.println(cars.isEmpty());//判断空\n        cars.clear();// 清空\n        System.out.println(cars);\n\n        ArrayList&lt;Car&gt; cars1 = new ArrayList&lt;&gt;();\n        cars1.add(new Car(\"大众\",150000));\n        cars1.add(new Car(\"法拉利\",150000));\n        cars.addAll(cars1);// 添加多个\n        cars.addAll(cars1);\n        System.out.println(cars);\n\n        cars.add(car1);\n        System.out.println(cars);\n\n        System.out.println(cars.containsAll(cars1));// 包含多个\n\n        //cars.removeAll(cars1);// 删除列表中的所有\n        //System.out.println(cars);\n\n        // for遍历\n        System.out.println(\"=================for遍历=============\");\n        for (Car car : cars) {\n            System.out.println(car);\n        }\n\n        \n        System.out.println(\"=================迭代器遍历=============\");\n        // 迭代器遍历\n        Iterator&lt;Car&gt; iterator = cars.iterator();\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n\n    }\n}\n\nclass Car{\n    private String name;\n    private double price;\n\n    public Car() {\n    }\n\n    public Car(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/rp2040_vscode_debug/index.html",
    "href": "posts/rp2040_vscode_debug/index.html",
    "title": "rp2040 config vscode env",
    "section": "",
    "text": "Abstract\nusing 2 pic pico to development\nide is vscode, tools with openOCD.\n\n莓派作为调试器惊醒调试, ide 使用 vscode\n\n\n\nReferance\ngetting-started-with-pico.pdf\nubuntu config pico env # pico_setup_linux\n\npico set up on arch linux and config picoprobe for debug, flash, as serial port….\n\ngit clone https://github.com/raspberrypi/pico-sdk.git –branch master cd pico-sdk git submodule update –init cd .. git clone https://github.com/raspberrypi/pico-examples.git –branch master\n\n\ninstall toolChain\nsudo pacman -Sy arm-none-eabi-newlib arm-none-eabi-gcc cmake base-devel\n\n\nflash with another pico swd\npwd:\n\npico/openocd/tcl\n\nexcute:\n\nsudo ../src/openocd -f interface/picoprobe.cfg -f target/rp2040.cfg -s tlc -c “program /home/dd21/Projects/github/pico/pico-examples/build/blink/blink.elf verify reset exit”\n\n\n\ndebug\n1.start openOCD\n\nsudo ../src/openocd -f interface/picoprobe.cfg -f target/rp2040.cfg\n2.start remot gdb debug\ninstall gdb-multiarch\ngdb-multiarch blink.elf\n\nif you see guile2.2.so.1 no such file or dirtory\nplease install your need version\n\npcman -S guile2.2\n\nthen continue to excute above command\n3.enter the gdb\n\ntarget remote localhost:3333\n\n\n\nconfig with vscode\n使用 vscode 需要注意的点\n\npico_sk_path\nopenOCD 的调试器(我使用的是另外一块 pico)\n复制 vscode 调试器配置的时候注意使用 remote 的那个配置, swd 的我失败了\n修改 vscode 的 launch.json 中的gdbTarget我们使用的是localhost:3333 - 需要先加载文件sudo openocd -f interface/picoprobe.cfg -f target/rp2040.cfg -s xxxxxxx \nxxx 所指的是 interface 的位置,如果安装了 openOCD, 则位置在/usr/bin/local/share/openocd/script/\nlocal/ share 对应的还有一个 local/bin bin 中的都是可执行文件.\n其他的问题大概率是线没有连接好.\nwarning: 修改 runToMain 为”entryPoin”:“main”\nerror: cannot read svd file\n\n\n\ncreate a pico project\n\ncd pico-project-generator excute:\n\n./pico_project.py --gui\nif you see import _tkinter # If this fails your Python may not be configured for Tk means you need to install “Tk”\narchLinux:\nsudo pacman -S install tk\nthen excute command above you will see a gui like this"
  },
  {
    "objectID": "posts/vmware镜像站/index.html",
    "href": "posts/vmware镜像站/index.html",
    "title": "vmware镜像站",
    "section": "",
    "text": "https://softwareupdate.vmware.com/cds/vmw-desktop/ws/"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html",
    "href": "posts/webSocket -- 03 socket.io/index.html",
    "title": "webSocket – 03 socket.io",
    "section": "",
    "text": "为什么使用socket.io 1. 简单 2. 高效：连接池的管理比自己写的要高效（通常）"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html#测试",
    "href": "posts/webSocket -- 03 socket.io/index.html#测试",
    "title": "webSocket – 03 socket.io",
    "section": "测试：",
    "text": "测试：\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/pyqt5 --01简单继承关系/index.html",
    "href": "posts/pyqt5 --01简单继承关系/index.html",
    "title": "pyqt5 –01简单继承关系",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\napp = QApplication(sys.argv)# 创建一个应用（程序） sys.argv接受启动敞口 传递过来的参数\n\n\nwindow = QWidget() # QWidget()是程序内部的位置，不包括最大最小化的那个框\nwindow.setWindowTitle('这是标题')\nwindow.resize(600,500)  # 窗口大小\n\n\n# 按钮\nbtn = QPushButton(window)# 按钮继承了窗口，所以按钮在这个wedget中\nbtn.setText('按钮上的文字')\nbtn.resize(100,50)\nbtn.move(100,100)  # 位置按钮的左上角到widget左上角的位置\nbtn.setStyleSheet('background-color:red')# 样式，css样式的写法\n\n\nlabel = QLabel(window)\nlabel.setText('标签名')\nlabel.setStyleSheet('background-color:red')# 样式，css样式的写法\n\nlabel.show()\nwindow.show()\n\n# sys.exit()  接受程序结束代码号（检测代码退出原因）\nsys.exit(app.exec_())# app.exec_()消息循环功能\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java常用类-- System类的常用方法, Runtime类/index.html",
    "href": "posts/java常用类-- System类的常用方法, Runtime类/index.html",
    "title": "java常用类– System类的常用方法, Runtime类",
    "section": "",
    "text": "package cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n        // 获取当前系统属性\n        Properties properties = System.getProperties();\n        System.out.println(properties);\n        // 获取系统属性的所有key(属性名),返回set对象\n        Set&lt;String&gt; keys = properties.stringPropertyNames();\n        for (String key : keys) {\n            String value = System.getProperty(key);\n            System.out.println(key+\"---&gt;\"+value);\n        }\n\n    }\n}\n ### System.currentTimeMillis() * System.gc();//内存回收 * System.exit(0);// 程序结束 * System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n *\n *               System.gc();//内存回收\n *               System.exit(0);// 程序结束\n *               System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n \n        System.out.println(\"------------------------------System.currentTimeMillis()-----------------------------------\");\n        long startTime = System.currentTimeMillis();\n\n        int sum=0;\n        for (int i = 0; i &lt; 10000000; i++) {\n            sum+=i;\n        }\n\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"程序运行时间:\"+(endTime-startTime)+\"毫秒\");      \n    }\n}\n\n\n\n          用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n          每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n          应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n          Runtime run = Runtime.getRuntime();\n\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.io.IOException;\n\n/**\n * @author ：fly\n * @description: Runtime类\n *               用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n *               每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n *               应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n *               Runtime run = Runtime.getRuntime();\n *\n *\n * @date ：2021/10/31 15:25\n */\npublic class RuntimeDemo {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Runtime runtime = Runtime.getRuntime();\n        System.out.println(\"处理器个数\" + runtime.availableProcessors()+\"核\");\n        System.out.println(\"空闲内存大小\" + runtime.freeMemory()+\"byte\");\n        System.out.println(\"最大内存大小\" + runtime.maxMemory()+\"byte\");\n        Process process = runtime.exec(\"notepad.exe\");//相当于打开cmd执行命令\n        Thread.sleep(3000);\n        process.destroy();// 3s后进程销毁;\n\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- System类的常用方法, Runtime类/index.html#system类的常用方法",
    "href": "posts/java常用类-- System类的常用方法, Runtime类/index.html#system类的常用方法",
    "title": "java常用类– System类的常用方法, Runtime类",
    "section": "",
    "text": "package cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n        // 获取当前系统属性\n        Properties properties = System.getProperties();\n        System.out.println(properties);\n        // 获取系统属性的所有key(属性名),返回set对象\n        Set&lt;String&gt; keys = properties.stringPropertyNames();\n        for (String key : keys) {\n            String value = System.getProperty(key);\n            System.out.println(key+\"---&gt;\"+value);\n        }\n\n    }\n}\n ### System.currentTimeMillis() * System.gc();//内存回收 * System.exit(0);// 程序结束 * System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * @author ：fly\n * @description: java常用库System\n *               system类定义了一些常用的系统属性和相关方法\n *               获取Jvm版本,国家,操作系统架构,操作系统名......\n *\n *               System.gc();//内存回收\n *               System.exit(0);// 程序结束\n *               System.arraycopy(原数组,目标数组,要复制的起始位置,目标起始位置,复制长度);\n * @date ：2021/10/31 15:01\n */\npublic class SystemDemo {\n    public static void main(String[] args) {\n \n        System.out.println(\"------------------------------System.currentTimeMillis()-----------------------------------\");\n        long startTime = System.currentTimeMillis();\n\n        int sum=0;\n        for (int i = 0; i &lt; 10000000; i++) {\n            sum+=i;\n        }\n\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"程序运行时间:\"+(endTime-startTime)+\"毫秒\");      \n    }\n}\n\n\n\n          用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n          每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n          应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n          Runtime run = Runtime.getRuntime();\n\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.SystemAndRuntime;\n\nimport java.io.IOException;\n\n/**\n * @author ：fly\n * @description: Runtime类\n *               用来表示虚拟机的运行状态,用于封装java虚拟机进程,\n *               每次使用java命令启动java虚拟机都会产生对应的一个Runtime实例,并且只有一个实例\n *               应用程序会通过该实例与运行时的环境相连,应用程序不能创建自己的runtime实例,需要手动创建安\n *               Runtime run = Runtime.getRuntime();\n *\n *\n * @date ：2021/10/31 15:25\n */\npublic class RuntimeDemo {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Runtime runtime = Runtime.getRuntime();\n        System.out.println(\"处理器个数\" + runtime.availableProcessors()+\"核\");\n        System.out.println(\"空闲内存大小\" + runtime.freeMemory()+\"byte\");\n        System.out.println(\"最大内存大小\" + runtime.maxMemory()+\"byte\");\n        Process process = runtime.exec(\"notepad.exe\");//相当于打开cmd执行命令\n        Thread.sleep(3000);\n        process.destroy();// 3s后进程销毁;\n\n    }\n}"
  },
  {
    "objectID": "posts/qt线程问题(耗时操作)/index.html",
    "href": "posts/qt线程问题(耗时操作)/index.html",
    "title": "qt线程问题(耗时操作)",
    "section": "",
    "text": "qt多线程问题: 方法1: qtsignal 启动线程,避免界面卡死 方法2: 使用QApplication.processEvents() 方法3: 使用QThread"
  },
  {
    "objectID": "posts/javaGUI-- 键盘监听/index.html",
    "href": "posts/javaGUI-- 键盘监听/index.html",
    "title": "javaGUI– 键盘监听",
    "section": "",
    "text": "键盘监听 监听按下的按键\npackage cn.usts.edu.lesson03;\n\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class TestKeyPressListener {\n    public static void main(String[] args) {\n        new KeyPressFrame(\"键盘监听\");\n    }\n}\n\n\nclass KeyPressFrame extends Frame{\n    public KeyPressFrame(String title) {\n        super(title);\n        setBounds(100,100,400,200);\n        setVisible(true);\n\n        // 添加键盘监听\n        this.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int keyCode = e.getKeyCode();\n                if (keyCode == KeyEvent.VK_SPACE){\n                    System.out.println(\"按下了空格键\");\n                }\n            }\n        });\n\n    }\n}"
  },
  {
    "objectID": "posts/树莓派开箱点亮(无屏幕)/index.html",
    "href": "posts/树莓派开箱点亮(无屏幕)/index.html",
    "title": "树莓派开箱点亮(无屏幕)",
    "section": "",
    "text": "树莓派4B\n系统下载连接(64bit):https://downloads.raspberrypi.org/raspios_arm64_latest # 解压下载的系统: 得到xxx.img  # 打开写盘工具 win32disk: https://www.onlinedown.net/iopdfbhjl/110173?module=download&t=website 选中解压好的img文件  # 配置wifi信息  ### 进入到boot分区: 右键新建文件: wpa_supplicant.conf\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n \nnetwork={\nssid=\"WIFI名字\"\npsk=\"密码\"\n}\n\n\n配置ssh:(可以使用功能ssh连接树莓派)\n右键ssh文件: ssh # 查看树莓派ip地址: 进入到路由器里面看192.168.0.1或者192.168.1.1(通常)根据品牌而定义 # 使用windows的ssh连接 ****打开cmd**** 输入 ssh pi@树莓派的ip地址\nssh pi@192.168.0.111\n输入密码"
  },
  {
    "objectID": "posts/java注解和反射-- 自定义注解/index.html",
    "href": "posts/java注解和反射-- 自定义注解/index.html",
    "title": "java注解和反射– 自定义注解",
    "section": "",
    "text": "使用@interface自定义注解时,自动继承了java.lang .annotation.Annotation接口\npackage cn.usts.edu.SelfDesignAnnotation;\n\nimport java.lang.annotation.*;\n\n/**\n * 自定义注解\n *      注解参数的使用\n *      类型+ 参数名() default 默认值\n * */\n\npublic class SelfAnnotation {\n\n\n    @Self\n    public void test01(){\n\n    }\n\n    @Self(name = \"test01\", age = 12,sex = \"男\",id = 15,school = {\"试验附中\"})\n    public void test02(){\n\n    }\n\n}\n\n\n@Target(value = ElementType.METHOD) // 注解生效位置,方法上\n@Retention(value = RetentionPolicy.RUNTIME) // 到那个位置还有效果\n@interface Self{\n//    类型   参数名   默认值\n    String name() default \"name1\";\n    int age() default 18;\n    String sex() default \"\";\n    int id() default -1;// 表示不存在\n    String[] school() default {\"清华\",\"北大\"};\n\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 自定义注解/index.html#自定义注解",
    "href": "posts/java注解和反射-- 自定义注解/index.html#自定义注解",
    "title": "java注解和反射– 自定义注解",
    "section": "",
    "text": "使用@interface自定义注解时,自动继承了java.lang .annotation.Annotation接口\npackage cn.usts.edu.SelfDesignAnnotation;\n\nimport java.lang.annotation.*;\n\n/**\n * 自定义注解\n *      注解参数的使用\n *      类型+ 参数名() default 默认值\n * */\n\npublic class SelfAnnotation {\n\n\n    @Self\n    public void test01(){\n\n    }\n\n    @Self(name = \"test01\", age = 12,sex = \"男\",id = 15,school = {\"试验附中\"})\n    public void test02(){\n\n    }\n\n}\n\n\n@Target(value = ElementType.METHOD) // 注解生效位置,方法上\n@Retention(value = RetentionPolicy.RUNTIME) // 到那个位置还有效果\n@interface Self{\n//    类型   参数名   默认值\n    String name() default \"name1\";\n    int age() default 18;\n    String sex() default \"\";\n    int id() default -1;// 表示不存在\n    String[] school() default {\"清华\",\"北大\"};\n\n}"
  },
  {
    "objectID": "posts/c++基础/index.html",
    "href": "posts/c++基础/index.html",
    "title": "c++基础",
    "section": "",
    "text": "输出\nhelloworld\ncout&lt;&lt; \"hello world\" &lt;&lt; endl;\n\n\n头文件\ndeclaration(.h) 和 definition(.cpp)任何的类都应该成对出现 \ncpp 02test.cpp # c预处理器\ng++ 02test.cpp --save-temp #保留编译过程中的中间过程文件\n.ii (编译预处理后的结果)\n.s(汇编代码)\n.o(目标代码)\n.out(最终可执行程序)\n\ng++ 02test.cpp --save -c # 只编译不链接\ng++ 02test.cpp --save-temps # 保留编译过程中的 .o 文件(给人看的)\ng++ 02test.cpp 03test.cpp --save-temps -Wall # 打印所有warning\n\n\n标准头文件程序:\n为了一个头文件(xxx.h)只能被一次引入,不能重复的引入\n#ifndef __LIST_HEAD__\n#define __LIST_HEAD__\n\n#include \"node.h\"\n\ntypedef struct _list\n{\n    Node *head;\n    Node *tail;\n} List;\n\n#endif\n\n\n双冒号作用域运算符\nusing namespace std; # 这里很关键否则cot,endl无法使用\nint a=10;\nvoid h(){\n    int a=20;\n    cout &lt;&lt; a &lt;&lt; endl; # 20\n    cout &lt;&lt; ::a&lt;&lt; endl;  # 10\n}\n有点类似匿名函数,匿名内部类的感觉\nvoid h(){\n    int a=20;\n    std::cout &lt;&lt; a &lt;&lt; std::endl; # 20 这里就不用using namespace std了\n    std::cout &lt;&lt; ::a&lt;&lt; std::endl;  # 10\n}\n\n\n地址输出\nint a = 0;\nconst char * p = \"hello\";\ncout &lt;&lt; \"变量a的地址: \" &lt;&lt; &a &lt;&lt; endl;                           // 变量a的地址\ncout &lt;&lt; \"变量a的地址: \" &lt;&lt; static_cast&lt;void *&gt;(&a) &lt;&lt; endl;      // 变量a的地址\ncout &lt;&lt; \"字符串 \" &lt;&lt; p &lt;&lt; endl;                                 // 字符串内容,即\"hello\"\ncout &lt;&lt; \"字符串的地址 \" &lt;&lt; static_cast&lt;const void *&gt;(p) &lt;&lt; endl; // 字符串的地址\n\n\n本地变量,成员变量\n参考地址:https://blog.csdn.net/smile_from_2015/article/details/50189797 参考地址:https://blog.csdn.net/du_minchao/article/details/48881637\n成员变量(实例变量) 成员变量随着对象的建立而建立，随着对象的消失而消失，在类中可以随意使用 (实例化对象后会有成员变量)\n本地变量(局部变量) 在方法体中任何位置都可以访问\n本地变量: 成员变量:可以在函数中随意访问.\ng++ -m32 a.cpp // 32位系统\n相同的类(对象)使用同一个function,同一个类 不同的对象调用同一个函数时,函数里面知道是哪个对象在调用他 ( 实现的方式*this隐藏的变量 )\n#include \"iostream\"\nusing namespace std;\n\n\nclass A{\n    public:\n        int i;\n        void f();\n};\n\nstruct B{\n    int i;\n};\n\n\nvoid A::f(){\n    i=20;\n    cout &lt;&lt; i &lt;&lt; endl;\n    cout &lt;&lt; \"A::f().i\" &lt;&lt; static_cast&lt;void *&gt;(&i) &lt;&lt; endl;\n    cout &lt;&lt; \"this\" &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; endl;\n}\n\nvoid f(struct B* p){\n    p-&gt;i=200;\n    cout &lt;&lt; p-&gt;i &lt;&lt; endl;\n\n}\n\nint main(){\n    A a;\n    B b;\n    A aa;\n    a.i = 10;\n    cout &lt;&lt; a.i &lt;&lt; endl;\n    cout &lt;&lt; \"&a  \\t\" &lt;&lt; static_cast&lt;void *&gt;(&a)&lt;&lt;endl;\n    cout &lt;&lt; \"&a.i\\t\"  &lt;&lt; static_cast&lt;void *&gt;(&a.i) &lt;&lt; endl;\n    //  cout &lt;&lt; b.i &lt;&lt; endl;\n    a.f();\n    aa.f();\n    f(&b);\n}\n\n\n构造函数constructor\n为什么要有构造函数\n# 因为c语言和其他的语言(java,python)不太一样,c++自己不会对内存初始化,为了提升效率,让程序员自己去初始化内存,\n\n# vsStudio的debug模式会填充0xcb,两个0xcb连起来(国标码)就会显示中文的烫,就以为着没有初始化的内存\n\n# 为了规范程序员的代码,然程序员去初始化内存,于是就出来了constructor就应需而生.\n构造函数, 没有返回类型,在这个对象被创建的时候自动被调用\nclass x {\n    int i;\n    public:\n        X(); // 这里的名字要和class的名字一样(大小写也一致)\n};   // 这里的这个 ; 很重要\n构造函数demo\n#include \"iostream\"\n\nusing namespace::std;\n\nclass Tree{\n    public:\n        Tree(int length);\n        int init_length;\n};\n\nTree::Tree(int length){\n    init_length = length;\n    cout &lt;&lt; \"inside Tree structor\" &lt;&lt; endl;\n} \n\nint main(){\n    cout &lt;&lt; \" ------stat----\" &lt;&lt; endl;\n    { // scope start\n        cout &lt;&lt; \"create Tree before\" &lt;&lt; endl;\n        Tree t(12);\n        cout &lt;&lt; \"create Tree after\" &lt;&lt; endl; \n    }// scope end\n    cout &lt;&lt; \" ----- end ----\" &lt;&lt; endl; \n    return 0;\n}\n\n\n\n析构函数\n释放掉之前构造函数申请的内存空间析构函数没有参数\nclass x {\n    int i;\n    public:\n        ~X(); \n};   \n析构函数demo\n#include \"iostream\"\n\nusing namespace::std;\n\nclass Tree{\n    public:\n        Tree(int length);\n        int init_length;\n        ~Tree();// 析构函数 Destructor\n\n};\n\nTree::Tree(int length){\n    init_length = length;\n    cout &lt;&lt; \"inside Tree structor\" &lt;&lt; endl;\n} \n\nTree::~Tree(){\n    cout &lt;&lt; static_cast&lt;void *&gt;(this) &lt;&lt; endl;\n}\n\nint main(){\n    cout &lt;&lt; \" ------stat----\" &lt;&lt; endl;\n    {\n    Tree t(12);\n    } // 析构函数的作用域scope,出了这个大括号就会调用析构函数.\n    cout &lt;&lt; \"create Tree after\" &lt;&lt; endl; \n    cout &lt;&lt; \" ----- end ----\" &lt;&lt; endl; \n    return 0;\n}\n\n\n\n动态内存分配\nc语言的动态内存分配是 malloc 和 free 在c++中采用的是: new(生成对象)和delete(回收对象)\n\nnew\n1.分配空间 2.调用构造函数(自定义类) 3.返回一个地址()\nnew int # new Type 分配一个type类型的空间出来\nnew Class  # new Class 分配一个对象给出来. \nnew int[10] # new Type[n] 分配n个type空间出来\n\n\ndelete\n把内存还给内存池. delete的时候先调用析构函数,然后内存空间才会被回收.\ndelete p; # 回收单个内存\ndelete[] p; # 回收一组内存\ndelete demo\n要点: 1: 不要用delete去释放不是 new 分配出来的内存 2: 不要delete同一个空间两次 3: delete 可以安全的删除一个空指针(int * p = 0;) 4: 数组的时候一定要用数组[]类型delete\n#include \"iostream\"\n\nusing namespace::std;\n\nclass A{\n\n    private:\n        int i;\n    public:\n        //int i;\n        A(){\n            cout &lt;&lt; \"A::A()\" &lt;&lt; endl;\n        }\n        ~A(){\n            cout &lt;&lt; \"~A\" &lt;&lt; i &lt;&lt; endl;\n        }\n        void set(int i){\n            this-&gt;i=i;\n        }\n        void f(){\n           cout &lt;&lt; \"hello\" &lt;&lt; endl; \n        }\n};\n\n\nint main(){\n    A* p = new A[10];\n    for (int i=0;i&lt;10;i++){\n        p[i].set(i);\n    }\n    delete[] p;// 释放内存\n    return 0;\n}\n\n\n\n访问限制\npublic：公开的,任何人都可以访问； protected：子孙类可以访问； private：只有自己可以访问。)(同一个类之内可以访问,成员函数…) friend : 可以互相访问 这个限制只有在编译阶段有效, 运行时刻没有限制 代码有点烂,不具备参考\n#include \"iostream\"\n\nusing namespace::std;\n\nclass A{\n\n    private:\n        int i;\n    public:\n        //int i;\n        A(){\n            cout &lt;&lt; \"A::A()\" &lt;&lt; endl;\n        }\n        ~A(){\n            cout &lt;&lt; \"~A\" &lt;&lt; i &lt;&lt; endl;\n        }\n        void set(int i){\n            this-&gt;i=i;\n        }\n        void f(){\n           cout &lt;&lt; \"hello\" &lt;&lt; endl; \n        }\n        void g(A* p2){\n            cout &lt;&lt; \"p2-&gt;i is :\"  &lt;&lt; p2-&gt;i &lt;&lt; endl;\n        }\n\n};\n\n\nint main(){\n    A* p = new A[10];\n    for (int i=0;i&lt;10;i++){\n        p[i].set(i);\n        p[i].g(&p[i]);\n    }\n    \n\n    delete[] p;// \n    return 0;\n}\nfriend demo\n#include \"iostream\"\n\nusing namespace::std;\n\n\nstruct A;\n\nstruct B{\n    void f(A*);\n};\n\n\nstruct A{\n    private:\n        int i;\n    public:\n        void hello();\n        friend void g(A*, int);\n        friend void B::f(A*);\n        friend struct Z;\n        friend void h();\n};\n\nvoid A::hello(){\n    i=100;\n    cout &lt;&lt; \"成员访问变量:\" &lt;&lt;  i &lt;&lt; endl;\n}\n\nvoid g(A* a, int i){\n    a-&gt;i = i;\n    cout &lt;&lt; \"friend 方法访问:\" &lt;&lt; i  &lt;&lt; endl;\n}\n\nvoid B::f(A* a){\n    a-&gt;i=999;\n    cout &lt;&lt; \"B中函数修改A中i: \"&lt;&lt; a-&gt;i&lt;&lt; endl;\n}\n\nstruct Z{\n    private:\n        int j;\n};\n\nvoid h(){\n    cout &lt;&lt;\"hello\" &lt;&lt;endl;\n}\n\n\nint main(){\n    A a;\n    a.hello();\n    A a;\n    a.hello();\n    \n    return 0;\n}\n\n\nclass和struct的区别\nclass默认的是private struct默认是public # 初始化列表(推荐) 初始化列表不要被名字唬住,其实就是是相当于在初始化之前给了一个默认值,赋值的过程提到了构造器之前.格式: Class(): key(value) 推荐类在初始化列表中做初始化,不要要构造器中做赋值\n#include \"iostream\"\n\nusing namespace::std;\n\n\nclass Student{\n    public:\n        int age;\n        string name;\n        Student():age(12),name(\"tom\"){};\n};\n\n\nint main(){\n    Student a;\n    cout &lt;&lt; a.name &lt;&lt; endl;\n    cout &lt;&lt; a.age &lt;&lt; endl;\n    return 0;\n}\n\n\n\n组合和继承\n组合是对象进行拼装,是存在对象的 继承是类进行拼装,是没有真实的存在的 c++中的组合适类的组合,不是对象的组合 ### interface 对外公开的部分(public) ### 继承 继承可以访问继承的成员变量,成员方法,interface(就是member data,member function中public的部分)\n子类可以使用父类的所有内容(但是在实例化的时候就不可以了,实例化的时候只可以访问public的部分!!!!!) protected属性表示只可以子类访问,其他的类都不行(测试实例化的对象可不可以) private 子类可以访问,但是实例化对象不可以. public 谁都可以访问.\n#include\"iostream\"\n\nusing namespace std;\n\n\nclass Person{\n    public:\n        string name;\n        void work(){\n            cout &lt;&lt; \"work......\"  &lt;&lt; name &lt;&lt; endl;\n        }\n        Person():name(\"tom\"){};\n        ~Person(){ cout &lt;&lt; \"~person\" &lt;&lt; endl;};\n    \n    private:\n        int age=10;\n        void wash_clothes(){\n            cout &lt;&lt; \"wash clothes\" &lt;&lt; endl;\n        } \n    \n    protected:\n        string book=\"TomAndJerry\";\n        void use_note(){\n            cout &lt;&lt; \"use note\" &lt;&lt; endl;\n        }\n};\n\nclass Parent :public Person{\n    string self_book;\n\n    public:\n    void hello(){\n        self_book = Person::book;// child class can use prarent class protected data;\n        cout &lt;&lt; self_book &lt;&lt; endl;\n    }\n    void self_wash(){\n        //Person::wash_clothes();// protected can not use anywhere \n    }\n};\n\n\nint main(){\n    Parent father;\n    cout &lt;&lt; father.name &lt;&lt;endl;\n    father.work();// because is public\n    father.hello();\n    //father.self_book;// protected can be used by class not entertiy\n    //father.age;// can not be use the reason is not public\n     \n    return 0;\n}\n\n\n\n函数重载(function overload)\n相同的函数名,接受不同的参数\nvoid hello(){};\nvoid hello(string name){};\nvoid hello(int age){};\nvoid hello(int age,float weight){};\nvoid hello(float height,float wieight){};\n...\n\n\n默认参数(default arguement)\n虽然方便但是不推荐,因为在后期调用的时候只能看到赋值一个参数,容易误解 默认参数要写到.h文件中 a.h\nvoid hello(int i; int j=10);\na.cpp\n#include \"a.h\"\n#include \"iostream\"\n\nusing namespace std;\n\nvoid hello(int i,int j){\n    cout &lt;&lt; i &lt;&lt; \"|\" &lt;&lt; j &lt;&lt; endl;            \n}\n\nint main(){\n    hello(999);\n    return 0;\n}\n\n\n内联函数(inline function)\n空间换时间 类型校验 递归问题,函数代码超过20行 函数构造的的时候直接写操作,默认是inline 的 ### 什么时候inline 代码很少 2~3行 频繁调用(循环中)  ### class的inline写法:  # static\n// main 函数运行完才会释放\nstatic int a=0;\n// 函数执行完就会释放\nvoid func(){\n    int a = 0;\n}\n\n\ndefine\n\ndefine和const的区别\nconst可以进行类型检查\ncosnt int A  200;\ndefine是完全的替换\n#define A 100;\n\n\n\nconst\nconst 常量,不可以修改.\nconst double PI=3.1415926\n\n// not allow\nPI++;\nextern表示这是一个声明而不是一个定义. (有但是不知道是多少,相当于匿名) 告诉编译器说,你可以放心大胆的用,后边我会给你提供值得的 ### 问题 初始化的的时候一定要给具体的值,不可以用extern\nextern const int buffersize;\n\nconst pointer / pointer const\n对象是const: 对象不可以修改.指针可以修改\n#include\"iostream\"\n\nusing namespace std;\n\nclass A{\n    public:\n    int age=19;\n};\n\nint main(){\n    A a;\n    A a2;\n    const A* p1=&a;\n    cout &lt;&lt; p1-&gt;age=10 &lt;&lt;endl;// error!!!!\n    p1++;//not error!!!!\n    return 0;\n}\n指针是const: 指针不可以修改(不可以p++)但是可以通过不同的指针\n#include\"iostream\"\n\nusing namespace std;\n\nclass A{\n    public:\n    int age=19;\n};\n\nint main(){\n    A a;\n    A a2;\n    A* const p1=&a;\n    cout &lt;&lt; p1-&gt;age &lt;&lt;endl;\n    p1++; // error!!!!!\n    return 0;\n}\nPerson p1(\"tom\",18);\n\nconst Person* p = &p1; // 对象是const不可以修改\nPerson const* p = &p1; // 对象是const不可以修改\nPerson *const p = &p1; // 指针是const不可以修改\nconst Person *const p  = &p1; // 都不可以修改\nconst写在 * 的前面对象是const 表示指向的那块内存是const,不能通过这个指针修改所指的对象. const写在 * 的后面指针是const 表示指针的地址是const ### 字符类型是放在全局数据区里面的\nvoid hello() const; // 表示这个const加在this上\nvoid hello(cosnt *A this){};\n\nvoid hello(); // 这两个方法构成了重载.\nvoid hello(*A this){};\n\n\n\n引用\n#include&lt;iostream&gt;\n\nint main(){\n    int a = 100;\n    int& b = a; // b的vule就是a的value\n    std::cout&lt;&lt; b &lt;&lt;std::endl;\n    \n    return 0;\n}\n\n\n文件保存\n#include &lt;iostream&gt;\n#include&lt;fstream&gt;\n\nstd::ofstream fileSteam;\nint data = 100;\n\nfileSteam.open(\"D:test.txt\")\n\nfileSteam &lt;&lt; data &lt;&lt; std::endl;\nfileSteam.close()\n\n\n文件读取(按行)\n文件读取参考\n#include &lt;iostream&gt;\n#include&lt;fstream&gt;\n\nint main(){\n    std::string read_data;\n    std::ifstream inFile(\"./readme\",std::ios::in);\n        while(std::getline(inFile,read_data)){\n            std::cout &lt;&lt; read_data &lt;&lt; std::endl;\n        }\n    inFile.close();        \n  return 0;\n}"
  },
  {
    "objectID": "posts/TI_dsp入门-ti c660/index.html",
    "href": "posts/TI_dsp入门-ti c660/index.html",
    "title": "TI_dsp入门-ti c660",
    "section": "",
    "text": "dps分类: 都可以进行浮点数的预算 定点 : 无法使用硬件加速, 软件模拟, 性能消耗, 开发耗时(q格式) 浮点 :"
  },
  {
    "objectID": "posts/vs打包qt程序/index.html",
    "href": "posts/vs打包qt程序/index.html",
    "title": "vs打包qt程序",
    "section": "",
    "text": "把vs切换到Release模式,编译程序  # 进入到项目的Release文件夹中把*.exe文件拷贝出来  # 进入到新建的空文件夹package_demo把.exe文件复制进去.  # 打开qt的MSVC编译器(编译成windows平台的可执行程序) 用windows自带的应用搜索功能搜索即可, 版本号根据所装版本而定 这里用32位的,方便在32和64位机器上运行.因为64位机器是兼容32机器的,方便在两个系统运行  # 进入到exe所在文件夹,执行以下命令\nwindeployqt *.exe\n\n\n\n在这里插入图片描述\n\n\nwindeployqt VitalSignsRadar_Demo.exe\n 执行完效果:   # 到这里在开发环境是运行是没有问题的 打包的目的是为了在用户的环境上使用,所以我们要把开发环境下qt之外的包也打包进来 这里用EnigmaVirtualBox打包额外的需要的包 \n  # 点击 添加 -&gt; 添加文件夹递归"
  },
  {
    "objectID": "posts/sapmle_rate/index.html",
    "href": "posts/sapmle_rate/index.html",
    "title": "sample rate how to set",
    "section": "",
    "text": "Abstract\nsample rate how to set and set it reaseon.\n\n\nReferance\nbilibi:爱用显微镜看世界 频域信号绘制\n\n\n名词\n\n采样频率\n\n\n采样频率（sampling rate）表示一秒内对信号进行的采样次数，单位是赫兹（Hz）。如果采样频率越高，就代表采样的次数越多，信号的分辨率就越高。\n\n\n采样点数\n\n\n采样点数（number of samples）表示对信号进行的采样次数，它与采样频率关系密切，因为采样点数就等于采样时间 × 采样频率。\n采样分辨率取决于采样频率和采样点数，通常使用采样频率作为指标。在数字信号处理中，一般要求采样频率大于信号最高频率的两倍，这是为了保证采样完整地反映了信号的特征。\n\n\n\n采样点数和采样率的关系\nclose all       % 关闭所有窗口.\nfs = 10;        % 采样频率 10hz 表示, 将1秒分成10份, 采样率越高时间越,曲线越平滑[这里10个点, 不知道为什么会多一个]\nt = 1;          % 1秒, 表示采样时间1秒,这样1s就采样10个点 这样采样的时间就越长,信号的周期也越多\nts = 0:1/fs:t;  % 时间矢量(采样点数),将10s的时间按照采样率平均分, 那就是每次0.1时间步进.\n\nf0=1;           % 信号的频率, 1hz表示在1秒中内可以有1个周期变化, 但是根据采样率,所能分辨的频率和采样率有关,如果采样率没有\nplot(sin(2*pi*f0*ts));\n10hz 采样频率采样 1hz 的信号.\n\n这样看起来是没有问题的, 但是我们把信号调整为 2hz, 采样率不变.如下图, 好像看起来没有太大问题.\n\nclose all\nfs = 10;\nt = 1;\nts = 0:1/fs:t;\n\nf0=2;              % &lt;------------\nplot(sin(2*pi*f0*ts));\n3hz 的信号呢?\nclose all\nfs = 10;\nt = 1;\nts = 0:1/fs:t;\n\nf0=3;\nplot(sin(2*pi*f0*ts));\n 好像有点不对劲了 \n\n5hz 呢?\nclose all\nfs = 10;\nt = 1;\nts = 0:1/fs:t;\n\nf0=5;\nplot(sin(2*pi*f0*ts));\n彻底不对劲了, 怎么少了一个(应该说是无法分辨了), 好像奈奎斯特还真有点道理了 \n\n所以采样大于 2 倍还是有道理的, 但是遇到问题就要解决问题, 该怎么解决这个问题呢.\n增加采样点数哇, 增加采样点数有两种方法.\n\n增减采样频率.(增减采样频率那肯定时硬件升级了, 经费燃起来了.)\n增加采样时间.(经费差了点, 时间不差事.) 还是需要根据具体应用来\n\n 我选择先上寿元(拉长采样时间)\nclose all\nfs = 10;\nt = 2;       % &lt;----------------\nts = 0:1/fs:t;\n\nf0=5;\nplot(sin(2*pi*f0*ts));\n大意了, 寿元白烧了(时间拉长增加采样点无效[此实验]). \n增加采样率试试, 这有点香."
  },
  {
    "objectID": "posts/应用视觉设计/index.html",
    "href": "posts/应用视觉设计/index.html",
    "title": "应用视觉设计",
    "section": "",
    "text": "这部分课程主要关于应用视觉设计。开始的挑战展示了一些核心的原则，代码基于一个指定的卡片布局。\nweb 内容大部分都是文本。CSS 里面的text-align属性可以控制文本的对齐方式。\ntext-align: justify;可以让除最后一行之外的文字两端对齐，即每行的左右两端都紧贴行的边缘。\ntext-align: center;可以让文本居中对齐。\ntext-align: right;可以让文本右对齐。\ntext-align: left;是text-align的默认值，它可以让文本左对齐"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-text-align-属性创建视觉平衡",
    "href": "posts/应用视觉设计/index.html#使用-text-align-属性创建视觉平衡",
    "title": "应用视觉设计",
    "section": "",
    "text": "这部分课程主要关于应用视觉设计。开始的挑战展示了一些核心的原则，代码基于一个指定的卡片布局。\nweb 内容大部分都是文本。CSS 里面的text-align属性可以控制文本的对齐方式。\ntext-align: justify;可以让除最后一行之外的文字两端对齐，即每行的左右两端都紧贴行的边缘。\ntext-align: center;可以让文本居中对齐。\ntext-align: right;可以让文本右对齐。\ntext-align: left;是text-align的默认值，它可以让文本左对齐"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-width-属性调整元素的宽度",
    "href": "posts/应用视觉设计/index.html#使用-width-属性调整元素的宽度",
    "title": "应用视觉设计",
    "section": "使用 width 属性调整元素的宽度",
    "text": "使用 width 属性调整元素的宽度\n你可以使用 CSS 里面的width属性来指定元素的宽度。属性值可以是相对单位（比如 em），绝对单位（比如 px），或者包含块（父元素）宽度的百分比。下面这个例子把图片的宽度设置为 220px：\nimg { width: 220px; } ## 使用 height 属性调整元素的高度 和width属性类似，你可以使用 CSS 里面的height属性来指定元素的高度。下面这个例子把图片的高度设置为 20px：\nimg { height: 20px; }"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-strong-标签加粗文本",
    "href": "posts/应用视觉设计/index.html#使用-strong-标签加粗文本",
    "title": "应用视觉设计",
    "section": "使用 strong 标签加粗文本",
    "text": "使用 strong 标签加粗文本\n术语：Strong =&gt; s =&gt; 加粗。\n你可以使用strong标签来加粗文字。添加了strong标签后，浏览器会自动给元素应用font-weight:bold;。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-u-标签给文本添加下划线",
    "href": "posts/应用视觉设计/index.html#使用-u-标签给文本添加下划线",
    "title": "应用视觉设计",
    "section": "使用 u 标签给文本添加下划线",
    "text": "使用 u 标签给文本添加下划线\n术语：Underline =&gt; u =&gt; 下划线。\n你可以使用u标签来给文字添加下划线。添加了u标签后，浏览器会自动给元素应用text-decoration: underline;。 ## 使用 em 标签强调文本 术语：emphasis =&gt; em =&gt; 强调。\n你可以使用em标签来强调文本。由于浏览器会自动给元素应用font-style: italic;，所以文本会显示为斜体 ## 使用 s 标签给文本添加删除线 术语：Strikethrough =&gt; s =&gt; 删除线。\n你可以用s标签来给文字添加删除线，我是明晃晃的删除线，它代表着这段文字不再有效。添加了s标签后，浏览器会自动给元素应用text-decoration: line-through;。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-hr-标签创建水平线",
    "href": "posts/应用视觉设计/index.html#使用-hr-标签创建水平线",
    "title": "应用视觉设计",
    "section": "使用 hr 标签创建水平线",
    "text": "使用 hr 标签创建水平线\n术语：Horizontal Rule =&gt; hr =&gt; 水平线。\n你可以用hr标签来创建一条宽度撑满父元素的水平线。它一般用来表示文档主题的改变，在视觉上将文档分隔成几个部分 ## 调整文本的背景色 为了让页面更美观，除了设置整个页面的背景色以及文字颜色外，你还可以单独设置文字的背景色，即在文字的父元素上添加background-color属性。在本挑战里我们将使用rgba()颜色，而不是之前学到的hex编码或者rgb()颜色。\nrgba 代表： r = red 红色 g = green 绿色 b = blue 蓝色 a = alpha 透明度 RGB 值可以在 0 到 255 之间。alpha 值可以在 0 到 1 之间，其中 0 代表完全透明，1 代表完全不透明。rgba()非常棒，因为你可以设置颜色的透明度，这意味着你可以做出一些很漂亮的半透明效果。 ## 调整标题与段落的大小 标题（h1到h6）的文字应该比的段落的文字大，这样可以让用户更直观的看到页面的布局，同时能区别出不同元素的重要程度，更方便用户捕捉关键的信息。你可以使用font-size属性来设置元素内文字的大小。 ## 给卡片元素添加 box-shadow box-shadow属性用来给元素添加阴影，该属性值是由逗号分隔的一个或多个阴影列表。\nbox-shadow属性的每个阴影依次由下面这些值描述： offset-x阴影的水平偏移量； offset-y阴影的垂直偏移量; blur-radius模糊距离； spread-radius阴影尺寸； 颜色。 其中blur-raduis和spread-raduis是可选的。\n下面是创建了多个阴影的 CSS 例子，阴影加了模糊效果，颜色是透明度很高的黑色:\nbox-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); ## 降低元素的 opactiy CSS 里的opacity属性用来设置元素的透明度。\n值 1 代表完全不透明。 值 0.5 代表半透明。 值 0 代表完全透明。 透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-text-transform-属性给文本添加大写效果",
    "href": "posts/应用视觉设计/index.html#使用-text-transform-属性给文本添加大写效果",
    "title": "应用视觉设计",
    "section": "使用 text-transform 属性给文本添加大写效果",
    "text": "使用 text-transform 属性给文本添加大写效果\nCSS 里面的text-transform属性来改变英文中字母的大小写。它通常用来统一页面里英文的显示，且无需直接改变 HTML 元素中的文本。\n下面的表格展示了text-transform的不同值对文字 “Transform me” 的影响。  ## 设置多个标题元素的 font-size 在上一个挑战里你已经设置了每个标题的font-size，接下来你将设置font-weight。\nfont-weight属性用于设置文本中所用的字体的粗细。 ## 设置段落文本的 font-size CSS 里面的font-size属性不只限于标题，它可以应用于任何包含文字的元素内。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#设置段落的-line-height",
    "href": "posts/应用视觉设计/index.html#设置段落的-line-height",
    "title": "应用视觉设计",
    "section": "设置段落的 line-height",
    "text": "设置段落的 line-height\nCSS 提供line-height属性来设置行间的距离。行高，顾名思义，用来设置每行文字所占据的垂直空间。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#调整锚点的悬停状态",
    "href": "posts/应用视觉设计/index.html#调整锚点的悬停状态",
    "title": "应用视觉设计",
    "section": "调整锚点的悬停状态",
    "text": "调整锚点的悬停状态\n本挑战将要涉及到伪类。伪类是可以添加到选择器上的关键字，用来选择元素的指定状态。\n比如，超链接可以使用:hover伪类选择器定义它的悬停状态样式。下面是悬停超链接时改变超链接颜色的 CSS：\na:hover { color: red; } ## 更改元素的相对位置 在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了 position 属性来覆盖它。\n当元素的 position 设置为relative时，它允许你通过 CSS 指定该元素在当前普通流页面下的相对偏移量。 CSS 里控制各个方向偏移量的对应的属性是left、right、top和bottom。它们代表着从原来的位置向对应的方向偏移指定的像素、百分比或者 ems。下面的例子展示了段落向上偏移 10 像素：\np { position: relative; bottom: 10px; } 把元素的 position 设置成 relative 并不会改变该元素在普通流布局所占的位置，也不会对其它元素的位置产生影响。\n注意 定位可以让你在页面布局上更灵活、高效。注意不管元素的定位是怎样，内部的 HTML 代码阅读起来应该是整洁、有意义的。这样也可以让视障人员（他们重度依赖辅助设备比如屏幕阅读软件）能够浏览你的网页。 ## 使用 CSS 偏移移动相对定位的元素 CSS 里面的top、bottom、left和right定义了元素在相应方位的偏移距离。元素将从当前位置，向属性相反的方向偏移。就像你在上一个挑战看到的，top属性使h2向下移动。left属性使元素向右移动。 h2 { position: relative;\n}\n## 绝对定位的参照物是元素的父元素\n接下来要介绍 CSSposition属性的取值选项absolute，absolute相对于其包含块定位。和relative定位不一样，absolute定位会将元素从当前的文档流里面移除，周围的元素会忽略它。可以用 CSS 的 top、bottom、left 和 right 属性来调整元素的位置。\nabsolute定位比较特殊的一点是元素的定位参照于最近的已定位祖先元素。如果它的父元素没有添加定位规则（默认是position:relative;）,浏览器会继续寻找直到默认的 body 标签。 ## 固定定位的参照物是浏览器的窗口 接下来要介绍的是fixed定位，它是一种特殊的绝对（absolute）定位，区别是其包含块是浏览器窗口。和绝对定位类似，fixed定位使用 top、bottom、left 和 right 属性来调整元素的位置，并且会将元素从当前的文档流里面移除，其它元素会忽略它的存在。\nfixed定位和absolute定位的最明显的区别是fixed定位元素不会随着屏幕滚动而移动。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-float-属性将元素左浮动或右浮动",
    "href": "posts/应用视觉设计/index.html#使用-float-属性将元素左浮动或右浮动",
    "title": "应用视觉设计",
    "section": "使用 float 属性将元素左浮动或右浮动",
    "text": "使用 float 属性将元素左浮动或右浮动\n接下来要介绍的定位机制并不是position属性的选项，它通过元素的float属性来设置。浮动元素不在文档流中，它向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。通常需要用width属性来指定浮动元素占据的水平空间。 ## 使用 z-index 属性更改重叠元素的位置 当一些元素重叠时，在 HTML 里后出现的元素会默认显示在更早出现的元素的上面。你可以使用z-index属性指定元素的堆叠次序。z-index的取值是整数，数值大的元素优先于数值小的元素显示。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-margin-属性将元素水平居中",
    "href": "posts/应用视觉设计/index.html#使用-margin-属性将元素水平居中",
    "title": "应用视觉设计",
    "section": "使用 margin 属性将元素水平居中",
    "text": "使用 margin 属性将元素水平居中\n在应用设计中经常需要把一个块级元素水平居中显示。一种常见的实现方式是把块级元素的margin值设置为auto。\n同样的，这个方法也对图片奏效。图片默认是内联元素，但是可以通过设置其display属性为block来把它变成块级元素。 ## 了解互补色 色彩理论以及设计色彩学很复杂，这里将只涉及很基础的部分。在网站设计里，颜色能让内容更醒目，能调动情绪，从而创造舒适的视觉体验。不同的颜色组合对网站的视觉效果影响很大，精妙的设计都需要适宜的颜色来美化页面内容。\n一半是科学，一半是艺术，色环是我们认识颜色关系的好工具 - 它是一个近色相邻异色相离的圆环。当两个颜色恰好在色环的两端时，这两个颜色叫做补色。绘画中两只补色在混合后会变成灰色。补色搭配能形成强列的对比效果，传达出活力、能量、兴奋等意义。\n下面是一些十六进制码（hex code）补色的例子：\n红色（#FF0000）和蓝绿色 (#00FFFF) 绿色（#00FF00）和品红色（#FF00FF） 蓝色（#0000FF）和黄色（#FFFF00） 现在很多的在线选色工具都有寻找补色的功能。\n注意 对于所有的颜色关卡： 颜色能吸引用户的注意，但不是唯一的方式，切勿喧宾夺主，过度使用会适得其反。详细会在应用无障碍章节介绍。 ## 了解三原色 电脑显示器和手机屏幕是一种加色模型，将红（R）、绿（G）、蓝（B）三原色的色光以不同的比例相加，以产生多种多样的色光。两种原色相加产生二次色：蓝绿（G+B）、品红（R+B）和黄色（R+G）。你在上一个挑战里已经见过这些颜色了。这些二次色恰好是在合成它们时未使用的原色的补色，即在色环中位于两端。例如，品红色是红色和蓝色相加产生，它是绿色的补色。\n三次色是由原色和二次色相加产生的颜色，例如红色（原色）和黄色（二次色）相加产生橙色。将这六种颜色中相邻的颜色相加，便产生了十二色色环。\n设计里面有很多种颜色搭配方法。涉及到三次色的一种配色方法是分裂补色搭配法。选定主色之后，在色环上选择与它的补色相邻的两种颜色与之搭配。此种搭配既有对比，又不失和谐。\n下面是使用分裂补色搭配法创建的三个颜色：\n ## 将各种元素的颜色调整为互补色 通过前面关卡的学习，我们知道了补色搭配能形成强列的对比效果，让内容更富生机。但是如果使用不当效果会适得其反，比如如果文字背景色和文字颜色互为补色，文字会很难看清。通常的做法是，一种颜色做为主要颜色，其补色用来装点页面 ## 调整颜色的色相 HSL 色彩空间模型是一种将 RGB 色彩模型中的点放在圆柱坐标系中的表示法，描述了色相（hue）、饱和度（saturation）、亮度（lightness）。CSS3 引入了对应的hsl()属性做为对应的颜色描述方式。\n色相是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。以颜色光谱为例，光谱左边从红色开始，移动到中间的绿色，一直到右边的蓝色，色相值就是沿着这条线的取值。在hsl()里面，色相用色环来代替光谱，色相值就是色环里面的颜色对应的从 0 到 360 度的角度值。\n饱和度是指色彩的纯度，也就是颜色里灰色的占比，越高色彩越纯，低则逐渐变灰，取0-100%的数值。\n亮度决定颜色的明暗程度，也就是颜色里白色或者黑色的占比，100% 亮度是白色， 0% 亮度是黑色，而 50% 亮度是“一般的”。\n下面是一些使用hsl()描述颜色的例子，颜色都为满饱和度，中等亮度:  ## 调整颜色的色调 hsl()使 CSS 更改色调更方便。给纯色添加白色可以创造更浅的色调，添加黑色可以创造更深的色调。另外，还可以通过给纯色添加灰色来同时改变颜色的深浅和明暗。回忆下hsl()里面的‘s’和‘l’分辨代表饱和度和亮度。饱和度代表灰色的占比，亮度代表白色和黑色的占比。这在当你有了一个基色调却需要微调时非常有用。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#创建一个-css-线性渐变",
    "href": "posts/应用视觉设计/index.html#创建一个-css-线性渐变",
    "title": "应用视觉设计",
    "section": "创建一个 CSS 线性渐变",
    "text": "创建一个 CSS 线性渐变\nHTML 元素的背景色并不局限于单色。CSS 还提供了颜色过渡，也就是渐变。可以通过background里面的linear-gradient()来实现线性渐变，下面是它的语法：\nbackground: linear-gradient(gradient_direction, 颜色 1, 颜色 2, 颜色 3, …);\n第一个参数指定了颜色过渡的方向 - 它的值是角度，90deg 代表垂直渐变，45deg 的渐变角度和反斜杠方向差不多。剩下的参数指定了渐变颜色的顺序：\n例子：\nbackground: linear-gradient(90deg, red, yellow, rgb(204, 204, 255));"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-css-线性渐变创建条纹元素",
    "href": "posts/应用视觉设计/index.html#使用-css-线性渐变创建条纹元素",
    "title": "应用视觉设计",
    "section": "使用 CSS 线性渐变创建条纹元素",
    "text": "使用 CSS 线性渐变创建条纹元素\nrepeating-linear-gradient()函数和linear-gradient()很像，主要区别是repeating-linear-gradient()重复指定的渐变。 repeating-linear-gradient()有很多参数，为了便于理解，本关只用到角度值和起止渐变颜色值。\n角度就是渐变的方向。起止渐变颜色值代表渐变颜色及其宽度值，由颜色值和起止位置组成，起止位置用百分比或者像素值表示。\n在代码编辑器的例子里，渐变开始于 0 像素位置的yellow，然后过渡到距离开始位置 40 像素的blue。由于下一个起止渐变颜色值的起止位置也是 40 像素，所以颜色直接渐变成第三个颜色值green，然后过渡到距离开始位置 80 像素的red。\n下面的代码可以帮助理解成对的起止渐变颜色值是如何过渡的。\n0px [黄色 – 过渡 – 蓝色] 40px [绿色 – 过渡 – 红色] 80px\n如果每对起止渐变颜色值的颜色都是相同的，由于是在两个相同的颜色间过渡，那么中间的过渡色也为同色，接着就是同色的过渡色和下一个起止颜色，最终产生的效果就是条纹。\n&lt;style&gt;\n\n  div{ \n    border-radius: 20px;\n    width: 70%;\n    height: 400px;\n    margin:  50 auto;\n    background: repeating-linear-gradient(\n      45deg,\n      yellow 0px,\n       yellow 40px,\n       black 40px,\n       black 80px\n    );\n\n  }\n\n&lt;/style&gt;\n ## 通过添加细微图案作为背景图像来创建纹理 添加一个精致的背景图，可以增加页面的质感，让页面更美观。关键是要找到一个平衡点，抢了内容的风头，喧宾夺主可就不妙了。background属性支持使用url()函数通过链接的方式引入一个指定纹理或样式的图片。图片链接地址在括号内，一般会用引号包起来。 background:url(https://i.imgur.com/MJAkxbh.png) ## 使用 CSS Transform scale 属性可以更改元素的大小 CSS 属性transform里面的scale()函数，可以用来改变元素的显示比例。下面的例子把页面的段落元素放大了 2 倍：\np { transform:scale(2); }"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用css-transform-scale-属性在悬停时缩放元素",
    "href": "posts/应用视觉设计/index.html#使用css-transform-scale-属性在悬停时缩放元素",
    "title": "应用视觉设计",
    "section": "使用CSS Transform scale 属性在悬停时缩放元素",
    "text": "使用CSS Transform scale 属性在悬停时缩放元素\ntransform属性有很多函数，可以对元素进行调整大小、移动、旋转、翻转等操作。当使用伪类描述元素的指定状态如:hover时，transform属性可以方便的给元素添加交互。\n下面是当用户悬停段落元素时，段落大小缩放到原始大小 2.1 倍的例子：\np:hover { transform: scale(2.1); } ## 使用 CSS Transform skex 属性沿X轴倾斜元素 接下来要介绍的transform属性是skewX，skewX使选择的元素沿着 X 轴（横向）翻转指定的角度。\n下面的代码沿着 X 轴翻转段落元素 -32 度。\np { transform: skewX(-32deg); }  ## 使用 CSS 创建一个图形 术语表：blur-radius =&gt; 模糊半径，spread-radius =&gt; 辐射半径，transparent =&gt; 透明的，border-radius =&gt; 圆角边框。\n通过使用选择器选择不同的元素并改变其属性，你可以创造一些有趣的形状。比如新月。你可以使用box-shadow属性来设置元素的阴影，border-radius属性控制元素的圆角边框。\n首先你将会创建一个圆的、透明的对象，它具有模糊阴影并略微向两边递减。如你所见，这个阴影其实就是新月形狀。\n为了创建一个圆形的对象，border-radius应该被设置成 50%。\n你应该还记得之前关卡的box-shadow属性以及它的依次取值offset-x、offset-y、blur-radius、spread-radius和颜色值。其中blur-radius和spread-radius是可选的。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用-css-和-html-创建更复杂的形状",
    "href": "posts/应用视觉设计/index.html#使用-css-和-html-创建更复杂的形状",
    "title": "应用视觉设计",
    "section": "使用 CSS 和 HTML 创建更复杂的形状",
    "text": "使用 CSS 和 HTML 创建更复杂的形状\n世界上最流行的形状非心形莫属了，在本关里你将用纯 CSS 创建一个心形。但是首先你需要了解:before和:after伪类。这些伪类用来在选择元素之前和之后添加一些内容。在下面的例子里，:before伪类元素用来给 class 为heart的元素添加一个正方形。\n:before和:after必须配合content来使用。这个属性通常用来给元素添加内容诸如图片或者文字。当:before和:after伪类用来添加某些形状而不是图片或文字时，content属性仍然是必需的，但是它的值可以是空字符串。\n在上面的例子里，class 为heart元素的:before伪类添加了一个黄色的长方形，长方形的height和width分别为 50px 和 70px。由于设置了其边框半径为 25%，所以长方形为圆角长方形，同时其相对位置为距离left5px，以及向top偏移 50px。\n.heart:before {\n  content: \"\";\n  background-color: yellow;\n  border-radius: 25%;\n  position: absolute;\n  height: 50px;\n  width: 70px;\n  top: -50px;\n  left: 5px;\n}\n心形图案css\n&lt;style&gt;\n.heart {\n  position: absolute;\n  margin: auto;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: pink;\n  height: 50px;\n  width: 50px;\n  transform:rotate(-45deg) ;\n}\n.heart:after {\n  background-color: pink;\n  content: \"\";\n  border-radius: 50%;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  top: 0px;\n  left: 25px;\n}\n.heart:before {\n  content:'' ;\n  background-color: pink;\n  border-radius: 50%;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  top: -25px;\n  left: 0px;\n} \n&lt;/style&gt;\n&lt;div class = \"heart\"&gt;&lt;/div&gt;"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#了解-css-的关键帧和动画是如何工作的",
    "href": "posts/应用视觉设计/index.html#了解-css-的关键帧和动画是如何工作的",
    "title": "应用视觉设计",
    "section": "了解 CSS 的关键帧和动画是如何工作的",
    "text": "了解 CSS 的关键帧和动画是如何工作的\n如果要给元素添加动画，你需要了解animation属性以及@keyframes规则。animation属性控制动画的外观，@keyframes规则控制动画中各阶段的变化。总共有 8 个animation属性。为了便于理解，本关暂时只涉及到两个最常用的属性。\nanimation-name设置动画的名称， 也就是要绑定的选择器的@keyframes的名称。\nanimation-duration设置动画所花费的时间。\n@keyframes能够创建动画。 创建动画的原理是将一套 CSS 样式逐渐变化为另一套样式。具体是通过设置动画期间对应的“frames”的 CSS 的属性，以百分比来规定改变的时间，或者通过关键词“from”和“to”，等价于 0% 和 100%。打个比方，CSS 里面的 0% 属性就像是电影里面的开场镜头。CSS 里面的 100% 属性就是元素最后的样子，相当于电影里的演职员表或者鸣谢镜头。CSS 在对应的时间内给元素过渡添加效果。下面举例说明@keyframes和动画属性的用法：\n#anim {\n  animation-name: colorful;\n  animation-duration: 3s;\n}\n@keyframes colorful {\n  0% {\n    background-color: blue;\n  }\n  100% {\n    background-color: yellow;\n  }\n}\nid 为anim的元素，代码设置animation-name为colorful，设置animation-duration为 3 秒。然后把@keyframes引用到名为colorful的动画属性上。colorful在动画开始时（0%）设置颜色为蓝色，在动画结束时（100%）设置颜色为黄色。注意不是只有开始和结束的过渡可以设置，0% 到 100% 间的任意百分比你都可以设置。 ## 使用CSS动画更改按钮的悬停状态 你可以在按钮悬停时使用@keyframes改变按钮的颜色。\n下面是在图片悬停时改变图片宽度的例子：\n&lt;style&gt;\n  img:hover {\n    animation-name: width;\n    animation-duration: 500ms;\n  }\n\n  @keyframes width {\n    100% {\n      width: 40px;\n    }\n  }\n&lt;/style&gt;\n\n&lt;img src=\"https://bit.ly/smallgooglelogo\" alt=\"Google's Logo\" /&gt;\n注意ms代表毫秒，1000ms 等于 1s。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#修改动画的填充模式颜色保持",
    "href": "posts/应用视觉设计/index.html#修改动画的填充模式颜色保持",
    "title": "应用视觉设计",
    "section": "修改动画的填充模式颜色保持",
    "text": "修改动画的填充模式颜色保持\n太棒了，但是现在还不完美。注意动画在500ms之后重置了，所以按钮又变成了之前的颜色。而我们想要的效果是按钮在悬停时始终高亮。\n这可以通过把animation-fill-mode设置成forwards来实现。animation-fill-mode指定了在动画结束时元素的样式。你可以向这样设置它：\nanimation-fill-mode: forwards; ## 使用 CSS 动画创建运动 当元素的position被指定，如fixed或者relative时，CSS 偏移属性right、left、top和bottom可以用在动画规则里创建动作。\n就像下面的例子展示的那样，你可以在50%keyframe 处设置top属性为 50px， 在开始（0%）和最后（100%）keframe 处设置为 0px，以产生项目向下运动，然后返回的动作效果。\n@keyframes rainbow {\n  0% {\n    background-color: blue;\n    top: 0px;\n  }\n  50% {\n    background-color: green;\n    top: 50px;\n  }\n  100% {\n    background-color: yellow;\n    top: 0px;\n  }\n}"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#通过从左到右淡化元素来创建视觉方向",
    "href": "posts/应用视觉设计/index.html#通过从左到右淡化元素来创建视觉方向",
    "title": "应用视觉设计",
    "section": "通过从左到右淡化元素来创建视觉方向",
    "text": "通过从左到右淡化元素来创建视觉方向\n在本关里，你将要改变动画元素的opacity，使其在到达屏幕右侧时渐隐。\n在展示的动画里，具有渐变背景的圆形元素在 50% 标记的@keyframes规则处向右移动。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用无限的动画计数制作永不停止的动画",
    "href": "posts/应用视觉设计/index.html#使用无限的动画计数制作永不停止的动画",
    "title": "应用视觉设计",
    "section": "使用无限的动画计数制作永不停止的动画",
    "text": "使用无限的动画计数制作永不停止的动画\n之前的关卡里介绍了一些动画属性以及@keyframes规则的用法。还有一个常用的动画属性是animation-iteration-count，这个属性允许你控制动画循环的次数。下面是一个例子：\nanimation-iteration-count: 3;\n在这里动画会在运行 3 次后停止，如果想让动画一直运行，可以把值设置成 infinite。"
  },
  {
    "objectID": "posts/应用视觉设计/index.html#使用无限的动画计数制作-css-心跳",
    "href": "posts/应用视觉设计/index.html#使用无限的动画计数制作-css-心跳",
    "title": "应用视觉设计",
    "section": "使用无限的动画计数制作 CSS 心跳",
    "text": "使用无限的动画计数制作 CSS 心跳\n这也是一个用animation-iteration-count属性创造持续动画的例子，它基于前面关卡创建的心形。\n心跳动画的每一秒包含两个部分。heart元素（包括:before和:after）使用transform属性改变其大小，背景div使用background属性改变其颜色`\n&lt;style&gt;\n  .back {\n    position: fixed;\n    padding: 0;\n    margin: 0;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: white;\n    animation-name: backdiv;\n    animation-duration: 1s; \n    animation-iteration-count:infinite;\n  }\n\n  .heart {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: pink;\n    height: 50px;\n    width: 50px;\n    transform: rotate(-45deg);\n    animation-name: beat;\n    animation-duration: 1s;\n    animation-iteration-count:infinite;\n    \n  }\n  .heart:after {\n    background-color: pink;\n    content: \"\";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: 0px;\n    left: 25px;\n  }\n  .heart:before {\n    background-color: pink;\n    content: \"\";\n    border-radius: 50%;\n    position: absolute;\n    width: 50px;\n    height: 50px;\n    top: -25px;\n    left: 0px;\n  }\n\n  @keyframes backdiv {\n    50% {\n      background: #ffe6f2;\n    }\n  }\n\n  @keyframes beat {\n    0% {\n      transform: scale(1) rotate(-45deg);\n    }\n    50% {\n      transform: scale(0.6) rotate(-45deg);\n    }\n  }\n\n&lt;/style&gt;\n&lt;div class=\"back\"&gt;&lt;/div&gt;\n&lt;div class=\"heart\"&gt;&lt;/div&gt;"
  },
  {
    "objectID": "posts/Django-- 1_配置数据库(mysql8.0)/index.html",
    "href": "posts/Django-- 1_配置数据库(mysql8.0)/index.html",
    "title": "Django– 1_配置数据库(mysql8.0)",
    "section": "",
    "text": "1.安装驱动\npip install mysqlclient\n2.修改settings.py文件中DATABASES\nDATABASES = {\n 'default':{\n          'ENGINE' :'django.db.backends.mysql',# 驱动\n          'NAME':'lice_management',# 数据库名\n          'USER':'root',# 用户名\n          'PASSWORD':'123321',# 密码\n          'HOST':'127.0.0.1',# 地址\n          'PORT':'3306',# 端口\n\n }\n}\npycharm中的配置,Django不需要这个配置\n3.注意mysql8.0开始连接要加上参数\nurl: jdbc:mysql://localhost:3306/数据库名?characterEncoding=utf8&useSSL=false&serverTimezone=UTC&rewriteBatchedStatements=true"
  },
  {
    "objectID": "posts/spi通信/index.html",
    "href": "posts/spi通信/index.html",
    "title": "spi 通信",
    "section": "",
    "text": "使用两个 stm32 芯片进行 spi 通信 主端循环发送, 从端一次接收, 接收后将数据从串口发送. 主要的 HAL 接口函数如下\nHAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi,\n                                            uint8_t           *pTxData,\n                                            uint8_t           *pRxData,\n                                            uint16_t           Size)"
  },
  {
    "objectID": "posts/spi通信/index.html#主端g030",
    "href": "posts/spi通信/index.html#主端g030",
    "title": "spi 通信",
    "section": "主端(G030)",
    "text": "主端(G030)\nwhile(1)循环发送数据 主要的 HAL 接口函数"
  },
  {
    "objectID": "posts/spi通信/index.html#从端f103",
    "href": "posts/spi通信/index.html#从端f103",
    "title": "spi 通信",
    "section": "从端(F103)",
    "text": "从端(F103)\n只接收一次代码, 然后卡在wait status"
  },
  {
    "objectID": "posts/numpy/index.html",
    "href": "posts/numpy/index.html",
    "title": "learning numpy",
    "section": "",
    "text": "learing some basic operation of numpy"
  },
  {
    "objectID": "posts/numpy/index.html#创建数组",
    "href": "posts/numpy/index.html#创建数组",
    "title": "learning numpy",
    "section": "创建数组",
    "text": "创建数组\na = np.array([2,23,4])  # list 1d\nprint(a)\n# [2 23 4]"
  },
  {
    "objectID": "posts/numpy/index.html#指定数据-dtype",
    "href": "posts/numpy/index.html#指定数据-dtype",
    "title": "learning numpy",
    "section": "指定数据 dtype",
    "text": "指定数据 dtype\n根据指定数据类型, 更高的精度速度会更慢,储存大小也随之扩大.\n# specify the type of parameters\narr_int64 = np.array([1,2,3],dtype=np.int64)\nprint(arr_int64.dtype) # int64"
  },
  {
    "objectID": "posts/numpy/index.html#创建特定数据",
    "href": "posts/numpy/index.html#创建特定数据",
    "title": "learning numpy",
    "section": "创建特定数据",
    "text": "创建特定数据\n普通创建2d矩阵\na = np.array([[2,23,4],[2,32,4]])  # 2d 矩阵 2行3列\nprint(a)\n\"\"\"\n[[ 2 23  4]\n [ 2 32  4]]\n\"\"\"\n创建全零数组\na = np.zeros((3,4)) # 数据全为0，3行4列\n\"\"\"\narray([[ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.]])\n\"\"\"\n创建全一数组, 同时也能指定这些特定数据的 dtype:\na = np.ones((3,4),dtype = np.int)   # 数据为1，3行4列\n\"\"\"\narray([[1, 1, 1, 1],\n       [1, 1, 1, 1],\n       [1, 1, 1, 1]])\n\"\"\"\n创建全空数组, 其实每个值都是接近于零的数: &gt; empty不像zeros一样，并不会将数组的元素值设定为0，因此运行起来可能快一些。在另一方面，它要求用户人为地给数组中的每一个元素赋值，所以应该谨慎使用。\na = np.empty((3,4)) # 数据为empty，3行4列\n\"\"\"\narray([[  0.00000000e+000,   4.94065646e-324,   9.88131292e-324,\n          1.48219694e-323],\n       [  1.97626258e-323,   2.47032823e-323,   2.96439388e-323,\n          3.45845952e-323],\n       [  3.95252517e-323,   4.44659081e-323,   4.94065646e-323,\n          5.43472210e-323]])\n\"\"\"\n用 arange 创建连续数组:\na = np.arange(10,20,2) # 10-19 的数据，2步长\n\"\"\"\narray([10, 12, 14, 16, 18])\n\"\"\"\n使用 reshape 改变数据的形状\n# reshape code\nbase_arr = np.arange(12)\nprint(base_arr)\n# [ 0  1  2  3  4  5  6  7  8  9 10 11]\nreshape_arr = np.reshape(base_arr,(3,4))\nreshape_arr_1 = base_arr.reshape((3,4))\n\nprint(reshape_arr_1)\n# [[ 0  1  2  3]\n#  [ 4  5  6  7]\n#  [ 8  9 10 11]]\n用 linspace 创建线段型数据: &gt; 等分区间\na = np.linspace(1,10,20)    # 开始端1，结束端10，且分割成20个数据，生成线段\n\"\"\"\narray([  1.        ,   1.47368421,   1.94736842,   2.42105263,\n         2.89473684,   3.36842105,   3.84210526,   4.31578947,\n         4.78947368,   5.26315789,   5.73684211,   6.21052632,\n         6.68421053,   7.15789474,   7.63157895,   8.10526316,\n         8.57894737,   9.05263158,   9.52631579,  10.        ])\n\"\"\"\n属性.py"
  },
  {
    "objectID": "posts/numpy/index.html#numpy-的几种基本运算-1",
    "href": "posts/numpy/index.html#numpy-的几种基本运算-1",
    "title": "learning numpy",
    "section": "numpy 的几种基本运算",
    "text": "numpy 的几种基本运算\n上述代码中的 a 和 b 是两个属性为 array 也就是矩阵的变量，而且二者都是1行4列的矩阵， 其中b矩阵中的元素分别是从0到3。 如果我们想要求两个矩阵之间的减法，你可以尝试着输入：\nc=a-b  # array([10, 19, 28, 37])****\n有所不同的是，在Numpy中，想要求出矩阵中各个元素的乘方需要依赖双星符号 **，以二次方举例，即：\nc=b**2  # array([0, 1, 4, 9])\n另外，Numpy中具有很多的数学函数工具，比如三角函数等，当我们需要对矩阵中每一项元素进行函数运算时，可以很简便的调用它们（以sin函数为例）：\nc=10*np.sin(a)  \n# array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])\n\n此时由于进行逻辑判断，返回的是一个bool类型的矩阵，即对满足要求的返回True，不满足的返回False。上述程序执行后得到的结果是[True True True False]。 需要注意的是，如果想要执行是否相等的判断， 依然需要输入 == 而不是 = 来完成相应的逻辑判断。\n\n角度弧度转换以及判断输出\n# sin cos tan ... 0~360°: angle =&gt; radian\nsin_arr = np.arange(0,360,1)\nh = np.sin(sin_arr*np.pi/180)\nprint(h)\nprint(abs(h)&gt;0.5)\n上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：\n# multi dimensional array\naa = np.array([[1,2,3],[4,5,6]])\nbb = np.arange(6).reshape(2,3)\nprint(aa)\nprint(bb)\n此时构造出来的矩阵a和b便是2行2列的，其中 reshape 操作是对矩阵的形状进行重构， 其重构的形状便是括号中给出的数字。 稍显不同的是，Numpy中的矩阵乘法分为两种， 其一是前文中的对应元素相乘，其二是标准的矩阵乘法运算，即对应行乘对应列得到相应元素： ## 点积(数量积) \n\n\n\n\n\n\nc_dot = np.dot(a,b)"
  },
  {
    "objectID": "posts/numpy/index.html#叉积",
    "href": "posts/numpy/index.html#叉积",
    "title": "learning numpy",
    "section": "叉积",
    "text": "叉积"
  },
  {
    "objectID": "posts/darknet--训练/index.html",
    "href": "posts/darknet--训练/index.html",
    "title": "darknet–训练",
    "section": "",
    "text": "训练目标：\nperson detection # 准备数据集 voc数据集： http://pjreddie.com/media/files/VOCtrainval_11-May-2012.tar http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar\n存放位置如下：—&gt;执行python voc_label.py 会生成 txt文档 \n\n\n准备预训练权重文件\n这里我们用yolov3-tiny版本的预训练权重文件： yolov3-tiny.conv.11： https://jszhuanben.lanzouf.com/iKuPK01mxl5i 放到：D:\\project\\c\\train_demo\\build\\darknet\\x64中 # 复制一个cfg文件 yolov3-tiny.cfg改名为：yolov3-tiny-obj.cfg ### 下面的配置根据个人电脑来配置 修改yolov3-tiny.cfg文件中 batch=64 修改yolov3-tiny.cfg文件中 batch=64 \n4 计算锚点\ndarknet detector calc_anchors data/voc/v3_tiny_obj.data -num_of_clusters 6 -width 416 -height 416\n\n\n提取初始化权重\ndarknet partial data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.weights data/voc/yolov3-tiny.conv.15 15\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI-- 单选框 JRadioButton _ 复选框 JCheckBox/index.html",
    "href": "posts/javaGUI-- 单选框 JRadioButton _ 复选框 JCheckBox/index.html",
    "title": "javaGUI– 单选框 JRadioButton _ 复选框 JCheckBox",
    "section": "",
    "text": "单选框记得分组,要不然不是只能选一个 一个分组中只能选择一个 复选框可以选多个 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JButtonDemo extends JFrame {\n    public JButtonDemo() {\n        this.setTitle(\"单选框/复选框\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 单选框\n        JRadioButton radioButton01 = new JRadioButton(\"JRadioButton01\");\n        JRadioButton radioButton02 = new JRadioButton(\"JRadioButton02\");\n        JRadioButton radioButton03 = new JRadioButton(\"JRadioButton03\");\n\n        // 因为单选框智能选择一个,所以分组,每个组内只能选择一个\n        ButtonGroup group = new ButtonGroup();\n        group.add(radioButton01);\n        group.add(radioButton02);\n        group.add(radioButton03);\n\n        // 复选框\n        JCheckBox checkBox01 = new JCheckBox(\"checkBox01\");\n        JCheckBox checkBox02 = new JCheckBox(\"checkBox02\");\n        JCheckBox checkBox03 = new JCheckBox(\"checkBox03\");\n\n        Container container = this.getContentPane();\n        container.add(radioButton01,BorderLayout.WEST);\n        container.add(radioButton02,BorderLayout.CENTER);\n        container.add(radioButton03,BorderLayout.EAST);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new FlowLayout());\n        panel.add(checkBox01);\n        panel.add(checkBox02);\n        panel.add(checkBox03);\n        container.add(panel,BorderLayout.NORTH);\n    }\n\n    public static void main(String[] args) {\n        new JButtonDemo();\n    }\n}"
  },
  {
    "objectID": "posts/jdbc-- c3p0xml 链接/index.html",
    "href": "posts/jdbc-- c3p0xml 链接/index.html",
    "title": "jdbc– c3p0xml 链接",
    "section": "",
    "text": "// 配置文件连接\n    @Test\n    public void c3p0Test02() throws SQLException {\n        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"mysql\");\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i &lt; 5000; i++) {\n            Connection connection = comboPooledDataSource.getConnection();\n            connection.close();\n        }\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n配置文件放src下 c3p0-config.xml\n&lt;c3p0-config &gt;\n  &lt;named-config name=\"mysql\"&gt;\n  &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://127.0.0.1:3306/persons?rewriteBatchedStatements=true&lt;/property&gt;\n  &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n  &lt;property name=\"user\"&gt;root&lt;/property&gt;\n  &lt;property name=\"password\"&gt;123312&lt;/property&gt;\n\n  &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt;\n  &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt;\n  &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt;\n  &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt;\n  &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt;\n  &lt;!--每次增长长度--&gt;\n  &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt;\n  &lt;!--每个对象命令数--&gt;\n  &lt;property name=\"maxStatementsPerConnection\"&gt;2&lt;/property&gt;\n  &lt;/named-config&gt;\n&lt;/c3p0-config&gt;"
  },
  {
    "objectID": "posts/jdbc-- c3p0xml 链接/index.html#c3p0xml-链接",
    "href": "posts/jdbc-- c3p0xml 链接/index.html#c3p0xml-链接",
    "title": "jdbc– c3p0xml 链接",
    "section": "",
    "text": "// 配置文件连接\n    @Test\n    public void c3p0Test02() throws SQLException {\n        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"mysql\");\n\n        System.out.println(\"执行....\");\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i &lt; 5000; i++) {\n            Connection connection = comboPooledDataSource.getConnection();\n            connection.close();\n        }\n        System.out.println(\"执行时间\"+(System.currentTimeMillis()-start));\n    }\n配置文件放src下 c3p0-config.xml\n&lt;c3p0-config &gt;\n  &lt;named-config name=\"mysql\"&gt;\n  &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://127.0.0.1:3306/persons?rewriteBatchedStatements=true&lt;/property&gt;\n  &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n  &lt;property name=\"user\"&gt;root&lt;/property&gt;\n  &lt;property name=\"password\"&gt;123312&lt;/property&gt;\n\n  &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt;\n  &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt;\n  &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt;\n  &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt;\n  &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt;\n  &lt;!--每次增长长度--&gt;\n  &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt;\n  &lt;!--每个对象命令数--&gt;\n  &lt;property name=\"maxStatementsPerConnection\"&gt;2&lt;/property&gt;\n  &lt;/named-config&gt;\n&lt;/c3p0-config&gt;"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "href": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "title": "stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数",
    "section": "",
    "text": "在 RT-Thread 中，有一个打印函数 rt_kprintf() 供用户使用，方便在调试的时候输出各种信息。如果 要想使用 rt_kprintf()，则必须将控制台重映射到 rt_kprintf()，这个控制台可以是串口、CAN、USB、 以太网等输出设备，用的最多的就是串口，接下来我们讲解下如何将串口重定向到 rt_kprintf()。[参考野火F103]\n\n\n\n添加bsp_usart.c, bsp_usart.h\n\nbsp_usart.c\n#include \"bsp_usart.h\"\n\n /**\n  * @brief  配置嵌套向量中断控制器NVIC\n  * @param  无\n  * @retval 无\n  */\nstatic void NVIC_Configuration(void)\n{\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  /* 嵌套向量中断控制器组选择 */\n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  /* 配置USART为中断源 */\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  /* 抢断优先级*/\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\n  /* 子优先级 */\n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  /* 使能中断 */\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  /* 初始化配置NVIC */\n  NVIC_Init(&NVIC_InitStructure);\n}\n\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n  // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 串口中断优先级配置\n    NVIC_Configuration();\n    \n    // 使能串口接收中断\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);    \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);        \n}\n\n/*****************  发送一个字节 **********************/\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)\n{\n    /* 发送一个字节数据到USART */\n    USART_SendData(pUSARTx,ch);\n        \n    /* 等待发送数据寄存器为空 */\n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n/****************** 发送8位的数组 ************************/\nvoid Usart_SendArray( USART_TypeDef * pUSARTx, uint8_t *array, uint16_t num)\n{\n  uint8_t i;\n    \n    for(i=0; i&lt;num; i++)\n  {\n        /* 发送一个字节数据到USART */\n        Usart_SendByte(pUSARTx,array[i]);   \n  \n  }\n    /* 等待发送完成 */\n    while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET);\n}\n\n/*****************  发送字符串 **********************/\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str)\n{\n    unsigned int k=0;\n  do \n  {\n      Usart_SendByte( pUSARTx, *(str + k) );\n      k++;\n  } while(*(str + k)!='\\0');\n  \n  /* 等待发送完成 */\n  while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET)\n  {}\n}\n\n/*****************  发送一个16位数 **********************/\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch)\n{\n    uint8_t temp_h, temp_l;\n    \n    /* 取出高八位 */\n    temp_h = (ch&0XFF00)&gt;&gt;8;\n    /* 取出低八位 */\n    temp_l = ch&0XFF;\n    \n    /* 发送高八位 */\n    USART_SendData(pUSARTx,temp_h); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);\n    \n    /* 发送低八位 */\n    USART_SendData(pUSARTx,temp_l); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n///重定向c库函数printf到串口，重定向后可使用printf函数\nint fputc(int ch, FILE *f)\n{\n        /* 发送一个字节数据到串口 */\n        USART_SendData(DEBUG_USARTx, (uint8_t) ch);\n        \n        /* 等待发送完毕 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);     \n    \n        return (ch);\n}\n\n///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\nint fgetc(FILE *f)\n{\n        /* 等待串口输入数据 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);\n\n        return (int)USART_ReceiveData(DEBUG_USARTx);\n}\n\n\n\nbsp_usart.h\n#ifndef __USART_H\n#define __USART_H\n\n\n#include \"stm32f10x.h\"\n#include &lt;stdio.h&gt;\n\n/** \n  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏\n    * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线\n    * 2-修改GPIO的宏\n  */\n    \n// 串口1-USART1\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n    \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define  DEBUG_USART_IRQ                USART1_IRQn\n#define  DEBUG_USART_IRQHandler         USART1_IRQHandler\n\n\n// 串口2-USART2\n//#define  DEBUG_USARTx                   USART2\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3\n\n//#define  DEBUG_USART_IRQ                USART2_IRQn\n//#define  DEBUG_USART_IRQHandler         USART2_IRQHandler\n\n// 串口3-USART3\n//#define  DEBUG_USARTx                   USART3\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART3\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOB   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOB\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                USART3_IRQn\n//#define  DEBUG_USART_IRQHandler         USART3_IRQHandler\n\n// 串口4-UART4\n//#define  DEBUG_USARTx                   UART4\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART4\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOC\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                UART4_IRQn\n//#define  DEBUG_USART_IRQHandler         UART4_IRQHandler\n\n\n// 串口5-UART5\n//#define  DEBUG_USARTx                   UART5\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART5\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOD\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2\n\n//#define  DEBUG_USART_IRQ                UART5_IRQn\n//#define  DEBUG_USART_IRQHandler         UART5_IRQHandler\n\n\nvoid USART_Config(void);\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch);\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str);\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch);\n\n#endif /* __USART_H */\n\n\n\n重构void rt_hw_console_output(const char *str)函数\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include &lt;rthw.h&gt;\n#include &lt;rtthread.h&gt;\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n    // 初始化串口\n    USART_Config();\n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}\n\n\n/**************************重写rtthread控制台输出, 通过串口发送*************************************/\nvoid rt_hw_console_output(const char *str)\n{\n    /*进入临界区*/\n    rt_enter_critical();\n\n    /* 直到将字符串发送完 */\n    while (*str != '\\0')\n    {\n        /* 换行 */\n        if (*str == '\\n')\n        {\n            USART_SendData(DEBUG_USARTx, '\\r');\n            while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n        }\n\n        USART_SendData(DEBUG_USARTx, *str++);\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n    }\n\n    /* 退出临界区 */\n    rt_exit_critical();\n}   \n  \n\n\n\n初始化串口配置\n\nboard.c\nUSART_Config();\n\n\n\n调用\n\nmian.c\n/**\n *********************************************************************\n * @file    main.c\n * @author  fire\n * @version V1.0\n * @date    2018-xx-xx\n * @brief   RT-Thread 3.0 + STM32 工程模版\n *********************************************************************\n * @attention\n *\n * 实验平台:野火 F103-指南者 STM32 开发板\n * 论坛    :http://www.firebbs.cn\n * 淘宝    :https://fire-stm32.taobao.com\n *\n **********************************************************************\n */\n\n/*\n*************************************************************************\n*                             包含的头文件\n*************************************************************************\n*/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n*/\n/**\n * @brief  主函数\n * @param  无\n * @retval 无\n */\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[1], Red\\r\\n\");\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[2], Green\\r\\n\");\n    }\n}"
  },
  {
    "objectID": "posts/Django项目三步快速创建/index.html",
    "href": "posts/Django项目三步快速创建/index.html",
    "title": "Django项目三步快速创建",
    "section": "",
    "text": "pip install django==2.1.7                 # 安装Django2.1.7版本，高版本不兼容\npip 安装的库的时候很大概率可能会出现安装失败 的情况，他会提示升级pip的版本。大多数情况不用升级，直接多pip安装一次两次就好了，就会安装上。\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n直接调出cmd（win+r，输入cmd回车，在弹出的cmd中输入pip install…..）"
  },
  {
    "objectID": "posts/Django项目三步快速创建/index.html#方法①",
    "href": "posts/Django项目三步快速创建/index.html#方法①",
    "title": "Django项目三步快速创建",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/Django项目三步快速创建/index.html#方法②",
    "href": "posts/Django项目三步快速创建/index.html#方法②",
    "title": "Django项目三步快速创建",
    "section": "",
    "text": "直接调出cmd（win+r，输入cmd回车，在弹出的cmd中输入pip install…..）"
  },
  {
    "objectID": "posts/Django项目三步快速创建/index.html#三启动项目",
    "href": "posts/Django项目三步快速创建/index.html#三启动项目",
    "title": "Django项目三步快速创建",
    "section": "三、启动项目",
    "text": "三、启动项目\n项目创建成功，就要启动项目测试下了 ①先进入到__init__所在的文件夹下，执行以下命令\npython manage.py runserver 0:8000       # 运行项目 0 = 0.0.0.0 允许所有ip访问\n如果没法访问\npython manage.py runserver 127.0.0.1:8000       # 运行项目 允许所有127.0.0.1访问\n ②出现小火箭，就成功了  ③下次就不用执行：python manage.py runserver 127.0.0.1:8000了 直接接点绿色小箭头就行了 \n④如果没法自动创建Django启动项\n1）  2）  3）  现在就都配置好了"
  },
  {
    "objectID": "posts/Django项目三步快速创建/index.html#最后",
    "href": "posts/Django项目三步快速创建/index.html#最后",
    "title": "Django项目三步快速创建",
    "section": "最后",
    "text": "最后\n设置terminal编码(如果terminal窗口出现乱码) file——&gt;settings"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "href": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "title": "stm32F103-RT-Thread邮箱(mailbox)",
    "section": "",
    "text": "在编码前先打开rtconfig.h中的mailbox选项. &gt; 这个程序会创建2个动态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。 数据按照制定顺序进行发送,FIFO或者priority.\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nuint8_t count = 0;\n\n/* message */\nstatic char msg_1[] = \"hello\";\nstatic char msg_2[] = \"world.\";\nstatic char msg_3[] = \"@\";\n\n\n/* mail_box control block */\nstatic rt_mailbox_t mb_1 = RT_NULL;\n\n/* thread control blcok */\nstatic rt_thread_t mb_thread_1 = RT_NULL;\nstatic rt_thread_t mb_thread_2 = RT_NULL;\n\n/* thread_1 to send msg*/\nstatic void thread_1_entry(void *parameter)\n{\n    while (count &lt; 10)\n    {\n        count++;\n        if (count & 0x1)\n        {\n            if(RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_1)){\n                // rt_kprintf(\"-----%x++++++++++%p\\n\",(rt_uint32_t)&msg_1,&msg_1); // -----20000029++++++++++20000029\n\n                rt_kprintf(\"msg_1_send successful!!!\\n\");\n            }\n            else{\n                rt_kprintf(\"msg_1_send failed!!!\\n\");\n            }\n        }\n        //\n        else\n        {\n            if (RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_2))\n            {\n                rt_kprintf(\"msg_2_send successful!!!\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"msg_2_send failed!!!\\n\");\n            }\n        }\n\n        // thread wait 200 ticks\n        rt_thread_delay(50);\n    }\n\n    // message send [finish]\n    rt_mb_send(mb_1, (rt_uint32_t)&msg_3);\n    rt_kprintf(\"END flag is send....\");\n}\n \n/* thread_2 to receive msg */\nstatic void thread_2_entry(void *parameter){\n    char *str;\n    while (1)\n    {\n        rt_kprintf(\"thread_[2]: try reveive msg.....\\n\");\n        \n        if (rt_mb_recv(mb_1, (rt_uint32_t *)&str, RT_WAITING_FOREVER) == RT_EOK)\n        {\n            rt_kprintf(\"[%d]msg:%s\\n\",count,str);\n            if(str==msg_3){\n                rt_kprintf(\"revc END ............\\n\");\n                break;\n            }\n            rt_thread_delay(100);\n        }\n        else{\n            rt_kprintf(\"2_recv msg faild.....\\n\");\n        }\n    }\n    rt_mb_detach(mb_1);\n    \n}\n\n\n\nint main(void){\n// 这里的1,是mb_size,控制mailbox可以同时发送几个邮件\n    mb_1 = rt_mb_create(\"mb_1\",1,RT_IPC_FLAG_FIFO);\n    \n    if(mb_1!=RT_NULL){\n        rt_kprintf(\"mail_box is create\\n\");\n    }\n    else{\n        rt_kprintf(\"mail_box is create failed.\\n\");\n        return -1;\n    }\n\n    // mb_thread_1 create\n    mb_thread_1 = rt_thread_create(\"mb_thread_1\",thread_1_entry,RT_NULL,512,3,20);\n    if(mb_thread_1!=RT_NULL){\n        rt_thread_startup(mb_thread_1);\n    }   \n    // mb_thread_2 create\n    mb_thread_2 = rt_thread_create(\"mb_thread_2\", thread_2_entry, RT_NULL, 512, 3, 20);\n    if (mb_thread_2 != RT_NULL)\n    {\n        rt_thread_startup(mb_thread_2);\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html#邮箱-mailbox",
    "href": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html#邮箱-mailbox",
    "title": "stm32F103-RT-Thread邮箱(mailbox)",
    "section": "",
    "text": "在编码前先打开rtconfig.h中的mailbox选项. &gt; 这个程序会创建2个动态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。 数据按照制定顺序进行发送,FIFO或者priority.\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nuint8_t count = 0;\n\n/* message */\nstatic char msg_1[] = \"hello\";\nstatic char msg_2[] = \"world.\";\nstatic char msg_3[] = \"@\";\n\n\n/* mail_box control block */\nstatic rt_mailbox_t mb_1 = RT_NULL;\n\n/* thread control blcok */\nstatic rt_thread_t mb_thread_1 = RT_NULL;\nstatic rt_thread_t mb_thread_2 = RT_NULL;\n\n/* thread_1 to send msg*/\nstatic void thread_1_entry(void *parameter)\n{\n    while (count &lt; 10)\n    {\n        count++;\n        if (count & 0x1)\n        {\n            if(RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_1)){\n                // rt_kprintf(\"-----%x++++++++++%p\\n\",(rt_uint32_t)&msg_1,&msg_1); // -----20000029++++++++++20000029\n\n                rt_kprintf(\"msg_1_send successful!!!\\n\");\n            }\n            else{\n                rt_kprintf(\"msg_1_send failed!!!\\n\");\n            }\n        }\n        //\n        else\n        {\n            if (RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_2))\n            {\n                rt_kprintf(\"msg_2_send successful!!!\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"msg_2_send failed!!!\\n\");\n            }\n        }\n\n        // thread wait 200 ticks\n        rt_thread_delay(50);\n    }\n\n    // message send [finish]\n    rt_mb_send(mb_1, (rt_uint32_t)&msg_3);\n    rt_kprintf(\"END flag is send....\");\n}\n \n/* thread_2 to receive msg */\nstatic void thread_2_entry(void *parameter){\n    char *str;\n    while (1)\n    {\n        rt_kprintf(\"thread_[2]: try reveive msg.....\\n\");\n        \n        if (rt_mb_recv(mb_1, (rt_uint32_t *)&str, RT_WAITING_FOREVER) == RT_EOK)\n        {\n            rt_kprintf(\"[%d]msg:%s\\n\",count,str);\n            if(str==msg_3){\n                rt_kprintf(\"revc END ............\\n\");\n                break;\n            }\n            rt_thread_delay(100);\n        }\n        else{\n            rt_kprintf(\"2_recv msg faild.....\\n\");\n        }\n    }\n    rt_mb_detach(mb_1);\n    \n}\n\n\n\nint main(void){\n// 这里的1,是mb_size,控制mailbox可以同时发送几个邮件\n    mb_1 = rt_mb_create(\"mb_1\",1,RT_IPC_FLAG_FIFO);\n    \n    if(mb_1!=RT_NULL){\n        rt_kprintf(\"mail_box is create\\n\");\n    }\n    else{\n        rt_kprintf(\"mail_box is create failed.\\n\");\n        return -1;\n    }\n\n    // mb_thread_1 create\n    mb_thread_1 = rt_thread_create(\"mb_thread_1\",thread_1_entry,RT_NULL,512,3,20);\n    if(mb_thread_1!=RT_NULL){\n        rt_thread_startup(mb_thread_1);\n    }   \n    // mb_thread_2 create\n    mb_thread_2 = rt_thread_create(\"mb_thread_2\", thread_2_entry, RT_NULL, 512, 3, 20);\n    if (mb_thread_2 != RT_NULL)\n    {\n        rt_thread_startup(mb_thread_2);\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "",
    "text": "darknet框架相pyrtorch轻量化很多，将darknet和qt进行整合，大多项目都是基于单独的框架的，对于整合的工作相对来说低很多"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "创建完成记得保存",
    "text": "创建完成记得保存\n对修改完的ui文件进行编译"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "环境配置需要的文件",
    "text": "环境配置需要的文件\n\nincldue 文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nconfig文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nlib文件夹"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "链接器中附加目录中的附加依赖项",
    "text": "链接器中附加目录中的附加依赖项\nopencv版本根据自身开发环境进行配置"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "生成",
    "text": "生成\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "双击即可运行",
    "text": "双击即可运行\n点击右上角的 x 关闭只关闭了界面, 系统检测进程还是在后台运行, 需要重写closeEvent 进行关闭系统."
  },
  {
    "objectID": "posts/中科大源/index.html",
    "href": "posts/中科大源/index.html",
    "title": "中科大源",
    "section": "",
    "text": "地址\nhttps://mirrors.ustc.edu.cn/\n\n\n使用帮助文档\nhttps://mirrors.ustc.edu.cn/help/debian.html"
  },
  {
    "objectID": "posts/java多线程-- 静态代理(简单剖析)/index.html",
    "href": "posts/java多线程-- 静态代理(简单剖析)/index.html",
    "title": "java多线程– 静态代理(简单剖析)",
    "section": "",
    "text": "静态代理 * 就是创建一个A对象代替B对象去干活, * 把认为不重要的事情交给A(代理)去做 * 到主要时候换B上厂,有点明星请替身的滋味\npackage cn.usts.edu.lesson04;\n\n/**\n * 静态代理\n * 就是创建一个A对象代替B对象去干活, \n * 把认为不重要的事情交给A(代理)去做\n * 到主要时候换B上厂,有点明星请替身的滋味\n * */\n\ninterface Marry{\n    void doMarry(String name);\n}\n\n// 你去实现Marry接口\nclass You implements Marry{\n    @Override\n    public void doMarry(String name) {\n        System.out.println(name+\"结婚啦\");\n    }\n}\n\n// 婚庆公司 也实现结婚接口\nclass WeddingCompany implements Marry{\n    private Marry target;// 代理的目标 [帮谁代理结婚的]\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    public void before(){\n        System.out.println(\"布置现场\");\n    }\n\n    public void after(){\n        System.out.println(\"收尾款\");\n    }\n\n    @Override\n    public void doMarry(String name) {\n        this.before();\n        this.target.doMarry(name);\n        this.after();\n    }\n}\n\n// 主体类\npublic class staticProxy {\n    public static void main(String[] args) {\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.doMarry(\"小明\");\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- Runnable简单实现(例子)/index.html",
    "href": "posts/java多线程-- Runnable简单实现(例子)/index.html",
    "title": "java多线程– Runnable简单实现(例子)",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\npublic class RunnableSimpleDemo implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 20; i++) {\n            System.out.println(\"吃第\"+i+\"个馒头\");\n        }\n    }\n\n    public static void main(String[] args) {\n//        RunnableSimpleDemo runnableSimpleDemo = new RunnableSimpleDemo();\n//        Thread thread = new Thread(runnableSimpleDemo);\n//        thread.start();// 线程启动\n        new Thread(new RunnableSimpleDemo()).start();// 线程启动\n\n        for (int i = 0; i &lt; 20; i++) {\n            System.out.println(\"喝第\"+i+\"口水\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/infineon_radar_init_env/index.html",
    "href": "posts/infineon_radar_init_env/index.html",
    "title": "Infineon Radar Env Init",
    "section": "",
    "text": "Description\n搭建 infineon 60G 毫米波雷达开发环境\n\n\n资料准备\n\n\ninfineon 60G雷达相关下载资料\n下载资料需要先注册账号\n下载资料如下\n\n\n\n\n\ninfineon 60Ghz 毫米波雷达环境创建\n\n\n将上述两个工具安装好 打开development kit \n\n\n\n\n将会看到如下界面\n\n\n\n开发框架代码在development kit 安装目录下，进入到安装目录，所需代码和文档都在该目录下。"
  },
  {
    "objectID": "posts/qt--vs2022+qt5.15.2/index.html",
    "href": "posts/qt--vs2022+qt5.15.2/index.html",
    "title": "qt–vs2022+qt5.15.2",
    "section": "",
    "text": "最终效果\n项目结构 \n # demo的搭建 \n          \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/腾讯云简单使用-Python/index.html",
    "href": "posts/腾讯云简单使用-Python/index.html",
    "title": "腾讯云简单使用-Python",
    "section": "",
    "text": "腾讯云使用踩坑\nssh无法连接: 修改sshd文件 :PermitRootLogin=yes, PasswordAuthentication 改成yes reboot\n\n\nPython虚拟环境:\npip intall virtualenv之后命令无效,not fund command 修改:vim ~/.bashrc 重启: sudo service ssh restart 最后添加:\nexport WORKON_HOME=$HOME/.virtualenvs\nexport PROJECT_HOME=$HOME/workspace\nsource /usr/local/bin/virtualenvwrapper.sh\n生效:\nsource ~/.bashrc\n指定版本创建:\nmkvirtualenv py39 --python==python3.9\n\n\nAnnaconda环境\n配置环境变量:\nsudo vim /etc/profile\n\nexport PATH=$PATH:/root/anaconda3/bin #conda安装路径\n\nsource /etc/profile"
  },
  {
    "objectID": "posts/ti_mmwave_create_env_of_ccs/index.html",
    "href": "posts/ti_mmwave_create_env_of_ccs/index.html",
    "title": "create env of mmwave radar of ccs",
    "section": "",
    "text": "This article discusses how to install and configure TI’s mmWave Radar Software Development Kit (SDK) in the Code Composer Studio (CCS) development environment, so that developers can use this toolkit to implement their own radar applications. In the article, the author introduces the basic features and functions of the mmWave Radar SDK, as well as how to configure the relevant environment variables and paths in CCS to successfully install and use the SDK. The article also provides some practical tips and suggestions to help readers better understand and use this toolkit. Overall, this article provides useful information and guidance for developers who want to use CCS and TI mmWave radar to develop their own radar applications"
  },
  {
    "objectID": "posts/ti_mmwave_create_env_of_ccs/index.html#install-ccs.exe",
    "href": "posts/ti_mmwave_create_env_of_ccs/index.html#install-ccs.exe",
    "title": "create env of mmwave radar of ccs",
    "section": "1. install ccs.exe",
    "text": "1. install ccs.exe"
  },
  {
    "objectID": "posts/ti_mmwave_create_env_of_ccs/index.html#install-mmwave_sdk.exe",
    "href": "posts/ti_mmwave_create_env_of_ccs/index.html#install-mmwave_sdk.exe",
    "title": "create env of mmwave radar of ccs",
    "section": "2. install mmwave_sdk.exe",
    "text": "2. install mmwave_sdk.exe"
  },
  {
    "objectID": "posts/ti_mmwave_create_env_of_ccs/index.html#install-radar-tool-box",
    "href": "posts/ti_mmwave_create_env_of_ccs/index.html#install-radar-tool-box",
    "title": "create env of mmwave radar of ccs",
    "section": "3. install radar tool box",
    "text": "3. install radar tool box\nopen ccs.exe -&gt; view -&gt; resources Explorer\n\n-&gt; install"
  },
  {
    "objectID": "posts/javaGUI--列表框 JList/index.html",
    "href": "posts/javaGUI--列表框 JList/index.html",
    "title": "javaGUI–列表框 JList",
    "section": "",
    "text": "注意动态写入和静态写入\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.Vector;\n\npublic class JComboBoxDemo02 extends JFrame {\n    public JComboBoxDemo02() {\n        this.setBounds(100,100,400,200);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        //String[] contents = {\"1\",\"2\",\"3\"}; // 静态的写入\n        Vector&lt;Object&gt; contents = new Vector&lt;&gt;();//动态写入\n        contents.add(\"tom\");\n        contents.add(\"jack\");\n        contents.add(\"lili\");\n        contents.add(\"加载完成\");\n\n\n        JList&lt;Object&gt; list = new JList&lt;&gt;(contents);\n        Container container = this.getContentPane();\n        container.add(list);\n\n    }\n\n    public static void main(String[] args)  {\n        new JComboBoxDemo02();\n    }\n\n}"
  },
  {
    "objectID": "posts/cod_sensor/index.html",
    "href": "posts/cod_sensor/index.html",
    "title": "cod sensor getting started",
    "section": "",
    "text": "The conductivity sensor is vital for liquid analysis. Understanding its working principle is crucial for efficient measurement tools. It induces current through an electric field in the liquid, reflecting ion concentration and conductivity. This knowledge guides advanced sensor development, enhancing sensitivity and stability. By fusing electronics with physics, these sensors play a key role in environmental monitoring, water analysis, and industrial automation, boosting efficiency and quality."
  },
  {
    "objectID": "posts/cod_sensor/index.html#标准溶液",
    "href": "posts/cod_sensor/index.html#标准溶液",
    "title": "cod sensor getting started",
    "section": "标准溶液",
    "text": "标准溶液\n氯化钾溶液\n配置方法\n配好的标准溶液: 雷磁: https://item.jd.com/34306782421.html 梅特勒: https://i-item.jd.com/100040781043.html ## 电导率传感器原理\n电导率表示物质导电的性能。电导率越大则导电性能越强，反之越小。\n电导的基本单位是西门子（S），原来被称为姆欧，取电阻单位欧姆倒数之意（电阻率的倒数为电导率）。\n\n电导率计算 电导率常数 K= L/A 其中：A-测量电极的有效极板，L-两极板的距离。 这一值则被称为电极常数。在电极间存在均匀电场的情况下,电极常数可以通过几何尺寸算出。 当两个面积为1cm^2的方形极板，之间相隔1cm组成电极时，此电极的常数 K=1cm^-1。如果用此对电极测得电导值 G=1000μS，则被测溶液的电导率 K=1000 μS/cm。\n\n\n标准溶液 标准溶液一般都使用KCl（氯化钾）溶液，这是因为KCl的电导率的不同的温度和浓度情况下非常稳定，准确。0.1 mol/l的KCl溶液在25℃时电导率为12.88mS/CM。\n\n\n工作原理 当液体中存在离子（如溶解的盐、酸、碱等）时，这些离子会在电场的作用下移动。正离子会朝着负极移动，负离子会朝着正极移动。这种离子的移动导致了电流在液体中的流动。电导率仪测量在液体中产生的电流强度。电流的强度与液体中的离子浓度以及电场强度之间存在关系。通常，电导率仪会将测量到的电流转换为数字信号，以便进一步处理和显示。\n电子单元采用适当频率的交流信号的方法，将信号放大处理后换算成电导率。仪器中还配有与传器相匹配的温度测量系统，能补偿到标准温度电导率的温度补偿系统、温度系数调节系统以及电导池常数调节系统，以及自动换档功能等。\n\n\n电导率仪的电导电极的种类 由二个电极组成的测量电极被称为科尔劳施（Kohlrausch）电极。"
  },
  {
    "objectID": "posts/cod_sensor/index.html#竞品对比",
    "href": "posts/cod_sensor/index.html#竞品对比",
    "title": "cod sensor getting started",
    "section": "竞品对比",
    "text": "竞品对比\n奇崛电子\n\n\n蛙视\n\n\n凯米斯\n\n禹山"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html",
    "href": "posts/电动车头盔检测系统(毕设)/index.html",
    "title": "电动车头盔检测系统(毕设)",
    "section": "",
    "text": "技术选型:\nyolov5+pyqt+mysql"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#信息采集",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#信息采集",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.1信息采集",
    "text": "1.1信息采集\n字段\n录入\n展示\n修改\n删除"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#实时检测报警",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#实时检测报警",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.2实时检测报警",
    "text": "1.2实时检测报警\n实时画面\n违章信息"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#视频留存管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#视频留存管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "1.3视频留存管理模块",
    "text": "1.3视频留存管理模块\n视频保存\n视频列表\n时间查询"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#工作人员管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#工作人员管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "2.1工作人员管理模块",
    "text": "2.1工作人员管理模块\n登陆面板\n人员管理:CRUD"
  },
  {
    "objectID": "posts/电动车头盔检测系统(毕设)/index.html#违法信息管理模块",
    "href": "posts/电动车头盔检测系统(毕设)/index.html#违法信息管理模块",
    "title": "电动车头盔检测系统(毕设)",
    "section": "2.2违法信息管理模块",
    "text": "2.2违法信息管理模块\n发送违章信息[ 时间, 地点, 原因 ]\n(违法信息通过电动车车牌追踪到人并打印通知单)\n方案1:邮件通知\n方案2:短信通知(推荐)"
  },
  {
    "objectID": "posts/nb_iot_shadow_device/index.html",
    "href": "posts/nb_iot_shadow_device/index.html",
    "title": "nb-iot of shadow device",
    "section": "",
    "text": "Abstract\nThis article explores the application of NB-IoT technology in the Internet of Things and highlights the Shadow device and data synchronization features provided by the Aliyun platform. NB-IoT is a low-power, wide-coverage communication technology for large-scale IoT devices. The Shadow device facilitates real-time synchronization and remote control of device status, while data synchronization enables efficient monitoring and management of IoT devices. These technologies offer an effective solution for IoT applications.\n\n\nReferance\naliyun 帮助手册\n\n\n准备\n已在阿里云新建设备\n\n\n属性上报数据格式\n{\n    \"method\": \"update\", \n    \"state\": {\n        \"reported\": {\n            \"z\": -1\n        }\n    }, \n    \"version\": 1\n}\n\n\n设备主动获取\n先订阅 /shadow/get/ProductKey/DeviceName\nAT+QMTSUB=0,1,\"/shadow/get/ProductKey/DeviceName\",1\\r\\n\n在发布 /shadow/update/ProductKey/DeviceName\nAT+QMTPUB=0,1,1,0,\"/shadow/update/ProductKey/DeviceName\"\\r\\n\n\n# 发布内容\n{\n    \"method\": \"get\"\n}\n\n# 按照16进制发送\n\\x1a"
  },
  {
    "objectID": "posts/Pycharm环境配置/index.html",
    "href": "posts/Pycharm环境配置/index.html",
    "title": "Pycharm环境配置",
    "section": "",
    "text": "一、打开设置 ①file–&gt;settings  ②File | Settings | Project: ‘项目名’| Project Interpreter \n二、找到你的Python所在位置 ①第一种：创建项目专属新环境  ②找到python.exe所在位置  ①第二种：不使用新环境，使用旧的环境（这样搞容易出问题）  ③最后点ok，pycharm基本上就ok了。"
  },
  {
    "objectID": "posts/EMD/index.html",
    "href": "posts/EMD/index.html",
    "title": "Empirical Mode Decomposition",
    "section": "",
    "text": "An unsupervised signal analysis method for decomposing and feature extraction of complex signals. The algorithm decomposes signals iteratively by constructing modal functions."
  },
  {
    "objectID": "posts/EMD/index.html#生成信号",
    "href": "posts/EMD/index.html#生成信号",
    "title": "Empirical Mode Decomposition",
    "section": "生成信号",
    "text": "生成信号\nt = 2;  % 2 s\nfs = 1000;      % 采样1000hz\nts = 0:1/fs:t;\n\nsig_low2high = chirp(ts,50,2,300);  %50hz 升频道300hz  时间2s\nsig_high2low = chirp(ts,300,2,50);  %300hz 降频道50hz  时间2s"
  },
  {
    "objectID": "posts/EMD/index.html#打开信号分析器",
    "href": "posts/EMD/index.html#打开信号分析器",
    "title": "Empirical Mode Decomposition",
    "section": "打开信号分析器",
    "text": "打开信号分析器\n\n1. 导入信号\n\n\n\n2. 设置采样率\n左侧变量窗口, 右键-&gt; 设置时间.\n\n导入完成\n从频谱图上我们很难看出他们的频率变化, 所以有了短时傅里叶变换. \n打开是频图, 就能够很清晰的看到各个时间的频率变化."
  },
  {
    "objectID": "posts/esp32_dev_1/index.html",
    "href": "posts/esp32_dev_1/index.html",
    "title": "design an esp32 development Board",
    "section": "",
    "text": "learning so much mcu with development Board of official. this time i want to learn how to design a\ndevelemopment board. This need EDA software like AD. But LCEDA is very sample to use."
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#设计完成",
    "href": "posts/esp32_dev_1/index.html#设计完成",
    "title": "design an esp32 development Board",
    "section": "设计完成",
    "text": "设计完成"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#eda",
    "href": "posts/esp32_dev_1/index.html#eda",
    "title": "design an esp32 development Board",
    "section": "0.EDA",
    "text": "0.EDA\n\n立创EDA\n\n不得不说立创EDA对我这个第一次画pcb的人来说真好用，总结以下要点。\n\n 先设置规则， 设置规则避免不了线宽，过孔设置，但是芯片datasheet中的参数好像都比较严苛，但是我想要白嫖嘉立创的免费打样，就得  根据厂商的工艺参数来 .\nGND和电源网络先隐藏最后布\nGND最好走线连接，我想当然，最后铺铜就可以了，结果有很多游离铜块。\n信号线尽量避开电源线\n个人理解双层板顶层根据芯片走线方向控制一致， 我的板子应该是顶层水平和芯片那里的走线保持一致。 两层之间的走线最好垂直，最好不要有平行线尤其是电源线。 \n放置缝合孔，尽量连接尽可能多的GND， 保证信号的完整性。\n推荐在信号两侧布置过孔提高抗干扰能力。\n使用禁用区域，禁用铺铜，避免游离铜块\n丝印层字体最小线宽5mil，高度40mil，在小就看不清楚了。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#电源power",
    "href": "posts/esp32_dev_1/index.html#电源power",
    "title": "design an esp32 development Board",
    "section": "1.电源（power）",
    "text": "1.电源（power）\n参考立创开源项目上的电源方案， 使用ASM的3.3VLDO（0.23RMB），该方案根据手册推荐， 使用了两颗钽电容。（0.5+0.4RMB）， 焊接的时候上电冒烟了我才想起来查一下，钽电容的方向，想当然了，以为电容都没方向。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#usb使用type-c",
    "href": "posts/esp32_dev_1/index.html#usb使用type-c",
    "title": "design an esp32 development Board",
    "section": "2. USB使用type-c",
    "text": "2. USB使用type-c\n看了别人推荐的micro-usb，还是上了type-c，烙铁焊接的时候还是有点难度，引脚容易粘连，不过我用吸锡带拖了一遍粘连，效果非常不错。图便宜买的便宜的母座，发现很涩。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#复位按钮",
    "href": "posts/esp32_dev_1/index.html#复位按钮",
    "title": "design an esp32 development Board",
    "section": "复位按钮",
    "text": "复位按钮\n白按钮，淘宝有货，但是运费太贵了，2毛一个按钮，快递费8块，没办法还是多买点吧，买了60个，下次画板子一定先去看元器件。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#串口芯片",
    "href": "posts/esp32_dev_1/index.html#串口芯片",
    "title": "design an esp32 development Board",
    "section": "串口芯片",
    "text": "串口芯片\nCH340K（2.2RMB），电烙铁焊接的时候有点难度，因为芯片底面有个GND，烙铁放不下去，不过办法总比困难多， 先给焊盘上锡，然后焊锡融化快速将芯片推到位，一定要快，要不然芯片会歪在pcb上，其他引脚无法对齐。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#led",
    "href": "posts/esp32_dev_1/index.html#led",
    "title": "design an esp32 development Board",
    "section": "LED",
    "text": "LED\n和esp s3的开发板一致，都是WS2812，该芯片的优点是只占用了一个gpio，可以实现RGB的控制，但是成本也比较贵。参考了别人的设计对比芯片手册给出的设计，参考开源设计上用的是3.3 v供电，可是手册上的是5v，于是我选用了5v，上电测试后发现太亮了，爆闪，大意了。看看后续用pwm调一下。引脚还设计错了设置成IO38了，开发板是IO48。"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#注入灵魂烧录程序",
    "href": "posts/esp32_dev_1/index.html#注入灵魂烧录程序",
    "title": "design an esp32 development Board",
    "section": "注入灵魂（烧录程序）",
    "text": "注入灵魂（烧录程序）\n第一次上电发现板子一直重启，不知道怎么回事，以为电源芯片不行，供电不足，后更换可调电源输出3.3v还是一样，于是排查复位电路，全部拆除依旧重启，后连接串口助手波特率9600强行连接（OTG的串口，自带的那个不是走ch340的那个），发现一些报错， 后去搜索，发现bilibili的一个帖子，说到Strapping引脚，将IO0，和IO46进行拉低，即可解决问题，当时我才反应过来，会不会是因为flash里面没有内容，程序错误，所以导致的这个报错，IO0拉低不就是板子上的boot按钮嘛，于是恍然明白，进boot然后烧录程序即可。\n进到example\nidf.py settarge esp32s3\n\nidf.py build\n\nidf.py -p COMx"
  },
  {
    "objectID": "posts/esp32_dev_1/index.html#元器件购买",
    "href": "posts/esp32_dev_1/index.html#元器件购买",
    "title": "design an esp32 development Board",
    "section": "元器件购买",
    "text": "元器件购买"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html",
    "href": "posts/Spring简单使用（依赖注入）/index.html",
    "title": "Spring简单使用（依赖注入）",
    "section": "",
    "text": "IOC（Inversion of Control）:控制反转\n 创建对象的方式改变了，以前是new创建对象，现在时通过Spring创建对象\nAOP（Aspect Oriented Programming）:面向切片编程\n创建代码会有很多重复的部分，如异常处理、日志等。只需要写一遍，利用aop写入程序中"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring",
    "title": "Spring简单使用（依赖注入）",
    "section": "",
    "text": "IOC（Inversion of Control）:控制反转\n 创建对象的方式改变了，以前是new创建对象，现在时通过Spring创建对象\nAOP（Aspect Oriented Programming）:面向切片编程\n创建代码会有很多重复的部分，如异常处理、日志等。只需要写一遍，利用aop写入程序中"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring核心包",
    "text": "spring核心包\nbeans：bean管理 Context：上下文（体现在xml配置） Expression Language：spring EL表达式 Core：spring框架核心"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring入门程序",
    "text": "spring入门程序\nUserDao.java\npackage cn.edu.usts.spring;\n\npublic class UserDao {\npublic  void say() {\n    System.out.println(\"spring test！！\");\n}\n}\napplicationContext.xml\nspring-framework-4.3.6.RELEASE-dist\\spring-framework-4.3.6.RELEASE\\docs\\spring-framework-reference\\html\\index.html------&gt;7.2.1\n\n\n\n在这里插入图片描述\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\"&gt;\n\n    &lt;bean id=\"userDao\" class=\"cn.edu.usts.spring.UserDao\"&gt;&lt;/bean&gt;\n\n&lt;/beans&gt;\n\nTest,java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport cn.edu.usts.spring.UserDao;\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        // 实例化容器\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        // 通过容器获取实例\n        UserDao userDao = (UserDao)applicationContext.getBean(\"userDao\");\n        // 使用实例中方法\n        userDao.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "href": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "title": "Spring简单使用（依赖注入）",
    "section": "通过set方法进行依赖注入",
    "text": "通过set方法进行依赖注入\nUserService.java\npackage cn.edu.usts.spring;\n\npublic class UserService {\n    public UserDao userDao;\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n\n\n    public void say(){\n        System.out.println(\"userService say test!!!\");\n        this.userDao.say();\n    }\n}\napplicationContext.xml\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}\nTest.java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/java和-- Collections工具类/index.html",
    "href": "posts/java和-- Collections工具类/index.html",
    "title": "java和– Collections工具类",
    "section": "",
    "text": "Collections工具类\npackage cn.usts.edu.collections;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/**\n * @author ：fly\n * @description: 集合工具类\n * @date ：2021/11/3 16:20\n */\npublic class CollectionsDemo {\n\n    public static void main(String[] args) {\n        ArrayList al = new ArrayList();\n        al.add(\"tom\");\n        al.add(\"tom\");\n        al.add(\"jack\");\n        al.add(\"al\");\n        al.add(\"swallow\");\n\n        System.out.println(\"正常顺序\");\n        System.out.println(al);\n\n        // 位置交换\n        System.out.println(\"=========0,最后 位置交换=======\");\n        Collections.swap(al,0,al.size()-1);// 0,最后 位置交换\n        System.out.println(al);\n\n        System.out.println(\"=========逆序=======\");\n        Collections.reverse(al);\n        System.out.println(\"逆序:\"+al);\n\n        // 随机排序\n        System.out.println(\"=========随机排序=======\");\n        Collections.shuffle(al);\n        System.out.println(al);\n\n        // 自然顺序\n        System.out.println(\"=========自然顺序=======\");\n        Collections.sort(al);\n        System.out.println(al);\n\n\n        // 自定义排序\n        System.out.println(\"=========自定义排序(字符大到小)=======\");\n        Collections.sort(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if(o1 instanceof String) { // 校验是否是String\n                    return ((String) o2).compareTo((String) o1);\n                }\n                return 0;\n            }\n        });\n        System.out.println(al);\n\n\n        System.out.println(\"=========自定义排序(长度大到小)=======\");\n        Collections.sort(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String) o2).length() - (((String) o1).length());\n            }\n        });\n        System.out.println(al);\n\n\n        // 自然排序最大值\n        System.out.println(\"=========自定义(长度最大)=======\");\n        Object max = Collections.max(al, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String) o1).length() - (((String) o2).length());\n            }\n        });\n        System.out.println(max);\n\n        // 自定义最大值\n        System.out.println(\"=========自然排序最大值=======\");\n        Comparable max1 = Collections.max(al);\n        System.out.println(max1);\n\n\n        // 同理max(),自定义也同理\n//        Collections.min();\n\n\n        // 出现次数\n        System.out.println(\"=========出现次数=======\");\n        int tomTimes = Collections.frequency(al, \"tom\");\n        System.out.println(\"tom出现:\"+tomTimes+\"次\");\n\n\n        // 复制\n        System.out.println(\"=========复制数组=======\");\n        ArrayList bal = new ArrayList();\n        for (Object o : al) {\n            bal.add(\"\"); // 新的数组默认为零,不填充空的数据,回报数组Index越界\n        }\n        Collections.copy(bal,al);\n        System.out.println(bal);\n\n        //替换\n        System.out.println(\"=========替换元素=======\");\n        Collections.replaceAll(al,\"tom\",\"汤姆\");\n        System.out.println(al);\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java多线程-- thread.getState() 查看线程状态/index.html",
    "href": "posts/java多线程-- thread.getState() 查看线程状态/index.html",
    "title": "java多线程– thread.getState() 查看线程状态",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\n/**\n * 一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。\n *\n * 线程状态。 线程可以处于以下状态之一：\n * NEW              尚未启动的线程处于此状态。\n * RUNNABLE         在Java虚拟机中执行的线程处于此状态。\n * BLOCKED          被阻塞等待监视器锁定的线程处于此状态。\n * WAITING          正在等待另一个线程执行特定动作的线程处于此状态。\n * TIMED_WAITING    正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\n * TERMINATED       已退出的线程处于此状态。\n *\n *\n * */\n\npublic class ThreadStateDemo implements Runnable {\n    @Override\n    public void run() {\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(\n                // lambda表达式实现的run方法.\n                ()-&gt;{\n            for (int i = 0; i &lt; 5; i++) {\n                try {\n                    Thread.sleep(1000);// 延时1s\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"------------------\");\n        });\n\n\n        System.out.println(thread.getState()); // 获取启动前的状态\n\n        // 线程启动\n        thread.start();\n        System.out.println(thread.getState());// 获取启动时的状态\n\n        while (thread.getState()!=Thread.State.TERMINATED){\n            Thread.sleep(900); // 延时100ms刷新状态\n            System.out.println(thread.getState());\n\n        }\n    }\n}"
  },
  {
    "objectID": "posts/esp8266--04 继电器没有反应/index.html",
    "href": "posts/esp8266--04 继电器没有反应/index.html",
    "title": "esp8266–04 继电器没有反应",
    "section": "",
    "text": "esp8266 nodemcu 采用板子上的5v(VU)供电,尽量避免使用5v供电上的GND引脚."
  },
  {
    "objectID": "posts/esp8266--04 继电器没有反应/index.html#继电器踩坑",
    "href": "posts/esp8266--04 继电器没有反应/index.html#继电器踩坑",
    "title": "esp8266–04 继电器没有反应",
    "section": "",
    "text": "esp8266 nodemcu 采用板子上的5v(VU)供电,尽量避免使用5v供电上的GND引脚."
  },
  {
    "objectID": "posts/stm32芯片开发包/index.html",
    "href": "posts/stm32芯片开发包/index.html",
    "title": "stm32芯片开发包",
    "section": "",
    "text": "stm32芯片开发包\nhttps://www.keil.com/dd2/pack/#!#eula-container\n\n\n固件库\nhttps://blog.csdn.net/cbkdgq/article/details/88076843   ## RCC - 218  ODR -269"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html",
    "href": "posts/java注解和反射-- 反射/index.html",
    "title": "java注解和反射– 反射",
    "section": "",
    "text": "是一类在运行时可以改变其结构的语言∶例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。\n通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n主要动态语言:Object-C、C#、JavaScript、PHP、Python等。"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html#动态语言",
    "href": "posts/java注解和反射-- 反射/index.html#动态语言",
    "title": "java注解和反射– 反射",
    "section": "",
    "text": "是一类在运行时可以改变其结构的语言∶例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。\n通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n主要动态语言:Object-C、C#、JavaScript、PHP、Python等。"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html#静态语言",
    "href": "posts/java注解和反射-- 反射/index.html#静态语言",
    "title": "java注解和反射– 反射",
    "section": "静态语言",
    "text": "静态语言\n与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C+ Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!"
  },
  {
    "objectID": "posts/java注解和反射-- 反射/index.html#反射",
    "href": "posts/java注解和反射-- 反射/index.html#反射",
    "title": "java注解和反射– 反射",
    "section": "反射",
    "text": "反射\n通过Reflection的api操作实例化出来的对象从而获得对象内部的属性和方法,从而对对象进行操作. 反射例子 \npackage cn.usts.edu.Reflection03;\n\n/**\n * 一个类在内存中只有一个class对象唯一的\n *  反射的原理:\n *      所有的类都有一个公共的祖宗类,都是Class的子类,所以根据他的父类可以倒退找到他的子类\n *      从而调用到子类中到方法和属性\n * */\n\npublic class ReflectionDemo {\n\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        System.out.println(c1);\n        Class c2 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c3 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c4 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n        Class c5 = Class.forName(\"cn.usts.edu.Reflection03.User\");\n\n        // 一个类在内存中只有一个class对象\n        // 一个类被加载后,类的整个结构都会被封装在class对象中,所以他们的哈希值是一样的\n        System.out.println(c1.hashCode());\n        System.out.println(c2.hashCode());\n        System.out.println(c3.hashCode());\n        System.out.println(c4.hashCode());\n        System.out.println(c5.hashCode());\n    }\n\n}\n\n\n\n// 实体类,pojo,entity\nclass User{\n    private int age;\n    private int id;\n    private String name;\n\n    public User(int age, int id, String name) {\n        this.age = age;\n        this.id = id;\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/安卓7以上安装系统证书(system分区没有权限)/index.html",
    "href": "posts/安卓7以上安装系统证书(system分区没有权限)/index.html",
    "title": "安卓7以上安装系统证书(system分区没有权限)",
    "section": "",
    "text": "试验环境 小米8 已root 安卓9 system分区没有修改权限大概率是没有remount\n\n\n下载安装openssl https://jszhuanben.lanzouy.com/iPxBM0bb6gni 添加及环境变量(openssl所在目录)\n\n\n获取系统证书 - 从抓包软件中获取证书(charles,fiddler等)\n\n &gt;- 将证书文件重新命名为hash.0\nopenssl x509 -subject_hash_old -in Charles.pem\n \n\n将文件放入系统证书目录中\n\n\n利用adb的shell进行操作\n\n# 修改system分区为可读写\nmount -o remount,rw /system\n\n# 移动文件到系统证书目录(文件已经通过拖拉放到手机上了anlink)\nmv 0c454880.0 /system/etc/security/cacerts\n \n# 修改文件权限\nchmod 644 /system/etc/security/cacerts/0c454880.0\n\n查看证书 - 可以查看到证书才算成功\n\n \n\n后续的操作就是正常的charles代理的设置, 设置wifi代理ip和端口,就不叙述了"
  },
  {
    "objectID": "posts/C语言的指针理解问题/index.html",
    "href": "posts/C语言的指针理解问题/index.html",
    "title": "C语言的指针理解问题",
    "section": "",
    "text": "对于c语言中的指针有两种写法, * 靠进类型和靠近变量, 如下\n\nint* p1;\nint *p2;\n有的理解说是p1 是int*类型, 其实不然, 这两种表达的都是*p的类型是int ,这样理解起来非常顺畅, 那取地址&也很清晰了.\n\n一个指针变量在没有赋值(设置地址)时,是不可以通过该指针访问其他变量的!!!! 下面这段代码表示这个指针中的值是一个随机的一个值,随机访问,就代表随机访问一块内存,并修改其中的值为10, 这将导致严重问题.\n\nint *p;\n*p = 10; // 绝对不可以!!!!!!!!"
  },
  {
    "objectID": "posts/java多线程-- yield 线程礼让/index.html",
    "href": "posts/java多线程-- yield 线程礼让/index.html",
    "title": "java多线程– yield 线程礼让",
    "section": "",
    "text": "加上礼让大概率会让被礼让的先执行.不是一定被礼让的先执行 \npackage cn.usts.edu.lesson06;\n\n/**\n * 线程礼让\n * 礼让的线程会重新和竞争的线程再次公平竞争cpu的资源\n * 再次竞争的结果为最后结果\n * */\n\npublic class ThreadYieldDemo implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"开始\");\n        if (Thread.currentThread().getName().equals(\"线程A\")){ // 如果是线程A就礼让\n            Thread.yield();// 线程礼让\n        }\n        System.out.println(Thread.currentThread().getName()+\"执行结束\");\n    }\n\n    public static void main(String[] args) {\n        ThreadYieldDemo threadYieldDemo = new ThreadYieldDemo();\n        new Thread(threadYieldDemo,\"线程A\").start();\n        new Thread(threadYieldDemo,\"线程B\").start();\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- yield 线程礼让/index.html#yield-线程礼让",
    "href": "posts/java多线程-- yield 线程礼让/index.html#yield-线程礼让",
    "title": "java多线程– yield 线程礼让",
    "section": "",
    "text": "加上礼让大概率会让被礼让的先执行.不是一定被礼让的先执行 \npackage cn.usts.edu.lesson06;\n\n/**\n * 线程礼让\n * 礼让的线程会重新和竞争的线程再次公平竞争cpu的资源\n * 再次竞争的结果为最后结果\n * */\n\npublic class ThreadYieldDemo implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"开始\");\n        if (Thread.currentThread().getName().equals(\"线程A\")){ // 如果是线程A就礼让\n            Thread.yield();// 线程礼让\n        }\n        System.out.println(Thread.currentThread().getName()+\"执行结束\");\n    }\n\n    public static void main(String[] args) {\n        ThreadYieldDemo threadYieldDemo = new ThreadYieldDemo();\n        new Thread(threadYieldDemo,\"线程A\").start();\n        new Thread(threadYieldDemo,\"线程B\").start();\n    }\n}"
  },
  {
    "objectID": "posts/pico_power_supply/index.html",
    "href": "posts/pico_power_supply/index.html",
    "title": "rp2040 power supply",
    "section": "",
    "text": "Abstract\npower supply of pico and how to set power of application.\n\n\nReferance\npico sdk datasheet\n\n\n\nname\nlevel\n\n\n\n\nIOVDD\n1.8~3.3v\n\n\nDVDD\n1.1v\n\n\nVIN\n3.3v\n\n\nVIOUT\n1.1v\n\n\nUSB\n3.3v\n\n\nADC\n1.8 or 3.3v(√)\n\n\n\nVIN,VOUT是内部降压芯片可用可不用, 但是不用也要有个输入.\nUSB的供电是3.3v 如果应用没有usb的需求和话随便给电\nADC推荐3.3v\nDVDD 是内部电压 1.1v IOVDD 可以设1.8~3.3v都行,但是设置为1.8的时候再给上3.3v可能会导致芯片报废."
  },
  {
    "objectID": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html",
    "href": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html",
    "title": "java多线程– sleep实现 ( 时间刷新 , 模拟倒计时)",
    "section": "",
    "text": "时间刷新\n模拟倒计时 ## 时间刷新"
  },
  {
    "objectID": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html#模拟倒计时",
    "href": "posts/java多线程-- sleep实现 ( 时间刷新 , 模拟倒计时)/index.html#模拟倒计时",
    "title": "java多线程– sleep实现 ( 时间刷新 , 模拟倒计时)",
    "section": "模拟倒计时",
    "text": "模拟倒计时\n\n\n\n在这里插入图片描述\n\n\n // 模拟倒计时\n    @Test\n    public void tenSecondFlush(){\n        int num = 10;\n        while (true){\n            if (num &lt;= 0) {\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n                System.out.println(num--);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n\n        }\n    }"
  },
  {
    "objectID": "posts/C语言状态传递,通过指针判断并带回结果/index.html",
    "href": "posts/C语言状态传递,通过指针判断并带回结果/index.html",
    "title": "C语言状态传递,通过指针判断并带回结果",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/java基础知识（笔记）/index.html",
    "href": "posts/java基础知识（笔记）/index.html",
    "title": "java基础知识（笔记）",
    "section": "",
    "text": "1、打开cmd执行javac HelloWorld 的执行原理\n* jiava.exe 命令启动jvm（java虚拟机）\n* jvm启动之后会启动类加载器（classLoader）\n* classLoader会在硬盘上的某个文职搜索HelloWorld.class字节码文件\n* 找到改文件执行\n* 找不到该文件报错\n\n\n疑问：classLoader实在哪个位置上搜素HelloWorld.class字节码文件的？\n    * 默认情况下，classLoader从当前路径下加载xxx.class 字节码文件的\n    * 也可以让classLoader去某个指定的路径下加载字节码文件，这是需要配置环境变量classpath\n    * classpath环境属于java语言中的环境变量，不属于windows操作系统【path环境变量属于操作系统】\n    * classpath是给classLoader类加载器指订路径的\n    * 设置这样环境变量： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n    - 在任意位置打开cmd，都可以执行，java HelloWorld\n    * classpath环境变量没有配置的话，类加载器默认都会从当前路径下找字节码文件（xx.class文件）\n    * 从上所述，环境变量classpath不用配置，这样类加载器会自动从当前路径下加载class字节码文件。所以，每一次执行.class文件程序的时候，都需要在dos命令窗口中先切换到.class字节码文件所在的路径下，然后运行。\n2、关于java源程序中的注释\n* 什么是注释？注释的作用是什么？\n    - 出现在java的源程序中，对java的作用是什么？\n    - 只是不会被编译到.class文件中\n    - 一个好的开发习惯应该是多编写注释，这样代码的的可读性比较高\n* java中的注释怎么写\n\n\n    - 单行注释，只注释当前行\n        // 单行注释，只注释当行\n\n\n\n    - 多行注释\n        /*\n            多行注释\n            多行注释\n            多行注释\n        */\n        \n\n    - javadoc注释\n        /**\n        * javadoc注释\n        * javadoc注释\n        * javadoc注释\n        **/\n3、对HelloWorld程序进行解释： 需要记忆\n* public\n    * class\n    * static \n    * void \n    * System.out.println(\"\"); 向控制台输出消息\n    * 类体\n    * 方法体\n    * 类体中不能直接编辑java语句【除了声明变量】\n    * 一个java语句必须以；结尾\n    * 方法体中可以编写多条java语句\n    * 主方法是程序的入口，固定写法，sun公司规定的\n4、public class 和class 的区别：\n    * 一个java源文件当中可以定义多个class\n    * 一个java源文件中public的class不是必须的，可以没有public class\n    * 一个class会定义生成一个xxx.class 字节码文件\n    * 一个java源文件当中定义公开的类（public class）的话，只能有一个，并且雷鸣必须和java的源文件名一致。\n    *  每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，想执行X.class中的main方法，java X\n    * 注意：当在命令窗口中执行java.Hello，name要求Hello.class中必须有主方法。没有主方法运行会报找不到主方法错发。"
  },
  {
    "objectID": "posts/java基础知识（笔记）/index.html#第一章",
    "href": "posts/java基础知识（笔记）/index.html#第一章",
    "title": "java基础知识（笔记）",
    "section": "",
    "text": "1、打开cmd执行javac HelloWorld 的执行原理\n* jiava.exe 命令启动jvm（java虚拟机）\n* jvm启动之后会启动类加载器（classLoader）\n* classLoader会在硬盘上的某个文职搜索HelloWorld.class字节码文件\n* 找到改文件执行\n* 找不到该文件报错\n\n\n疑问：classLoader实在哪个位置上搜素HelloWorld.class字节码文件的？\n    * 默认情况下，classLoader从当前路径下加载xxx.class 字节码文件的\n    * 也可以让classLoader去某个指定的路径下加载字节码文件，这是需要配置环境变量classpath\n    * classpath环境属于java语言中的环境变量，不属于windows操作系统【path环境变量属于操作系统】\n    * classpath是给classLoader类加载器指订路径的\n    * 设置这样环境变量： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n    - 在任意位置打开cmd，都可以执行，java HelloWorld\n    * classpath环境变量没有配置的话，类加载器默认都会从当前路径下找字节码文件（xx.class文件）\n    * 从上所述，环境变量classpath不用配置，这样类加载器会自动从当前路径下加载class字节码文件。所以，每一次执行.class文件程序的时候，都需要在dos命令窗口中先切换到.class字节码文件所在的路径下，然后运行。\n2、关于java源程序中的注释\n* 什么是注释？注释的作用是什么？\n    - 出现在java的源程序中，对java的作用是什么？\n    - 只是不会被编译到.class文件中\n    - 一个好的开发习惯应该是多编写注释，这样代码的的可读性比较高\n* java中的注释怎么写\n\n\n    - 单行注释，只注释当前行\n        // 单行注释，只注释当行\n\n\n\n    - 多行注释\n        /*\n            多行注释\n            多行注释\n            多行注释\n        */\n        \n\n    - javadoc注释\n        /**\n        * javadoc注释\n        * javadoc注释\n        * javadoc注释\n        **/\n3、对HelloWorld程序进行解释： 需要记忆\n* public\n    * class\n    * static \n    * void \n    * System.out.println(\"\"); 向控制台输出消息\n    * 类体\n    * 方法体\n    * 类体中不能直接编辑java语句【除了声明变量】\n    * 一个java语句必须以；结尾\n    * 方法体中可以编写多条java语句\n    * 主方法是程序的入口，固定写法，sun公司规定的\n4、public class 和class 的区别：\n    * 一个java源文件当中可以定义多个class\n    * 一个java源文件中public的class不是必须的，可以没有public class\n    * 一个class会定义生成一个xxx.class 字节码文件\n    * 一个java源文件当中定义公开的类（public class）的话，只能有一个，并且雷鸣必须和java的源文件名一致。\n    *  每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，想执行X.class中的main方法，java X\n    * 注意：当在命令窗口中执行java.Hello，name要求Hello.class中必须有主方法。没有主方法运行会报找不到主方法错发。"
  },
  {
    "objectID": "posts/java基础知识（笔记）/index.html#第二章",
    "href": "posts/java基础知识（笔记）/index.html#第二章",
    "title": "java基础知识（笔记）",
    "section": "第二章",
    "text": "第二章\n1、标识符\njava当中凡是可以自己起名字的单词都是标识符【类名、方法名、接口名、变量名、常量名、、、、、】\n标识符的命名队则: ①标识符必须要由数字、字母、下划线组成，不能含有其他字符。 ②不能由数字开头 ③严格区分大小写 ④关键字不能做标识符\n2、关键字\n具有特殊含义的单词，提前制定好的。\n全部小写\n如：public、static、void 、、、、、、\n3、字面值\n数字、字符、字符串、、、、\n通俗的说字面值就是数据\n4、变量\n内存中存储数据最基本的单元\n    * 每一个变量都由三部分组成\n        - 数据类型\n        - 变量名\n        - 存储的相关数据\n        \n    * 可以重复读取\n    * 变量存储的数据要和变量的类型是一致的\n    * 在同一个作用域内变量不能重名\n    * 声明类型和复制可以同时进行 int a = 100;\n    * 变量的作用域：出了大括号就不认识了\n    * 根据出现的位置可以分为：\n        - 局部变量： 方法体外内【花括号里面】\n        - 成员变量： 方法体之外，类体之内\n    \n5、数据类型\n作用：\n    * 指导java运行机给该变量分配多大的内存空间，不同类型的数据类型分配的内存空间大小也不一样\n    * 数据类型包括：\n        - 基本数据类型【4大类8小种】\n            四大类: 整数型（byte1,short2,int4,long8）、浮点型(float4,double8)、布尔型(boolean1)、字符型(char2)\n        - 引用数据类型【字符串型】"
  },
  {
    "objectID": "posts/config_nvim/index.html",
    "href": "posts/config_nvim/index.html",
    "title": "neovim install and config",
    "section": "",
    "text": "Abstract\ni want to code with vim but i haven’t configt that for a long time. today i make up mine mind to config vim.\n\n\nReferance\nhttps://www.youtube.com/watch?v=ctH-a-1eUME&list=PLhoH5vyxr6Qq41NFL4GvhFp-WLd5xzIzZ\nhttps://github.com/LunarVim/Neovim-from-scratch\n\n\ninstall nvim & config\nsudo pacman -S neovim\n\ngit clone https://github.com/LunarVim/Neovim-from-scratch\n\ncd neovim-from-scratch/usr\n\ngit checkout 01-options\n\nnvim options.lua\nyou can read and help from this command\n:help options\n\n:help bachup\n\n...\n\n\n\nkey map\nkey map is very usefull this will make vim like some ide\ngit checkout -b 02-keymap\n\n\nvimPlug\nplug will make you vim becom more powerfull\nnvim pulg install path is\n～/.local/share/nvim/site/pack/packer/start\n\n：packerXXXX\ninstall plugs\ncd /home/dd21/.config/nvim/lua/user\nadd pulg link this\n\ninstall markdownPreview\nuse \"iamcco/markdown-preview.nvim\"  -- 这里按照官方的命令发生vim：492错误不知道怎么回事，不添加选项没有任何问题\n\n:w\n\ncd /home/dd21/.local/share/nvim/site/pack/packer/opt/markdown-preview.nvim/app\n\nsudo pacman -S yarn \n\nyarn install \n\nnvim README.md\n# then input \n:MarkDownPreview\n\n\ncolor theme\nyou can use defualt nvim color theme\nopen the init.lua\nnvim options.lua\n\n# open the line 19 annotation\ntermguicolors = true\n\n# set the colortheme in terminal\n:colorscheme tokyonight\nyou open nvim per time to setup color theme, if you want to set for ever\nnvim ./lua/user/colorscheme.lua\nlocal colorscheme = \"tokyonight\"\n\nlocal status_ok, _ = pcall(vim.cmd, \"colorscheme \" .. colorscheme)\nif not status_ok then\n  vim.notify(\"colorscheme \" .. colorscheme .. \" not found!\")\n  return\nend\n\n\nlsp install\ncd plug.lua\n\n# install plug\n:w\n\n# show lsp install info window\nlspinstall\n\n# add with `i`\n# remove with `x`"
  },
  {
    "objectID": "posts/java_jdk安装，配置环境（win10）/index.html",
    "href": "posts/java_jdk安装，配置环境（win10）/index.html",
    "title": "java_jdk安装，配置环境（win10）",
    "section": "",
    "text": "1.打开jdk下载官网地址  2.向下翻找到自己需要的版本   3.登陆才可以下载\n找到个免费的下载账号，短期内应该可用，（从csdn中找到的，如有侵权，联系删除）\n账号：1789936303@qq.com\n密码：Oracle123456\n 4.找到下载好的jdk安装包双击安装 推荐默认安装在固态盘，一直下一步，傻瓜安装（默认安装路径C:\\Program Files\\Java）\n 5.自此jdk安装完成，配置jdk环境\n①右键我的电脑—–&gt;属性——-&gt;高级设置\n ②点击环境变量\n\n\n\n在这里插入图片描述\n\n\n③点击新建\n ④设置变量名和变量值\n ⑤上一步确定完，在下办框（系统变量）中找到path———–&gt;双击\n\n\n\n在这里插入图片描述\n\n\n⑥新建——-&gt;粘贴\n%JAVA_HOME%\\bin\n ⑦创建classpath变量 变量值从点【.】号开始复制\n变量名：  classpath\n变量值：    .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n ⑧判断是否安装成功 win+r-------&gt;cmd------&gt;java win+r-------&gt;cmd------&gt;javac 出现以下界面为成功"
  },
  {
    "objectID": "posts/git/index.html",
    "href": "posts/git/index.html",
    "title": "git",
    "section": "",
    "text": "git commit\ngit checkout HEAD git checkout pushed git checkout main\ngit reset HEAD^ git revert HEAD\ngit rebase main git branch -f main HEAD\ngit cherry-pick c1 c2 c3 git rebase -i HEAD~2"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html",
    "href": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html",
    "title": "java注解和反射– 利用反射获取类的运行时结构(属性,方法,对象,构造器)",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.getClassMethod05;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 获取类的运行时结构(属性,方法,对象,构造器)\n *               方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n * @date ：2021/10/28 14:26\n */\npublic class GetClassMethod {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class&lt;?&gt; c1 = Class.forName(\"cn.usts.edu.getClassMethod05.User\");\n\n        // 获取报名+类名\n        System.out.println(c1.getName());\n        // 获取类的名字\n        System.out.println(c1.getSimpleName());\n\n        // 获取类的属性:\n        Field[] fields = c1.getFields();// 只能获取到public修饰的属性\n        // 遍历\n        for (Field field : fields) {\n            System.out.println(field);\n        }\n\n        // 获取指定属性的值\n        Field name = c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(\"=================\");\n        Method[] methods = c1.getMethods();// 获取包括父类的所有方法\n        for (Method method : methods) {\n            System.out.println(\"包括父类的\"+method);\n        }\n\n        Method[] declaredMethods = c1.getDeclaredMethods();// 获取当前类的方法\n        for (Method declaredMethod : declaredMethods) {\n            System.out.println(\"当前类的\"+declaredMethod);\n        }\n\n        // 获取指定方法\n        System.out.println(\"============获取指定方法=========\");\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        System.out.println(method03);\n        Method method01_int = c1.getDeclaredMethod(\"method01\", int.class);\n        System.out.println(method01_int);\n        // Method method01 = c1.getDeclaredMethod(\"method01\", null); ide 推荐null不写\n        Method method01 = c1.getDeclaredMethod(\"method01\");\n        System.out.println(method01);\n\n        // 获取构造器\n        System.out.println(\"============获取构造器=========\");\n        Constructor&lt;?&gt;[] constructors = c1.getConstructors();\n        System.out.println(\"所有构造器\");\n        for (Constructor&lt;?&gt; constructor : constructors) {\n            System.out.println(constructor);\n        }\n\n        // 获取指定构造器,因为方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class, String.class);\n        System.out.println(\"指定构造器\");\n        System.out.println(declaredConstructor);\n    }\n}\n\n\n// pojo 实体类\nclass User {\n    public int age;\n    public String name;\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html#利用反射获取类的运行时结构属性方法对象构造器",
    "href": "posts/java注解和反射-- 利用反射获取类的运行时结构(属性,方法,对象,构造器)/index.html#利用反射获取类的运行时结构属性方法对象构造器",
    "title": "java注解和反射– 利用反射获取类的运行时结构(属性,方法,对象,构造器)",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.getClassMethod05;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 获取类的运行时结构(属性,方法,对象,构造器)\n *               方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n * @date ：2021/10/28 14:26\n */\npublic class GetClassMethod {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class&lt;?&gt; c1 = Class.forName(\"cn.usts.edu.getClassMethod05.User\");\n\n        // 获取报名+类名\n        System.out.println(c1.getName());\n        // 获取类的名字\n        System.out.println(c1.getSimpleName());\n\n        // 获取类的属性:\n        Field[] fields = c1.getFields();// 只能获取到public修饰的属性\n        // 遍历\n        for (Field field : fields) {\n            System.out.println(field);\n        }\n\n        // 获取指定属性的值\n        Field name = c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(\"=================\");\n        Method[] methods = c1.getMethods();// 获取包括父类的所有方法\n        for (Method method : methods) {\n            System.out.println(\"包括父类的\"+method);\n        }\n\n        Method[] declaredMethods = c1.getDeclaredMethods();// 获取当前类的方法\n        for (Method declaredMethod : declaredMethods) {\n            System.out.println(\"当前类的\"+declaredMethod);\n        }\n\n        // 获取指定方法\n        System.out.println(\"============获取指定方法=========\");\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        System.out.println(method03);\n        Method method01_int = c1.getDeclaredMethod(\"method01\", int.class);\n        System.out.println(method01_int);\n        // Method method01 = c1.getDeclaredMethod(\"method01\", null); ide 推荐null不写\n        Method method01 = c1.getDeclaredMethod(\"method01\");\n        System.out.println(method01);\n\n        // 获取构造器\n        System.out.println(\"============获取构造器=========\");\n        Constructor&lt;?&gt;[] constructors = c1.getConstructors();\n        System.out.println(\"所有构造器\");\n        for (Constructor&lt;?&gt; constructor : constructors) {\n            System.out.println(constructor);\n        }\n\n        // 获取指定构造器,因为方法和构造器都有重载的存在,所以要给定参数类型,来定位到指定的构造器和方法\n        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class, String.class);\n        System.out.println(\"指定构造器\");\n        System.out.println(declaredConstructor);\n    }\n}\n\n\n// pojo 实体类\nclass User {\n    public int age;\n    public String name;\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- udp通信/index.html",
    "href": "posts/java网络编程-- udp通信/index.html",
    "title": "java网络编程– udp通信",
    "section": "",
    "text": "客户端发送\npackage cn.usts.edu.lesson04;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpClientDemo01 {\n    public static void main(String[] args) throws Exception{\n        // 建立socket连接\n        DatagramSocket socket = new DatagramSocket();\n        // 建立一个数据包\n        String msg = \"hello udp application\";\n        int port=9999;\n        InetAddress IP = InetAddress.getByName(\"127.0.0.1\");\n        // 字节数据,字节数据长度,目的ip,目的端口\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(),msg.getBytes().length,IP,port);\n        // 发送\n        socket.send(datagramPacket);\n        // 关闭\n        socket.close();\n    }\n\n}\n服务端接收\npackage cn.usts.edu.lesson04;\n\n\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UdpServerDemo01 {\n    public static void main(String[] args) throws Exception {\n        // 发放端口\n        DatagramSocket socket = new DatagramSocket(9999);\n        // 接收数据\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n        // 接收\n        socket.receive(packet);\n        // 输出\n        System.out.println(new String(packet.getData(), 0, packet.getLength()));\n        // 关闭\n        socket.close();\n\n    }\n}"
  },
  {
    "objectID": "posts/缺失的计算机课程YouTube课程/index.html",
    "href": "posts/缺失的计算机课程YouTube课程/index.html",
    "title": "缺失的计算机课程YouTube课程",
    "section": "",
    "text": "课程的目的\n一共有11节课程， 每节课有一个主题，带你熟悉计算机工具\n\n\nclass 1\n\nwhat is shell\n\nshell 就是一个接受命令，然后返回结果的一个工具，解析你的命令给计算机执行，然后将执行结果返回给用户 &gt; how to use shell\nshell的使用就像使用魔法一样，通过像魔法一样的单词来进行操作。\n其实shell的操作也称不上是魔法，每个命令其实就是一个单独的可执行程序，能够有同的功能，这也得益于linux的开源精神，开源作者为Linux大家庭添砖加瓦\necho hello              # 将会在终端中输出一行hello\necho $PATH              # 将会在终端中输出系统环境变量每个变量用:隔开\n\ninstall tldr tldr is cleaner than man\n\nsudo apt-get install npm\nsudo Jnpm install -g tldr\n\nhow to use tldr\n\ntldr tail               # 然后显示描述和案例，非常简洁，非常奈斯\n\ntail 将打印该./目录下的文件，然后打印最后一行， 然后输出到out.txt中\n\nls -l ./ |tail -n1 &gt; out.txt\n\ncurl grep curl 和网络相关 grep 过滤信息\n\n                                    # 过滤关键词 Date关键字这一行|裁剪用‘ ’，第2个裁剪单位\ncurl --head --silent www.google.com | grep -i Date| cut --delimiter=' ' f2\n控制键盘led灯亮灭\n# on\necho 1| sudo tee /sys/class/leds/input27::capslock/brightness\n# off\necho 0| sudo tee /sys/class/leds/input27::capslock/brightness\n\nxdg-open 能够使用适合的程序打开，html用浏览器打开，文件夹用文件管理器打开\n\nxdg-open xxx.html\nxdg-open aa.txt\n...\n\n\nclass 2(shell script)\n\n脚本语言的编写\n\n\n单引号和双引号的作用是不一样的, 单引号不做解释,原样输出,双引号进行解释\n\nfoo=bar\necho \"$foo\"\n# prints bar\necho '$foo'\n# prints $foo\n\n函数编写\n\n函数名和脚本名一致, 编写完成执行source mcd.sh即可全局使用该脚本\nmcd () {\n    # -p表示可以添加子目录(可以套娃)\n    mkdir -p \"$1\"\n    # 进入到创建的目录\n    cd \"$1\"\n}\n\n$ 的使用\n\n$0 - 脚本的名字\n$1 to $9 - 脚本的后边跟的参数\n$@ - 所有参数\n$# - 参数个数返回上一条命令的执行结果\n$$ - 当前进行的id\n$_ - 上次的执行的命令的最后一个参数\n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# cat mcd.sh \nmcd(){\n    #mkdir -p \"$1\"\n    #cd \"$1\"\n\n    # 所有参数\n    echo \"@=$@\"\n    # 参数个数\n    echo \"#=$#\"\n    # 返回上一条命令的结果\n    echo \"?=$?\"\n    # 返回当前脚本进程号\n    echo '$$'\"=$$\"\n    # \n    echo '$_'\"=$_\"\n}\n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# source mcd.sh \n(base) root@VM-12-14-ubuntu:~/projects/cs_base/script# mcd aaa bb cc dd\n@=aaa bb cc dd\n#=4\n?=0\n$$=901010\n$_=$$=901010\n\n!! - 上一条整条命令\n\n(base) root@VM-12-14-ubuntu:~# echo hello\nhello\n(base) root@VM-12-14-ubuntu:~# !!\necho hello\nhello\n(base) root@VM-12-14-ubuntu:~# ls\ncreate_variables.sh  mcd.sh\n(base) root@VM-12-14-ubuntu:~# !!\nls\ncreate_variables.sh  mcd.sh\n(base) root@VM-12-14-ubuntu:~#\n\n|| 和 && || 第一个条件是否满足, 不满足执行后一个 && 两个条件同时满足才执行.\n\n\n\n\nll\n左边参数\n右边参数\n\n\n\n\n条件\n√\n不执行\n\n\n条件\n×\n执行\n\n\n\n\n\n\n&&\n左边参数\n右边参数\n是否执行\n\n\n\n\n条件\n√\n√\n执行\n\n\n条件\n×\n√\n不执行\n\n\n\nfalse || echo \"Oops, fail\"\n# Oops, fail\n\ntrue || echo \"Will not be printed\"\n#\n\ntrue && echo \"Things went well\"\n# Things went well\n\nfalse && echo \"Will not be printed\"\n#\n\ntrue ; echo \"This will always run\"\n# This will always run\n\nfalse ; echo \"This will always run\"\n# This will always run\n\n命令参数的使用$(cmd)\n\na=$(pwd)\necho \"we are now at:$a\"\n\n拼接不同进程的信息, CMD &lt;(CMD) &lt;(CMD)\n\n diff &lt;(ls .) &lt;(ls ../)\n ls &lt;(ls .) &lt;(ls ../)\n cat &lt;(ls .) &lt;(ls ../)\n ...\n\n对比不同路径下文件的内容中是否包含hello关键字 注意$(cmd)是执行命令, $VALUE 是取值 [xxx] 和[[xxx]]的区别,前者是旧版本,后者是新版本, 前者的适配性更好,但是后者的语法更适合人类编写,参考地址:[xxx]和[[xxx]]详细对比说明\n\n#!/bin/bash    \necho \"find_diff program is excute at:$(date)\"    \n    \necho \"sh name is:$0, with $# arguements, with pid is: $$\"    \n    \n# 遍历文件夹中的文件    \nfor file in \"$@\";do    \n    # 过滤文件中的hello关键字, 输出到系统中垃圾倾倒的地方    \n    echo \"-----------&gt;$file\"    \n    grep hello  \"$file\" &gt; /dev/null 2&gt; /dev/null    \n    \n    # 如果上面这行执行结果不等于0 \n    #if [[ $? -ne 0 ]]; then  \n    if [ $? -ne 0 ]; then    \n       echo \"$file has no '1'\"    \n       # 在没有的文件后边追一个 # hello    \n       echo \"#hello\" &gt;&gt; \"$file\"    \n    fi    \ndone\n$# 表示提供到shell脚本或者函数的参数总数。\n$0 表示第一个参数。\n-ne 表示不等于。\n这是unix的shell编程语句，如果上一条命令执行后的结束代码不是0则执行下面的命令，知道fi行之前，例子：\nwho am i | grep root\nif [ $? -ne 0 ]\nthen\necho 'hello'\nfi\n另外：\n整数比较\n-eq 等于,如:if [\"$a\" -eq \"$b\" ]\n-ne 不等于,如:if [\"$a\" -ne \"$b\" ]\n-gt 大于,如:if [\"$a\" -gt \"$b\" ]\n-ge 大于等于,如:if [\"$a\" -ge \"$b\" ]\n-lt 小于,如:if [\"$a\" -lt \"$b\" ]\n-le 小于等于,如:if [\"$a\" -le \"$b\" ]\n&lt; 小于(需要双括号),如:((\"$a\" &lt; \"$b\"))\n&lt;= 小于等于(需要双括号),如:((\"$a\" &lt;= \"$b\"))\n&gt; 大于(需要双括号),如:((\"$a\" &gt; \"$b\"))\n&gt;= 大于等于(需要双括号),如:((\"$a\" &gt;= \"$b\"))\n\nls *.sh 命令过滤\n\n\n参数扩展\n\nconvert hello.jpg hello.png\nconvert hello.{jpg,png} # \n\ntouch hello.{png,jpg}\nrm *.{jpg,png}\n &gt; find 查找文件, 名字,日期(n天内..),类型(文件,文件夹), 大小(文件大小), 额外操作(删除,对比…)\nfind . -name src -type d\nfind ./{a,b} -path '*.py' -type f\n\n1、-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件\n2、-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名\n3、-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名\n\n# Find all zip files with size in range 500k to 10M\nfind . -size +500k -size -10M -name '*.tar.gz'\n\n# 删除\n# Delete all files with .tmp extension\nfind . -name '*.tmp' -exec rm {} \\;\n# Find all PNG files and convert them to JPG\nfind . -name '*.png' -exec convert {} {}.jpg \\;\n &gt;locate文件子串查找\n许多时候我们并不知道文件的位置,只有一些关键字, 所以通过关键字全局查找显得非常必要(有点类似windows 的everything)\nlocate hello\n\ngrep文件内容查找\n\n# 在指定文件内查找\ngrep hello xxx.sh\n# 在当前目录递归查找hello\ngrep -r hello .\n\nrg按照文件类型, 指定路径,搜索指定内容\n\nrg \"echo\" -t sh ~/projects/cs_base/\n\n# 获取前后2行(一共4行)内容\nrg \"echo\" -t sh -C 4 ~/projects/cs_base/\n\nctrl+r搜索历史, 继续按可以继续向前翻符合的命令 history展示全部命令\n\n\nfzf文件内容查找\n\ncat hello|fzf\n\n\n\n在这里插入图片描述\n\n\n\nbroot nnn # class 3 # class 4 # class 5 # class 6 # class 7 # class 8 # class 9 # class 10 # class 11 # 答疑"
  },
  {
    "objectID": "posts/C语言边界问题/index.html",
    "href": "posts/C语言边界问题/index.html",
    "title": "C语言边界问题",
    "section": "",
    "text": "int 的除法\n\nint a = 10/12;          // 0\nint a = 13/12;          // 1\nint a = 23/12;          // 1\nint a = 0/12;           // 0\nint a = -1/12;          // 0    \n\n% 边界\n\n 0%10           // 0\n 1%10           // 1\n-1%10           // -1 \n\nwhile的边界问题\n\nwhile(0){}      // false\nwhile(1){}      // true\nwhile(-1){}     // true\n\nif的边界问题\n\nif( 0){}        // false\nif(-1){}        // true\nif( 1){}        // true"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "",
    "text": "【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】\n不正确的源会导致找不到依赖的问题\nUbuntu18.4换阿里源参考：Ubuntu18.4换阿里源 ## 1.安装build-essential 如果安装中出现资源占用参考：解决资源占用\nsudo apt-get install build-essential"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装前请确认配置正确的源",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装前请确认配置正确的源",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "",
    "text": "【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】 【无法安装的问题大多是源没换好的问题导致的，注意Ubuntu版本和源地址要匹配！！！！！重要的事情说三遍】\n不正确的源会导致找不到依赖的问题\nUbuntu18.4换阿里源参考：Ubuntu18.4换阿里源 ## 1.安装build-essential 如果安装中出现资源占用参考：解决资源占用\nsudo apt-get install build-essential"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gcc",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gcc",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "2.安装gcc",
    "text": "2.安装gcc\nsudo apt-get install gcc"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gdb",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装gdb",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "3.安装gdb",
    "text": "3.安装gdb\nsudo apt-get install gdb"
  },
  {
    "objectID": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装vim编辑器",
    "href": "posts/在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】/index.html#安装vim编辑器",
    "title": "在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】",
    "section": "4.安装vim编辑器",
    "text": "4.安装vim编辑器\nsudo apt-get install vim"
  },
  {
    "objectID": "posts/linux matlab安装失败major/index.html",
    "href": "posts/linux matlab安装失败major/index.html",
    "title": "linux matlab安装失败major",
    "section": "",
    "text": "微信公众号搜索linux资源库 里面有提供破解版\nI got problems installing Matlab R2022a on Arch. Running the installer throws the following error:\nterminate called after throwing an instance of ‘std::runtime_error’ what(): Failed to launch web window with error: Unable to launch the MATLABWindow application. The exit code was: 127 fish: Job 1, ‘sudo ./install’ terminated by signal SIGABRT (Abort)\n\nI fixed it by running the following commands.\n\n安装后还需要重新执行次操作\ncd &lt;matlab installer root directory&gt;\ncd /bin/glnxa64\nls | grep libfreetype\nmkdir exclude\nmv libfreetype.so.6 exclude/\nmv libfreetype.so.6.16.0 exclude/\n然后报错是因为matlab指向的是自带的libtiff.so.5需将软连接重新指向 系统的libtiff.so.5\nbin/glnxa64/MATLABWindow: /home/dd21/Software/MATLAB/R2022b/bin/glnxa64/libtiff.so.5: version `LIBTIFF_4.0' not found (required by /usr/lib/libgdk_pixbuf-2.0.so.0)\n\n解决方案\n在matlab中输入,检测信息： cd(matlabroot) ! bin/glnxa64/MATLABWindow - slLibraryBrowser\n\n# matlab install path \ncd /Software/MATLAB/R2022b/bin/glnxa64 \n# create new linker\nln -s /usr/lib64/libtiff.so.5 ./libtiff.so.5\nsudo vim /usr/share/applications/matlab.desktop\n快捷方式\n[Desktop Entry]\nVersion=R2020b\nType=Application\nTerminal=false\nMimeType=text/x-matlab\nExec=/usr/local/MATLAB/R2022b/bin/matlab -desktop\nName=MATLAB\nIcon=matlab\nCategories=Development;Math;Science\nComment=Scientific computing environment\nStartupNotify=true"
  },
  {
    "objectID": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html",
    "href": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html",
    "title": "java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】",
    "section": "",
    "text": "在这里插入图片描述\n\n\n\n\n// 设置响应行状态码为 402\nresponse.setStatus(402);\n\n\n\n在这里插入图片描述\n\n\n\n\n\n// 设置404错误返回信息为 找不到states路径\nresponse.sendError(404,\"找不到states路径\");\n\n\n\n在这里插入图片描述\n\n\n\n\n\n2.1 setHeader() 只添加一个响应数据\nresponse.setHeader(\"sex\":\"0\");\nresponse.setHeader(\"sex\":\"0\");\n// 第二次设置会覆盖掉第一次设置的值\nresponse.setHeader(\"sex\":\"1\");\n2.2 addHeader() 添加多个响应数据\nresponse.addHeader(\"name\":\"hello\");\nresponse.addHeader(\"name\":\"hello\");\n// 第二次设置不会覆盖掉第一次设置的值\nresponse.addHeader(\"name\":\"hello2\");\n 2.3 setContentLength() 设置响应头长度\n// 设置响应头长度\nresponse.setContentLength(999);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置响应行状态码",
    "href": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置响应行状态码",
    "title": "java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】",
    "section": "",
    "text": "// 设置响应行状态码为 402\nresponse.setStatus(402);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置错误提示信息",
    "href": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置错误提示信息",
    "title": "java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】",
    "section": "",
    "text": "// 设置404错误返回信息为 找不到states路径\nresponse.sendError(404,\"找不到states路径\");\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置响应头",
    "href": "posts/java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别----＞步骤2】/index.html#设置响应头",
    "title": "java EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】",
    "section": "",
    "text": "2.1 setHeader() 只添加一个响应数据\nresponse.setHeader(\"sex\":\"0\");\nresponse.setHeader(\"sex\":\"0\");\n// 第二次设置会覆盖掉第一次设置的值\nresponse.setHeader(\"sex\":\"1\");\n2.2 addHeader() 添加多个响应数据\nresponse.addHeader(\"name\":\"hello\");\nresponse.addHeader(\"name\":\"hello\");\n// 第二次设置不会覆盖掉第一次设置的值\nresponse.addHeader(\"name\":\"hello2\");\n 2.3 setContentLength() 设置响应头长度\n// 设置响应头长度\nresponse.setContentLength(999);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java多线程--ReentrantLock ( Lock上锁 _ 解锁 )/index.html",
    "href": "posts/java多线程--ReentrantLock ( Lock上锁 _ 解锁 )/index.html",
    "title": "java多线程–ReentrantLock ( Lock上锁 _ 解锁 )",
    "section": "",
    "text": "Lock 的应用\n\n可重复性锁,相比传统的synchronized\nReentrantLock更直观,直观上锁解锁 \n\npackage cn.usts.edu.lesson08;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 可重复性锁,相比传统的synchronized\n * ReentrantLock更直观,直观上锁解锁\n * */\n\npublic class LockDemo implements Runnable{\n\n    private int tickets=10;\n\n    private final ReentrantLock lock = new ReentrantLock(); // 实例化锁\n\n    public static void main(String[] args) {\n        LockDemo lockDemo = new LockDemo();\n        new Thread(lockDemo).start();\n        new Thread(lockDemo).start();\n        new Thread(lockDemo).start();\n    }\n\n\n\n    @Override\n    public void run() {\n\n        try {\n            lock.lock();// 上锁\n\n            while (true){\n                if (tickets&gt;0){\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(tickets--);\n                }\n                else {\n                    break;\n                }\n            }\n        }finally {\n            lock.unlock();// 解锁\n        }\n\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- thread.setDaemon(true) 守护线程简单实现/index.html",
    "href": "posts/java多线程-- thread.setDaemon(true) 守护线程简单实现/index.html",
    "title": "java多线程– thread.setDaemon(true) 守护线程简单实现",
    "section": "",
    "text": "守护线程 ,就是当有其他线程开启时,守护线程就一直开启\n守护线程会在所有线程结束后自动结束,\n\n模型: 人的生命有限 默认100年,上帝会一直存在,所以一直会守护着你\npackage cn.usts.edu.lesson06;\n\n/**\n * 守护线程 ,就是当有其他线程开启时,守护线程就一直开启\n * 守护线程会在所有线程结束后自动结束\n * */\n\npublic class DaemonTest {\n    public static void main(String[] args) {\n        God god = new God();\n        You you = new You();\n        Thread godThread = new Thread(god);\n        godThread.setDaemon(true);// 默认是普通用户线程  默认值是false   true表示开启守护线程\n        godThread.start();//守护线程启动\n\n        Thread youThread = new Thread(you);\n        youThread.start();\n    }\n    \n}\n\nclass God implements Runnable{\n\n    @Override\n    public void run() {\n        while (true){ // 理论上是一直执行,可是当所有线程结束的时候他也会结束.\n            System.out.println(\"上帝一直在守护你\");\n        }\n    }\n}\n\nclass You implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 36500; i++) {\n            System.out.println(\"快乐的一天\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/arch安装kde/index.html",
    "href": "posts/arch安装kde/index.html",
    "title": "arch安装kde",
    "section": "",
    "text": "好多安装视频都是框框一段乱敲, 不明所以,不知道安装的是什么插件以及基本功能, 做个笔记记录下安装过程\n\nked社区:https://apps.kde.org/zh-cn/ &gt; 进入到这个社区一下就明白了 pacman -S xxxx 的一堆桌面插件是什么了 # 时间设置\n# 设置时区\ntimedatectl set-timezone Asia/Shanghai\n\n# 打开网络更新时间\ntimedatectl set-ntp true\n\n# 查看状态\ntimedatectl status\n\n配置bash shell环境变量\n# 进入保存环境变量的目录\ncd /etc/skel\n\n# 查看所有的文件(包括隐藏文件)\nls -al  \n\n# 编辑.bashrc文件(系统启动时运行的文件),这里的编辑器根据自己的写,nvim, vim, nano....,这一句即可,其他的可以不要\nnvim .bashrc    \n    -&gt; export EDITOR=nvim       \n\n# 其他的是颜色的显示\n\n\n\n在这里插入图片描述\n\n\n\n\n添加用户\n# 添加用户,并在home目录下创建一个和z同名的文件夹\nuseradd --create-home z\n\n# 查看用户信息\nid z\n\n# 设置密码\npasswd z\n\n# 将z用户添加到常用de用户组中\nusermod -G wheel,users,power,ld,adm,optical,storage z\n\n\n安装sudo 给普通用户提权\n# 安装\npacman -S sudo\n\n# 编辑visudo\nvisudo\n    --&gt; 去掉图中注释\n # 修改文文字设置 本文参考https://www.bilibili.com/read/cv13858119?from=search&spm_id_from=333.337.0.0 \n  \n\n\n安装桌面\nplasma指南 安装 plasma-meta 元软件包或者 plasma 组。 关于 plasma-meta 和 plasma 两者的不同见元软件包与软件包组。若要使用 Plasma 的最小安装，请安装 plasma-desktop 包。\n\n前者是软件包组，pacman -S plasma 允许你自由选装组内软件，后者是软件包，依赖的是前者的全部软件，不能选装，一旦软件包组里有软件新加入，前者不会要求你安装，后者会。\n\npacman -S plasma \n\n\n启动管理\n# \npacman -S sddm\nsystemctl enable sddm \n# 如果切换管理器先把之前的关闭\nsystemctl disable sddm\n\n# 手动启动sddm\nsudo systemctl start sddm \npacman -S dolphin konsole kdeconnect kcalc\n\n\n\n名称\n功能\n\n\n\n\ndolphin\n文件管理\n\n\nkonsole\n命令行终端\n\n\nkdeconnect\n手机电脑互联(发送文件等)\n\n\nkcalc\n计算器"
  },
  {
    "objectID": "xiaomi_3s_box_openwrt/index.html",
    "href": "xiaomi_3s_box_openwrt/index.html",
    "title": "xiaomi 3s flash openwrt",
    "section": "",
    "text": "Abstract\nuse xiaomi box flash to an openwrt device\n\n\nReferance\nopenwrt install openclash\n安装openclash依赖库会出现以下报错\n\n\npkg_hash_check_unresolved: cannot find dependency kernel (= 6.1.31-1-ea9c0bad270bcff7df7febc55ee0cc63) for kmod-ipt-core\n\n\n解决方法： 将kennel版本修改为报错信息中的版本即可解决问题\nvim /usr/lib/opkg/status\n\n# 全局替换，将123替换为456\n# 语法 ：%s#123#456#g  \n：%s#5.15.110-1-5c2e6274bba101fd7a88dbfd8c0f25d8#6.1.31-1-ea9c0bad270bcff7df7febc55ee0cc63#g\n\n\n安装clash内核\ncortex A53是armV8 下载链接： clash 内核下载\n解压命令：\n# 压缩\ntar -zcvf 压缩文件名 .tar.gz 被压缩文件名\n# 解压\ntar -zxvf 压缩文件名.tar.gz\n\ntar -zxvf clash-linux-armv8.tar.gz\n安装clash内核位置\nmkdir /etc/openclash/core/\nmv clash /etc/openclash/core/\n\n\nopenclash 安装\n安装完依赖，安装openclash"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TengFei Zhang",
    "section": "",
    "text": "Fresh graduates majoring in computer science, love life and love coding."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "TengFei Zhang",
    "section": "Education",
    "text": "Education\nSuzhou University of Science and Technology | Jun 2022"
  },
  {
    "objectID": "index.html#experience-at-school",
    "href": "index.html#experience-at-school",
    "title": "TengFei Zhang",
    "section": "Experience at school",
    "text": "Experience at school\nRanking: 5/45 | GPA: 3.24 | Teaching assistant | Scholarship x 3\nQualification Certificate of Computer and Software Technology Proficiency Of Junior"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "TengFei Zhang",
    "section": "Experience",
    "text": "Experience\nElectric Vehicle Helmet Illegal Detection System(Yolo, Ocr, Spider.. ) | Graduation Project | Feb 2022\nVideo Capture Tools (Pyqt, OpenCv, Ftplib..) | Su Zhou HighWise | Oct 2021\nLicense Management Platform (Django, Vue, Mysql..) | Su Zhou HighWise | Jan 2021\nHuman Detection (Yolo, Qt..) | Su Zhou Ravsense | Apr 2022\nRadar Raw ADC Data Capture(AWR6843, not DCA1000..) | Su Zhou Ravsense | Jul 2022\nVitalSign Algorithm Porting(RTOS, Matlab Coder, STM32H7..) | Su Zhou Ravsense | Oct 2022\nE-mail:izhangtengfei@163.com"
  },
  {
    "objectID": "article.html",
    "href": "article.html",
    "title": "Article",
    "section": "",
    "text": "cod sensor getting started\n\n\n\n\n\n\n\ncod\n\n\n\n\n\n\n\n\n\n\n\nAug 11, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncreate env of esp32 s3 with IDF\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nJun 28, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnb-iot of shadow device\n\n\n\n\n\n\n\nnb-iot\n\n\n\n\n\n\n\n\n\n\n\nJun 16, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngetting started with mmwave radar\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nJun 15, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnb-iot eDRX(Extended Discontinuous Reception)\n\n\n\n\n\n\n\nnb-iot\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnb-iot advantages and disadvantages between B5 and B8\n\n\n\n\n\n\n\nnb-iot\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nopcrating string of c with &lt;string.h&gt;\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nMay 30, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncreate env of mmwave radar of ccs\n\n\n\n\n\n\n\nti\n\n\nradar\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmmwave level sensing demo notes\n\n\n\n\n\n\n\nti\n\n\nradar\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nti mmwave sdk notes\n\n\n\n\n\n\n\nti\n\n\nradar\n\n\n\n\n\n\n\n\n\n\n\nApr 25, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nhow to use bc26 with tencent&ali iot platform\n\n\n\n\n\n\n\nnb-iot\n\n\n\n\n\n\n\n\n\n\n\nMar 29, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncreate esp8266 env with IDF\n\n\n\n\n\n\n\nesp8266\n\n\n\n\n\n\n\n\n\n\n\nMar 25, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux usb or other device auth how to control\n\n\n\n\n\n\n\nlinux\n\n\npico\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nrp2040 power supply\n\n\n\n\n\n\n\npico\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncmdke use case\n\n\n\n\n\n\n\ncmake\n\n\n\n\n\n\n\n\n\n\n\nFeb 24, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncreate env on ubuntu\n\n\n\n\n\n\n\npico\n\n\n\n\n\n\n\n\n\n\n\nFeb 23, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlearning numpy\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nFeb 21, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nEmpirical Mode Decomposition\n\n\n\n\n\n\n\nalgrithm\n\n\n\n\n\n\n\n\n\n\n\nFeb 12, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nFilter Design & Analysis Tool(FdaTool)\n\n\n\n\n\n\n\nmatlab\n\n\n\n\n\n\n\n\n\n\n\nFeb 12, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nFMCW\n\n\n\n\n\n\n\nradar\n\n\n\n\n\n\n\n\n\n\n\nFeb 12, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nsample rate how to set\n\n\n\n\n\n\n\nmatlab\n\n\ndsp\n\n\n\n\n\n\n\n\n\n\n\nFeb 11, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nfft demo\n\n\n\n\n\n\n\ndsp\n\n\nmatlab\n\n\n\n\n\n\n\n\n\n\n\nFeb 11, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nhow to set stack size of stm32\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nFeb 8, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ndesign an esp32 development Board\n\n\n\n\n\n\n\nesp32\n\n\n\n\n\n\n\n\n\n\n\nFeb 7, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32 add dsp\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nJan 30, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngit advanced operate\n\n\n\n\n\n\n\ngit\n\n\n\n\n\n\n\n\n\n\n\nJan 10, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nhow to set and check shell of linux\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nJan 10, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvscode icon abnormal\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvscode candidate key: tab && shift tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nneovim install and config\n\n\n\n\n\n\n\nvim\n\n\n\n\n\n\n\n\n\n\n\nJan 7, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32 usb cdc vitural serial port\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nJan 6, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nbinary bomb\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nJan 4, 2023\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nrp2040 config vscode env\n\n\n\n\n\n\n\nrp2040\n\n\nenv\n\n\n\n\n\n\n\n\n\n\n\nDec 25, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvsdoe fix can not swap esc and caps lock\n\n\n\n\n\n\n\nvscode\n\n\nenv\n\n\n\n\n\n\n\n\n\n\n\nDec 25, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspi 通信\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 21, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ninfineon radar usecase (RBB7 Demo)\n\n\n\n\n\n\n\ninfineon\n\n\natmel\n\n\nmicroChip\n\n\n\n\n\n\n\n\n\n\n\nDec 13, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nMicro Chirp Create Project\n\n\n\n\n\n\n\ninfineon\n\n\nradar\n\n\nenv\n\n\nmicroChip\n\n\n\n\n\n\n\n\n\n\n\nDec 12, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nelf 文件解析\n\n\n\n\n\n\n\nelf\n\n\ngcc\n\n\n\n\n\n\n\n\n\n\n\nDec 11, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngcc entry point is 0x1600 not 0x08048000\n\n\n\n\n\n\n\ncs\n\n\ngcc\n\n\n\n\n\n\n\n\n\n\n\nDec 11, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ninfineon BGTR13C target code\n\n\n\n\n\n\n\ninfineon\n\n\nradar\n\n\n\n\n\n\n\n\n\n\n\nDec 8, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ninfineon BTGR13C Radar shield\n\n\n\n\n\n\n\ninfineon\n\n\n\n\n\n\n\n\n\n\n\nDec 7, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nInfineon Radar Env Init\n\n\n\n\n\n\n\ninfineon\n\n\nenv\n\n\n\n\n\n\n\n\n\n\n\nDec 6, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nhow to use infineon Radar MCU7\n\n\n\n\n\n\n\nradar\n\n\ninfineon\n\n\n\n\n\n\n\n\n\n\n\nDec 6, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch安装kde\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nPython–Threading\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.setDaemon(true) 守护线程简单实现\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n临时邮箱\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程–ReentrantLock ( Lock上锁 _ 解锁 )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 网图多线程下载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 设置响应头内容、长度；响应行状态码、错误提示信息【setHeader和addHeader的区别—-＞步骤2】\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –03QObje对象的使用\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux matlab安装失败major\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n内存管理\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n在Ubuntu下配置C语言编辑环境【gcc】,【gdb】，【build-essential】\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch yay安装qq\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nC语言边界问题\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 得到class类的几种方式\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n缺失的计算机课程YouTube课程\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– udp通信\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaArrayList作业1\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 利用反射获取类的运行时结构(属性,方法,对象,构造器)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 01简单跑通\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngit\n\n\n\n\n\n\n\ngit\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_jdk安装，配置环境（win10）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–02 按钮状态监测\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n二分查找\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava基础知识（笔记）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt多线程QThread()\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nC语言状态传递,通过指针判断并带回结果\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–frame\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– sleep实现 ( 时间刷新 , 模拟倒计时)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 信号灯法则\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing[JFrame]\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– yield 线程礼让\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–03 按钮次数计数\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nC语言的指针理解问题\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmap作业三(集合)韩顺平\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n安卓7以上安装系统证书(system分区没有权限)\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nidea配置mapper.xml不提示解决方案\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 反射\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmysql8.0安装\n\n\n\n\n\n\n\nmysql\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32芯片开发包\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–监听器02\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–04 继电器没有反应\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nkeil5设置调试器stm32\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.getState() 查看线程状态\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch安装\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava和– Collections工具类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n算法 –0_算法是什么\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nSpring简单使用（依赖注入）\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–滚动条JScrollPane\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– URL（基本用法）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nPycharm环境配置\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncordova安装启动\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 会话和会话技术 -cookie\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n电动车头盔检测系统(毕设)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– StatementSQL注入演示\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 重定向的多种实现方法\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–列表框 JList\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–表格布局\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–监听器 [ 关闭按钮 ]\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n腾讯云简单使用-Python\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n清除html和css标签自带的默认样式\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt–vs2022+qt5.15.2\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_Fastjson的使用\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Runnable简单实现(例子)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npip加速\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 静态代理(简单剖析)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– String、StringBuffer（StringBuilder）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n中科大源\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE -Session\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt+darknet+yolo+vs2022(附加库目录lib库)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread邮箱(mailbox)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 初识多线程的问题(简单案例)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango项目三步快速创建\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n算法– 1_递归\n\n\n\n\n\n\n\nalgorithm\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread 重映射串口到 rt_kprintf 函数\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt移动界面无响应[ 多线程 ]\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– c3p0xml 链接\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt大小端转换\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– 单选框 JRadioButton _ 复选框 JCheckBox\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ndarknet–训练\n\n\n\n\n\n\n\ndarknet\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango项目\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnodejs安装–（npm安装）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava–gui_简单计算器\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango– 1_配置数据库(mysql8.0)\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743+CubeMX+RtThread工程创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n应用视觉设计\n\n\n\n\n\n\n\ncss\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava冒泡排序\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–布局练习\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs打包qt程序\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyinstaller打包程序问题总结\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_dsp入门-ti c660\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava–创建Tomcat服务器\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nc++基础\n\n\n\n\n\n\n\nc++\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-json-乱码解决\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 自定义注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 一行代码实现定时刷新，定时跳转\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n树莓派开箱点亮(无屏幕)\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\napp反爬\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– 键盘监听\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nclion+pico+调试(另一块pico做调试)环境搭建\n\n\n\n\n\n\n\npico\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt线程问题(耗时操作)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– System类的常用方法, Runtime类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–文本框JTextField_密码框JPasswordField()_文本域 JTextArea\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –01简单继承关系\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 简单登陆跳转逻辑\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket – 03 socket.io\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvmware镜像站\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743使用\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– JPanel\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaArrayList作业二\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程停止\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n简单的创建一个DHCP服务器（WinServ2008-2R）【图文】\n\n\n\n\n\n\n\nnetwork\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux入门操作\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu18版本换源\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n毫米波雷达\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n小米刷机\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nCSS_基础\n\n\n\n\n\n\n\nhtml\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n计算机组成原理\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvue – 01安装、创建、跑通\n\n\n\n\n\n\n\nvue\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDNS图文步骤配置\n\n\n\n\n\n\n\nnetwork\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–窗口事件监听\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nalu整数加法_减法\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 通信协议\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –04QObje对象的父子关系使用\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– lambda表达式(实现原理, 4行代码 最简单的实现 )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux下_终端_终端模拟器_shell_bash的区别\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nfrida的typescript环境搭建\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava- 贪吃蛇\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–01点亮一个LED\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE请求转发（转发和重定向）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_js脚本自动调试\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ndarknet-配置部署\n\n\n\n\n\n\n\ndarknet\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ndarknet用公共数据集训练自己的模型\n\n\n\n\n\n\n\ndarknet\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread–信号量(semaphare)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nquarto\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –02面向对象的设计思想\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 利用反射来 实例化对象,调用功能方法,设置属性\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– URL(网络资源下载)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux–改变用户所在组(改变登陆初始位置)\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– Tcp聊天\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nnvim打造c语言环境\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 死锁模拟( synchronized )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程–龟兔赛跑\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n文件管理服务器\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nEclipse中配置Tomcat\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 生产者消费者\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_ccs修改环境变量\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc–事务\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nCisco思科交换机Vlan划分\n\n\n\n\n\n\n\nnetwork\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npyqt5 –05对象类型判定和控件继承类型\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nclion破解\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE一行代码解决乱码（设置服务器编码；设置浏览器编码方式）\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–04wifi开关\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nEclipse国内镜像快速下载\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux– linux忘记密码(修改root密码)\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 解决请求中的缓冲区中文乱码问题\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 元注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n计算机组成原理 – 大端模式,小端模式\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 简单实现多线程\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–icon\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nmanjaro install\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– druid\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nJava函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nprotobuf协议– 01使用（js简单实现）\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nsmt32-f103寄存器点灯\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大操作系统基础-ics\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava集合– 所有\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux– 查看和修改文件所在组\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nHTML基础\n\n\n\n\n\n\n\nhtml\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– Math和Random\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_icboost+IWR6843\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 获取请求行、请求头、请求正文\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\narch没有wifi\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava集合– HashSet小练习\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–下拉框JComboBox\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango– 0_从零开始(创建)\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– 测试PreparedStatement\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngit – 回退版本(两个版本之间来回切)\n\n\n\n\n\n\n\ngit\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\npowershell获取脚本执行权限\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南京大学ics pa实验O\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 内置注解\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango-管理平台\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n模仿网易严选(vant)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程管理\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux– 提权\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类–时间日期类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–浮动布局(FlowLayOut)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava EE 利用Referer简单实现防盗链功能\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-hellomvc-02\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– 结果集ResultSet\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nfrida对java hash类型打印\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n三步简单解决3306端口占用问题（windows）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nDjango中配置mysql数据库\n\n\n\n\n\n\n\ndjango\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射– 所有类的Class类型\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n汇编–00安装dosBox\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大ics课程\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngithub全局加速下载\n\n\n\n\n\n\n\ngit\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread– 互斥量(mutex)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nfrida安装\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux ssh长时间无操作断连\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 端口\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava_TreeSet和HashSet的去重原理 (作业四)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–东西南北中布局\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell脚本批量创建多个用户\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt –问题总结(头文件问题,QString转换,查找组件)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLNK1104错误_无法打开文件xxx.lib_和查看所有宏定义$xxxx\n\n\n\n\n\n\n\nbug\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread定时器\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspring整合SSM\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Callable接口简单应用\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 02 聊天室\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– PreparedStatement( DML语句)insert,delete,update\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncharles安装激活\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt无法输出\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringMVC-设置日期时间对象【自定义日期时间格式】\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs studio添加include和依赖库\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwin11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nweb-packet –01\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32–io口拉高还是拉低\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– IP地址\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nJDBC操作数据(以mysql为例)的5种常用方法\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava常用类– 包装类\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nbug – Pyqt5+openCV报错(QObject_moveToThread)\n\n\n\n\n\n\n\nbug\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– join(线程插队,优先执行)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava网络编程– 文件传输\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell批量创建20个指定文件名格式的文件（或文件夹）\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nLinux _ Ubuntu18解决(无法获得锁 var_lib_dpkg_lock - open (11 资源暂时不可用))\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射–通过反射获取到注解的值\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\napp爬虫–持续更新\n\n\n\n\n\n\n\nspider\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程池( Executors.newFixedThreadPool() )\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell编程的简单实现\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ncubeMX+RT_threa\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava GUI编程–panel\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread移植(固件库版本)-项目创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n中断-轮询\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nNavicat中 int(0)表示什么【init（0）是什么意思】\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux–创建用户修改&修改密码\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n设置Caps_Lock和Esc交换\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqtQByteArry以二进制写入多n个字节\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI– 鼠标监听\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nCygwin使用：配置c环境\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread动态内存分配\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n多普勒原理\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njdbc– 批处理\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ngithub总数换dns,总是修改hosts,双击Python脚本直接秒修改\n\n\n\n\n\n\n\ngit\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing之[Dialog]弹窗\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu21 美化\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– thread.setPriority() 线程优先级\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– 线程休眠(sleep)\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njavaGUI–Swing [ icon ]画一个icon\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nesp8266–00GPIO引脚对应关系(nodeMCU)\n\n\n\n\n\n\n\nesp\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– CopyOnWriteArrayList\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava多线程– Runnable接口实现多线程网图下载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt上位机 – 自己开发出口助手\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nkeil5激活—＞2032年\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程同步(event)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\njava注解和反射–类加的载\n\n\n\n\n\n\n\njava\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\n南大ics基础课\n\n\n\n\n\n\n\ncs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nlinux键盘f1-f12功能键盘失效\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\ndarknet–使用yolo算法进行目标检测（保姆教程）\n\n\n\n\n\n\n\ndarknet\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nMatlab Coder\n\n\n\n\n\n\n\nmatlab\n\n\n\n\n\n\n\n\n\n\n\nNov 22, 2022\n\n\ndd21\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Python--Threading/index.html",
    "href": "posts/Python--Threading/index.html",
    "title": "Python–Threading",
    "section": "",
    "text": "代码位置 # 传统的dos系统是一个单进程的程序 windows系统是一个并行的系统,曹勇的是到进程的编程模式, windows进程管理器可以查看进程 ## 在多核cup出现直线的设计方式: 时间片轮转算法,保证同时执行多个进程,但是在摸一个时间点上智能执行一个进程(利用这种方式很好的压榨cpu性能和资源) ## 进程的定义 进程是一个具有一定独立能力的程序关于摸个数据集合的一次运行活动 进程是系统进行资源分配和调度和运行的基本单位 进程实体中包含有三个组成部分: \"程序\",数据,pcb(进程控制块)  服务器的硬件性能是有限的,但是对于大部分程序来说都是属于过剩的状态,如果按照传统的单进程的模式来运行,会造成硬件资源的浪费 ## 解决资源过剩的方法 不同的计算机会有不同的配置,如果想要充分发挥出程序的性能,就要可以动态的获取当前可以运行的cpu的数量,于是就出现了可以通过多进程来实现数据和资源的获取\n\n\n# 导入多进程模块\nimport multiprocessing\n\n\nprint(\"当前可用cpu数:{}\".format(multiprocessing.cpu_count()))  # 当前可用cpu数:8\n\"\"\"\n    任何进程都包含有各自的数据,也就是说不同的进程之间的数据是不可以直接互相访问的,\n我们可以通过威其他的技术进行操作  example:管道\n    进程的创建到销毁都有 \"生命周期\" \n\"\"\"\n\n\n\n ### 创建状态 系统已经为程序分配好了pcb(可以获取进程的信息),但是需要执行的进程的上下文管理器(上下文环境)未分配,所以这个程序无法被调度(运行) ### 就绪状态 该进程已经分配到了出cpu之外的资源(上下文资源(就是调用关系,所属关系)),等待cpu调度 * 例1:桌椅–&gt;教室 * 例2:教室–&gt;学校\n\n\n进程一切就绪,一分配到了cpu资源,开始正常执行(执行进程) ### 阻塞状态 一个程序执行不能一直占用cpu(公共资源),根据资源调度的算法,每一个进程执行一段时间后都需要交出当前cpu的资源,给其他进程执行 ### 终止状态 某一个进程达到了自然终止的状态,或者进程强行停止,那么进程将进入到终止状态,,进程将不再被执行\n\n\n\n\n多进程可以提高程序运行效率,但是传统的的多进程模式只适合并发并不多的情况:成百上千的并发进程就不适合使用了, 会造成资源过多的消耗,导致资源不足的问题,从而降低了系统性能,所以要提高资源的利用率,以及进程的可复用性"
  },
  {
    "objectID": "posts/Python--Threading/index.html#获取当前可cpu数量",
    "href": "posts/Python--Threading/index.html#获取当前可cpu数量",
    "title": "Python–Threading",
    "section": "",
    "text": "# 导入多进程模块\nimport multiprocessing\n\n\nprint(\"当前可用cpu数:{}\".format(multiprocessing.cpu_count()))  # 当前可用cpu数:8\n\"\"\"\n    任何进程都包含有各自的数据,也就是说不同的进程之间的数据是不可以直接互相访问的,\n我们可以通过威其他的技术进行操作  example:管道\n    进程的创建到销毁都有 \"生命周期\" \n\"\"\""
  },
  {
    "objectID": "posts/Python--Threading/index.html#进程的生命周期",
    "href": "posts/Python--Threading/index.html#进程的生命周期",
    "title": "Python–Threading",
    "section": "",
    "text": "### 创建状态 系统已经为程序分配好了pcb(可以获取进程的信息),但是需要执行的进程的上下文管理器(上下文环境)未分配,所以这个程序无法被调度(运行) ### 就绪状态 该进程已经分配到了出cpu之外的资源(上下文资源(就是调用关系,所属关系)),等待cpu调度 * 例1:桌椅–&gt;教室 * 例2:教室–&gt;学校\n\n\n进程一切就绪,一分配到了cpu资源,开始正常执行(执行进程) ### 阻塞状态 一个程序执行不能一直占用cpu(公共资源),根据资源调度的算法,每一个进程执行一段时间后都需要交出当前cpu的资源,给其他进程执行 ### 终止状态 某一个进程达到了自然终止的状态,或者进程强行停止,那么进程将进入到终止状态,,进程将不再被执行"
  },
  {
    "objectID": "posts/Python--Threading/index.html#进程池",
    "href": "posts/Python--Threading/index.html#进程池",
    "title": "Python–Threading",
    "section": "",
    "text": "多进程可以提高程序运行效率,但是传统的的多进程模式只适合并发并不多的情况:成百上千的并发进程就不适合使用了, 会造成资源过多的消耗,导致资源不足的问题,从而降低了系统性能,所以要提高资源的利用率,以及进程的可复用性"
  },
  {
    "objectID": "posts/临时邮箱/index.html",
    "href": "posts/临时邮箱/index.html",
    "title": "临时邮箱",
    "section": "",
    "text": "知乎指南\nhttps://www.guerrillamail.com/"
  },
  {
    "objectID": "posts/java多线程-- 网图多线程下载/index.html",
    "href": "posts/java多线程-- 网图多线程下载/index.html",
    "title": "java多线程– 网图多线程下载",
    "section": "",
    "text": "多线程同时下载多张图片\npackage cn.usts.edu.lesson01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 练习Thread\n * 实现多线程同时下载\n * */\npublic class ThreadImageDownload extends Thread{\n    String file;\n    String url;\n    String filename;\n\n    public ThreadImageDownload(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public void run() {\n        ImageDownload imageDownload = new ImageDownload();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n    }\n\n    public static void main(String[] args) {\n        ThreadImageDownload t1 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        ThreadImageDownload t2 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        ThreadImageDownload t3 = new ThreadImageDownload(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\nclass  ImageDownload{\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/pyqt5 --03QObje对象的使用/index.html",
    "href": "posts/pyqt5 --03QObje对象的使用/index.html",
    "title": "pyqt5 –03QObje对象的使用",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject对象学习')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        obj = QObject()\n        obj.setObjectName('第一个objectname')\n        obj.setProperty('key', 'value')\n        obj.setProperty('key2', 'value2')\n        print(obj.property('key'))\n        print(obj.objectName())  # 设置属性+set,去掉set就是获取(get)\n        print(obj.dynamicPropertyNames())  # 获取所有已经设置的键值对\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/内存管理/index.html",
    "href": "posts/内存管理/index.html",
    "title": "内存管理",
    "section": "",
    "text": "一个编译完成的程序包含很多段 .text [ 代码段 ] .data [ 数据段 ] .bss [ 未初始化数据段 ]\n全局变量和static修饰的变量是在编译的时候分配空间的"
  },
  {
    "objectID": "posts/arch yay安装qq/index.html",
    "href": "posts/arch yay安装qq/index.html",
    "title": "arch yay安装qq",
    "section": "",
    "text": "arch yay安装qq\n还原后再文件末尾添加!!!!!, making xxxx 需要安装base-devel"
  },
  {
    "objectID": "posts/java注解和反射-- 得到class类的几种方式/index.html",
    "href": "posts/java注解和反射-- 得到class类的几种方式/index.html",
    "title": "java注解和反射– 得到class类的几种方式",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.Reflection03;\n\n/**\n * @author ：fly\n * @description: 获取class对象的方法\n * @date ：2021/10/27 14:11\n */\npublic class GetClassDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person = new Teacher();\n        System.out.println(\"这个人是\"+person.name);\n\n        // 方式1: 通过对象获取\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式2: forName获取\n        Class c2 = Class.forName(\"cn.usts.edu.Reflection03.Teacher\");\n        System.out.println(c2.hashCode());\n\n        // 方式3:通过类名.class获取\n        Class c3 = Teacher.class;\n        System.out.println(c3.hashCode());\n\n        // 方式4: 内置类型的包装类都有一个Type属性\n        Class c4 = Integer.TYPE;\n        System.out.println(c4);\n\n        // 方式5: 通过父类获取\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\n// pojo1\nclass Person{\n    int age;\n    String name;\n\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public Person() {\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// pojo2 教师\nclass Teacher extends Person{\n    public Teacher() {\n        this.age = 30;\n        this.name = \"老师\";\n    }\n}\n\n// pojo3 学生\nclass Student extends Person{\n    public Student() {\n        this.age=18;\n        this.name=\"学生\";\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 得到class类的几种方式/index.html#获取class对象的方法",
    "href": "posts/java注解和反射-- 得到class类的几种方式/index.html#获取class对象的方法",
    "title": "java注解和反射– 得到class类的几种方式",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.Reflection03;\n\n/**\n * @author ：fly\n * @description: 获取class对象的方法\n * @date ：2021/10/27 14:11\n */\npublic class GetClassDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person = new Teacher();\n        System.out.println(\"这个人是\"+person.name);\n\n        // 方式1: 通过对象获取\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式2: forName获取\n        Class c2 = Class.forName(\"cn.usts.edu.Reflection03.Teacher\");\n        System.out.println(c2.hashCode());\n\n        // 方式3:通过类名.class获取\n        Class c3 = Teacher.class;\n        System.out.println(c3.hashCode());\n\n        // 方式4: 内置类型的包装类都有一个Type属性\n        Class c4 = Integer.TYPE;\n        System.out.println(c4);\n\n        // 方式5: 通过父类获取\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\n// pojo1\nclass Person{\n    int age;\n    String name;\n\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public Person() {\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// pojo2 教师\nclass Teacher extends Person{\n    public Teacher() {\n        this.age = 30;\n        this.name = \"老师\";\n    }\n}\n\n// pojo3 学生\nclass Student extends Person{\n    public Student() {\n        this.age=18;\n        this.name=\"学生\";\n    }\n}"
  },
  {
    "objectID": "posts/infineon_BTGR13C_target_code/index.html",
    "href": "posts/infineon_BTGR13C_target_code/index.html",
    "title": "infineon BGTR13C target code",
    "section": "",
    "text": "infineon 下位机代码处理流程概览, 以 MCU7 为案例"
  },
  {
    "objectID": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c",
    "href": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c",
    "title": "infineon BGTR13C target code",
    "section": "RadarBaseboardMCU7:: main.c",
    "text": "RadarBaseboardMCU7:: main.c\n\n标题格式 dir::file.cor(file.h) :: function :: interfunction….\n\n进入到 main 函数中, main 函数中结构很简单\nint main(void)\n{\n    // Board构造函数, 只调用这里只调用一次\n    Board_Constructor();\n\n    /* Loop forever */\n    while (1)\n    {\n        Board_run();\n    }\n}"
  },
  {
    "objectID": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c-board_constructor",
    "href": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c-board_constructor",
    "title": "infineon BGTR13C target code",
    "section": "RadarBaseboardMCU7:: main.c :: Board_Constructor",
    "text": "RadarBaseboardMCU7:: main.c :: Board_Constructor\n该函数是 board 构造(init), 在该函数的Platform_Constructor()初始化平台, 创建低级接口\nvoid Platform_Constructor(void)\n{\n    System_init();\n    System_disableWatchdog();\n\n    SysTimer_init();\n\n    System_startUSB();\n\n    PlatformInterfaces_Constructor();\n\n    Timer_Constructor();\n}\n接下来是对底板(atmel)的判断, 判断地板的类型, 这些参数配置在BoardDefinition.h中, 后续如果添加版本, 只需要修改这里的定义即可.\n// 如果不是Rev. A, 将原本BOARD_NAME_BASE的位置截断.\nif (!Sams70RevisionA())\n    {\n        // If this is not Rev. A, trim the suffix from the board name\n        boardInfo.name[sizeof(BOARD_NAME_BASE) - 1] = '\\0';\n    }\nBoardDefinition.h\n对板子信息进行描述, 方便后期移植工作.\n// BOARD_NAME will be trimmed to BOARD_NAME_BASE in Board.c depending on silicon revision\n#define BOARD_NAME_BASE \"RadarBaseboardMCU7\"\n#define BOARD_NAME      BOARD_NAME_BASE \" (Rev. A)\"\n#define BOARD_VID       0x058B\n#define BOARD_PID       0x0251\n\n//#define BOARD_EEPROM_ADDRESS_24CW128X 0x50\n\n#define COMMUNICATION_SERIAL\n\n\n#include \"../../../version.h\"\n后边是对gpio, spi,i2c 的构造, 这里的代码写的很巧妙, 分别在上层创建对应各个外设的类(结构体), 但是实际上该类掉用的是bsp的接口, 这么做将 bsp 和上层接口进行分离, 使得 bsp 做出修改后, 只要接口不做调整, 上层应用也无需做出调整. IGpio前面的 I应该是Interface的意思.\n    IGpio *gpio = &PlatformGpio;\n    ISpi *spi   = &PlatformSpi;\n    II2c *i2c   = &PlatformI2c;\n紧接着是对雷达接口的创建, 和上面的操作类似.\n IRadar *radar = NULL;\n下面是对, 板子的类型做出检测：HatvanPlus 或 HatvanLegacy(MCU7)\n是对板子的一个类型的判断, 判断有几个 connecter, MCU7 上, 有两个链接器, 但是只能初始化一个.\n/* 检测板类型：HatvanPlus 或 HatvanLegacy。\n     *\n     * 用于检测的引脚：\n     * 在标记为 BoardID 并连接到下拉的 HatvanPlus 上;\n     * 在标记为S2_SPI_DIR并连接到引体向上的 HatvanLegacy 上，\n     * 作为第二电平转换器电路的一部分。\n     *\n     * 解决方法：需要使能 LDO2 以提供 3.3v\n     * 用于上拉偏置，实现精确检测。\n*/\n\n  // detect board type\n    const bool isHatvanLegacy = Board_isHatvanLegacy();\n    if (isHatvanLegacy)\n    {\n        ShieldConnectorDefinition = &ShieldConnectorDefinitionHatvanLegacy[0];\n        BoardSpiDefinition        = &BoardSpiDefinitionHatvanLegacy[0];\n        BoardRadarPinsConfigAvian = &BoardRadarPinsConfigAvianHatvanLegacy[0];\n        m_shieldConnectorCount    = ARRAY_SIZE(ShieldConnectorDefinitionHatvanLegacy);\n    }\n    else\n    {\n        // HatvanPlus has two different kinds of connectors and just one is initialized\n        if (Board_isHatvanPlusV9Connected())\n        {\n            ShieldConnectorDefinition = &ShieldConnectorDefinitionHatvanPlus[1];\n            BoardSpiDefinition        = &BoardSpiDefinitionHatvanPlus[1];\n            BoardRadarPinsConfigAvian = &BoardRadarPinsConfigAvianHatvanPlus[1];\n        }\n        else\n        {\n            ShieldConnectorDefinition = &ShieldConnectorDefinitionHatvanPlus[0];\n            BoardSpiDefinition        = &BoardSpiDefinitionHatvanPlus[0];\n            BoardRadarPinsConfigAvian = &BoardRadarPinsConfigAvianHatvanPlus[0];\n        }\n        m_shieldConnectorCount = 1;\n    }\n因为上面对板子类型进行判断, 所以才得到 spi的一个具体配置信息, 才能后进行初始化工作, 代码如下.\nPlatformSpi_initialize(BoardSpiDefinition, m_shieldConnectorCount);\n对spi配置完成后对 led 进行配置, 配置 led 的一个状态表, 以及当前状态的设置.\nLedSequence_Constructor();\n    LedSequence_setStatus(LED_STATUS_OPERATING);\n检查核心板(radar 部分(shield))连接器是否存在配置错误 只有当扩展板具有 I2C 上拉时，才能检测到镜像连接 , OC 引脚上的其他意外电平被解释为错误的配置\n if (Board_detectShields() == E_SUCCESS)\n    {\n        /*\n                使用 SPI 和 I2C 检查已知设备是否存在,\n\n                尝试读取芯片 ID 并按以下顺序实例化相应的驱动程序\n                （每个实例化只有一个设备）\n\n                - Avian (SPI)  mcu 7 版本调用这个!!!!!\n                - LTR11 (SPI)\n                - ATR22 (I2C)\n        */\n\n        radar = Board_detectRadar(gpio, spi, i2c, &m_data);\n    }\n通信协议等外设, 继续正常初始化，这样即使没有检测到设备，I2C、SPI、GPIO 等也可以使用. 是能通信接口.\n// Enable communication interface\n    RequestHandler_Constructor(gpio, spi, m_data, i2c);\n    ProtocolHandler_Constructor();\n    CommandHandlerRadar_Constructor();\n判断 radar 所有外设是否配置完成, 如果配置完成, 设置数据回调函数, 让回调函数来处理数据, 回调了函数Board_dataCallback, 其中封装了一帧的数据, 并发送给上层的操作.\n if (radar != NULL)\n    {\n        Commands_IRadar_register(radar);\n\n        // register callback function to handle arriving data\n        m_data-&gt;registerCallback(Board_dataCallback, NULL);\n    }\n到此整块板子(雷达和主控) 的各部分件构造全部完成"
  },
  {
    "objectID": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c-board_run",
    "href": "posts/infineon_BTGR13C_target_code/index.html#radarbaseboardmcu7-main.c-board_run",
    "title": "infineon BGTR13C target code",
    "section": "RadarBaseboardMCU7:: main.c :: Board_run()",
    "text": "RadarBaseboardMCU7:: main.c :: Board_run()\n\n该部分, 是雷达各部分初始化工作,以及使能完成后, 对各中操作的监听, 以及响应的中断处理函数.\n\n/* Loop forever */\n    while (1)\n    {\n        Board_run();\n    }\n进入到Board_run函数中, Platform_run函数中没有任何操作, 预留给用户进行编写运行过程中的相关状态操作(猜测).\n// needs to be called for state machines, etc.\nPlatform_run();\n接下来的三个函数是针对三款不同的 60G mmwave(Avian, ltr11, atr22)进行执行响应的操作, 但是如果没有创建对应的实力的话, 函数会直接返回, 不会执行任何操作.\n// these run functions can just be called unconditionally, since they will immediately return by default if they are not initialized\n    DataAvian_run();\n    DataLtr11_run();\n    DataAtr22_run();\n\n\n\n\n\n\n这里的案例是avian系列的, 所以进入到该函数中其他两个函数在该平台下, 直接返回, 无任何操作.\n\n\n\nDataAvian_run 函数中, 先判断是够构建该实力, 判断该变量是否被实例化, 如果没有实例化, 没有实例化的默认值为NULL, 所以该函数直接反回, DataLtr11_run 和 DataAtr22_run 中的该部分操作也类似.\nif (!m_callback)\n    {\n        return;\n    }\n接下来是将雷达数据区遍历, 这里最大支持一个数据.\nfor (unsigned int index = 0; index &lt; DATA_AVIAN_MAX_COUNT; index++)\n检查雷达运行状态\nif (!self-&gt;running)\n        {\n            continue;\n        }\n检查数据队列中的数据, 是否有数据\n /* Check if new data packets have been fetched into the queue */\n        Queue_t *queue          = &self-&gt;queue;\n        const uint32_t written = queue-&gt;written;\n        const uint32_t read    = queue-&gt;read;\n        if (read == written)\n        {\n            // queue is empty\n            continue;\n        }\n往上层发送数据, 上位机.\n /* Transmit enqueued data packets to upper layers */\n        const uint32_t idx_read             = queue-&gt;idx_read;\n        const uint32_t max_packets          = queue-&gt;max_packets;\n        const uint32_t packet_size          = queue-&gt;packet_size;\n        const uint32_t payload_size         = queue-&gt;payload_size;\n        uint8_t *payload                    = &queue-&gt;buffer[idx_read * packet_size];\n        const queue_packet_header_t *header = &queue-&gt;packetHeaders[idx_read];\n        const uint64_t timestamp            = chrono_ticks_to_microseconds(header-&gt;ticks);\n检查是否溢出, 数据可能来自不同的 frame, 如果来自不同 frame, 判断会不会导致 FIFO 溢出.\n/* Check if FIFO overflow or underflow condition occurred */\n        bool errors = false;\n        if (self-&gt;frameSlices &gt; 1)\n        {\n            // In case a frame is being aggregated, check all slices in the queue\n            uint32_t idx_write = queue-&gt;idx_write;\n            for (uint32_t i = idx_read; i &lt; idx_write; i++)\n            {\n                const queue_packet_header_t *sliceHeader = &queue-&gt;packetHeaders[i];\n\n                errors = fifo_overflow(sliceHeader-&gt;gsr0);\n                if (errors)\n                {\n                    break;\n                }\n            }\n        }\n        else\n        {\n            // If no aggregation, just check the next slice in the queue\n            errors = fifo_overflow(header-&gt;gsr0);\n        }\n如果存在错误, 将雷达停止, 回调溢出错误函数, 记录当前时间错, 和 FIFO 索引.然后继续往下运行\nif (errors)\n        {\n            DataAvian_stop(self-&gt;index);\n            errorCallback(ERR_FIFO_OVERFLOW, self-&gt;index, timestamp);\n            continue;\n        }\n检查队列中是否有完整的数据帧, 如果没有回调函数还不能被调用.\nconst uint32_t slicesAvailable = written - read;\n        if (slicesAvailable &lt; self-&gt;frameSlices)\n        {\n            // complete frame is not yet available\n            这里的如果错误的逻辑还没有写, 就是错误与否都往上发送\n            continue;\n        }\n将队列中的数据进行发送\nm_callback(m_arg, payload, payload_size * self-&gt;frameSlices, self-&gt;index, timestamp);\n更新读取的索引, 和已读数量, 并且释放上一帧已经发送的数据\nqueue-&gt;idx_read = (idx_read + self-&gt;frameSlices) % max_packets;\n        queue-&gt;read     = read + self-&gt;frameSlices;\n如果数据队列已满, 数据获取请求可能会被挂起, 没有被挂起则每次回调后更新指针.\nif (self-&gt;pending)\n        {\n            DataAvian_fetchCallback(self, false);\n            self-&gt;pending--;\n        }"
  },
  {
    "objectID": "posts/javaArrayList作业1/index.html",
    "href": "posts/javaArrayList作业1/index.html",
    "title": "javaArrayList作业1",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/3 20:03\n */\npublic class NewsDemo {\n    public static void main(String[] args) {\n        ArrayList&lt;News&gt; newsArray = new ArrayList&lt;&gt;();\n        newsArray.add(new News(\"新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧\"));\n        newsArray.add(new News(\"男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生\"));\n\n        System.out.println(\"============默认=============\");\n        System.out.println(newsArray);\n\n        System.out.println(\"============逆序=============\");\n        Collections.reverse(newsArray);\n        System.out.println(newsArray);\n\n        System.out.println(\"============裁剪=============\");\n        for (News one : newsArray) {\n            if (one.getTitle().length()&gt;15){\n                System.out.println(one.getTitle().substring(0,14)+\".....\");\n            }\n        }\n    }\n}\n\nclass News{\n    private String title;\n    private String content;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n\n    public News(String title) {\n        this.title = title;\n    }\n\n    @Override\n    public String toString() {\n        return \"News{\" +\n                \"title='\" + title + '\\'' +\n\n                '}';\n    }\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/webSocket-node -- 01简单跑通/index.html",
    "href": "posts/webSocket-node -- 01简单跑通/index.html",
    "title": "webSocket-node – 01简单跑通",
    "section": "",
    "text": "简单实现架构图\n\n\n\n在这里插入图片描述\n\n\n安装webSocket\nnpm install websocket\n启动程序前配置package.json\n{\n  \"scripts\": {\n    \"start\": \"node index.js 8080\"\n  },\n  \"dependencies\": {\n    \"websocket\": \"^1.0.34\"\n  }\n}\n服务端程序: serverClient.js\nvar WebSocket = require('websocket').server\nvar http = require('http')\n\n// 创建httpServer\nvar httpServer = http.createServer().listen(8080,function (){\n    console.log('http://127.0.0.1:8080')\n})\n\n// 创建webSocketServer\nvar wsServer = new WebSocket({\n    httpServer:httpServer,\n    autoAcceptConnections:false\n})\n\nwsServer.on('request',function (request){\n    var connection = request.accept()\n    connection.on('message',function (msg){\n        console.log(msg)\n\n        // 发送给客户端\n        connection.send(msg.utf8Data)\n    })\n})\n客户端程序: Client.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"msg\"&gt;&lt;/div&gt;\n    &lt;input type=\"text\" id=\"text\"&gt;\n    &lt;input type=\"submit\" value=\"发送\" onclick=\"send()\"&gt;\n\n    &lt;script&gt;\n        var websocket = new WebSocket('ws://localhost:8080');\n        // ws ---&gt; http\n        // wss ---&gt; https\n\n        websocket.readyState\n        // 0 链接还没有建立\n        // 1 连接建立成功\n        // 2 连接正在关闭\n        // 3 连接已经关闭\n        websocket.onopen = function () {\n            console.log(websocket.readyState)\n        }\n        \n        function send() {\n            var text = document.getElementById('text').value\n            websocket.send(text)\n        }\n\n        websocket.onmessage = function (backMsg){\n            console.log(backMsg.data)\n        }\n    &lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n客户端： 服务端："
  },
  {
    "objectID": "posts/nb_iot_eDRX/index.html",
    "href": "posts/nb_iot_eDRX/index.html",
    "title": "nb-iot eDRX(Extended Discontinuous Reception)",
    "section": "",
    "text": "This paper discusses the application of eDRX (Extended Discontinuous Reception) and PSM (Power Saving Mode) in the context of the BC26 module, which is designed for NB-IoT applications. These power-saving techniques aim to reduce energy consumption and improve efficiency. The BC26 module supports eDRX and PSM, allowing IoT devices to achieve longer battery life and reduced energy consumption.\nKeywords: eDRX, PSM, BC26"
  },
  {
    "objectID": "posts/nb_iot_eDRX/index.html#taut3412-和-psmt3324配置",
    "href": "posts/nb_iot_eDRX/index.html#taut3412-和-psmt3324配置",
    "title": "nb-iot eDRX(Extended Discontinuous Reception)",
    "section": "TAU(T3412) 和 PSM(T3324)配置",
    "text": "TAU(T3412) 和 PSM(T3324)配置\nAT指令\nAT+CPSMS\n格式:\n# 查询语法\nAT+CPSMS=?\n# 查询目前设置的值\nAT+CPSMS?\n# 设置\nAT+CPSMS=&lt;mode&gt;[,,,&lt;requested_periodic_TAU&gt;[,&lt;requested_active_time&gt;]]\n\n# 打开psm,配置 TAU定时器值 和 PSM定时器值\nAT+CPSMS=1,,,TAU_VALUE,PSM_VALUE\n\n# 关闭PSM\nAT+CPSMS=0\n\n在PSM模式下, 且eDRX没有开启, 云端只能等待设备发送数据, 的requested_active_time时间内将下行数据传递到设备, 否则无法将数据发送到设备, 这种模式存在弊端,就是发送周期很长适用于三表类型的应用场景, 但是功耗也是很低uA级别.\n\nrequested_active_time: 在该段时间内可以发送数据也可以接收数据, 当requested_active_time结束后, 终端模块会进入到PSM(省电模式), 在该模式中就不可以接收数据了, 但是可以随时发送数据."
  },
  {
    "objectID": "posts/nb_iot_eDRX/index.html#edrx配置",
    "href": "posts/nb_iot_eDRX/index.html#edrx配置",
    "title": "nb-iot eDRX(Extended Discontinuous Reception)",
    "section": "eDRX配置",
    "text": "eDRX配置\nAT+QEDRXCFG\n# 查询语法\nAT+QEDRXCFG=?\n# 查询目前设置的值\nAT+QEDRXCFG?\n# 设置\nAT+QEDRXCFG=&lt;mode&gt;[,&lt;AcT_type&gt;[,&lt;requested_eDRX_value&gt;[,&lt;requested_paging_time_window_value&gt;]]]\n\n# 打开psm,配置 TAU定时器值 和 PSM定时器值\nAT+QEDRXCFG=1,5,\"1101\",\"0011\"\n# mode: -0 OFF  AcT_type        requested_eDRX_value        requested_paging_time_window_value\n#       -1 ON   接入技术类型            eDRX 周期"
  },
  {
    "objectID": "posts/esp8266--02 按钮状态监测/index.html",
    "href": "posts/esp8266--02 按钮状态监测/index.html",
    "title": "esp8266–02 按钮状态监测",
    "section": "",
    "text": "esp8266 nodeMCU上的LED灯为反向空控制 输入高电平为熄灭,输入低电平为点亮\nint buttonState = 0;         // 设置初始状态为0低电平\n\nvoid setup() {\n    // 设置串频率为9600\n  Serial.begin(9600);\n  // 设置板子上的led灯作为输出信号:\n  pinMode(LED_BUILTIN, OUTPUT);\n  // 初始化D0为信号采集针脚:\n  pinMode(16, INPUT);\n}\n\nvoid loop() {\n  // 设置按钮状态为D0采集到的状态:\n  buttonState = digitalRead(16);\n  // 串口打印信息(可以去掉)\n  Serial.println(buttonState+\"----\");\n  // 判断按钮是否按下\n  if (buttonState == HIGH) {\n    // 把LED点亮   \n    digitalWrite(LED_BUILTIN,LOW );\n    Serial.println(buttonState+\"----on\");\n  } else {\n    // turn LED off:\n    digitalWrite(LED_BUILTIN, HIGH);\n     Serial.println(buttonState+\"----off\");\n  }\n}"
  },
  {
    "objectID": "posts/esp8266--02 按钮状态监测/index.html#用d0口检测按钮是否按下.",
    "href": "posts/esp8266--02 按钮状态监测/index.html#用d0口检测按钮是否按下.",
    "title": "esp8266–02 按钮状态监测",
    "section": "",
    "text": "esp8266 nodeMCU上的LED灯为反向空控制 输入高电平为熄灭,输入低电平为点亮\nint buttonState = 0;         // 设置初始状态为0低电平\n\nvoid setup() {\n    // 设置串频率为9600\n  Serial.begin(9600);\n  // 设置板子上的led灯作为输出信号:\n  pinMode(LED_BUILTIN, OUTPUT);\n  // 初始化D0为信号采集针脚:\n  pinMode(16, INPUT);\n}\n\nvoid loop() {\n  // 设置按钮状态为D0采集到的状态:\n  buttonState = digitalRead(16);\n  // 串口打印信息(可以去掉)\n  Serial.println(buttonState+\"----\");\n  // 判断按钮是否按下\n  if (buttonState == HIGH) {\n    // 把LED点亮   \n    digitalWrite(LED_BUILTIN,LOW );\n    Serial.println(buttonState+\"----on\");\n  } else {\n    // turn LED off:\n    digitalWrite(LED_BUILTIN, HIGH);\n     Serial.println(buttonState+\"----off\");\n  }\n}"
  },
  {
    "objectID": "posts/esp8266--02 按钮状态监测/index.html#简化程序",
    "href": "posts/esp8266--02 按钮状态监测/index.html#简化程序",
    "title": "esp8266–02 按钮状态监测",
    "section": "简化程序",
    "text": "简化程序\nint buttonState = 0;         // 设置初始状态为0低电平\n\nvoid setup() {  \n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(16, INPUT);\n}\n\nvoid loop() {\n  buttonState = digitalRead(16);\n\n  if (buttonState == HIGH) {\n    digitalWrite(LED_BUILTIN,LOW);\n  } else { \n    digitalWrite(LED_BUILTIN, HIGH);\n  }\n}"
  },
  {
    "objectID": "posts/二分查找/index.html",
    "href": "posts/二分查找/index.html",
    "title": "二分查找",
    "section": "",
    "text": "二分查找的边界问题:\n\n[ left, right ) 左闭右开的情况 1.注意起始的右指针的位置, 因为右指针不包括, 所以是数组长度 2.指针的移动, 虽然不会影响结果, 但是有重复的区间, 所以还是尽量避开重复区间\n\nint  Search_Bin(int arr[], int length,int target){\n    int L=0;\n    int R=length;\n   \n    while(L&lt;R){\n        int mid = (L+R)/2;                      // 获取中间元素的索引\n        if(target&gt;arr[mid]){                    // 如果target大于mid\n           l=mid+1;                             // 将左指针右移动到mid+1的位置, 因为刚才左区已经查找过了, 所以要mid+1\n        }\n        else if(target&lt;arr[mid]){               // 如果target小于mid\n           r=mid;                               // 将右指针左移到mid的位置, 因为右边是一个开区间,不包含,所以直接是mid的位置.\n        }\n        else{\n            return mid;                         // mid的数据为targe直接返回当前mid.\n        }\n    }\n    \n    return 0;\n}\n\n[ left, right ] 左闭右闭的情况 1.注意起始的右指针的位置, 因为右指针的位置也包括在内, 所以是数组长度-1 2.注意左右指针移动区间\n\nint  Search_Bin(int arr[], int length,int target){\n    int L=0;\n    int R=length-1;\n   \n    while(L&lt;=R){\n        int mid = (L+R)/2;                      \n        if(target&gt;arr[mid]){                    \n           l=mid+1;                             // 将左指针右移动到mid+1的位置, 因为刚才左区已经查找过了, 所以要mid+1\n        }\n        else if(target&lt;arr[mid]){               \n           r=mid-1;                             // 因为右指针的位置也包含了, 所以需要将右指针移动到mid-1\n        }\n        else{\n            return mid;                         \n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "objectID": "posts/qt多线程QThread()/index.html",
    "href": "posts/qt多线程QThread()/index.html",
    "title": "qt多线程QThread()",
    "section": "",
    "text": "创建\nclass MyThread : public QThread\n{\nprotected:\n    void run()\n    {\n        /* 线程的相关代码 */\n    }\n};\n\n\n调用\nThread *thread = new Thread;\n\nthread-&gt;start();"
  },
  {
    "objectID": "posts/javaGUI--frame/index.html",
    "href": "posts/javaGUI--frame/index.html",
    "title": "javaGUI–frame",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestFrame {\n    public static void main(String[] args) {\n        // 窗口初始化\n        Frame frame = new Frame(\"我的第一个frame窗口\");\n\n        // 设置可见性\n        frame.setVisible(true);\n\n        // 设置窗口大小\n        frame.setSize(400,400);\n\n        // 设置位置\n        frame.setLocation(100,100);\n\n        // 设置背景色\n        frame.setBackground(new Color(78,145,10));\n\n\n    }\n\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java多线程-- 信号灯法则/index.html",
    "href": "posts/java多线程-- 信号灯法则/index.html",
    "title": "java多线程– 信号灯法则",
    "section": "",
    "text": "利用标志位,控制生产和消费 生产一个消费一个\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson08;\npublic class TrafficLightDemo {\n    public static void main(String[] args) {\n        Googs googs = new Googs();\n        new Productor1(googs).start();\n        new Consumer1(googs).start();\n    }\n}\n//生产者\nclass Productor1 extends Thread{\n    Googs goog;\n    Productor1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            goog.production(i+\"产品\");\n        }\n    }\n}\n\n//消费者\nclass Consumer1 extends Thread{\n    Googs goog;\n    Consumer1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            goog.consume();\n        }\n    }\n}\n\n//商品\nclass Googs{\n    //设置产品属性\n    public String name;\n    //设置标识位 flag为true消费者消费，如果false生产者生产\n    boolean flag = true;\n\n    //生产者生产\n    public synchronized void production(String name){\n        //如果生产完之后，等待消费者消费\n        if(!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产者生产了第\"+name);\n        //通知消费者消费\n        this.name = name;\n        this.notifyAll();\n        flag = !this.flag;\n    }\n    //消费者消费\n    public synchronized void consume(){\n        //如果消费完了，等待生产者生产\n        if(flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"消费了\"+this.name+\"产品--\");\n        this.notifyAll();\n        flag = !this.flag;\n\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 信号灯法则/index.html#信号灯法则",
    "href": "posts/java多线程-- 信号灯法则/index.html#信号灯法则",
    "title": "java多线程– 信号灯法则",
    "section": "",
    "text": "利用标志位,控制生产和消费 生产一个消费一个\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson08;\npublic class TrafficLightDemo {\n    public static void main(String[] args) {\n        Googs googs = new Googs();\n        new Productor1(googs).start();\n        new Consumer1(googs).start();\n    }\n}\n//生产者\nclass Productor1 extends Thread{\n    Googs goog;\n    Productor1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            goog.production(i+\"产品\");\n        }\n    }\n}\n\n//消费者\nclass Consumer1 extends Thread{\n    Googs goog;\n    Consumer1(Googs goog){\n        this.goog = goog;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            goog.consume();\n        }\n    }\n}\n\n//商品\nclass Googs{\n    //设置产品属性\n    public String name;\n    //设置标识位 flag为true消费者消费，如果false生产者生产\n    boolean flag = true;\n\n    //生产者生产\n    public synchronized void production(String name){\n        //如果生产完之后，等待消费者消费\n        if(!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产者生产了第\"+name);\n        //通知消费者消费\n        this.name = name;\n        this.notifyAll();\n        flag = !this.flag;\n    }\n    //消费者消费\n    public synchronized void consume(){\n        //如果消费完了，等待生产者生产\n        if(flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"消费了\"+this.name+\"产品--\");\n        this.notifyAll();\n        flag = !this.flag;\n\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--Swing[JFrame]/index.html",
    "href": "posts/javaGUI--Swing[JFrame]/index.html",
    "title": "javaGUI–Swing[JFrame]",
    "section": "",
    "text": "注意JFrame中的容器\npackage cn.usts.edu.lesson04;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JFrameDemo02 {\n    public static void main(String[] args) {\n        new TestJFrameDemo02().init();\n    }\n}\n\n\nclass TestJFrameDemo02 extends JFrame{\n    public void init(){\n        this.setBounds(100,100,400,300);\n        this.setVisible(true);\n        this.setTitle(\"hello\");\n        JLabel label = new JLabel(\"这是我的第二个JFrame程序\");\n        label.setHorizontalAlignment(SwingConstants.CENTER);// 水平对准\n\n        this.add(label);    // 添加组件\n\n        Container container = this.getContentPane();// 获取(内容面板)当前容器 有点awt中的getSource的味道\n        container.setBackground(Color.orange);//设置背景色\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);// 关闭按钮\n    }\n\n\n}"
  },
  {
    "objectID": "posts/esp8266--03 按钮次数计数/index.html",
    "href": "posts/esp8266--03 按钮次数计数/index.html",
    "title": "esp8266–03 按钮次数计数",
    "section": "",
    "text": "按下容易出现抖动,也程序误以为按下开关,所以要避免Debounce\n\nint buttonState = 0;         // 按钮状态\nint beforeState = 0;        // 按下前的状态   \nint counter = 0;            // 计数器\n\nvoid setup() {\n\n  Serial.begin(9600);       // 频率设置\n \n  pinMode(LED_BUILTIN, OUTPUT);     // 设置点亮LED\n \n  pinMode(16, INPUT);               // D0针脚为信号监测\n}\n\nvoid loop() {\n  buttonState = digitalRead(16);        // 获取按钮状态\n\n  if (buttonState == HIGH) {            // 判断是否按下\n          digitalWrite(LED_BUILTIN,LOW );   //按下点亮\n      } else {\n          digitalWrite(LED_BUILTIN,HIGH );   // 否则关闭\n            }\n  \n  //Serial.println(buttonState); \n  //Serial.println(beforeState); \n  //Serial.println(\"------------------------\");         \n  if(buttonState==HIGH and beforeState==LOW){\n      ++counter;\n      Serial.print(\"the press time is: \");\n      Serial.print(counter);\n      Serial.println();\n      //Serial.println(\"++++++++++++++++++++++++++++++++++\");\n    }\n  //Serial.println(buttonState);\n  // 避免debounce\n  if(buttonState!=beforeState){\n    delay(50);\n    }\n  beforeState=buttonState;          // 将按钮当前状态传递回去\n  delay(1);\n}"
  },
  {
    "objectID": "posts/esp8266--03 按钮次数计数/index.html#调试程序",
    "href": "posts/esp8266--03 按钮次数计数/index.html#调试程序",
    "title": "esp8266–03 按钮次数计数",
    "section": "",
    "text": "按下容易出现抖动,也程序误以为按下开关,所以要避免Debounce\n\nint buttonState = 0;         // 按钮状态\nint beforeState = 0;        // 按下前的状态   \nint counter = 0;            // 计数器\n\nvoid setup() {\n\n  Serial.begin(9600);       // 频率设置\n \n  pinMode(LED_BUILTIN, OUTPUT);     // 设置点亮LED\n \n  pinMode(16, INPUT);               // D0针脚为信号监测\n}\n\nvoid loop() {\n  buttonState = digitalRead(16);        // 获取按钮状态\n\n  if (buttonState == HIGH) {            // 判断是否按下\n          digitalWrite(LED_BUILTIN,LOW );   //按下点亮\n      } else {\n          digitalWrite(LED_BUILTIN,HIGH );   // 否则关闭\n            }\n  \n  //Serial.println(buttonState); \n  //Serial.println(beforeState); \n  //Serial.println(\"------------------------\");         \n  if(buttonState==HIGH and beforeState==LOW){\n      ++counter;\n      Serial.print(\"the press time is: \");\n      Serial.print(counter);\n      Serial.println();\n      //Serial.println(\"++++++++++++++++++++++++++++++++++\");\n    }\n  //Serial.println(buttonState);\n  // 避免debounce\n  if(buttonState!=beforeState){\n    delay(50);\n    }\n  beforeState=buttonState;          // 将按钮当前状态传递回去\n  delay(1);\n}"
  },
  {
    "objectID": "posts/esp8266--03 按钮次数计数/index.html#精简程序",
    "href": "posts/esp8266--03 按钮次数计数/index.html#精简程序",
    "title": "esp8266–03 按钮次数计数",
    "section": "精简程序",
    "text": "精简程序\nint buttonState = 0;         // 按钮状态\nint beforeState = 0;        // 按下前的状态   \nint counter = 0;            // 计数器\n\nvoid setup() {\n  Serial.begin(9600);       // 频率设置\n  pinMode(16, INPUT);               // D0针脚为信号监测\n}\n\nvoid loop() {       \n  if(buttonState==HIGH and beforeState==LOW){\n      ++counter;\n      Serial.print(\"the press time is: \");\n      Serial.print(counter);\n      Serial.println();\n    }\n  if(buttonState!=beforeState){\n    delay(50);\n    }\n  beforeState=buttonState;          // 将按钮当前状态传递回去\n  delay(1);\n}"
  },
  {
    "objectID": "posts/map作业三(集合)韩顺平/index.html",
    "href": "posts/map作业三(集合)韩顺平/index.html",
    "title": "map作业三(集合)韩顺平",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.*;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 13:06\n */\npublic class EmployeeDemo {\n    public static void main(String[] args) {\n        Map m = new HashMap();\n        m.put(\"jack\",650);\n        m.put(\"tom\",1200);\n        m.put(\"smith\",2900);\n\n        System.out.println(\"=========for遍历=========\");\n        Set keySet = m.keySet();\n        for (Object key : keySet) {\n            int sal =(int) m.get(key);\n            System.out.println(key+\"---\"+sal+\"元\");\n        }\n\n\n        // entrySet遍历\n        System.out.println(\"=========entrySet迭代器遍历=========\");\n        Set entrySet = m.entrySet();\n        Iterator iterator = entrySet.iterator();\n        while (iterator.hasNext()){\n            Map.Entry next = (Map.Entry) iterator.next();\n            System.out.println(next.getKey()+\"---\"+next.getValue()+\"元\");\n        }\n\n        System.out.println(\"=========修改jack=========\");\n        m.replace(\"jack\",2600);\n        m.forEach((key,value)-&gt; System.out.println(key+\"---\"+value+\"元\"));\n        // m.put(\"jack\",26000);\n\n        System.out.println(\"=========+100=========\");\n        m.forEach((key,value)-&gt;{m.replace(key,(int)value+100);});\n        m.forEach((key,value)-&gt; System.out.println(key+\"---\"+value+\"元\"));\n\n\n        System.out.println(\"=========遍历工资=========\");\n        Collection values = m.values();\n        for (Object value : values) {\n            System.out.println(\"工资:\"+value);\n        }\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/map作业三(集合)韩顺平/index.html#map作业三",
    "href": "posts/map作业三(集合)韩顺平/index.html#map作业三",
    "title": "map作业三(集合)韩顺平",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.homework;\n\nimport java.util.*;\n\n/**\n * @author ：fly\n * @description:\n * @date ：2021/11/4 13:06\n */\npublic class EmployeeDemo {\n    public static void main(String[] args) {\n        Map m = new HashMap();\n        m.put(\"jack\",650);\n        m.put(\"tom\",1200);\n        m.put(\"smith\",2900);\n\n        System.out.println(\"=========for遍历=========\");\n        Set keySet = m.keySet();\n        for (Object key : keySet) {\n            int sal =(int) m.get(key);\n            System.out.println(key+\"---\"+sal+\"元\");\n        }\n\n\n        // entrySet遍历\n        System.out.println(\"=========entrySet迭代器遍历=========\");\n        Set entrySet = m.entrySet();\n        Iterator iterator = entrySet.iterator();\n        while (iterator.hasNext()){\n            Map.Entry next = (Map.Entry) iterator.next();\n            System.out.println(next.getKey()+\"---\"+next.getValue()+\"元\");\n        }\n\n        System.out.println(\"=========修改jack=========\");\n        m.replace(\"jack\",2600);\n        m.forEach((key,value)-&gt; System.out.println(key+\"---\"+value+\"元\"));\n        // m.put(\"jack\",26000);\n\n        System.out.println(\"=========+100=========\");\n        m.forEach((key,value)-&gt;{m.replace(key,(int)value+100);});\n        m.forEach((key,value)-&gt; System.out.println(key+\"---\"+value+\"元\"));\n\n\n        System.out.println(\"=========遍历工资=========\");\n        Collection values = m.values();\n        for (Object value : values) {\n            System.out.println(\"工资:\"+value);\n        }\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/idea配置mapper.xml不提示解决方案/index.html",
    "href": "posts/idea配置mapper.xml不提示解决方案/index.html",
    "title": "idea配置mapper.xml不提示解决方案",
    "section": "",
    "text": "1、确保ieda连接数据库 2、ctrl+alt+s 进入设置"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html",
    "href": "posts/mysql8.0安装/index.html",
    "title": "mysql8.0安装",
    "section": "",
    "text": "在这里插入图片描述\n\n\n[mysqld]\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=D:\\environment\\mysql-8.0.27-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\environment\\mysql-8.0.27-winx64\\Data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n\n\n\n\n\n\nmysqld --initialize --console\n\n\n\n在这里插入图片描述\n\n\n\n\n\nmysqld --install\n 如果安装没成功：\nsc delete mysql\nmysqld --install\n\n\n\nnet start mysql\n\n\n\n在这里插入图片描述\n\n\n\n\n           username\nALTER user 'root'@'localhost' IDENTIFIED BY 'new password';\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html#配置my.ini文件",
    "href": "posts/mysql8.0安装/index.html#配置my.ini文件",
    "title": "mysql8.0安装",
    "section": "",
    "text": "在这里插入图片描述\n\n\n[mysqld]\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=D:\\environment\\mysql-8.0.27-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\environment\\mysql-8.0.27-winx64\\Data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html#执行初始化生成随机密码",
    "href": "posts/mysql8.0安装/index.html#执行初始化生成随机密码",
    "title": "mysql8.0安装",
    "section": "",
    "text": "mysqld --initialize --console\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html#安装",
    "href": "posts/mysql8.0安装/index.html#安装",
    "title": "mysql8.0安装",
    "section": "",
    "text": "mysqld --install\n 如果安装没成功：\nsc delete mysql\nmysqld --install"
  },
  {
    "objectID": "posts/mysql8.0安装/index.html#启动mysql",
    "href": "posts/mysql8.0安装/index.html#启动mysql",
    "title": "mysql8.0安装",
    "section": "",
    "text": "net start mysql\n\n\n\n在这里插入图片描述\n\n\n\n\n           username\nALTER user 'root'@'localhost' IDENTIFIED BY 'new password';\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/javaGUI--监听器02/index.html",
    "href": "posts/javaGUI--监听器02/index.html",
    "title": "javaGUI–监听器02",
    "section": "",
    "text": "点击 \npackage cn.usts.edu.lesson02;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestActionEvent {\n\n    public static void main(String[] args) {\n\n\n        Frame frame = new Frame(\"action Event\");\n        Button button = new Button();\n        frame.add(button,BorderLayout.CENTER);\n        frame.pack();\n        frame.setVisible(true);\n\n        // 按钮监听\n        MyActionListener myActionListener = new MyActionListener();\n        // addActionListener需要一个ActionListener于是我们创建了一个myActionListener\n        button.addActionListener(myActionListener);\n\n        // 关闭\n        myClose(frame);\n\n    }\n\n\n    // 监听关闭按钮\n    private static void myClose(Frame frame){\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n\n\nclass MyActionListener implements ActionListener{\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"监听到按钮动作\");\n    }\n}"
  },
  {
    "objectID": "posts/keil5设置调试器stm32/index.html",
    "href": "posts/keil5设置调试器stm32/index.html",
    "title": "keil5设置调试器stm32",
    "section": "",
    "text": "&gt; # 选所用的调试器\n &gt; # 设置 \n  \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/arch安装/index.html",
    "href": "posts/arch安装/index.html",
    "title": "arch安装",
    "section": "",
    "text": "arch 轻量化linux的安装过程\n参考地址:\nhttps://wiki.archlinux.org/title/Locale_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE"
  },
  {
    "objectID": "posts/arch安装/index.html#进入fdisk",
    "href": "posts/arch安装/index.html#进入fdisk",
    "title": "arch安装",
    "section": "进入fdisk",
    "text": "进入fdisk\np       // 打印信息\ng       // 设置disk类型为GPT\nn       // 创建一个新的分区\n设置引导分区(boot分区), &gt; 开始位置(直接回车,从开头), 设置分区编号(1-128):默认为1 // 直接回车表示默认 &gt; 结束位置(+512M) 如果有提示覆盖,输入Y\nn           // 创建分区\n回车          // 默认编号为1\n回车          // 默认从头开始\n+512M       // 向后512M\n设置swap分区 &gt; 休眠, 虚拟内存 &gt; 位置从刚才的512MB开始向后1G\nn// 创建swap分区\n3// 编号为3\n回车// 默认从头开始\n+1G // 向后1G\n设置主分区 &gt;存储系统数据\nn       // 创建swap分区\n2       // 编号为3\n回车      // 默认从头开始\n回车      // 向后所有\n分区完成  保存设置!!!!\nw       // 保存设置\n修改文件系统格式\nmkfs.fat -F32 引导分区          // 引导分区支持fat32,\nmkfs.ext4 主分区                   // linux主分区是ext4格式 \nmkswap swap分区                   // swap分区\nswapon swap分区                   // inux swapon命令用于激活Linux系统中交换空间，Linux系统的内存管理必须使用交换区来建立虚拟内存。"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html",
    "href": "posts/算法 --0_算法是什么/index.html",
    "title": "算法 –0_算法是什么",
    "section": "",
    "text": "算法听起来很神秘(高级),其实算法就是去做一件事情的方法,顺序,一个问题按照什么顺序(方法)去求解是最优的"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html#算法是什么",
    "href": "posts/算法 --0_算法是什么/index.html#算法是什么",
    "title": "算法 –0_算法是什么",
    "section": "",
    "text": "算法听起来很神秘(高级),其实算法就是去做一件事情的方法,顺序,一个问题按照什么顺序(方法)去求解是最优的"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html#例子1",
    "href": "posts/算法 --0_算法是什么/index.html#例子1",
    "title": "算法 –0_算法是什么",
    "section": "例子1:",
    "text": "例子1:\n外面下雨了,房间里的水开了,电话响了,衣服还没收\n遇到这些事情怎么做才是最优解,每个人都有不同的答案,取决于每个人的需求"
  },
  {
    "objectID": "posts/算法 --0_算法是什么/index.html#例子2",
    "href": "posts/算法 --0_算法是什么/index.html#例子2",
    "title": "算法 –0_算法是什么",
    "section": "例子2:",
    "text": "例子2:\n淘米,切菜,蒸饭,炒菜 这些事情怎么安排\n大多数人的选怎是:  淘米--&gt;蒸饭\n                        --&gt;切菜\n                        --&gt;炒菜\n因为在蒸饭的同是我们可以切菜炒菜,所以这样的顺序是一个大多数的情况,这就叫算法"
  },
  {
    "objectID": "posts/stm32_stack_size/index.html",
    "href": "posts/stm32_stack_size/index.html",
    "title": "how to set stack size of stm32",
    "section": "",
    "text": "Abstract\nstm32 project default stack size is: 0x1000 Byte, is 4KB if we want to use more biger stack. we need to adjust the stack size, but we only know the RAM size, if we set the RAM size of stack, the MCU doesn’t work.\n\n\nReferance\nnone\n\n\nhow to set stack\nthe max stack size is: Rotal_RAM = RAM1 + RAM2(is ram2 is none you can assign the whole RAM to RAM1(stack))\n\nset the stack accroding to the RAM1\n\n\n\nMAX demo with RAM2\n\n\n\nname\nsize\n\n\n\n\nTotal_RAM\n0x10000(64k)\n\n\nRAM1\n0xc000\n\n\nRAM2\n0x4000\n\n\n\n\n\n\nMAX demo without RAM2\n\n\n\nname\nsize\n\n\n\n\nTotal_RAM\n0x10000(64k)\n\n\nRAM1\n0x10000"
  },
  {
    "objectID": "posts/javaGUI--滚动条JScrollPane/index.html",
    "href": "posts/javaGUI--滚动条JScrollPane/index.html",
    "title": "javaGUI–滚动条JScrollPane",
    "section": "",
    "text": "将区域加上滚动条,和文本域 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JScrollDemo extends JFrame {\n    public JScrollDemo() {\n        this.setTitle(\"文本域\");\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 文本域\n        JTextArea textArea = new JTextArea(20,50);\n        textArea.setText(\"文本域默认输入的内容\");\n\n        // JScroll带滚动条的\n        JScrollPane scrollPane = new JScrollPane(textArea);\n\n        Container container = this.getContentPane();\n        container.add(scrollPane);\n\n    }\n\n    public static void main(String[] args) {\n        new JScrollDemo();\n    }\n}"
  },
  {
    "objectID": "posts/java网络编程-- URL（基本用法）/index.html",
    "href": "posts/java网络编程-- URL（基本用法）/index.html",
    "title": "java网络编程– URL（基本用法）",
    "section": "",
    "text": "package cn.usts.edu.lesson06;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * URL 统一资源定位符\n * 定位到网络中的资源\n * */\npublic class URLDemo {\n\n    public static void main(String[] args) throws MalformedURLException {\n        URL url = new URL(\"https://img-home.csdnimg.cn/images/20211019040101.gif?name=123\");\n        System.out.println(\"协议=\"+url.getProtocol());// 协议\n        System.out.println(\"主机ip=\"+url.getHost());// 主机ip\n        System.out.println(\"文件=\"+url.getPath());// 文件\n        System.out.println(\"全路径=\"+url.getFile());// 全路径\n        System.out.println(\"参数=\"+url.getQuery());// 参数\n\n    }\n}"
  },
  {
    "objectID": "posts/cordova安装启动/index.html",
    "href": "posts/cordova安装启动/index.html",
    "title": "cordova安装启动",
    "section": "",
    "text": "1、创建应用程序\n参考： https://www.w3cschool.cn/cordova/cordova_first_application.html\ncordova create CordovaProject io.cordova.hellocordova CordovaApp\n\nCordovaProject 是创建应用程序的目录名称。\nio.cordova.hellocordova 是默认的反向域值。 如果可能，您应该使用您自己的域值。\nCordovaApp 是您应用的标题。\n\n\n\n2 、 添加平台\n进入到创建的项目（CordovaProject）目录中\ncordova platform add android\n ### 3、构建和运行 安装javaSDK 下载地址：https://www.oracle.com/java/technologies/downloads/#jdk17-windows \nJAVA_HOME  = 安装的jdk位置\n\n\n\n在这里插入图片描述\n\n\n%JAVA_HOME%\\bin;\n%JAVA_HOME%\\jre\\bin\n #### 测试jdk是否安装成功\njava -version\n ### 安装安卓SDK installer_r24.4.1-windows.exe 下载地址 https://www.androiddevtools.cn/ \n #### 添加环境变量\nANDROID_HOME（不推荐）\nANDROID_SDK_ROOT（推荐）\nD:\\environment\\Android\\android-sdk\n\n\n\n在这里插入图片描述\n\n\n%ANDROID_SDK_ROOT%\\tools\n%ANDROID_SDK_ROOT%\\platform-tools\n\n%ANDROID_HOME%\\tools\n%ANDROID_HOME%\\platform-tools\n 测试SDK是否安装成功 adb --version  ### 接下来下载gradle要不然出现一下报错\nUsing Android SDK: D:\\environment\\Android\\android-sdk\nCould not find an installed version of Gradle either in Android Studio,\nor on your system to install the gradle wrapper. Please include gradle\nin your path, or install Android Studio\n\n\n\n在这里插入图片描述\n\n\ngradle：下载地址https://services.gradle.org/distributions/\n\n\ngradle添加环境变量\n  ### 3、运行\ncordova build android\n\n\n\n在这里插入图片描述\n\n\n\n外部设备启动：（内部的报错，懒得搞了，真实机器测试）\ncordova run android"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "",
    "text": "cookie是一种会话管理技术，他是用来保存会话技术过程中产生的数据，然后在浏览器和服务器交互时，会使用cookie里面保存的数据。\n首次访问不会携带cookie"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html#cookie对象",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html#cookie对象",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "",
    "text": "cookie是一种会话管理技术，他是用来保存会话技术过程中产生的数据，然后在浏览器和服务器交互时，会使用cookie里面保存的数据。\n首次访问不会携带cookie"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html#常用api",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html#常用api",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "2、常用api",
    "text": "2、常用api\n//得到cookie对象： \nCookie cookie = new Cookie( String key, String value);\n//回写（响应）到浏览器：\n response.addCookie(cookie);\n//得到cookie 的名称 ：\nString name = cookie.getName(),\n//得到cookie 的值：   \nString value = cookie.getValue();\n//给cookie设置 生命时长： \nsetMaxAge(int sr);\n//设置cookie生命为7 天;\n例：setMaxAge(60*60*24*7)\n    分类：\n        ①会话级别cookie，浏览器关闭，cookie对象就销毁了；\n        ②持久化cookie，通过setMaxAge()这个方法设置。\n    给cookie设置路径，设置域名：\n        setPath(路径的url),setDomain(域名)；\n        例：域名就是服务器名称   如：www.baidu.com\n//得到cookie：\nCookie[] cookies = request.getCookies();"
  },
  {
    "objectID": "posts/java EE 会话和会话技术 -cookie/index.html#cookie记录上次访问时间",
    "href": "posts/java EE 会话和会话技术 -cookie/index.html#cookie记录上次访问时间",
    "title": "java EE 会话和会话技术 -cookie",
    "section": "3、cookie记录上次访问时间",
    "text": "3、cookie记录上次访问时间\n默认级别cookie（浏览器关闭就会消失）\nresponse.setContentType(\"text/html;charset=utf-8\");\n        // 获取cookies\n        Cookie[] cookies = request.getCookies();\n        // 遍历cookies数组\n        String lasTime=null;\n        for(int i=0; cookies != null&& i&lt;cookies.length;i++){\n            String name = cookies[i].getName();\n            if(\"lastAccess\".equals(name)){\n                // 获取cookie的时间\n                lasTime = cookies[i].getValue();\n            }\n        }\n        // 判断是否是首次访问，如果cookie里有时间，就不是第一次访问\n        if(lasTime == null){\n            //String time = String.format(\"%tF %&lt;tT\", new Date());\n            //Cookie cookie = new Cookie(\"lastAccess\", time);\n            response.getWriter().print(\"您是第一次访问\");\n        }\n        else{\n            response.getWriter().print(\"您上次访问时间是：\"+lasTime);\n            //String time = String.format(\"%F %&lt;tT\", new Date());\n            //Cookie cookie = new Cookie(\"lastAccess\", time);\n            //response.addCookie(cookie);\n        }\n        \n        String time = String.format(\"%tF %&lt;tT\", new Date());\n        Cookie cookie = new Cookie(\"lastAccess\", time);\n        response.addCookie(cookie);\n持久化cookie\nString time = String.format(\"%tF %&lt;tT\", new Date());\n        Cookie cookie = new Cookie(\"lastAccess\", time);\n        // 保留7天\n        cookie.setMaxAge(60*60*24*7);\n        response.addCookie(cookie);"
  },
  {
    "objectID": "posts/jdbc-- StatementSQL注入演示/index.html",
    "href": "posts/jdbc-- StatementSQL注入演示/index.html",
    "title": "jdbc– StatementSQL注入演示",
    "section": "",
    "text": "解决方案: preparedStatement 测试用户名: 1' or 测试密码: or '1'='1\n// StatementSQL注入演示\n    @Test\n    public void statementSqlDemo() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"src/cn/usts/edu/config/db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");  \n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n        String sql =\"select admin.amin,admin.psd from admin where amin='\"+name+\"'and psd='\"+psd+\"'\";\n\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        // 获取结果\n        if (resultSet.next()){ // 查询到结果才会有记录\n            System.out.print(\"登陆成功\");\n        }else{\n            System.out.print(\"登陆失败\");\n        }\n\n\n        // 切断链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n\n    }\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/jdbc-- StatementSQL注入演示/index.html#statementsql注入演示",
    "href": "posts/jdbc-- StatementSQL注入演示/index.html#statementsql注入演示",
    "title": "jdbc– StatementSQL注入演示",
    "section": "",
    "text": "解决方案: preparedStatement 测试用户名: 1' or 测试密码: or '1'='1\n// StatementSQL注入演示\n    @Test\n    public void statementSqlDemo() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"src/cn/usts/edu/config/db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");  \n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n        String sql =\"select admin.amin,admin.psd from admin where amin='\"+name+\"'and psd='\"+psd+\"'\";\n\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        // 获取结果\n        if (resultSet.next()){ // 查询到结果才会有记录\n            System.out.print(\"登陆成功\");\n        }else{\n            System.out.print(\"登陆失败\");\n        }\n\n\n        // 切断链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n\n    }\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 重定向的多种实现方法/index.html",
    "href": "posts/java EE 重定向的多种实现方法/index.html",
    "title": "java EE 重定向的多种实现方法",
    "section": "",
    "text": "// 重定向到'/myProject/login.html '\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"hello\");\n\n\n\n// 重定向到'/myProject/login.html '\nresponse.sendRedirect(\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.sendRedirect(\"hello\");"
  },
  {
    "objectID": "posts/java EE 重定向的多种实现方法/index.html#第一种实现方法通过-302和location-实现",
    "href": "posts/java EE 重定向的多种实现方法/index.html#第一种实现方法通过-302和location-实现",
    "title": "java EE 重定向的多种实现方法",
    "section": "",
    "text": "// 重定向到'/myProject/login.html '\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.setStatus(302);\nresponse.setHeader(\"Location\",\"hello\");"
  },
  {
    "objectID": "posts/java EE 重定向的多种实现方法/index.html#第二种实现方法-推荐",
    "href": "posts/java EE 重定向的多种实现方法/index.html#第二种实现方法-推荐",
    "title": "java EE 重定向的多种实现方法",
    "section": "",
    "text": "// 重定向到'/myProject/login.html '\nresponse.sendRedirect(\"/myProject/login.html\");\n\n// 重定向到名为hello的servlet\nresponse.sendRedirect(\"hello\");"
  },
  {
    "objectID": "posts/javaGUI--表格布局/index.html",
    "href": "posts/javaGUI--表格布局/index.html",
    "title": "javaGUI–表格布局",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestGridLayOut {\n    // 表格布局\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"GridLayOut\");\n        frame.setVisible(true);\n\n        // 按钮组件\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n        Button button5 = new Button(\"button5\");\n        Button button6 = new Button(\"button6\");\n\n        // 设置布局形式为表格布局\n        frame.setLayout(new GridLayout(2,3));\n\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.add(button4);\n        frame.add(button5);\n        frame.add(button6);\n\n        // 自动调整为合适大小\n        frame.pack();\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--表格布局/index.html#效果",
    "href": "posts/javaGUI--表格布局/index.html#效果",
    "title": "javaGUI–表格布局",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestGridLayOut {\n    // 表格布局\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"GridLayOut\");\n        frame.setVisible(true);\n\n        // 按钮组件\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n        Button button5 = new Button(\"button5\");\n        Button button6 = new Button(\"button6\");\n\n        // 设置布局形式为表格布局\n        frame.setLayout(new GridLayout(2,3));\n\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.add(button4);\n        frame.add(button5);\n        frame.add(button6);\n\n        // 自动调整为合适大小\n        frame.pack();\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--监听器 [ 关闭按钮 ]/index.html",
    "href": "posts/javaGUI--监听器 [ 关闭按钮 ]/index.html",
    "title": "javaGUI–监听器 [ 关闭按钮 ]",
    "section": "",
    "text": "// 监听事件,监听窗口关闭实践\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });"
  },
  {
    "objectID": "posts/清除html和css标签自带的默认样式/index.html",
    "href": "posts/清除html和css标签自带的默认样式/index.html",
    "title": "清除html和css标签自带的默认样式",
    "section": "",
    "text": "在我们编写前端页面的时候，html和css标签有时候会自带一些格式，我们一般习惯性把自带格式全部清除，在需要的时候再自己写上，这样代码的可读性更加的高，也不会把自己搞混淆。\nhtml{color:#000;background:#FFF;} \nbody,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td { \nmargin:0; \npadding:0; \n} \ntable { \nborder-collapse:collapse; \nborder-spacing:0; \n} \nfieldset,img { \nborder:0; \n} \naddress,caption,cite,code,dfn,em,strong,th,var { \nfont-style:normal; \nfont-weight:normal; \n} \nol,ul { \nlist-style:none; \n} \ncaption,th { \ntext-align:left; \n} \nh1,h2,h3,h4,h5,h6 { \nfont-size:100%; \nfont-weight:normal; \n} \nq:before,q:after { \ncontent:''; \n} \nabbr,acronym { border:0; \n}"
  },
  {
    "objectID": "posts/清除html和css标签自带的默认样式/index.html#清除的目的",
    "href": "posts/清除html和css标签自带的默认样式/index.html#清除的目的",
    "title": "清除html和css标签自带的默认样式",
    "section": "",
    "text": "在我们编写前端页面的时候，html和css标签有时候会自带一些格式，我们一般习惯性把自带格式全部清除，在需要的时候再自己写上，这样代码的可读性更加的高，也不会把自己搞混淆。\nhtml{color:#000;background:#FFF;} \nbody,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td { \nmargin:0; \npadding:0; \n} \ntable { \nborder-collapse:collapse; \nborder-spacing:0; \n} \nfieldset,img { \nborder:0; \n} \naddress,caption,cite,code,dfn,em,strong,th,var { \nfont-style:normal; \nfont-weight:normal; \n} \nol,ul { \nlist-style:none; \n} \ncaption,th { \ntext-align:left; \n} \nh1,h2,h3,h4,h5,h6 { \nfont-size:100%; \nfont-weight:normal; \n} \nq:before,q:after { \ncontent:''; \n} \nabbr,acronym { border:0; \n}"
  },
  {
    "objectID": "posts/matlab-coder/index.html",
    "href": "posts/matlab-coder/index.html",
    "title": "Matlab Coder",
    "section": "",
    "text": "matlab Coder 可以将matlab脚本转换为c or C++代码, 极大程度让用户专注算法的设计\n\n可以指定接口类型, 但是无法指定中间变量的类型\n在转换后注意tmwtypes.h和rtwtypes.h的include\n接口参数类型的指定\n\n\n\n\nfunction [data_MCA] = MultiChannelAverage(data_radar)\n% 输入data_radar: numADCSamples * 8\n% 输出data_MCA: numADCSamples * 1\n\ndata_MCA = mean(data_radar,2);\nend\n\n\n\n/*\n * File: MultiChannelAverage.c\n *\n * MATLAB Coder version            : 5.2\n * C/C++ source code generated on  : 29-Nov-2022 14:55:50\n */\n\n/* Include Files */\n#include \"MultiChannelAverage.h\"\n\n/* Function Definitions */\n/*\n * 输入data_radar: numADCSamples * 8\n *  输出data_MCA: numADCSamples * 1\n *\n * Arguments    : const cint16_T data_radar[1024]\n *                creal_T data_MCA[128]\n * Return Type  : void\n */\nvoid MultiChannelAverage(const cint16_T data_radar[1024], creal_T data_MCA[128])\n{\n  double ai;\n  double im;\n  double re;\n  int data_radar_re_tmp;\n  int k;\n  int xj;\n  int xoffset;\n  for (xj = 0; xj &lt; 128; xj++) {\n    data_MCA[xj].re = data_radar[xj].re;\n    data_MCA[xj].im = data_radar[xj].im;\n  }\n  for (k = 0; k &lt; 7; k++) {\n    xoffset = (k + 1) &lt;&lt; 7;\n    for (xj = 0; xj &lt; 128; xj++) {\n      data_radar_re_tmp = xoffset + xj;\n      data_MCA[xj].re += (double)data_radar[data_radar_re_tmp].re;\n      data_MCA[xj].im += (double)data_radar[data_radar_re_tmp].im;\n    }\n  }\n  for (xj = 0; xj &lt; 128; xj++) {\n    im = data_MCA[xj].re;\n    ai = data_MCA[xj].im;\n    if (ai == 0.0) {\n      re = im / 8.0;\n      im = 0.0;\n    } else if (im == 0.0) {\n      re = 0.0;\n      im = ai / 8.0;\n    } else {\n      re = im / 8.0;\n      im = ai / 8.0;\n    }\n    data_MCA[xj].re = re;\n    data_MCA[xj].im = im;\n  }\n}\n\n/*\n * File trailer for MultiChannelAverage.c\n *\n * [EOF]\n */"
  },
  {
    "objectID": "posts/matlab-coder/index.html#matlab代码",
    "href": "posts/matlab-coder/index.html#matlab代码",
    "title": "Matlab Coder",
    "section": "",
    "text": "function [data_MCA] = MultiChannelAverage(data_radar)\n% 输入data_radar: numADCSamples * 8\n% 输出data_MCA: numADCSamples * 1\n\ndata_MCA = mean(data_radar,2);\nend"
  },
  {
    "objectID": "posts/matlab-coder/index.html#转换完成后的c语言代码",
    "href": "posts/matlab-coder/index.html#转换完成后的c语言代码",
    "title": "Matlab Coder",
    "section": "",
    "text": "/*\n * File: MultiChannelAverage.c\n *\n * MATLAB Coder version            : 5.2\n * C/C++ source code generated on  : 29-Nov-2022 14:55:50\n */\n\n/* Include Files */\n#include \"MultiChannelAverage.h\"\n\n/* Function Definitions */\n/*\n * 输入data_radar: numADCSamples * 8\n *  输出data_MCA: numADCSamples * 1\n *\n * Arguments    : const cint16_T data_radar[1024]\n *                creal_T data_MCA[128]\n * Return Type  : void\n */\nvoid MultiChannelAverage(const cint16_T data_radar[1024], creal_T data_MCA[128])\n{\n  double ai;\n  double im;\n  double re;\n  int data_radar_re_tmp;\n  int k;\n  int xj;\n  int xoffset;\n  for (xj = 0; xj &lt; 128; xj++) {\n    data_MCA[xj].re = data_radar[xj].re;\n    data_MCA[xj].im = data_radar[xj].im;\n  }\n  for (k = 0; k &lt; 7; k++) {\n    xoffset = (k + 1) &lt;&lt; 7;\n    for (xj = 0; xj &lt; 128; xj++) {\n      data_radar_re_tmp = xoffset + xj;\n      data_MCA[xj].re += (double)data_radar[data_radar_re_tmp].re;\n      data_MCA[xj].im += (double)data_radar[data_radar_re_tmp].im;\n    }\n  }\n  for (xj = 0; xj &lt; 128; xj++) {\n    im = data_MCA[xj].re;\n    ai = data_MCA[xj].im;\n    if (ai == 0.0) {\n      re = im / 8.0;\n      im = 0.0;\n    } else if (im == 0.0) {\n      re = 0.0;\n      im = ai / 8.0;\n    } else {\n      re = im / 8.0;\n      im = ai / 8.0;\n    }\n    data_MCA[xj].re = re;\n    data_MCA[xj].im = im;\n  }\n}\n\n/*\n * File trailer for MultiChannelAverage.c\n *\n * [EOF]\n */"
  },
  {
    "objectID": "posts/java_Fastjson的使用/index.html",
    "href": "posts/java_Fastjson的使用/index.html",
    "title": "java_Fastjson的使用",
    "section": "",
    "text": "1·导入依赖\n&lt;dependency&gt;\n   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n   &lt;version&gt;1.2.60&lt;/version&gt;\n&lt;/dependency&gt;\n2·创建FastJsonDemo.class\npackage cn.usts.deu.controller;\n\nimport cn.usts.deu.pojo.User1;\nimport com.alibaba.fastjson.JSON;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@RestController\npublic class FastJsonController {\n    @RequestMapping(\"/fast1\")\n    public void fastJson1(){\n        User1 user2 = new User1(\"tom2\",13,\"男\");\n        User1 user3 = new User1(\"tom3\",11,\"女\");\n        User1 user4 = new User1(\"tom4\",14,\"女\");\n        User1 user5 = new User1(\"tom5\",12,\"男\");\n        User1 user6 = new User1(\"tom6\",11,\"男\");\n        List&lt;User1&gt; list= new ArrayList&lt;User1&gt;();\n        list.add(user2);\n        list.add(user3);\n        list.add(user4);\n        list.add(user5);\n        list.add(user6);\n        // Java对象 转 JSON字符串\n        String lis1 = JSON.toJSONString(list);\n        System.out.println(lis1);\n        String user = JSON.toJSONString(user2);\n        System.out.println(user);\n\n        //json 字符串转java对象\n        User1 javaProject_user = JSON.parseObject(user,User1.class);\n        \n    }\n}"
  },
  {
    "objectID": "posts/pip加速/index.html",
    "href": "posts/pip加速/index.html",
    "title": "pip加速",
    "section": "",
    "text": "pip加速\n清华镜像站使用 https://mirrors.tuna.tsinghua.edu.cn/help/pypi/"
  },
  {
    "objectID": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html",
    "href": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html",
    "title": "java常用类– String、StringBuffer（StringBuilder）",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.StringAndStringBufferDemo;\n\nimport java.util.Arrays;\n\n/**\n * @author ：fly\n * @description: String 类的常用操作\n * @date ：2021/10/31 13:28\n */\npublic class StringDemo {\n    public static void main(String[] args) {\n        String a = \"  hello world HELLO java hello fly \";\n        System.out.println( \"长度\"+a.length());// 长度\n        System.out.println(\"第0号索引位置上字符是啥\"+a.charAt(0));\n        System.out.println(\"第一次出现的位置\"+a.indexOf(\"ja\"));\n        System.out.println(\"最后一次出现\\\"he\\\"的位置\"+a.lastIndexOf(\"he\"));\n\n        System.out.println(\"是否以fly为结尾\"+a.endsWith(\"fly\"));\n        System.out.println(\"字符串是否相同\"+a.equals(\"asdfadsf\"));// 这里区分== ,== 比较的是地址值\n        System.out.println(\"字符串是否为空\"+a.isEmpty());\n        System.out.println(\"是否以..为开头\"+ a.startsWith(\"hello\"));\n        System.out.println(\"是否包含hello\"+ a.contains(\"hello\"));\n\n        System.out.println(\"将所有字符转换为大写\"+a.toUpperCase());\n        System.out.println(\"将所有字符转换为小写\"+a.toLowerCase());\n\n        System.out.println(\"将变量转换成string(字符串)\"+String.valueOf(12));\n        System.out.println(\"将字符串转换成一个字符数组\"+ Arrays.toString(a.toCharArray()));\n        char[] chars = a.toCharArray();\n        for (char aChar : chars) {\n            System.out.print(aChar+\",\");\n        }\n        System.out.println();\n\n        System.out.println(\"Hello替换掉hello--&gt;\"+a.replace(\"hello\", \"Hello\"));\n        System.out.println(\"以空格为分割点:\"+Arrays.toString(a.split(\" \")));\n        System.out.println(a);\n        System.out.println(\"从第2号位置开始保留\"+a.substring(2));\n        System.out.println(\"保留2-7号位置\"+a.substring(2,7));\n        System.out.println(\"去掉首尾空格\"+a.trim());\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#string的常见操作",
    "href": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#string的常见操作",
    "title": "java常用类– String、StringBuffer（StringBuilder）",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.StringAndStringBufferDemo;\n\nimport java.util.Arrays;\n\n/**\n * @author ：fly\n * @description: String 类的常用操作\n * @date ：2021/10/31 13:28\n */\npublic class StringDemo {\n    public static void main(String[] args) {\n        String a = \"  hello world HELLO java hello fly \";\n        System.out.println( \"长度\"+a.length());// 长度\n        System.out.println(\"第0号索引位置上字符是啥\"+a.charAt(0));\n        System.out.println(\"第一次出现的位置\"+a.indexOf(\"ja\"));\n        System.out.println(\"最后一次出现\\\"he\\\"的位置\"+a.lastIndexOf(\"he\"));\n\n        System.out.println(\"是否以fly为结尾\"+a.endsWith(\"fly\"));\n        System.out.println(\"字符串是否相同\"+a.equals(\"asdfadsf\"));// 这里区分== ,== 比较的是地址值\n        System.out.println(\"字符串是否为空\"+a.isEmpty());\n        System.out.println(\"是否以..为开头\"+ a.startsWith(\"hello\"));\n        System.out.println(\"是否包含hello\"+ a.contains(\"hello\"));\n\n        System.out.println(\"将所有字符转换为大写\"+a.toUpperCase());\n        System.out.println(\"将所有字符转换为小写\"+a.toLowerCase());\n\n        System.out.println(\"将变量转换成string(字符串)\"+String.valueOf(12));\n        System.out.println(\"将字符串转换成一个字符数组\"+ Arrays.toString(a.toCharArray()));\n        char[] chars = a.toCharArray();\n        for (char aChar : chars) {\n            System.out.print(aChar+\",\");\n        }\n        System.out.println();\n\n        System.out.println(\"Hello替换掉hello--&gt;\"+a.replace(\"hello\", \"Hello\"));\n        System.out.println(\"以空格为分割点:\"+Arrays.toString(a.split(\" \")));\n        System.out.println(a);\n        System.out.println(\"从第2号位置开始保留\"+a.substring(2));\n        System.out.println(\"保留2-7号位置\"+a.substring(2,7));\n        System.out.println(\"去掉首尾空格\"+a.trim());\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#stringbuffer常用操作",
    "href": "posts/java常用类-- String、StringBuffer（StringBuilder）/index.html#stringbuffer常用操作",
    "title": "java常用类– String、StringBuffer（StringBuilder）",
    "section": "StringBuffer常用操作",
    "text": "StringBuffer常用操作\nStringBuffer的出现是为了解决String无法修改的问题，StringBuffer是一个可边长的字符串，他的内容和长度都可以改变。 #### 附加点 StringBuffer 和 StringBuilder相似(使用方法一模一样,append,insert,delete,replace….) 但是StringBuffer有线程安全,StringBuild没有,所以StringBuild的性能略高 \npackage cn.usts.edu.fly.StringAndStringBufferDemo;\n\n/**\n * @author ：fly\n * @description: StringBuffer的常见操作\n *                  StringBuffer 和 StringBuilder相似(使用方法一模一样,append,insert,delete,replace....)\n *                  但是StringBuffer有线程安全,StringBuild没有,所以StringBuild的性能略高\n * @date ：2021/10/31 14:25\n */\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(\"像sb中写入字符串\"));\n        System.out.println(sb.insert(\"像sb中写入字符串\".length(), \"6666\"));// 插入6666\n\n        System.out.println(sb.delete(9,13));// StringBuffer中删除掉指定位置的字符串\n        System.out.println(\"索引为3的是:\"+sb.charAt(3));\n        System.out.println(sb.replace(4,5,\"替换\"));// 开始,结束,替换的字符串\n        sb.setCharAt(0,'向');\n        System.out.println(sb);\n        System.out.println(\"逆序:\"+sb.reverse());\n    }\n\n    public static void add(){\n\n    }\n}"
  },
  {
    "objectID": "posts/java EE -Session/index.html",
    "href": "posts/java EE -Session/index.html",
    "title": "java EE -Session",
    "section": "",
    "text": "session是一种会话赶礼技术，seession，用来保存会话过程中的数据，保存的数据存储到服务器端。\n\n\n\nsession是基于cookie实现的. 当session被创建时，会在服务器端开辟一块session空间，并把该空间的秘钥(JESSIONID)返回给浏览器， 用户拿到钥匙后对页面进行请求，将秘钥携带在请求头中（set-Cookie:JSEEIONID=111） ## 1.3 HttpSession API\nsession 常用方法：\n①得到session的id（JESSIONID对应的值）：getId();\n② 设置session的生命时长：setMaxInactiveInterval(int interval)\n③销毁session: invalidate();\n③得到session：HttpSession session = getSession();\nsession域对象：作用范围  一次完整的会话（包含多个请求）\n①存值：setAttribute(String key,Object obj);\n②取值：Object obj = getAttribute(String key);\n③移除值：removeAttribute(String key)\n总结域对象：\nrequest对象，session，servletContext对象，作用范围依次变大。\nrequest域对象：再用用范围是一次请求，通常和转发操作配合使用\nsession域对象：作用范围一次会话，通常和重定向配合使用\nservletContext域预想：作用范围整个项目，和重定向、转发操作、都可以配合使用。\n1.4 session超时 session对象有生命时长，他的默认存活时间是30分钟， 具体配置套tomcat软件中的conf下的文件，\n&lt;session-timeout&gt;30&lt;/session-timeout&gt;\n立即销毁session对象：invalidate"
  },
  {
    "objectID": "posts/java EE -Session/index.html#什么是session",
    "href": "posts/java EE -Session/index.html#什么是session",
    "title": "java EE -Session",
    "section": "",
    "text": "session是一种会话赶礼技术，seession，用来保存会话过程中的数据，保存的数据存储到服务器端。"
  },
  {
    "objectID": "posts/java EE -Session/index.html#原理",
    "href": "posts/java EE -Session/index.html#原理",
    "title": "java EE -Session",
    "section": "",
    "text": "session是基于cookie实现的. 当session被创建时，会在服务器端开辟一块session空间，并把该空间的秘钥(JESSIONID)返回给浏览器， 用户拿到钥匙后对页面进行请求，将秘钥携带在请求头中（set-Cookie:JSEEIONID=111） ## 1.3 HttpSession API\nsession 常用方法：\n①得到session的id（JESSIONID对应的值）：getId();\n② 设置session的生命时长：setMaxInactiveInterval(int interval)\n③销毁session: invalidate();\n③得到session：HttpSession session = getSession();\nsession域对象：作用范围  一次完整的会话（包含多个请求）\n①存值：setAttribute(String key,Object obj);\n②取值：Object obj = getAttribute(String key);\n③移除值：removeAttribute(String key)\n总结域对象：\nrequest对象，session，servletContext对象，作用范围依次变大。\nrequest域对象：再用用范围是一次请求，通常和转发操作配合使用\nsession域对象：作用范围一次会话，通常和重定向配合使用\nservletContext域预想：作用范围整个项目，和重定向、转发操作、都可以配合使用。\n1.4 session超时 session对象有生命时长，他的默认存活时间是30分钟， 具体配置套tomcat软件中的conf下的文件，\n&lt;session-timeout&gt;30&lt;/session-timeout&gt;\n立即销毁session对象：invalidate"
  },
  {
    "objectID": "posts/nb_iot_channel_choice/index.html",
    "href": "posts/nb_iot_channel_choice/index.html",
    "title": "nb-iot advantages and disadvantages between B5 and B8",
    "section": "",
    "text": "This study compares the selection of B5 (850 MHz) and B8 (900 MHz) frequency bands for Narrowband Internet of Things (NB-IoT) deployment. Factors such as coverage range, signal quality, spectrum availability, and interference considerations are evaluated to determine the advantages and drawbacks of using B5 and B8 bands. The findings assist in informed decision-making for NB-IoT implementation."
  },
  {
    "objectID": "posts/nb_iot_channel_choice/index.html#优缺点",
    "href": "posts/nb_iot_channel_choice/index.html#优缺点",
    "title": "nb-iot advantages and disadvantages between B5 and B8",
    "section": "优缺点",
    "text": "优缺点\nB5（850 MHz）的优点：\n\n\n传输范围：由于较低的频率，B5信号具有较好的穿透能力，可以在相对较长的距离内传输，并具有较强的建筑物穿透能力。\n信号质量：B5信号相对较低的频率可以减少多径干扰，因此在某些环境下，可能会具有更好的信号质量和连接可靠性。\n覆盖范围：相对于高频段，B5信号的覆盖范围较广，适合用于广阔的地理区域和较少基站的部署情况。\n\n\nB5（850 MHz）的缺点：\n\n\n频谱限制：由于B5频段在一些地区可能有限制或已经被分配给其他用途，因此在某些地区可能没有足够的可用频谱资源。\n带宽限制：相对于较高的频段，B5频段的可用带宽可能较窄，限制了数据传输速率的潜力。\n\n\nB8（900 MHz）的优点： &gt; 1. 频谱可用性：B8频段在许多地区可用且有较好的频谱资源分配，因此在大多数情况下可以获得较好的频谱支持。 &gt; 2. 信号传输：B8频段在传输质量方面通常表现良好，并且具有较好的覆盖范围和传输能力。\nB8（900 MHz）的缺点：\n\n\n覆盖距离：相对于B5频段，B8频段在传输距离方面可能稍短一些，穿透能力稍弱。\n干扰情况：由于B8频段的广泛使用，可能会面临更多的干扰源，如其他设备或邻近基站的干扰。"
  },
  {
    "objectID": "posts/java多线程-- 初识多线程的问题(简单案例)/index.html",
    "href": "posts/java多线程-- 初识多线程的问题(简单案例)/index.html",
    "title": "java多线程– 初识多线程的问题(简单案例)",
    "section": "",
    "text": "没有控制的并发会导致数据的不一致 \npackage cn.usts.edu.lesson02;\n\n/**\n * 并发会导致对数据的访问有问题\n * */\npublic class ThreadProblem implements Runnable{\n    private int tickets=10;\n\n    @Override\n\n    public void run() {\n        String threadName = Thread.currentThread().getName(); // 获取当前线程的名字\n        while (true){\n            if (tickets&lt;=0){\n                break;\n            }\n            System.out.println(\"【\"+threadName+\"】\"+tickets--);\n\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadProblem ticket = new ThreadProblem();\n        new Thread(ticket,\"小明\").start();\n        new Thread(ticket,\"小红\").start();\n        new Thread(ticket,\"黄牛\").start();\n    }\n\n\n}"
  },
  {
    "objectID": "posts/算法-- 1_递归/index.html",
    "href": "posts/算法-- 1_递归/index.html",
    "title": "算法– 1_递归",
    "section": "",
    "text": "递归就是所谓的套娃但是这个套娃是有前提的,要有终止的条件,不能无尽的套娃"
  },
  {
    "objectID": "posts/算法-- 1_递归/index.html#什么叫递归",
    "href": "posts/算法-- 1_递归/index.html#什么叫递归",
    "title": "算法– 1_递归",
    "section": "",
    "text": "递归就是所谓的套娃但是这个套娃是有前提的,要有终止的条件,不能无尽的套娃"
  },
  {
    "objectID": "posts/算法-- 1_递归/index.html#递归的例子",
    "href": "posts/算法-- 1_递归/index.html#递归的例子",
    "title": "算法– 1_递归",
    "section": "递归的例子",
    "text": "递归的例子\n# -*- coding: utf-8 -*-\n# @Time : 2021/11/28 16:08\n\n\ndef r1(n):\n    if n &gt; 0:\n        r1(n - 1)\n        print(n)\n\n\ndef r2(n):\n    if n &gt; 0:\n        print(n)\n        r1(n - 1)\n\n\nr1(3)\nprint('-------------')\nr2(3)\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "href": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "title": "qt移动界面无响应[ 多线程 ]",
    "section": "",
    "text": "创建子进程类\n\n普通的长时间操作界面容易卡死, 体验非常不好,为了提升体验, 所以将需要较长时间响应的事件都放到了子线程中执行, 这样主线程就不会出现假死的状态\n\n\n方法1(继承QThread):\n.h [头文件]\n#ifndef MYTHREAD_H\n#define MYTHREAD_H\n\n#include &lt;QThread&gt;\n\nclass Generate : public QThread\n{\n    Q_OBJECT\npublic:\n    explicit Generate(QObject* parent = nullptr);// 直接使用qt的类生成,这里没有默认的空指针,new的时候会报错,需要设置成nullptr\n\nprotected:\n    void run(); // 重写run函数\n\nsignals:\n    void curNumber(int num);// 自定义信号, 传递数据\n    void curimg(QImage* img); // 传递图片, 如果是自定义的结构, 需要注册类型:qRegisterMetaType&lt;int&gt;(\"int\")  [int根据自己的类型设置];\n\npublic slots:\n};\n\n#endif // MYTHREAD_H\n.c[源文件]\n#include \"mythread.h\"\n#include \"qdebug.h\"\n\nGenerate::Generate(QObject* parent) : QThread(parent)\n{\n\n}\n\nvoid Generate::run()\n{\n    qDebug() &lt;&lt; \"current Thread id is: \" &lt;&lt; QThread::currentThread();\n\n    int num = 0;\n    while (1)\n    {\n        emit curNumber(num++);\n        if (num == 999)\n        {\n            qDebug() &lt;&lt; \" sub Thread is finished...\";\n            break;\n        }\n        QThread::usleep(1);\n    }\n}\nmainwindow.c主线程\n#include \"qtwidgetsapplication_thread.h\"\n#include \"MyCreate.h\"\n\n\n\n#include &lt;qdebug.h&gt;\n\nQtWidgetsApplication_Thread::QtWidgetsApplication_Thread(QWidget *parent)\n    : QMainWindow(parent)\n{\n    ui.setupUi(this);\n    qDebug() &lt;&lt; \"main thread is : \" &lt;&lt; QThread::currentThread();\n    \n    // 将刚才的创建的类实例化\n    Generate * subThread_A = new Generate ;\n   \n\n\n    // 绑定信号和槽\n    connect(subThread_A, &Generate ::curNumber, this, [=](int num) {\n        ui.label-&gt;setNum(num);\n        });\n   \n\n\n    // 启动线程\n    connect(ui.pushButton, &QPushButton::clicked, this, [=]() {\n        subThread_A-&gt;start();\n        });\n    \n   \n\n}\n\n\n\n方法二(moveToThread):\n这种方法相对来说更加灵活     打开创建类的头文件MyThread.h\n\n修改MyThread(QObject *parent);—–&gt;MyThread(QObject *parent=nullptr);, 不修改在new的时候会报错 [类 不存在默认构造函数]\n\n 修改完成后如下\n#include &lt;QObject&gt;\n\nclass MyThread  : public QObject\n{\n    Q_OBJECT\n    \npublic:\n    MyThread(QObject *parent=nullptr);\n    ~MyThread();\n\n    // create working function to do sth what you want\n    void working(); //线程中执行的代码写到working中,这个函数名随意\n\nsignals:\n    // create a signal to kick the thread\n    void signal_hello(int count); // 设置一个触发信号, count为传递的变量, 将这个变量用来讲子线程和主线程之间进行传递数据.\n};\n打开创建类的源文件MyThread.cpp\n\n将刚才创建的头文件进行实现 这个程序的作用主要是将子线程中的变量发送到主线程进行显示\n\n#include \"MyThread.h\"\n\n#include \"qdebug.h\"\n#include \"qthread.h\"\n\nMyThread::MyThread(QObject *parent)\n    : QObject(parent)\n{}\n\nMyThread::~MyThread()\n{}\n\nvoid MyThread::working()\n{\n    int count = 0;\n    while (1) {\n        // kick the signal, and post the data [count] by this signal\n        emit signal_hello(++count);  // 将信号发送, 并将数据发送到主线程\n        if (count == 999) {\n            qDebug() &lt;&lt; \"sub thread is stoped:\";\n            break;\n        }\n        qDebug() &lt;&lt; \"current thread is:\" &lt;&lt; QThread::currentThread;\n    }\n}\n进入到主线程进行实现mainwindow.cpp\nMyThread* work = new MyThread;\nQThread* thread_c = new QThread;\n\nwork-&gt;moveToThread(thread_c);                    // 放到新线程中\nthread_c-&gt;start();                               // 启动线程\n\nconnect(ui.pushButton, &QPushButton::clicked, work, &MyThread::working);// 按钮点击信号\nconnect(work, &MyThread::signal_hello, this, [=](int count) {\n       ui.label-&gt;setNum(count);\n       });  // 界面刷新信号"
  },
  {
    "objectID": "posts/qt大小端转换/index.html",
    "href": "posts/qt大小端转换/index.html",
    "title": "qt大小端转换",
    "section": "",
    "text": "在这里插入图片描述\n\n\n以1580 0001为例\n    QByteArray b(\"15800001\");\n    qint32 a = parseValueInt32(b, 0, 8);\n    qDebug() &lt;&lt; \"\\tseqNum:\" &lt;&lt; a;\n32位大端解析:\nqint32 single_test::parseValueInt32(QByteArray data, int valuePos, int valueSize)\n{\n    bool ok;\n    QByteArray parseData;\n    parseData = data.mid(valuePos, valueSize);\n    QString strParseData = parseData;\n    qint32 tempInt32 = strParseData.toInt(&ok, 16);\n                            //                     0x15 80 00 01(原始数据反过来)\n    qDebug() &lt;&lt; tempInt32; // 16810005 (十进制) --&gt; 0x01 00 80 15(十六进制)\n    qint32 parseValueOut = qToBigEndian(tempInt32);     // Convert to Big-Endian\n    return parseValueOut;    \n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/cmake_demo/index.html",
    "href": "posts/cmake_demo/index.html",
    "title": "cmdke use case",
    "section": "",
    "text": "cmake can cross-platform, we only need to writeen once cmakefie. this is so cool so it worth to learning."
  },
  {
    "objectID": "posts/cmake_demo/index.html#set-value_1-value-1-和-set-value_2-value_2-value-2-的不同.",
    "href": "posts/cmake_demo/index.html#set-value_1-value-1-和-set-value_2-value_2-value-2-的不同.",
    "title": "cmdke use case",
    "section": "set (VALUE_1 \"value 1\") 和 set (VALUE_2 ${VALUE_2} \"value 2\") 的不同.",
    "text": "set (VALUE_1 \"value 1\") 和 set (VALUE_2 ${VALUE_2} \"value 2\") 的不同.\n参考:https://www.coder.work/article/6981794\n\n第一种情况 #A 您分配 “value 1”到变量 VALUE_1 ，但在第二种情况下，您分配给变量 VALUE_2 此变量已存在的值与 “value 2” 连接.\n\nset (VALUE_1 \"default value\")\nset (VALUE_2 \"default value\")\n\nset (VALUE_1 \"value 1\")  # A\nset (VALUE_2 ${VALUE_2} \"value 2\")  # B\n\nmessage(\"value 1:\" ${VALUE_1})\nmessage(\"value 2:\" ${VALUE_2})\noutput\n...\nvalue 1:value 1\nvalue 2:default valuevalue 2\n...\n\n从中可以找到刚刚定义的 USE_MYMATH 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 enter 键可以修改该选项。修改完成后可以按下c 选项完成配置，之后再按g键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。"
  },
  {
    "objectID": "posts/Django项目/index.html",
    "href": "posts/Django项目/index.html",
    "title": "Django项目",
    "section": "",
    "text": "Ubuntu下安装git\nsudo apt-get install git\nWindows下安装git\n进入官网，下载安装包，选好路径傻瓜安装\n\n\n\ngit --version\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yjDghJAj-1588223223775)(/../../../../AppData/Local/Temp/1564464652239.png)]\n\n\n\n\n\n创建一个用于存放项目的文件夹（Django_project_test)\n进入到项目文件夹，右键打开git bush\n（一般情况下文件夹以 . 开头的都是隐藏文件夹， 里面的文件切记不可以修改。）\nGit init    # 初始化会创建一个.git隐藏文件夹   这个文件夹为版本库\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nTxHa1vO-1588223223780)(/1564464822626.png)]\n\n\n\n# 配置全局信息\ngit config --global user.name 'xiaofei'\ngit config --global user.email 'izhangtengfei@163.com'\n\n# 配置信息会保存在家目录下面\n~/.gitconfig\n# 配置个人项目信息\ngit config user.name 'xiaofei'\ngit config user.email 'izhangtengfei@163.com'\n\n# 配置信息会保存在当前目录下的./git/config下\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZJmNAoQF-1588223223782)(/1564466169672.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xa0MbzDq-1588223223786)(/1564466511165.png)]\n\n\n\n创建好了本地仓库，就 准备开始开发了。\n在项目文件夹下创建readme.txt 文件， 并输入内容。\n将文件添加到代码库分两步\n①添加到暂存区\ngit add readme.txt    # 将文件添加到暂存区\n②将暂存区的文件提交到仓库。\ngit commit -m '备注'  # 备注处写入备注信息\ngit commit 命令 -m 参数后输入的是提交的说明。 命令执行成功后显示几个文件被改动，加了多少行，少了多少行。每次提交都会生成一个新的版本。\n（此次修改之前readme.txt是一个空的文件）\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ph8FBnkm-1588223223788)(/1564468015460.png)]\n修改后的文件为\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9S9h9D2a-1588223223789)(/1564468123232.png)]\n\n\n\n工作一段时间后，我们提交了很多次到本地仓库，也会产生很多的版本。怎么查看记录。\ngit log     # 查看历史操作记录  不可以查看删除的commit记录\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AJXBX74f-1588223223790)(/1564468383357.png)]\ngit reflog     # git reflog 可以查看所有分支的操作记录，包含已经删除的commit记录\n\n\n\n① git reset --hard HEAD^\n# 使用这种回退没命令会把回退完的节点作为当前节点，进行回退，例如现在1.3使用 git reset --hard HEAD^ 会回退到1.2版本。如果再次使用 git reset --head HEAD^ 版本就会回退到1.1以此类推。\n\n\nHEAD表示当前最新版本\nHEAD^表示当前最新版本的前一个版本\nHEAD^^表示当前最新版本的前两个版本，有几个^就回退几个版本\nHEAD~1表示最新版本的前一个版本\nHEAD~3表示最新版本的前3个版本， 后面数字是几就代表最新新版本之前的第几个版本\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vQ3p4oAd-1588223223791)(/1564474137454.png)]\n执行命令完\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i496Fdg9-1588223223792)(/1564474104120.png)]\n②git reset--hard 版本号 （版本号就是reflog中的版本号）\n版本非常多时选择这种方法。版本号就是每次commit生成的哈希(hash)值，只取用前几位数。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VBcWKQNz-1588223223793)(/1564474725121.png)]\n回退完的结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hx27iITp-1588223223794)(/1564474758460.png)]\n\n\n\n\n\n运行git status命令会显示当前工作区，暂存区，仓库的状态。当工作区的所有代码都提交到仓库 并和仓库保持一致时会显示：\nOn branch master\nnothing to commit, working tree clean\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RJEAfuPS-1588223223795)(/1564476920664.png)]\n修改之前：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0Kr69uUA-1588223223797)(/1564477007021.png)]\n修改之后的：\n# 修改完之后记得ctrl+s保存\n# 之后执行  git status查看状态\ngit status \n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e3PPxYSl-1588223223798)(/1564477127496.png)]\nbush窗口会显示：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-szfpjyTP-1588223223799)(/1564477287358.png)]\n\n\n\n# 只进行了保存操作，没有进行git add .（添加到暂存区）的操作。\n# 直接执行 git checkout 文件名，即可撤销修改。\ngit checkout readme.txt\n\n\n# 如多打开文件没有执行任何改动直接执行回退命令，会直接将整个文件清空。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O61t9rVr-1588223223800)(/1564477632643.png)]\n修改之前的样子\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7tj6RAKy-1588223223801)(/1564477905800.png)]\n修改之后\n工作区：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q3up2wYD-1588223223802)(/1564477989929.png)]\n进入bush进行状态查看：\n# git 会提醒你如何保存修改到本地仓库。我们想执行的是撤销操作不是添加操作。不必理会这里的提示\n执行以下代码会将\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fRZnkKAn-1588223223803)(/1564478069021.png)]\n\n\n\n工作区：\n修改之前的\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOI8qw13-1588223223804)(/1564479231904.png)]\n修改之后的：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F82PChA0-1588223223805)(/1564479050323.png)]\nbush：\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 查看状态\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 添加到暂存区\n$ git add .\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 查看状态确认是否添加到暂存区\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n        modified:   readme.txt\n\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 撤回到工作区\n$ git reset HEAD readme.txt\nUnstaged changes after reset:\nM       readme.txt\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 确认状态是否已经撤回到工作区\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n\n# 执行工作区的修改撤回命令\n$ git checkout readme.txt\nUpdated 1 path from the index\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mGMbKkeq-1588223223806)(/1564480056766.png)]\n\n\n\n\n\n对比本地仓库与工作区\n# 注意！！！ 创建文件时不要用文档打开，打开后再用notepad编辑会出现乱码，直接用notepad打开不会出现中文乱码\n\ngit diff HEAD -- 文件名     # 没有产生修改不会显示\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOf9JQ9Z-1588223223807)(/1564481673195.png)]\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-alMei6TF-1588223223810)(/1564481724616.png)]\n\n对比本地仓库个版本代码\n进入cd到文件所在的夹才可以进行对比\ngit diff HEAD HEAD^ -- 文件名\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aFQYW80i-1588223223811)(/1564481844704.png)]\n\n\n\n①没有添加到库中的文件\n# 直接删除即可\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fKn2h6M6-1588223223812)(/1564485120860.png)]\n②添加到暂存区但是没有提交的文件\n# 先撤回到工作区\ngit reset HEAD 文件名\n# 直接执行删除\n①中的操作\n③已经提交到版本库\n# 删除文件\n①的操作\n# 运行git add .\n# 提交\ngit commit -m '删除版本库'\n(这个方法类似于覆盖)\n\n\n\n\n\n\n① 克隆\n克隆就是将远程的代码仓库拉回到本地仓库，这种方式适用于远程仓库已经有东西了\n进入到项目所在文件夹打开bash窗口。\n#         clone的http地址\ngit clone https://gitee.com/itengfei/first_test.git    \n执行完以上命令的结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LCEwiUkT-1588223223814)(/1564561104558.png)]\n②本地已经初始化了一个仓库，与远程仓库建立连接再push\n\n\n每次push都会输入用户名和密码\n# 创建仓库 \ngit init\n# 建立远程连接\ngit remote add origin https://gitee.com/itengfei/first_test.git\n# 将代码推送上去 origin是远程仓库的名字，master是推送的分支\ngit push -u origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hHGqJ4k5-1588223223816)(/1564562718031.png)]\n用户名\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qNBp9b3B-1588223223817)(/1564562954745.png)]\n密码\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-X4EjStpf-1588223223818)(/1564565420742.png)]\n将远程仓库拉到本地仓库\ngit pull origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vLcOLOIu-1588223223819)(/1564565931844.png)]\n\n\n\n公钥管理 ：https://gitee.com/help/categories/38\n添加个人公钥\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sBJpg55U-1588223223821)(/1564567213412.png)]\n点击添加个人公钥接下来进入\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kXIQ4F5B-1588223223822)(/1564567384146.png)]\n生成公钥： https://gitee.com/help/articles/4181#article-header0\n①生成秘钥\n# 生成公钥     \"邮箱\"\n ssh-keygen -t rsa -C \"izhangtengfei@163.com\"\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RZxrzWCm-1588223223823)(/1564567870692.png)]\n②进入到家目录查看生成的秘钥\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5KmrHX7a-1588223223824)(/1564567851652.png)]\n推荐notepad打开 .pub 文件\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jrE7X4R4-1588223223826)(/1564568079139.png)]\n把.pub文件中的内容全部复制\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H9dlXbzX-1588223223827)(/1564568499541.png)]\n粘贴到网站的ssh公钥中\n图上漏了 ssh-rsa\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J7tcRXx0-1588223223828)(/1564568295187.png)]\n输入密码\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Oj8KXoUA-1588223223829)(/1564568642602.png)]\n添加完成\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gQRIi3gP-1588223223831)(/1564568676759.png)]\n连接\n复制ssh\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RuRpJCzL-1588223223832)(/1564568952113.png)]\n\n\n# 查看远程连接\ngit remote \n# 删除origin这个远程连接\ngit remote remove origin\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tLeF3zwT-1588223223834)(/1564569486795.png)]\n\n\n\n # 建立连接\n git remote add origin git@gitee.com:itengfei/first_test.git\n # 推送代码  推送到的地址     master 本地推送上去的分支\n git push origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dmUq3BLM-1588223223835)(/1564569731810.png)]\n修改内容\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D75ziSnV-1588223223836)(/1564569903274.png)]\n查看修改结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lT6pfxLx-1588223223837)(/1564569936912.png)]\n\n\n\n\n\n​ 正常的开发项目中都是多人协作，每个人的任务一般不会一天就完成，如果把没有完成的代码提交到远程仓库会影响被人工作。git提供了分支的功能就不用担心了，可以创建一个自己的分支，在上面干活，想提交就提交，等到工作完成再一次性合并到原来的分支。\n\n\n新建git仓库时会默认创建一个master分支，他叫主分支。\n一般情况下我们不会直接在主分支上干活，它主要用来发布版本。\n使用 git branch命令查看当前分支\n# 创建一个开发分支\ngit branch develop\n\n\n\n# 切换到develop分支\ngit checkout develop\n\n\n\n创建并切换到新建分支\n-b 表示 创并切换。\n# ①②合并成一条语句 创建并切换到新建分支\ngit checkout -b develop\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uDJCMZmJ-1588223223838)(/1564566781773.png)]\n\n\n\n创建好develop分支后，你开始干活，完成上级领导交给你的任务，根据用户的手机壳颜色更换app主题，5分钟之后开发完毕，提交：\n$ git add change_theme.py\n\nAdministrator@DESKTOP-F3CCKFR MINGW64 ~/Desktop/haha (develop)\n$ git commit -m 'complete change theme'\n[develop 5b83e32] complete change theme\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 change_theme.py\n经过测试功能完成，现在我们要合并到master分支\n首先切换到master\n$ git checkout master\nSwitched to branch 'master'\n查看工作区，你会发现刚才开发的功能文件没有了，不要惊慌，因为那个提交是在develop分支上，现在我们把develop分支的工作合并到master分支上：\n$ git merge develop\nUpdating 7173db6..5b83e32\nFast-forward\n change_theme.py | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 change_theme.py\ngit merge命令用于合并指定分支到当前分支。合并后，在查看文件夹发现，change_theme.py文件又回来了。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8OStZW0z-1588223223839)(/1564632106820.png)]\n\n\n\n合并完之后你也可以删除掉develop分支：\n$ git branch -d develop\nDeleted branch develop (was 5b83e32).\n$ git branch\n* master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e1T99hEi-1588223223840)(/1564632274888.png)]\n\n\n\n\n\n\n\n\n在Ubuntu上创建项目，实际部署大多是linux系统\n# 复制本机的Python环境 -p后面是 Python所在的路径   后面试复制后的环境名\nmkvirtualenv -p /usr/bin/python3.6 tzproject\n\n\n\n选择Django2.1.x最新版本，我们用的是2.1.10\n# 安装\npip install django==2.1.10\n\n\n# 进入到存放Django项目的文件夹\ncd ~/dj_project/\n# 创建Django项目\ndjango-admin startproject tz_project\n# 查看环境\nworkon\n# 进入到环境\nworkon tz_project\n\n\n\n\n通过pycharm的ssh连接虚拟机（服务器）\n\n\n选择一个存项目的本地文件，夹注意django项目和pycharm项目的根目录一定要保持一致，不要用一个pycharm的项目，管理多个django项目。\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aIDWEsDn-1588223223842)(/1565081046814.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9r12HJNZ-1588223223843)(/1565081616004.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hP6raF3l-1588223223844)(/1565081700289.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4QdxbLCM-1588223223845)(/1565081832839.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FgQLYdcg-1588223223846)(/1565082202430.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-41b5u4Ma-1588223223847)(/1565081924013.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZAcIw3pj-1588223223848)(/1565082109829.png)]\n\n\n\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hLqIkl03-1588223223849)(/1565082467843.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8m27THfv-1588223223849)(/1565083200722.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-45PhqKNr-1588223223850)(/1565083261276.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ns3oqlGh-1588223223851)(/1565083309002.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-V4h20zbx-1588223223852)(/1565083378768.png)]\n\n\n\n\n\n\ncreate database test_1\n\n\n\n# 创建一个名为fly可以远程访问的用户密码为Pythonvip\ncreate user 'fly'@'%' identified by 'pythonvip'\n\n\n\nhttps://www.cnblogs.com/wuxunyan/p/9095016.html\n# 所有权限给fly\ngrant all privileges on test_1.* to 'fly'@'%' ;\n\n\n\n安装mysqlclient\n# 首先更新ubuntu\nsudo apt-get update \n# 然后按照依赖库\nsudo apt-get install default-libmysqlclient-dev\n# 再切换到虚拟环境中\nworkon tzproject\n# 最后安装mysqlclient\npip install mysqlclient -i https://pypi.doubanio.com/simple\n# 方法一\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',               # 数据库引擎\n        'NAME': 'test_1',                                # 数据库名\n        'USER': 'fly',                                  # 用户名\n        'PASSWORD': 'pythonvip',                            # 密码\n        'HOST': '127.0.0.1',                                # 主机IP\n        'PORT': 3306                                        # 端口\n    }\n}\n方法二：\n创建utils工具文件夹，存放工具\n将数据库配置信息存到一个文件，在settings文件中将其引入。（推荐）\n新建数据库配置文件db.cnf(名字随意)\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ye6aG9rg-1588223223853)(/1565084327733.png)]\n# 方法二db.cnf文件\n[client]\ndatabase = tzproject\nuser = dj_user\npassword = pythonvip\nhost = 127.0.0.1\nport = 3306\ndefault-character-set = utf8\npymysql的使用\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zWlo4cN8-1588223223854)(/1565084964896.png)]\n\n\n\n\n用于存放用户session信息，以及需要缓存的各种信息。\n# 在虚拟机中安装django-redis\npip install django-redis    \n# settings.py文件中指定redis配置\n\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/0\",\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n        }\n    },\n    'session': {\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION': 'redis://127.0.0.1:6379/1',\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\n        }\n    },\n}\n\n# session存储缓存设置\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_CACHE_ALIAS = 'session'\n文档地址：https://django-redis-chs.readthedocs.io/zh_CN/latest/\ndjango文档：https://docs.djangoproject.com/en/2.2/topics/http/sessions/#using-cached-sessions\n\n\n\n用于记录系统运行过程中的各种日志信息。\n在项目根目录中创建一个logs文件夹，用于存放日志文件\n# 日志\nLOGGING = {\n    # 版本\n    'version': 1,\n    # 是否禁用已存在的日志器\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '{levelname} {asctime} {module} {lineno:d} {message}',\n            'style': '{',\n        },\n        'simple': {\n            'format': '{levelname} {module} {lineno:d} {message}',\n            'style': '{',\n        },\n    },\n    'filters': {\n        'require_debug_true': {\n            '()': 'django.utils.log.RequireDebugTrue',\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'filters': ['require_debug_true'],\n            'class': 'logging.StreamHandler',\n            'formatter': 'simple'\n        },\n        'file': {\n            'level': 'INFO',\n            # 这个handler可以记录一组日志文件\n            'class': 'logging.handlers.RotatingFileHandler',\n            'filename': os.path.join(BASE_DIR, 'logs/tz_django.log'),\n            # 单个日志文件最大字节数\n            'maxBytes': 300*1024*1024,\n            # 日志文件个数\n            'backupCount': 10,\n            'formatter': 'verbose'\n        },\n    },\n    'loggers': {\n        'django': {\n            'handlers': ['console', 'file'],\n            'level': 'INFO',  # 日志器接收的最低级别\n            'propagate': True,\n        },\n    },\n}\n# 使用方法\n# import the logging library\nimport logging\n\n# Get an instance of a logger\n# 此处的django为，settings.py文件中，LOGGING配置下的loggers中定义的日志器名称\nlogger = logging.getLogger('django')    \n\ndef my_view(request, arg1, arg):\n    ...\n    if ***:\n        # Log an error message\n        logger.error('Something went wrong!')\n官方文档：https://docs.djangoproject.com/en/2.2/topics/logging/#module-django.utils.log\n\n\n\n# 修改语言\nLANGUAGE_CODE = 'zh-hans'\n# 修改时区\nTIME_ZONE = 'Asia/Shanghai'\n\n\n\n在项目根目录创建一个static文件夹， 用来存放静态文件（css, js, img, font 等等）\nSTATIC_URL = '/static/'\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'static')\n]\n\n\n\n接着分别在apps文件夹和项目根目录文件夹上右键，加入到Source Root中，优化导入路径(pycharm提示)。\nimport os\nimport sys\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n# 将app添加到sys中，优化调用\nsys.path.insert(0, BASE_DIR)\nsys.path.insert(1, os.path.join(BASE_DIR, 'apps'))\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ATw9Q2y1-1588223223856)(/1565086240145.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UF97hUlH-1588223223857)(/1565086403244.png)]\n添加apps\n将创建的app放到apps中\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'news',\n]"
  },
  {
    "objectID": "posts/Django项目/index.html#一-git的使用",
    "href": "posts/Django项目/index.html#一-git的使用",
    "title": "Django项目",
    "section": "",
    "text": "Ubuntu下安装git\nsudo apt-get install git\nWindows下安装git\n进入官网，下载安装包，选好路径傻瓜安装\n\n\n\ngit --version\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yjDghJAj-1588223223775)(/../../../../AppData/Local/Temp/1564464652239.png)]\n\n\n\n\n\n创建一个用于存放项目的文件夹（Django_project_test)\n进入到项目文件夹，右键打开git bush\n（一般情况下文件夹以 . 开头的都是隐藏文件夹， 里面的文件切记不可以修改。）\nGit init    # 初始化会创建一个.git隐藏文件夹   这个文件夹为版本库\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nTxHa1vO-1588223223780)(/1564464822626.png)]\n\n\n\n# 配置全局信息\ngit config --global user.name 'xiaofei'\ngit config --global user.email 'izhangtengfei@163.com'\n\n# 配置信息会保存在家目录下面\n~/.gitconfig\n# 配置个人项目信息\ngit config user.name 'xiaofei'\ngit config user.email 'izhangtengfei@163.com'\n\n# 配置信息会保存在当前目录下的./git/config下\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZJmNAoQF-1588223223782)(/1564466169672.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xa0MbzDq-1588223223786)(/1564466511165.png)]\n\n\n\n创建好了本地仓库，就 准备开始开发了。\n在项目文件夹下创建readme.txt 文件， 并输入内容。\n将文件添加到代码库分两步\n①添加到暂存区\ngit add readme.txt    # 将文件添加到暂存区\n②将暂存区的文件提交到仓库。\ngit commit -m '备注'  # 备注处写入备注信息\ngit commit 命令 -m 参数后输入的是提交的说明。 命令执行成功后显示几个文件被改动，加了多少行，少了多少行。每次提交都会生成一个新的版本。\n（此次修改之前readme.txt是一个空的文件）\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ph8FBnkm-1588223223788)(/1564468015460.png)]\n修改后的文件为\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9S9h9D2a-1588223223789)(/1564468123232.png)]\n\n\n\n工作一段时间后，我们提交了很多次到本地仓库，也会产生很多的版本。怎么查看记录。\ngit log     # 查看历史操作记录  不可以查看删除的commit记录\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AJXBX74f-1588223223790)(/1564468383357.png)]\ngit reflog     # git reflog 可以查看所有分支的操作记录，包含已经删除的commit记录\n\n\n\n① git reset --hard HEAD^\n# 使用这种回退没命令会把回退完的节点作为当前节点，进行回退，例如现在1.3使用 git reset --hard HEAD^ 会回退到1.2版本。如果再次使用 git reset --head HEAD^ 版本就会回退到1.1以此类推。\n\n\nHEAD表示当前最新版本\nHEAD^表示当前最新版本的前一个版本\nHEAD^^表示当前最新版本的前两个版本，有几个^就回退几个版本\nHEAD~1表示最新版本的前一个版本\nHEAD~3表示最新版本的前3个版本， 后面数字是几就代表最新新版本之前的第几个版本\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vQ3p4oAd-1588223223791)(/1564474137454.png)]\n执行命令完\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i496Fdg9-1588223223792)(/1564474104120.png)]\n②git reset--hard 版本号 （版本号就是reflog中的版本号）\n版本非常多时选择这种方法。版本号就是每次commit生成的哈希(hash)值，只取用前几位数。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VBcWKQNz-1588223223793)(/1564474725121.png)]\n回退完的结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hx27iITp-1588223223794)(/1564474758460.png)]\n\n\n\n\n\n运行git status命令会显示当前工作区，暂存区，仓库的状态。当工作区的所有代码都提交到仓库 并和仓库保持一致时会显示：\nOn branch master\nnothing to commit, working tree clean\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RJEAfuPS-1588223223795)(/1564476920664.png)]\n修改之前：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0Kr69uUA-1588223223797)(/1564477007021.png)]\n修改之后的：\n# 修改完之后记得ctrl+s保存\n# 之后执行  git status查看状态\ngit status \n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e3PPxYSl-1588223223798)(/1564477127496.png)]\nbush窗口会显示：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-szfpjyTP-1588223223799)(/1564477287358.png)]\n\n\n\n# 只进行了保存操作，没有进行git add .（添加到暂存区）的操作。\n# 直接执行 git checkout 文件名，即可撤销修改。\ngit checkout readme.txt\n\n\n# 如多打开文件没有执行任何改动直接执行回退命令，会直接将整个文件清空。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O61t9rVr-1588223223800)(/1564477632643.png)]\n修改之前的样子\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7tj6RAKy-1588223223801)(/1564477905800.png)]\n修改之后\n工作区：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q3up2wYD-1588223223802)(/1564477989929.png)]\n进入bush进行状态查看：\n# git 会提醒你如何保存修改到本地仓库。我们想执行的是撤销操作不是添加操作。不必理会这里的提示\n执行以下代码会将\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fRZnkKAn-1588223223803)(/1564478069021.png)]\n\n\n\n工作区：\n修改之前的\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOI8qw13-1588223223804)(/1564479231904.png)]\n修改之后的：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F82PChA0-1588223223805)(/1564479050323.png)]\nbush：\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 查看状态\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 添加到暂存区\n$ git add .\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 查看状态确认是否添加到暂存区\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n        modified:   readme.txt\n\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 撤回到工作区\n$ git reset HEAD readme.txt\nUnstaged changes after reset:\nM       readme.txt\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n# 确认状态是否已经撤回到工作区\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nFly@DESKTOP-G76LKOK MINGW64 /d/all/Django_project_test (master)\n\n# 执行工作区的修改撤回命令\n$ git checkout readme.txt\nUpdated 1 path from the index\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mGMbKkeq-1588223223806)(/1564480056766.png)]\n\n\n\n\n\n对比本地仓库与工作区\n# 注意！！！ 创建文件时不要用文档打开，打开后再用notepad编辑会出现乱码，直接用notepad打开不会出现中文乱码\n\ngit diff HEAD -- 文件名     # 没有产生修改不会显示\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOf9JQ9Z-1588223223807)(/1564481673195.png)]\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-alMei6TF-1588223223810)(/1564481724616.png)]\n\n对比本地仓库个版本代码\n进入cd到文件所在的夹才可以进行对比\ngit diff HEAD HEAD^ -- 文件名\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aFQYW80i-1588223223811)(/1564481844704.png)]\n\n\n\n①没有添加到库中的文件\n# 直接删除即可\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fKn2h6M6-1588223223812)(/1564485120860.png)]\n②添加到暂存区但是没有提交的文件\n# 先撤回到工作区\ngit reset HEAD 文件名\n# 直接执行删除\n①中的操作\n③已经提交到版本库\n# 删除文件\n①的操作\n# 运行git add .\n# 提交\ngit commit -m '删除版本库'\n(这个方法类似于覆盖)\n\n\n\n\n\n\n① 克隆\n克隆就是将远程的代码仓库拉回到本地仓库，这种方式适用于远程仓库已经有东西了\n进入到项目所在文件夹打开bash窗口。\n#         clone的http地址\ngit clone https://gitee.com/itengfei/first_test.git    \n执行完以上命令的结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LCEwiUkT-1588223223814)(/1564561104558.png)]\n②本地已经初始化了一个仓库，与远程仓库建立连接再push\n\n\n每次push都会输入用户名和密码\n# 创建仓库 \ngit init\n# 建立远程连接\ngit remote add origin https://gitee.com/itengfei/first_test.git\n# 将代码推送上去 origin是远程仓库的名字，master是推送的分支\ngit push -u origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hHGqJ4k5-1588223223816)(/1564562718031.png)]\n用户名\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qNBp9b3B-1588223223817)(/1564562954745.png)]\n密码\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-X4EjStpf-1588223223818)(/1564565420742.png)]\n将远程仓库拉到本地仓库\ngit pull origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vLcOLOIu-1588223223819)(/1564565931844.png)]\n\n\n\n公钥管理 ：https://gitee.com/help/categories/38\n添加个人公钥\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sBJpg55U-1588223223821)(/1564567213412.png)]\n点击添加个人公钥接下来进入\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kXIQ4F5B-1588223223822)(/1564567384146.png)]\n生成公钥： https://gitee.com/help/articles/4181#article-header0\n①生成秘钥\n# 生成公钥     \"邮箱\"\n ssh-keygen -t rsa -C \"izhangtengfei@163.com\"\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RZxrzWCm-1588223223823)(/1564567870692.png)]\n②进入到家目录查看生成的秘钥\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5KmrHX7a-1588223223824)(/1564567851652.png)]\n推荐notepad打开 .pub 文件\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jrE7X4R4-1588223223826)(/1564568079139.png)]\n把.pub文件中的内容全部复制\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H9dlXbzX-1588223223827)(/1564568499541.png)]\n粘贴到网站的ssh公钥中\n图上漏了 ssh-rsa\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J7tcRXx0-1588223223828)(/1564568295187.png)]\n输入密码\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Oj8KXoUA-1588223223829)(/1564568642602.png)]\n添加完成\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gQRIi3gP-1588223223831)(/1564568676759.png)]\n连接\n复制ssh\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RuRpJCzL-1588223223832)(/1564568952113.png)]\n\n\n# 查看远程连接\ngit remote \n# 删除origin这个远程连接\ngit remote remove origin\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tLeF3zwT-1588223223834)(/1564569486795.png)]\n\n\n\n # 建立连接\n git remote add origin git@gitee.com:itengfei/first_test.git\n # 推送代码  推送到的地址     master 本地推送上去的分支\n git push origin master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dmUq3BLM-1588223223835)(/1564569731810.png)]\n修改内容\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D75ziSnV-1588223223836)(/1564569903274.png)]\n查看修改结果\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lT6pfxLx-1588223223837)(/1564569936912.png)]\n\n\n\n\n\n​ 正常的开发项目中都是多人协作，每个人的任务一般不会一天就完成，如果把没有完成的代码提交到远程仓库会影响被人工作。git提供了分支的功能就不用担心了，可以创建一个自己的分支，在上面干活，想提交就提交，等到工作完成再一次性合并到原来的分支。\n\n\n新建git仓库时会默认创建一个master分支，他叫主分支。\n一般情况下我们不会直接在主分支上干活，它主要用来发布版本。\n使用 git branch命令查看当前分支\n# 创建一个开发分支\ngit branch develop\n\n\n\n# 切换到develop分支\ngit checkout develop\n\n\n\n创建并切换到新建分支\n-b 表示 创并切换。\n# ①②合并成一条语句 创建并切换到新建分支\ngit checkout -b develop\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uDJCMZmJ-1588223223838)(/1564566781773.png)]\n\n\n\n创建好develop分支后，你开始干活，完成上级领导交给你的任务，根据用户的手机壳颜色更换app主题，5分钟之后开发完毕，提交：\n$ git add change_theme.py\n\nAdministrator@DESKTOP-F3CCKFR MINGW64 ~/Desktop/haha (develop)\n$ git commit -m 'complete change theme'\n[develop 5b83e32] complete change theme\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 change_theme.py\n经过测试功能完成，现在我们要合并到master分支\n首先切换到master\n$ git checkout master\nSwitched to branch 'master'\n查看工作区，你会发现刚才开发的功能文件没有了，不要惊慌，因为那个提交是在develop分支上，现在我们把develop分支的工作合并到master分支上：\n$ git merge develop\nUpdating 7173db6..5b83e32\nFast-forward\n change_theme.py | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 change_theme.py\ngit merge命令用于合并指定分支到当前分支。合并后，在查看文件夹发现，change_theme.py文件又回来了。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8OStZW0z-1588223223839)(/1564632106820.png)]\n\n\n\n合并完之后你也可以删除掉develop分支：\n$ git branch -d develop\nDeleted branch develop (was 5b83e32).\n$ git branch\n* master\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e1T99hEi-1588223223840)(/1564632274888.png)]"
  },
  {
    "objectID": "posts/Django项目/index.html#二项目创建",
    "href": "posts/Django项目/index.html#二项目创建",
    "title": "Django项目",
    "section": "",
    "text": "在Ubuntu上创建项目，实际部署大多是linux系统\n# 复制本机的Python环境 -p后面是 Python所在的路径   后面试复制后的环境名\nmkvirtualenv -p /usr/bin/python3.6 tzproject\n\n\n\n选择Django2.1.x最新版本，我们用的是2.1.10\n# 安装\npip install django==2.1.10\n\n\n# 进入到存放Django项目的文件夹\ncd ~/dj_project/\n# 创建Django项目\ndjango-admin startproject tz_project\n# 查看环境\nworkon\n# 进入到环境\nworkon tz_project\n\n\n\n\n通过pycharm的ssh连接虚拟机（服务器）\n\n\n选择一个存项目的本地文件，夹注意django项目和pycharm项目的根目录一定要保持一致，不要用一个pycharm的项目，管理多个django项目。\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aIDWEsDn-1588223223842)(/1565081046814.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9r12HJNZ-1588223223843)(/1565081616004.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hP6raF3l-1588223223844)(/1565081700289.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4QdxbLCM-1588223223845)(/1565081832839.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FgQLYdcg-1588223223846)(/1565082202430.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-41b5u4Ma-1588223223847)(/1565081924013.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZAcIw3pj-1588223223848)(/1565082109829.png)]\n\n\n\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hLqIkl03-1588223223849)(/1565082467843.png)]\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8m27THfv-1588223223849)(/1565083200722.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-45PhqKNr-1588223223850)(/1565083261276.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ns3oqlGh-1588223223851)(/1565083309002.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-V4h20zbx-1588223223852)(/1565083378768.png)]\n\n\n\n\n\n\ncreate database test_1\n\n\n\n# 创建一个名为fly可以远程访问的用户密码为Pythonvip\ncreate user 'fly'@'%' identified by 'pythonvip'\n\n\n\nhttps://www.cnblogs.com/wuxunyan/p/9095016.html\n# 所有权限给fly\ngrant all privileges on test_1.* to 'fly'@'%' ;\n\n\n\n安装mysqlclient\n# 首先更新ubuntu\nsudo apt-get update \n# 然后按照依赖库\nsudo apt-get install default-libmysqlclient-dev\n# 再切换到虚拟环境中\nworkon tzproject\n# 最后安装mysqlclient\npip install mysqlclient -i https://pypi.doubanio.com/simple\n# 方法一\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',               # 数据库引擎\n        'NAME': 'test_1',                                # 数据库名\n        'USER': 'fly',                                  # 用户名\n        'PASSWORD': 'pythonvip',                            # 密码\n        'HOST': '127.0.0.1',                                # 主机IP\n        'PORT': 3306                                        # 端口\n    }\n}\n方法二：\n创建utils工具文件夹，存放工具\n将数据库配置信息存到一个文件，在settings文件中将其引入。（推荐）\n新建数据库配置文件db.cnf(名字随意)\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ye6aG9rg-1588223223853)(/1565084327733.png)]\n# 方法二db.cnf文件\n[client]\ndatabase = tzproject\nuser = dj_user\npassword = pythonvip\nhost = 127.0.0.1\nport = 3306\ndefault-character-set = utf8\npymysql的使用\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zWlo4cN8-1588223223854)(/1565084964896.png)]\n\n\n\n\n用于存放用户session信息，以及需要缓存的各种信息。\n# 在虚拟机中安装django-redis\npip install django-redis    \n# settings.py文件中指定redis配置\n\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/0\",\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n        }\n    },\n    'session': {\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION': 'redis://127.0.0.1:6379/1',\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\n        }\n    },\n}\n\n# session存储缓存设置\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_CACHE_ALIAS = 'session'\n文档地址：https://django-redis-chs.readthedocs.io/zh_CN/latest/\ndjango文档：https://docs.djangoproject.com/en/2.2/topics/http/sessions/#using-cached-sessions\n\n\n\n用于记录系统运行过程中的各种日志信息。\n在项目根目录中创建一个logs文件夹，用于存放日志文件\n# 日志\nLOGGING = {\n    # 版本\n    'version': 1,\n    # 是否禁用已存在的日志器\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '{levelname} {asctime} {module} {lineno:d} {message}',\n            'style': '{',\n        },\n        'simple': {\n            'format': '{levelname} {module} {lineno:d} {message}',\n            'style': '{',\n        },\n    },\n    'filters': {\n        'require_debug_true': {\n            '()': 'django.utils.log.RequireDebugTrue',\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'filters': ['require_debug_true'],\n            'class': 'logging.StreamHandler',\n            'formatter': 'simple'\n        },\n        'file': {\n            'level': 'INFO',\n            # 这个handler可以记录一组日志文件\n            'class': 'logging.handlers.RotatingFileHandler',\n            'filename': os.path.join(BASE_DIR, 'logs/tz_django.log'),\n            # 单个日志文件最大字节数\n            'maxBytes': 300*1024*1024,\n            # 日志文件个数\n            'backupCount': 10,\n            'formatter': 'verbose'\n        },\n    },\n    'loggers': {\n        'django': {\n            'handlers': ['console', 'file'],\n            'level': 'INFO',  # 日志器接收的最低级别\n            'propagate': True,\n        },\n    },\n}\n# 使用方法\n# import the logging library\nimport logging\n\n# Get an instance of a logger\n# 此处的django为，settings.py文件中，LOGGING配置下的loggers中定义的日志器名称\nlogger = logging.getLogger('django')    \n\ndef my_view(request, arg1, arg):\n    ...\n    if ***:\n        # Log an error message\n        logger.error('Something went wrong!')\n官方文档：https://docs.djangoproject.com/en/2.2/topics/logging/#module-django.utils.log\n\n\n\n# 修改语言\nLANGUAGE_CODE = 'zh-hans'\n# 修改时区\nTIME_ZONE = 'Asia/Shanghai'\n\n\n\n在项目根目录创建一个static文件夹， 用来存放静态文件（css, js, img, font 等等）\nSTATIC_URL = '/static/'\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'static')\n]\n\n\n\n接着分别在apps文件夹和项目根目录文件夹上右键，加入到Source Root中，优化导入路径(pycharm提示)。\nimport os\nimport sys\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n# 将app添加到sys中，优化调用\nsys.path.insert(0, BASE_DIR)\nsys.path.insert(1, os.path.join(BASE_DIR, 'apps'))\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ATw9Q2y1-1588223223856)(/1565086240145.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UF97hUlH-1588223223857)(/1565086403244.png)]\n添加apps\n将创建的app放到apps中\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'news',\n]"
  },
  {
    "objectID": "posts/Django项目/index.html#创建templates文件夹",
    "href": "posts/Django项目/index.html#创建templates文件夹",
    "title": "Django项目",
    "section": "3.1 创建templates文件夹",
    "text": "3.1 创建templates文件夹\n创建templates文件夹用来存放html文件\n\n3.1.1 创建base模板\n用来继承页面中的相同文件，减少代码的冗余\n\n\n3.1.2 设置templates路径\n记得配置templates在settings文件中的路径\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\n\n3.1.3 分析页面，抽取出相同的部分\n利用 block  名字  和  endblock 来分离出不同的部分\n然后根据每个页面的不同填入不同的东西\n并修改硬写部分\n路径结构\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QyzJ1EOW-1588223223858)(/1565757006289.png)]\n\n①base.html文件\n&lt;!--base.html文件--&gt;\n\n{{% load static %}}\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n\n\n    &lt;title&gt;{{% block title %}}{{% endblock title %}}&lt;/title&gt;\n\n\n    &lt;link rel=\"stylesheet\" href={{% static \"css/base/reset.css\" %}}&gt;\n    &lt;link rel=\"stylesheet\" href={{% static \"css/base/common.css\" %}}&gt;\n\n    &lt;link rel=\"stylesheet\" href={{% static \"css/base/side.css\" %}}&gt;\n    &lt;link rel=\"stylesheet\" href=\"http://at.alicdn.com/t/font_684044_un7umbuwwfp.css\"&gt;\n    &lt;!--特殊的css--&gt;\n    {{% block css %}}\n    {{% endblock css %}}\n&lt;/head&gt;\n&lt;body&gt;\n&lt;!-- header start --&gt;\n&lt;header id=\"header\"&gt;\n    &lt;div class=\"mw1200 header-contain clearfix\"&gt;\n        &lt;!-- logo start --&gt;\n        &lt;h1 class=\"logo\"&gt;\n            &lt;a href=\"javascript:void(0);\" class=\"logo-title\"&gt;Python&lt;/a&gt;\n        &lt;/h1&gt;\n        &lt;!-- logo end --&gt;\n        &lt;!-- nav start --&gt;\n        &lt;nav class=\"nav\"&gt;\n            &lt;ul class=\"menu\"&gt;\n                &lt;li&gt;&lt;a href=\"{{% url 'news:index' %}}\"&gt;首页&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"{{% url 'course:index' %}}\"&gt;在线课堂&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"{{% url 'doc:index' %}}\"&gt;下载文档&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=\"search.html\"&gt;搜索&lt;/a&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n        &lt;!-- nav end --&gt;\n        &lt;!-- login start --&gt;\n        &lt;div class=\"login-box\"&gt;\n            &lt;div&gt;\n                &lt;i class=\"PyWhich py-user\"&gt;&lt;/i&gt;\n                &lt;span&gt;\n                  &lt;a href=\"{{% url 'user:login' %}}\" class=\"login\"&gt;登录&lt;/a&gt; / &lt;a href=\"{{% url 'user:register' %}}\"\n                                                                         class=\"reg\"&gt;注册&lt;/a&gt;\n              &lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"author hide\"&gt;\n                &lt;i class=\"PyWhich py-user\"&gt;&lt;/i&gt;\n                &lt;span&gt;qwertyui&lt;/span&gt;\n                &lt;ul class=\"author-menu\"&gt;\n                    &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;后台管理&lt;/a&gt;&lt;/li&gt;\n                    &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;退出登录&lt;/a&gt;&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;!-- login end --&gt;\n    &lt;/div&gt;\n&lt;/header&gt;\n&lt;!-- header end --&gt;\n\n&lt;!-- main start --&gt;\n&lt;!-- 除去页眉页脚的内容 --&gt;\n{{% block main %}}\n    &lt;main id=\"main\"&gt;\n        &lt;div class=\"w1200 clearfix\"&gt;\n            &lt;!-- main-contain start  --&gt;\n            &lt;!-- 主体内容 start  --&gt;\n            {{% block main_contain %}}\n\n            {{% endblock main_contain %}}\n            &lt;!-- 主体内容  end --&gt;\n            &lt;!-- main-contain  end --&gt;\n\n            &lt;!-- side start --&gt;\n            &lt;!-- 边上的内容 --&gt;\n            {{% block side %}}\n                &lt;aside class=\"side\"&gt;\n                    &lt;div class=\"side-activities\"&gt;\n                        &lt;h3 class=\"activities-title\"&gt;在线课堂&lt;a href=\"javascript:void(0)\"&gt;更多&lt;/a&gt;&lt;/h3&gt;\n                        &lt;div class=\"activities-img\"&gt;\n                            &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                &lt;img src={{% static \"images/english.jpg\" %}} alt=\"title\"&gt;\n                            &lt;/a&gt;\n                            &lt;p class=\"activities-tips\"&gt;对话国外小姐姐&lt;/p&gt;\n                        &lt;/div&gt;\n                        &lt;ul class=\"activities-list\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-start\"&gt;报名中&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a\n                                            href=\"https://www.shiguangkey.com/course/2432\"&gt; Django 项目班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-end\"&gt;已结束&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a\n                                            href=\"https://www.shiguangkey.com/course/2321\"&gt;Python入门基础班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"side-attention clearfix\"&gt;\n                        &lt;h3 class=\"attention-title\"&gt;关注我&lt;/h3&gt;\n                        &lt;ul class=\"side-attention-address\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i\n                                        class=\"PyWhich py-GitHub\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-zhihu\"\n                                                                                 style=\"color:rgb(0, 108, 226);\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-weibo\"\n                                                                                 style=\"color:rgb(245,92,110);\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                        &lt;div class=\"side-attention-qr\"&gt;\n                            &lt;p&gt;扫码关注&lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                    &lt;!--hot_news模板--&gt;\n                    {{% block hotnews %}}\n                    {{% endblock hotnews %}}\n\n                &lt;/aside&gt;\n            {{% endblock side %}}\n            &lt;!-- side end --&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n{{% endblock main %}}\n&lt;!-- main end --&gt;\n\n&lt;!-- footer start --&gt;\n&lt;!-- 页脚 start --&gt;\n{{% block foot %}}\n\n{{% endblock foot %}}\n&lt;!-- footer end --&gt;\n&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt;\n{#&lt;script src=\"{{% static 'js/base/common.js' %}}\"&gt;&lt;/script&gt;#}\n&lt;script src=\"{{% static 'js/base/message.js' %}}\"&gt;&lt;/script&gt;\n\n&lt;!-- js start --&gt;\n{{% block script %}}\n{{% endblock script %}}\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n②news.html文件\n{{% extends 'base/base.html' %}}\n{{% load static %}}\n{{% block title %}}\n    IndexPage\n{{% endblock title %}}\n\n{{% block css %}}\n    &lt;link rel=\"stylesheet\" href=\"{{% static 'css/news/index.css' %}}\"&gt;\n    &lt;script&gt;IMemuIndex=0&lt;/script&gt;\n{{% endblock css %}}\n\n\n\n\n&lt;!-- main start --&gt;\n{{% block main %}}\n    &lt;main id=\"main\"&gt;\n        &lt;div class=\"w1200 clearfix\"&gt;\n            &lt;!-- main-contain start  --&gt;\n            {{% block main_contain %}}\n                &lt;div class=\"main-contain\"&gt;\n                    &lt;!-- banner start --&gt;\n\n                    &lt;div class=\"banner\"&gt;\n                        &lt;ul class=\"pic\"&gt;\n                            &lt;!--淡入淡出banner--&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img src={{% static \"images/linux.jpg\" %}} alt=\"test\"&gt;&lt;/a&gt;\n                            &lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img src={{% static \"images/python_gui.jpg\" %}} alt=\"test\"&gt;&lt;/a&gt;\n                            &lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img\n                                    src={{% static \"images/python_function.jpg\" %}} alt=\"test\"&gt;&lt;/a&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img\n                                    src={{% static \"images/python_advanced.jpg\" %}} alt=\"test\"&gt;&lt;/a&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img\n                                    src={{% static \"images/jichujiaochen.jpeg\" %}} alt=\"test\"&gt;&lt;/a&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;&lt;img src={{% static \"images/python_web.jpg\" %}} alt=\"test\"&gt;&lt;/a&gt;\n                            &lt;/li&gt;\n\n\n                        &lt;/ul&gt;\n                        &lt;a href=\"javascript:void(0);\" class=\"btn prev\"&gt;\n                            &lt;i class=\"PyWhich py-arrow-left\"&gt;&lt;/i&gt;&lt;/a&gt;\n                        &lt;a href=\"javascript:void(0);\" class=\"btn next\"&gt;\n                            &lt;i class=\"PyWhich py-arrow-right\"&gt;&lt;/i&gt;&lt;/a&gt;\n                        &lt;ul class=\"tab\"&gt;\n                            &lt;!-- 按钮数量必须和图片一致 --&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                            &lt;li&gt;&lt;/li&gt;\n\n\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n\n                    &lt;!-- banner end --&gt;\n\n                    &lt;!-- content start --&gt;\n                    &lt;div class=\"content\"&gt;\n                        &lt;!-- recommend-news start --&gt;\n                        &lt;ul class=\"recommend-news\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"https://www.shiguangkey.com/course/2432\" target=\"_blank\"&gt;\n                                    &lt;div class=\"recommend-thumbnail\"&gt;\n                                        &lt;img src={{% static \"images/python_gui.jpg\" %}} alt=\"title\"&gt;\n                                    &lt;/div&gt;\n                                    &lt;p class=\"info\"&gt;Python GUI 教程 25行代码写一个小闹钟&lt;/p&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n\n                            &lt;li&gt;\n                                &lt;a href=\"https://www.shiguangkey.com/course/2432\" target=\"_blank\"&gt;\n                                    &lt;div class=\"recommend-thumbnail\"&gt;\n                                        &lt;img src={{% static \"images/python_advanced.jpg\" %}} alt=\"title\"&gt;\n                                    &lt;/div&gt;\n                                    &lt;p class=\"info\"&gt;python高性能编程方法一&lt;/p&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n\n                            &lt;li&gt;\n                                &lt;a href=\"https://www.shiguangkey.com/course/2432\" target=\"_blank\"&gt;\n                                    &lt;div class=\"recommend-thumbnail\"&gt;\n                                        &lt;img src={{% static \"images/jichujiaochen.jpeg\" %}} alt=\"title\"&gt;\n                                    &lt;/div&gt;\n                                    &lt;p class=\"info\"&gt;python基础 split 和 join函数比较&lt;/p&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                        &lt;!-- recommend-news end --&gt;\n\n                        &lt;!--  news-nav start--&gt;\n                        &lt;nav class=\"news-nav\"&gt;\n                            &lt;ul class=\"clearfix\"&gt;\n                                &lt;li class=\"active\"&gt;&lt;a href=\"javascript:void(0)\"&gt;最新资讯&lt;/a&gt;&lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"1\"&gt;python框架&lt;/a&gt;\n                                &lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"2\"&gt;Python基础&lt;/a&gt;\n                                &lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"3\"&gt;Python高级&lt;/a&gt;\n                                &lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"4\"&gt;Python函数&lt;/a&gt;\n                                &lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"5\"&gt;PythonGUI&lt;/a&gt;\n                                &lt;/li&gt;\n\n                                &lt;li&gt;&lt;a href=\"javascript:void(0)\" data-id=\"6\"&gt;Linux教程&lt;/a&gt;\n                                &lt;/li&gt;\n\n                            &lt;/ul&gt;\n                        &lt;/nav&gt;\n                        &lt;!--  news-nav end --&gt;\n\n                        &lt;!-- news-contain start --&gt;\n                        &lt;div class=\"news-contain\"&gt;\n                            &lt;ul class=\"news-list\"&gt;\n\n                                &lt;li class=\"news-item\"&gt;\n                                    &lt;a href=\"https://www.shiguangkey.com/course/2432\" class=\"news-thumbnail\"\n                                       target=\"_blank\"&gt;\n                                        &lt;img src={{% static \"images/linux.jpg\" %}} alt=\"linux查找文件或目录命令\"\n                                             title=\"linux查找文件或目录命令\"&gt;\n                                    &lt;/a&gt;\n                                    &lt;div class=\"news-content\"&gt;\n                                        &lt;h4 class=\"news-title\"&gt;&lt;a\n                                                href=\"#\"&gt;linux查找文件或目录命令&lt;/a&gt;\n                                        &lt;/h4&gt;\n                                        &lt;p class=\"news-details\"&gt;linux查找文件或目录命令，前提：知道文件或者目录的具体名字，例如：sphinx.conffind\n                                            查找find / -name\n                                            dirname 查找目录find -name...&lt;/p&gt;\n                                        &lt;div class=\"news-other\"&gt;\n                                            &lt;span class=\"news-type\"&gt;Linux教程&lt;/span&gt;\n                                            &lt;span class=\"news-time\"&gt;11/11 18:24&lt;/span&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/li&gt;\n\n                                &lt;li class=\"news-item\"&gt;\n                                    &lt;a href=\"https://www.shiguangkey.com/course/2432\" class=\"news-thumbnail\"\n                                       target=\"_blank\"&gt;\n                                        &lt;img src={{% static \"images/linux.jpg\" %}} alt=\"linux下svn命令的使用\"\n                                             title=\"linux下svn命令的使用\"&gt;\n                                    &lt;/a&gt;\n                                    &lt;div class=\"news-content\"&gt;\n                                        &lt;h4 class=\"news-title\"&gt;&lt;a\n                                                href=\"https://www.shiguangkey.com/course/2432/887\"&gt;linux下svn命令的使用&lt;/a&gt;\n                                        &lt;/h4&gt;\n                                        &lt;p class=\"news-details\"&gt;1、将文件checkout到本地目录svn checkout path（path是服务器上的目录） 例如：svn\n                                            checkout\n                                            svn://192.168.1.1/pro/domain 简写：svn co2、往版本库中添加新的文件 svn addfile 例如：svn add\n                                            te...&lt;/p&gt;\n                                        &lt;div class=\"news-other\"&gt;\n                                            &lt;span class=\"news-type\"&gt;Linux教程&lt;/span&gt;\n                                            &lt;span class=\"news-time\"&gt;11/11 18:24&lt;/span&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/li&gt;\n\n                                &lt;li class=\"news-item\"&gt;\n                                    &lt;a href=\"https://www.shiguangkey.com/course/2432\" class=\"news-thumbnail\"\n                                       target=\"_blank\"&gt;\n                                        &lt;img src={{% static \"images/linux.jpg\" %}} alt=\"实现linux和windows文件传输\"\n                                             title=\"实现linux和windows文件传输\"&gt;\n                                    &lt;/a&gt;\n                                    &lt;div class=\"news-content\"&gt;\n                                        &lt;h4 class=\"news-title\"&gt;&lt;a\n                                                href=\"https://www.shiguangkey.com/course/2432/886\"&gt;实现linux和windows文件传输&lt;/a&gt;\n                                        &lt;/h4&gt;\n                                        &lt;p class=\"news-details\"&gt;\n                                            其实这个题目有点大，这里介绍的只是linux和windows文件传输中的一种，但是这种方法却非常实用，那就是：ZModem协议具体是linux命令是：rz...&lt;/p&gt;\n                                        &lt;div class=\"news-other\"&gt;\n                                            &lt;span class=\"news-type\"&gt;Linux教程&lt;/span&gt;\n                                            &lt;span class=\"news-time\"&gt;11/11 18:24&lt;/span&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/li&gt;\n\n                                &lt;li class=\"news-item\"&gt;\n                                    &lt;a href=\"https://www.shiguangkey.com/course/2432\" class=\"news-thumbnail\"\n                                       target=\"_blank\"&gt;\n                                        &lt;img src={{% static \"images/linux.jpg\" %}} alt=\".htaccess配置详解\"\n                                             title=\".htaccess配置详解\"&gt;\n                                    &lt;/a&gt;\n                                    &lt;div class=\"news-content\"&gt;\n                                        &lt;h4 class=\"news-title\"&gt;&lt;a\n                                                href=\"https://www.shiguangkey.com/course/2432\"&gt;.htaccess配置详解&lt;/a&gt;\n                                        &lt;/h4&gt;\n                                        &lt;p class=\"news-details\"&gt;　　.htaccess文件设置基础教程 如果你设置好了比如常用的404页面 301重定向\n                                            页面还有500页面等会设置了\n                                            无非对你的seo技术有很大帮助那么 .htaccess文件到底怎么设置呢　　- .htaccess 文件(或者&quot;分布式...&lt;/p&gt;\n                                        &lt;div class=\"news-other\"&gt;\n                                            &lt;span class=\"news-type\"&gt;Linux教程&lt;/span&gt;\n                                            &lt;span class=\"news-time\"&gt;11/11 18:24&lt;/span&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/li&gt;\n\n                                &lt;li class=\"news-item\"&gt;\n                                    &lt;a href=\"https://www.shiguangkey.com/course/2432\" class=\"news-thumbnail\"\n                                       target=\"_blank\"&gt;\n                                        &lt;img src={{% static \"images/linux.jpg\" %}} alt=\"使用nohup命令让linux程序后台运行\"\n                                             title=\"使用nohup命令让linux程序后台运行\"&gt;\n                                    &lt;/a&gt;\n                                    &lt;div class=\"news-content\"&gt;\n                                        &lt;h4 class=\"news-title\"&gt;&lt;a\n                                                href=\"https://www.shiguangkey.com/course/2432\"&gt;使用nohup命令让linux程序后台运行&lt;/a&gt;\n                                        &lt;/h4&gt;\n                                        &lt;p class=\"news-details\"&gt;使用nohup让程序永远后台运行Unix/Linux下一般比如想让某个程序在后台运行，很多都是使用 &amp;\n                                            在程序结尾来让程序自动运行。比如我们要运行mysql在后台：/usr/local/mysql/bin/mysqld_safe --user=mysql\n                                            &amp;但是...&lt;/p&gt;\n                                        &lt;div class=\"news-other\"&gt;\n                                            &lt;span class=\"news-type\"&gt;Linux教程&lt;/span&gt;\n                                            &lt;span class=\"news-time\"&gt;11/11 18:24&lt;/span&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/li&gt;\n\n                            &lt;/ul&gt;\n                        &lt;/div&gt;\n                        &lt;!-- news-contain end --&gt;\n\n                        &lt;!-- btn-more start --&gt;\n                        &lt;a href=\"javascript:void(0);\" class=\"btn-more\"&gt;加载更多&lt;/a&gt;\n                        &lt;!-- btn-more end --&gt;\n                    &lt;/div&gt;\n                    &lt;!-- content end --&gt;\n                &lt;/div&gt;\n            {{% endblock main_contain %}}\n            &lt;!-- main-contain  end --&gt;\n\n            &lt;!-- side start --&gt;\n            {{% block side %}}\n                &lt;aside class=\"side\"&gt;\n                    &lt;div class=\"side-activities\"&gt;\n                        &lt;h3 class=\"activities-title\"&gt;在线课堂&lt;a href=\"javascript:void(0)\"&gt;更多&lt;/a&gt;&lt;/h3&gt;\n                        &lt;div class=\"activities-img\"&gt;\n                            &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                &lt;img src={{% static \"images/english.jpg\" %}} alt=\"title\"&gt;\n                            &lt;/a&gt;\n                            &lt;p class=\"activities-tips\"&gt;对话国外小姐姐&lt;/p&gt;\n                        &lt;/div&gt;\n                        &lt;ul class=\"activities-list\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-start\"&gt;报名中&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a\n                                            href=\"https://www.shiguangkey.com/course/2432\"&gt; Django 项目班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-end\"&gt;已结束&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a\n                                            href=\"https://www.shiguangkey.com/course/2321\"&gt;Python入门基础班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"side-attention clearfix\"&gt;\n                        &lt;h3 class=\"attention-title\"&gt;关注我&lt;/h3&gt;\n                        &lt;ul class=\"side-attention-address\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i\n                                        class=\"PyWhich py-GitHub\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-zhihu\"\n                                                                                 style=\"color:rgb(0, 108, 226);\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-weibo\"\n                                                                                 style=\"color:rgb(245,92,110);\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                        &lt;div class=\"side-attention-qr\"&gt;\n                            &lt;p&gt;扫码关注&lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n\n                    &lt;div class=\"side-hot-recommend\"&gt;\n                        &lt;h3 class=\"hot-recommend\"&gt;热门推荐&lt;/h3&gt;\n                        &lt;ul class=\"hot-news-list\"&gt;\n\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0)\" class=\"hot-news-contain clearfix\"&gt;\n                                    &lt;div class=\"hot-news-thumbnail\"&gt;\n                                        &lt;img src={{% static \"images/python_web.jpg\" %}}\n                                                     alt=\"\"&gt;\n                                    &lt;/div&gt;\n                                    &lt;div class=\"hot-news-content\"&gt;\n                                        &lt;p class=\"hot-news-title\"&gt;Django调试工具django-debug-toolbar安装使用教程&lt;/p&gt;\n                                        &lt;div class=\"hot-news-other clearfix\"&gt;\n                                            &lt;span class=\"news-type\"&gt;python框架&lt;/span&gt;\n                                            &lt;!-- 自带的 --&gt;\n                                            &lt;time class=\"news-pub-time\"&gt;11月11日&lt;/time&gt;\n                                            &lt;span class=\"news-author\"&gt;python&lt;/span&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n\n\n                &lt;/aside&gt;\n            {{% endblock side %}}\n            &lt;!-- side end --&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n{{% endblock main %}}\n&lt;!-- main end --&gt;\n\n&lt;!-- footer start --&gt;\n{{% block foot %}}\n    &lt;footer id=\"footer\"&gt;\n        &lt;div class=\"footer-box\"&gt;\n            &lt;div class=\"footer-content\"&gt;\n                &lt;p class=\"top-content\"&gt;\n                    &lt;span class=\"link\"&gt;\n                        &lt;a href=\"javascript:void(0)\"&gt;关于Python&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我就是我&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;人生苦短&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我用Python&lt;/a&gt;\n                    &lt;/span&gt;\n                    &lt;span class=\"about-me\"&gt;关于我: &lt;i class=\"PyWhich py-wechat\"&gt;&lt;/i&gt; XinLan&lt;/span&gt;\n                &lt;/p&gt;\n                &lt;p class=\"bottom-content\"&gt;\n                    &lt;span&gt;地址： xxxx&lt;/span&gt;\n                    &lt;span&gt;联系方式: &lt;a href=\"tel:400-1567-315\"&gt;400-1567-315&lt;/a&gt; (24小时在线)&lt;/span&gt;\n                &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p class=\"copyright-desc\"&gt;\n                Copyright &copy; 2008 - 2018 xxx有限公司. All Rights Reserved\n            &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/footer&gt;\n{{% endblock foot %}}\n&lt;!-- footer end --&gt;\n\n{{% block script %}}\n    &lt;script src=\"{{% static 'js/news/index.js' %}}\"&gt;&lt;/script&gt;\n    &lt;script src=\"{{% static 'js/base/common.js' %}}\"&gt;&lt;/script&gt;\n{{% endblock script %}}\n\n③doc.html文件\n{{% extends 'base/base.html' %}}\n{{% load static %}}\n\n\n{{% block title %}}\n    payInfo\n{{% endblock title %}}\n\n{{% block css %}}\n    &lt;link rel=\"stylesheet\" href=\"{{% static 'css/doc/docDownload.css' %}}\"&gt;\n    &lt;script&gt;IMemuIndex = 2&lt;/script&gt;\n{{% endblock css %}}\n&lt;body&gt;\n\n\n&lt;!-- main start --&gt;\n{{% block main %}}\n    &lt;main id=\"main\"&gt;\n        &lt;div class=\"w1200 clearfix\"&gt;\n            &lt;!-- main-contain start  --&gt;\n            {{% block main_contain %}}\n                &lt;div class=\"main-contain \"&gt;\n                    &lt;div class=\"banner\"&gt;\n                        &lt;img src=\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1802845035,3786939119&fm=26&gp=0.jpg\"\n                             alt=\"\"&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"pay-doc-contain\"&gt;\n                        &lt;ul class=\"pay-list\"&gt;\n\n                            &lt;li class=\"pay-item\"&gt;\n                                &lt;div class=\"pay-img doc\"&gt;&lt;/div&gt;\n                                &lt;div class=\"d-contain\"&gt;\n                                    &lt;p class=\"doc-title\"&gt;python cookbook 3.0 教程&lt;/p&gt;\n                                    &lt;p class=\"doc-desc\"&gt;强烈推荐的python 教程。&lt;/p&gt;\n\n                                    &lt;!-- /www/?xxx --&gt;\n                                    &lt;a href=\"#\" class=\"pay-price\"&gt;下载&lt;/a&gt;\n                                &lt;/div&gt;\n                            &lt;/li&gt;\n\n                            &lt;li class=\"pay-item\"&gt;\n                                &lt;div class=\"pay-img doc\"&gt;&lt;/div&gt;\n                                &lt;div class=\"pay-contain\"&gt;\n                                    &lt;p class=\"pay-title\"&gt;流畅的Python&lt;/p&gt;\n                                    &lt;p class=\"pay-desc\"&gt;【本书特色】\n\n                                        本书由奋战在Python开发一线近20年的Luciano Ramalho执笔，Victor Stinner、Alex\n                                        Martelli等Python大咖担纲技术审稿人，从语言设计层面剖析编程细节，兼顾Python 3和Python\n                                        2，告诉你Python中不亲自动手实践就无法理解的语言陷阱成因和解决之道，教你写出风格地道的Python代码。&lt;/p&gt;\n\n                                    &lt;!-- /www/?xxx --&gt;\n                                    &lt;a href=\"#\" class=\"pay-price\"&gt;下载&lt;/a&gt;\n                                &lt;/div&gt;\n                            &lt;/li&gt;\n\n                            &lt;li class=\"pay-item\"&gt;\n                                &lt;div class=\"pay-img doc\"&gt;&lt;/div&gt;\n                                &lt;div class=\"pay-contain\"&gt;\n                                    &lt;p class=\"pay-title\"&gt;深入Flask&lt;/p&gt;\n                                    &lt;p class=\"pay-desc\"&gt;深入Flask，强烈推荐！&lt;/p&gt;\n\n                                    &lt;!-- /www/?xxx --&gt;\n                                    &lt;a href=\"#\" class=\"pay-price\"&gt;下载&lt;/a&gt;\n                                &lt;/div&gt;\n                            &lt;/li&gt;\n\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            {{% endblock main_contain %}}\n            &lt;!-- main-contain  end --&gt;\n\n            &lt;!-- side start --&gt;\n            {{% block side %}}\n                &lt;aside class=\"side\"&gt;\n                    &lt;div class=\"side-activities\"&gt;\n                        &lt;h3 class=\"activities-title\"&gt;在线课堂&lt;a href=\"javascript:void(0)\"&gt;更多&lt;/a&gt;&lt;/h3&gt;\n                        &lt;div class=\"activities-img\"&gt;\n                            &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                &lt;img src=\"https://res.shiguangkey.com//file/201804/26/20180426142628123364782.jpg\"\n                                     alt=\"title\"&gt;\n                            &lt;/a&gt;\n                            &lt;p class=\"activities-tips\"&gt;对话国外小姐姐&lt;/p&gt;\n                        &lt;/div&gt;\n                        &lt;ul class=\"activities-list\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-start\"&gt;报名中&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a href=\"https://www.shiguangkey.com/course/2432\"&gt; Django 项目班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;\n                                    &lt;span class=\"active-status active-end\"&gt;已结束&lt;/span&gt;\n                                    &lt;span class=\"active-title\"&gt;&lt;a href=\"https://www.shiguangkey.com/course/2321\"&gt;Python入门基础班&lt;/a&gt;&lt;/span&gt;\n                                &lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"side-attention clearfix\"&gt;\n                        &lt;h3 class=\"attention-title\"&gt;关注我&lt;/h3&gt;\n                        &lt;ul class=\"side-attention-address\"&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i\n                                        class=\"PyWhich py-GitHub\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-zhihu\"\n                                                                                 style=\"color:rgb(0, 108, 226);\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                            &lt;li&gt;\n                                &lt;a href=\"javascript:void(0);\" target=\"_blank\"&gt;&lt;i class=\"PyWhich py-weibo\"\n                                                                                 style=\"color:rgb(245,91,94)\"&gt;&lt;/i&gt;XinLan&lt;/a&gt;\n                            &lt;/li&gt;\n                        &lt;/ul&gt;\n                        &lt;div class=\"side-attention-qr\"&gt;\n                            &lt;p&gt;扫码关注&lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n\n\n                &lt;/aside&gt;\n            {{% endblock side %}}\n            &lt;!-- side end --&gt;\n\n\n        &lt;/div&gt;\n    &lt;/main&gt;\n{{% endblock main %}}\n\n&lt;!-- main end --&gt;\n\n&lt;!-- footer start --&gt;\n{{% block foot %}}\n    &lt;footer id=\"footer\"&gt;\n        &lt;div class=\"footer-box\"&gt;\n            &lt;div class=\"footer-content\"&gt;\n                &lt;p class=\"top-content\"&gt;\n                    &lt;span class=\"link\"&gt;\n                        &lt;a href=\"javascript:void(0)\"&gt;关于Python&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我就是我&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;人生苦短&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我用Python&lt;/a&gt;\n                    &lt;/span&gt;\n                    &lt;span class=\"about-me\"&gt;关于我: &lt;i class=\"PyWhich py-wechat\"&gt;&lt;/i&gt; XinLan&lt;/span&gt;\n                &lt;/p&gt;\n                &lt;p class=\"bottom-content\"&gt;\n                    &lt;span&gt;地址： xxxx&lt;/span&gt;\n                    &lt;span&gt;联系方式: &lt;a href=\"tel:400-1567-315\"&gt;400-1567-315&lt;/a&gt; (24小时在线)&lt;/span&gt;\n                &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p class=\"copyright-desc\"&gt;\n                Copyright &copy; 2008 - 2018 xxx有限公司. All Rights Reserved\n            &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/footer&gt;\n{{% endblock foot %}}\n&lt;!-- footer end --&gt;\n{{% block script %}}\n    &lt;script src=\"{{% static 'js/base/common.js' %}}\"&gt;&lt;/script&gt;\n{{% endblock script %}}\n\n\n④user/login.html文件\n{{% extends 'base/base.html' %}}\n{{% load static %}}\n\n{{% block css %}}\n    &lt;link rel=\"stylesheet\" href=\"{{% static 'css/user/auth.css' %}}\"&gt;\n{{% endblock css %}}\n\n{{% block title %}}\n    login\n{{% endblock %}}\n\n&lt;!-- container start --&gt;\n{{% block main %}}\n    &lt;main id=\"container\"&gt;\n        &lt;div class=\"login-contain\"&gt;\n            &lt;div class=\"top-contain\"&gt;\n                &lt;h4 class=\"please-login\"&gt;请登录&lt;/h4&gt;\n{#                &lt;a href=\"javascript:void(0);\" class=\"register\"&gt;立即注册 &gt;&lt;/a&gt;#}\n                &lt;a href=\"{{% url 'user:register' %}}\" class=\"register\"&gt;立即注册 &gt;&lt;/a&gt;\n            &lt;/div&gt;\n            &lt;form action=\"\" method=\"post\" class=\"form-contain\"&gt;\n                &lt;div class=\"form-item\"&gt;\n                    &lt;input type=\"tel\" placeholder=\"请输入手机号\" name=\"mobile\" class=\"form-control\" autocomplete=\"off\"&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-item\"&gt;\n                    &lt;input type=\"password\" placeholder=\"请输入密码\" name=\"password\" class=\"form-control\"&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-item clearfix\"&gt;\n                    &lt;label&gt;\n                        &lt;input type=\"checkbox\" name=\"remember\"&gt;\n                        &lt;span&gt;记住我&lt;/span&gt;\n                    &lt;/label&gt;\n                    &lt;a href=\"javascript:void(0);\" class=\"forget-password\"&gt;忘记密码?&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-login\"&gt;\n                    &lt;input type=\"submit\" value=\"登录\" class=\"login-btn\"&gt;\n                &lt;/div&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n{{% endblock main %}}\n&lt;!-- container end --&gt;\n\n&lt;!-- footer start --&gt;\n{{% block foot %}}\n    &lt;footer id=\"footer\"&gt;\n        &lt;div class=\"footer-box\"&gt;\n            &lt;div class=\"footer-content\"&gt;\n                &lt;p class=\"top-content\"&gt;\n                    &lt;span class=\"link\"&gt;\n                        &lt;a href=\"javascript:void(0)\"&gt;关于Python&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我就是我&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;人生苦短&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我用Python&lt;/a&gt;\n                    &lt;/span&gt;\n                    &lt;span class=\"about-me\"&gt;关于我: &lt;i class=\"PyWhich py-wechat\"&gt;&lt;/i&gt; XinLan&lt;/span&gt;\n                &lt;/p&gt;\n                &lt;p class=\"bottom-content\"&gt;\n                    &lt;span&gt;地址： xxxx&lt;/span&gt;\n                    &lt;span&gt;联系方式: &lt;a href=\"tel:400-1567-315\"&gt;400-1567-315&lt;/a&gt; (24小时在线)&lt;/span&gt;\n                &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p class=\"copyright-desc\"&gt;\n                Copyright &copy; 2008 - 2018 xxx有限公司. All Rights Reserved\n            &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/footer&gt;\n{{% endblock %}}\n\n&lt;!-- footer end --&gt;\n{{% block script %}}\n{#&lt;script src=\"{{% static 'js/user/register.js' %}}\"&gt;&lt;/script&gt;#}\n&lt;script src=\"{{% static 'js/user/login.js' %}}\"&gt;&lt;/script&gt;\n{{% endblock script %}}\n\n\n⑤register.html文件\n{{% extends 'base/base.html' %}}\n{{% load static %}}\n\n{{% block title %}}\n    Register\n{{% endblock title %}}\n{{% block css %}}\n  &lt;link rel=\"stylesheet\" href=\"{{% static 'css/user/auth.css' %}}\"&gt;\n    &lt;script&gt;IMemuIndex=false&lt;/script&gt;\n{{% endblock css %}}\n\n\n&lt;!-- container start --&gt;\n{{% block main %}}\n&lt;main id=\"container\"&gt;\n  &lt;div class=\"register-contain\"&gt;\n    &lt;div class=\"top-contain\"&gt;\n      &lt;h4 class=\"please-register\"&gt;请注册&lt;/h4&gt;\n{#      &lt;a href=\"javascript:void(0);\" class=\"login\"&gt;立即登录 &gt;&lt;/a&gt;#}\n      &lt;a href=\"{{% url 'user:login' %}}\" class=\"login\"&gt;立即登录 &gt;&lt;/a&gt;\n    &lt;/div&gt;\n    &lt;form action=\"\" method=\"post\" class=\"form-contain\"&gt;\n        {{% csrf_token %}}\n\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\" class=\"form-control\" id=\"username\" autocomplete=\"off\"&gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"password\" placeholder=\"请输入密码\" name=\"password\" class=\"form-control\"&gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"password\" placeholder=\"请输入确认密码\" name=\"password_repeat\" class=\"form-control\"&gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"tel\" placeholder=\"请输入手机号\" name=\"mobile\" class=\"form-control\" autocomplete=\"off\" &gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"text\" placeholder=\"请输入图形验证码\" name=\"captcha_graph\" class=\"form-captcha\"&gt;\n        &lt;a href=\"javascript:void(0);\" class=\"captcha-graph-img\"&gt;\n          &lt;img src=\"{{% url 'image_code:image_code' %}}\" alt=\"验证码\" title=\"点击刷新\"&gt;\n        &lt;/a&gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"text\" placeholder=\"请输入短信验证码\" name=\"sms_captcha\" class=\"form-captcha\" autocomplete=\"off\"&gt;\n        &lt;a href=\"javascript:void(0);\" class=\"sms-captcha\" title=\"发送验证码\"&gt;获取短信验证码&lt;/a&gt;\n      &lt;/div&gt;\n      &lt;div class=\"form-item\"&gt;\n        &lt;input type=\"submit\" value=\"立即注册\" class=\"register-btn\"&gt;\n      &lt;/div&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n&lt;/main&gt;\n{{% endblock main %}}\n&lt;!-- container end --&gt;\n\n&lt;!-- footer start --&gt;\n{{% block foot %}}\n&lt;footer id=\"footer\"&gt;\n  &lt;div class=\"footer-box\"&gt;\n    &lt;div class=\"footer-content\"&gt;\n      &lt;p class=\"top-content\"&gt;\n                    &lt;span class=\"link\"&gt;\n                        &lt;a href=\"javascript:void(0)\"&gt;关于Python&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我就是我&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;人生苦短&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我用Python&lt;/a&gt;\n                    &lt;/span&gt;\n        &lt;span class=\"about-me\"&gt;关于我: &lt;i class=\"PyWhich py-wechat\"&gt;&lt;/i&gt; XinLan&lt;/span&gt;\n      &lt;/p&gt;\n      &lt;p class=\"bottom-content\"&gt;\n        &lt;span&gt;地址： xxxx&lt;/span&gt;\n        &lt;span&gt;联系方式: &lt;a href=\"tel:400-1567-315\"&gt;400-1567-315&lt;/a&gt; (24小时在线)&lt;/span&gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n    &lt;p class=\"copyright-desc\"&gt;\n      Copyright &copy; 2008 - 2018 xxx有限公司. All Rights Reserved\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n{{% endblock foot %}}\n&lt;!-- footer end --&gt;\n{{% block script %}}\n{#    &lt;script src=\"{{% static 'js/base/message.js' %}}\"&gt;&lt;/script&gt;#}\n    &lt;script src=\"{{% static 'js/user/register.js' %}}\"&gt;&lt;/script&gt;\n    &lt;script src=\"{{% static 'js/base/common.js' %}}\"&gt;&lt;/script&gt;\n{{% endblock script %}}\n\n\n⑥course.html文件\n{{% extends 'base/base.html' %}}\n{{% load static %}}\n\n\n\n{{% block title %}}\n    coursePage\n{{% endblock title %}}\n{{% block css %}}\n    &lt;link rel=\"stylesheet\" href=\"{{% static 'css/course/course.css' %}}\"&gt;\n    &lt;script&gt;IMemuIndex = 1&lt;/script&gt;\n{{% endblock css %}}\n\n\n\n{{% block main %}}\n    &lt;main id=\"course-container\"&gt;\n        &lt;div class=\"w1200\"&gt;\n            &lt;ul class=\"course-list\"&gt;\n\n                &lt;li class=\"course-item\"&gt;\n                    &lt;a href=\"https://www.shiguangkey.com/course/2432\"&gt;\n                        &lt;img class=\"course-img\" src={{% static \"images/python_advanced.jpg\" %}}\n                                alt=\"潭州英语\"&gt;\n                        &lt;div class=\"course-content\"&gt;\n                            &lt;p class=\"course-info\"&gt;python 全栈开发&lt;/p&gt;\n                            &lt;p class=\"course-author\"&gt;不动(python金牌讲师)&lt;/p&gt;\n                            &lt;p class=\"course-price free\"&gt;免费&lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/a&gt;\n                &lt;/li&gt;\n\n                &lt;li class=\"course-item\"&gt;\n                    &lt;a href=\"https://www.shiguangkey.com/course/2432\"&gt;\n                        &lt;img class=\"course-img\" src={{% static \"images/python_web.jpg\" %}}\n                                alt=\"潭州英语\"&gt;\n                        &lt;div class=\"course-content\"&gt;\n                            &lt;p class=\"course-info\"&gt;django 项目&lt;/p&gt;\n                            &lt;p class=\"course-author\"&gt;XinLan(python讲师)&lt;/p&gt;\n                            &lt;p class=\"course-price free\"&gt;免费&lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/a&gt;\n                &lt;/li&gt;\n\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n{{% endblock main %}}\n\n&lt;!-- footer start --&gt;\n{{% block foot %}}\n    &lt;footer id=\"footer\"&gt;\n        &lt;div class=\"footer-box\"&gt;\n            &lt;div class=\"footer-content\"&gt;\n                &lt;p class=\"top-content\"&gt;\n                    &lt;span class=\"link\"&gt;\n                        &lt;a href=\"javascript:void(0)\"&gt;关于Python&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我就是我&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;人生苦短&lt;/a&gt; |\n                        &lt;a href=\"javascript:void(0)\"&gt;我用Python&lt;/a&gt;\n                    &lt;/span&gt;\n                    &lt;span class=\"about-me\"&gt;关于我: &lt;i class=\"PyWhich py-wechat\"&gt;&lt;/i&gt; XinLan&lt;/span&gt;\n                &lt;/p&gt;\n                &lt;p class=\"bottom-content\"&gt;\n                    &lt;span&gt;地址： xxxx&lt;/span&gt;\n                    &lt;span&gt;联系方式: &lt;a href=\"tel:400-1567-315\"&gt;400-1567-315&lt;/a&gt; (24小时在线)&lt;/span&gt;\n                &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p class=\"copyright-desc\"&gt;\n                Copyright &copy; 2008 - 2018 xxx有限公司. All Rights Reserved\n            &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/footer&gt;\n{{% endblock foot %}}\n&lt;!-- footer end --&gt;\n&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt;\n{{% block script %}}\n    &lt;script src=\"{{% static 'js/base/common.js' %}}\"&gt;&lt;/script&gt;\n{{% endblock script %}}"
  },
  {
    "objectID": "posts/Django项目/index.html#创建static文件夹",
    "href": "posts/Django项目/index.html#创建static文件夹",
    "title": "Django项目",
    "section": "3.2 创建static文件夹",
    "text": "3.2 创建static文件夹\n创建static文件夹用来存放静态文件(css/js/img/)\n文件结构，每个模板的静态文件创建并放到不同的文件夹中\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8aQddVf6-1588223223861)(/1565757977142.png)]\n\n①css文件\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2uT6VJ3e-1588223223862)(/1565758060491.png)]\n\n\n②js文件\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-22AmnnTu-1588223223863)(/1565758133004.png)]\n\n\n③images文件\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7GDefwPC-1588223223864)(/1565758178816.png)]"
  },
  {
    "objectID": "posts/Django项目/index.html#编写views文件和路由配置编写urls文件",
    "href": "posts/Django项目/index.html#编写views文件和路由配置编写urls文件",
    "title": "Django项目",
    "section": "3.3 编写views文件和路由配置(编写urls文件)",
    "text": "3.3 编写views文件和路由配置(编写urls文件)\n以news为例，其他类推\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xueBXiwF-1588223223865)(/1565758673646.png)]\n\n3.3.1 views.py\nfrom django.shortcuts import render\n\n# Create your views here.\n\n# news主页\ndef index(request):\n    return render(request, 'news/index.html')\n3.3.2 urls.py\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GndDBNH0-1588223223866)(/1565758901074.png)]\n# 主路由\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    #\n    # path('admin', admin.site.urls),\n    # 分配news子路由\n    path('news/', include('news.urls')),\n    # 分配course子路由\n    path('course/', include('course.urls')),\n    # 分配doc子路由\n    path('doc/', include('doc.urls')),\n    # 分配user子路由\n    path('user/', include('user.urls')),\n    # 分配image_code子路由\n    path('verification/', include('verification.urls'))\n]\n# news的路由\nfrom django.urls import path\n\nfrom . import views\n\napp_name = 'news'\n\nurlpatterns = [\n    path('', views.index, name='index')\n]"
  },
  {
    "objectID": "posts/Django项目/index.html#填上缺少的block",
    "href": "posts/Django项目/index.html#填上缺少的block",
    "title": "Django项目",
    "section": "3.4 填上缺少的block",
    "text": "3.4 填上缺少的block\n根据每个页面的不同填上不同的内容\n3.1.3中已经填上"
  },
  {
    "objectID": "posts/Django项目/index.html#模型设置",
    "href": "posts/Django项目/index.html#模型设置",
    "title": "Django项目",
    "section": "4.1 模型设置",
    "text": "4.1 模型设置\n\n4.1.1 字段分析\n-用户名\n-密码\n-手机号\n-邮箱\n\n\n4.1.2 模型设计\ndjango的强大之处在于开发效率高，内置了权限模块之类的很多常用功能。在开始一个新的django项目时，如果权限模块中的User模型不满足项目要求，我们需要扩展或者自定义User模型。\n扩展User模型有两种方法：\n\n如果你不需要改变数据库存储内容，只是改变行为，那么可以建立有一个基于User模型的代理模型。\n如果想存储与User模型关联的信息，可以使用OneToOneField到包含其他信息字段的模型。这种one-to-one模型经常被称作Profile模型，因为它可能存储站点用户的非身份验证的相关信息。例如：\n\nfrom django.contrib.auth.models import User\n\nclass Employee(models.Model):\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    department = models.CharField(max_length=100)\n自定义User模型：\n如果不想使用django内置的权限系统，当然你需要自定义用户模型，这种情况不讨论。当然也不建议这么做，django内置权限系统有大的自定义功能扩展，而不是重复造轮子。\n开启一个新项目，官方强烈推荐用户自定义用户模型，即是默认的用户模型目前已经足够，但是未来可能会要扩展。\nfrom django.contrib.auth.models import AbstractUser\n\nclass User(AbstractUser):\n    pass\n注意:不要忘记在settings.py中设置AUTH_USER_MODEL指向它。\n一旦已经创立数据库表之后再去修改AUTH_USER_MODEL，会困难很多，因为它会影响外键和多对多关系。这个改动并不能自动完成，需要手动修复（巨坑）。\n官方文档\n\n\n4.1.3 user的models文件\n设置models文件来建立模型，这里用Django内置的User一定要注意！！！！！\n我们重写了User类，我们要让整个框架知道我们重写了User类，就要在settings文件中配置\n\n②settings.py\n# 自定义用户模型\nAUTH_USER_MODEL = 'user.User'\n\n\n①models.py\nfrom django.db import models\n# 导入Django的内置User模型类 取个别名因为下面会用到相同的名冲突\nfrom django.contrib.auth.models import AbstractUser, UserManager as _UserManager\n\n\n# 这个类继承_UserManager类\nclass UserManger(_UserManager):\n    \"\"\"\"\n      修改必须输入email的这个行为\n      重写create_superuser方法，去掉创建super_user必须的email的行为\n    \"\"\"\n    def create_superuser(self, username,  password, email=None, **extra_fields):\n        super().create_superuser(username=username, password=password, email=email, **extra_fields)\n\n\nclass User(AbstractUser):\n    \"\"\"\n    自定义user模型， 添加手机，email_active\n    \"\"\"\n    mobile = models.CharField(verbose_name='手机号', max_length=11, unique=True, help_text='手机号', error_messages={'unique': '此手机号码已注册'})\n\n    email_active = models.BooleanField(verbose_name='邮箱状态', default=False)\n\n    class Meta:\n        db_table = 'tb_user'      # 指定数据库表名\n        verbose_name = '用户'      # 在admin站点中的显示名称\n        verbose_name_plural = verbose_name    # 复数\n\n    # 返回的字段名\n    def __str__(self):\n        return self.username\n\n    # 通过createsuperuser 这个命令创建用户时，需要的字段\n    REQUIRED_FIELDS = ['mobile']\n\n    # 通过管理器来执行\n    objects = UserManger()\n\n\n\n③迁移\n# 数据库迁移 \npython manage.py makemigrations\n# 迁移生效\npython manage.py migrate\n我们这里用的是自己写的admin后台，没有用Django内置的后台\n所以我们将settings.py—-&gt; INSTALLED_APPS—-&gt;django.contrib.admin 注释掉(删掉)，urls.py 主路由中的admin路由也一定要注释掉，要不然无法迁移！！！\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nK23FfrY-1588223223867)(/1565761073556.png)]\n去掉admin路由\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iYU6CJHf-1588223223868)(/1565761243867.png)]\n\n\n④创建一个用户\n(tzproject) ~/code/tztz$ python manage.py createsuperuser\n用户名: admin\n手机号: 158xxxxxxxx\nPassword: \nPassword (again): \n密码长度太短。密码必须包含至少 8 个字符。\n这个密码太常见了。\nBypass password validation and create user anyway? [y/N]: y\nSuperuser created successfully."
  },
  {
    "objectID": "posts/Django项目/index.html#功能需求分析",
    "href": "posts/Django项目/index.html#功能需求分析",
    "title": "Django项目",
    "section": "4.2 功能需求分析",
    "text": "4.2 功能需求分析\n\n4.2.1 接口设计思路\n\n分析业务逻辑，明确在这个业务中需要涉及到几个相关子业务，将每个子业务当做一个接口来设计\n分析接口的功能任务，明确接口的访问方式与返回数据：\n\n接口的请求方式，如GET，POST，PUT等\n接口的URL路径定义\n需要接受的参数及参数格式（如路径参数，查询字符串，请求表单，JSON等）\n返回的数据及数据格式\n\n\n\n\n4.2.2 注册功能分析\n\n①流程图\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-f1t4hlXN-1588223223869)(/登录注册流程图.png)]\n\n\n②功能\n根据流程图结构分析注册业务包含以下功能\n\n注册页面\n图片验证码\n用户名检测是否注册\n手机号检测是否注册\n短信验证码\n注册保存用户数据\n\n因为图片验证码，短信验证码考虑到后续可能会在其他业务中用到，因此将验证码功能独立出来，创建一个新应用verification用来校验"
  },
  {
    "objectID": "posts/Django项目/index.html#图形验证码功能实现",
    "href": "posts/Django项目/index.html#图形验证码功能实现",
    "title": "Django项目",
    "section": "4.3 图形验证码功能实现",
    "text": "4.3 图形验证码功能实现\n\n4.3.1 接口设计\n接口说明：\n\n\n\n类目\n说明\n\n\n\n\n请求方式\nGET\n\n\nurl定义\n/verification/image_code/\n\n\n参数格式\n查询参数\n\n\n\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n描述\n\n\n\n\nrand\n字符串\n否\n随机值\n\n\n\n\n\n4.3.2后端代码\n\n①将验证码生成模块复制到根目录utils文件夹下\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UejbHgeM-1588223223870)(/1565762750062.png)]\n\n\n②创建新的app verification专门用来处理验证\n记得在settings文件中注册app\ncd ~/code/tztz/apps/\npython ../manage.py startapp verification\n\n\n③verification/views.py代码如下：\nimport logging\n\nfrom django.http import HttpResponse\n\nfrom utils.captcha.captcha import captcha\nfrom . import constants\n# 拿到Django的日志器\nlogger = logging.getLogger('django')\n\n\ndef image_code_view(request):\n    \"\"\"\n    生成图片验证码\n    url:/image_code/\n    :param request:\n    :return:\n    \"\"\"\n    # 返回两个值，一个是生成的text文本，另一个是image图片\n    text, image = captcha.generate_captcha()\n    # 将验证码存入session中name为'image_code'\n    request.session['image_code'] = text\n    # 设置session过期时间 单位秒\n    # constants设置常量便于后期修改数值\n    request.session.set_expiry(constants.IMAGE_CODE_EXPIRES)\n    # 将生成的image_code的text记录到日志器中\n    logger.info('Image code:{}'.format(text))\n    # 返回响应为二进制数据，数据类型为image/jpg，这样返回的数据可以直接渲染到浏览器页面上\n    return HttpResponse(content=image, content_type='image/jpg')\n\n\n④verification/urls.py代码如下：\nfrom django.urls import path\nfrom . import views\n# url的命名空间\napp_name = 'verification'\n\nurlpatterns = [\n    path('image_code/', views.image_code_view, name='image_code'),\n]\n\n\n⑤主urls文件\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    #\n    # path('admin', admin.site.urls),\n    # 分配news子路由\n    path('news/', include('news.urls')),\n    # 分配course子路由\n    path('course/', include('course.urls')),\n    # 分配doc子路由\n    path('doc/', include('doc.urls')),\n    # 分配user子路由\n    path('user/', include('user.urls')),\n    # 分配verification子路由\n    path('verification/', include('verification.urls'))\n]"
  },
  {
    "objectID": "posts/Django项目/index.html#注册页面",
    "href": "posts/Django项目/index.html#注册页面",
    "title": "Django项目",
    "section": "4.4 注册页面",
    "text": "4.4 注册页面\n\n4.4.1 接口设计\n①接口说明\n\n\n\n类目\n说明\n\n\n\n\n请求方式\nGET\n\n\nurl定义\n/verification/register/\n\n\n参数格式\n无参数\n\n\n\n②返回结果：\n注册页面\n\n\n4.4.2后端代码\n\n①user/views.py\nfrom django.shortcuts import render\nfrom django.views import View\n\n\nclass RegisterView(View):\n    def get(self, request):\n        return render(request, 'user/register.html')\n\n\n②user/urls.py\nfrom django.urls import path, include\nfrom . import views\napp_name = 'user'\n\nurlpatterns = [\n    path('register/', views.RegisterView.as_view(), name='register')\n]\n\n\n③根urls.py\nfrom django.urls import path, include\n\nurlpatterns = [\n    \n    path('user/', include('user.urls'))\n]\n\n\n\n4.4.3 前端页面代码\n①user/register.html代码如：\n3.1.3中的⑤\n\n\n4.4.4 js代码\n点击验证码图片刷新的js代码如下：\n$(() =&gt; {\n\n    // 1.点击刷新图像验证码\n    let $img = $('.form-contain .form-item .captcha-graph-img img');\n\n\n    $img.click(function () {\n        // 加入rand随机数防止浏览器认为是相同的请求\n        $img.attr('src', '/verification/image_code/?rand=' + Math.random())\n    });\n});"
  },
  {
    "objectID": "posts/Django项目/index.html#json响应数据结构设计",
    "href": "posts/Django项目/index.html#json响应数据结构设计",
    "title": "Django项目",
    "section": "4.5 json响应数据结构设计",
    "text": "4.5 json响应数据结构设计\n\n4.5.1 结构设计\n实际项目是多人协同开发，特别是前后端交互，后端返回数据结构要一致。\n{\"errno\": \"0\", \"errmsg\": \"OK\", \"data\": {...}}\n\n\n\n字段\n类型\n说明\n\n\n\n\nerrno\n字符串\n错误编码\n\n\nerrmsg\n字符串\n错误信息\n\n\ndata\njson\n返回数据\n\n\n\n在项目根目录中utils文件夹下创建res_code.py文件，用于定义错误编码，代码如下：\nclass Code:\n    OK = \"0\"\n    DBERR = \"4001\"\n    NODATA = \"4002\"\n    DATAEXIST = \"4003\"\n    DATAERR = \"4004\"\n    METHERR = \"4005\"\n    SMSERROR = \"4006\"\n    SMSFAIL = \"4007\"\n\n    SESSIONERR = \"4101\"\n    LOGINERR = \"4102\"\n    PARAMERR = \"4103\"\n    USERERR = \"4104\"\n    ROLEERR = \"4105\"\n    PWDERR = \"4106\"\n\n    SERVERERR = \"4500\"\n    UNKOWNERR = \"4501\"\n\n\nerror_map = {\n    Code.OK: \"成功\",\n    Code.DBERR: \"数据库查询错误\",\n    Code.NODATA: \"无数据\",\n    Code.DATAEXIST: \"数据已存在\",\n    Code.DATAERR: \"数据错误\",\n    Code.METHERR: \"方法错误\",\n    Code.SMSERROR: \"发送短信验证码异常\",\n    Code.SMSFAIL: \"发送短信验证码失败\",\n\n    Code.SESSIONERR: \"用户未登录\",\n    Code.LOGINERR: \"用户登录失败\",\n    Code.PARAMERR: \"参数错误\",\n    Code.USERERR: \"用户不存在或未激活\",\n    Code.ROLEERR: \"用户身份错误\",\n    Code.PWDERR: \"密码错误\",\n\n    Code.SERVERERR: \"内部错误\",\n    Code.UNKOWNERR: \"未知错误\",\n}\n\n\n4.5.2 .快捷方法\n为了方便定义一个快捷方法，在utils目录下创建json_res.py文件中添加如下代码：\nfrom django.http import JsonResponse\n\nfrom .res_code import Code\n\n\n# 返回json——Response数据\ndef json_response(errno=Code.OK, errmsg='', data=None, kwargs=None):\n    json_dict = {\n        'errno': errno,\n        'errmsg': errmsg,\n        'data': data,\n    }\n    # 判断是否有kwargs 并且是否为字典\n    if kwargs and isinstance(kwargs, dict):\n        # 将kwargs更新到json_dict中\n        json_dict.update(kwargs)\n    return JsonResponse(json_dict)\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7nppCtHa-1588223223871)(/1565765018299.png)]"
  },
  {
    "objectID": "posts/Django项目/index.html#判断用户是否注册的功能",
    "href": "posts/Django项目/index.html#判断用户是否注册的功能",
    "title": "Django项目",
    "section": "4.6 判断用户是否注册的功能",
    "text": "4.6 判断用户是否注册的功能\n\n4.6.1 接口设计\n\n①接口说明\n\n\n\n类目\n说明\n\n\n\n\n请求方法\nGET\n\n\nurl定义\nverification/username/(?P&lt;username&gt;\\w{5,20})/\n\n\n参数格式\nurl路径参数\n\n\n\n\n\n②参数说明\n\n\n\n参数名\n类型\n是否必须\n描述\n\n\n\n\nusername\n字符串\n是\n输入的用户名\n\n\n\n返回结果：\n {\n        'errno': errno,\n        'errmsg': errmsg,\n        'data':  {\n            'username': username,\n            'count': User.objects.filter(username=username).count()\n                },\n    }\n\n\n\n4.6.2 后端代码\n\n①创建新的app verification专门用来处理验证\ncd ~/code/tztz/apps/\npython ../manage.py startapp verification\n\n\n② verification/views.py代码\nfrom user.models import User\nfrom utils.json_res import json_response\n\n\n# 验证用户名\ndef check_username(request, username):\n  \n    data = {\n        'username': username,\n        'count': \n        # 去数据库中过滤username=username的数量有多少\n        User.objects.filter(username=username).count()\n    }\n    # 返回json数据\n    return json_response(data=data)\n\n\n③verification/urls.py代码\nfrom django.urls import path, re_path\n\nfrom . import views\n\napp_name = 'image_code'\n\nurlpatterns = [\n    # 图片验证码生成\n    path('image_code/', views.image_code, name='image_code'),\n    # 用户名校验\n    re_path('username/(?P&lt;username&gt;\\w{5,20})/', views.check_username, name='check_username'),\n   \n]\n\n\n\n4.6.3 前端页面代码\nuser/register.html代码如3.1.3中的⑤\n\n\n4.6.4 前端js代码\n$(()=&gt;{\n    // 定义状态变量\n    let isUsernameReady = false,\n        isPasswordReady = false,\n        isMobileReady = false,\n    \n    \n        // 2. 用户名校验， 光标离开就进行校验\n    let $username = $('#username');\n    // blur()光标移开username的反应\n    $username.blur(fnCheckUsername);\n\n    //反应是\n    function fnCheckUsername() {\n        // 进行校验之前先把值设置为false\n        isUsernameReady = false;\n        // 拿到username的值\n        let sUsername = $username.val();\n        if (sUsername === '') {\n            message.showError('用户名不能为空');\n            return\n        }\n        if (!(/^\\w{5,20}$/).test(sUsername)) {\n            message.showError('请输入5-11位的用户名');\n\n        }\n        $.ajax({\n            // 前面的'/'一定不能少！！！！！！！\n            // 前面的'/'一定不能少！！！！！！！\n            // 前面的'/'一定不能少！！！！！！！\n            url: '/verification/username/' + sUsername + '/',\n            type: 'GET',\n            dataType: 'json',\n            success: function (res) {\n                if (res.data.count === 0) {\n                    message.showInfo(res.data.username + '可以注册');\n                } else {\n                    message.showError(res.data.username + '该用户名已经注册');\n\n                }\n            }\n        })\n    }\n});"
  },
  {
    "objectID": "posts/Django项目/index.html#判断手机号码是否注册功能",
    "href": "posts/Django项目/index.html#判断手机号码是否注册功能",
    "title": "Django项目",
    "section": "4.7 判断手机号码是否注册功能",
    "text": "4.7 判断手机号码是否注册功能\n\n4.7.1 接口设计\n接口说明：\n\n\n\n类目\n说明\n\n\n\n\n请求方法\nGET\n\n\nurl定义\nverification/mobile/(?P&lt;mobile&gt;\\1[3-9]\\d{9})/\n\n\n参数格式\nurl路径参数\n\n\n\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n描述\n\n\n\n\nmoblie\n字符串\n是\n输入的手机号码\n\n\n\n返回结果：\njson_dict = {\n        'errno': errno,\n        'errmsg': errmsg,\n        'data': {\n            'mobile': 138xxxxxx,\n            'count': 查询数据库中的手机号码数量\n                },\n    }\n\n\n4.7.2 后端代码\n\n①verification/views.py代码\nimport logging\nimport random\n\nfrom django.shortcuts import render\nfrom django.http import JsonResponse, HttpResponse\nfrom django.views import View\nfrom django_redis import get_redis_connection\n\nfrom utils.captcha.captcha import captcha\nfrom . import constants\nfrom user.models import User\nfrom utils.res_code import json_response, Code, error_map\nfrom .forms import CheckImageForm\n\n\n# 手机号码校验\ndef check_mobile(request, mobile):\n    \"\"\"\n       校验手机号是否存在\n       url:/verification/mobile/(?P&lt;mobile&gt;1[3-9]\\d{9})/\n       :param request:\n       :param mobile:\n       :return:\n       \"\"\"\n    data = {\n        'mobile': mobile,\n        'count': \n        # 到数据库中查询手机数量\n        User.objects.filter(mobile=mobile).count(),\n    }\n    return json_response(data=data)\n    \n\n\n② verification/urls.py\nfrom django.urls import path, re_path\n\nfrom . import views\n\napp_name = 'image_code'\n\nurlpatterns = [\n    # 图片验证码生成\n    path('image_code/', views.image_code, name='image_code'),\n    # 用户名校验\n    re_path('username/(?P&lt;username&gt;\\w{5,20})/', views.check_username, name='check_username'),\n    # 手机号码校验\n    re_path('mobile/(?P&lt;mobile&gt;1[3-9]\\d{9})/', views.check_mobile, name='check_mobile'),\n    path('sms_code/', views.SmsCodeView.as_view(), name='sms_codeView')\n]\n\n\n\n4.7.3 前端js代码\n// 定义状态变量\n    let isUsernameReady = false,\n        isPasswordReady = false,\n        isMobileReady = false,\n      \n\n\n// 3. 手机号码校验\n    let $mobile = $('input[name=\"mobile\"]');\n    $mobile.blur(fnCheckMobile);\n\n    function fnCheckMobile(res) {\n        // 先设置false\n        isMobileReady = false;\n        // 拿到input框里的value\n        let sMobile = $mobile.val();\n        // 进行判断\n        if (sMobile === '') {\n            message.showError(\n                '手机号不能为空'\n            );\n            return;\n        }\n        if (!(/^1[3-9]\\d{9}$/).test(sMobile)) {\n            message.showError(\n                '请输入正确的11位手机号码'\n            );\n            return;\n        }\n        if((/^1[3-9]\\d{9}$/).test(sMobile)){\n            message.showSuccess(\n                '手机号码可以使用'\n            );\n\n        }\n\n        // 方法一（推荐）\n        $.ajax({\n            url: '/verification/mobile/' + sMobile + '/',\n            type: 'GET',\n            dataType: 'json',\n        })\n\n            .done((res) =&gt; {\n                // alert(res.data.count);\n                if (res.data.count !== 0) {\n                    // 拿到res传递过来的json数据res.mobile就是json数据中的data.mobile\n                    message.showError(res.data.mobile + '已经注册，请重新输入！')\n\n                } else {\n                    message.showInfo(res.data.mobile + '可以使用');\n                    isMobileReady = true\n                }\n            })\n            .fail(() =&gt; {\n                message.showError('服务器超时')\n            });\n\n\n        // 方法二\n        //  $.ajax({\n        //     url: '/verification/mobile/'+ sMobile + '/',\n        //     type: 'GET',\n        //     dataType: 'json',\n        //     success: function (data) {\n        //         // alert(data.count);\n        //         if(data.count !== 0){\n        //             message.showError(data.mobile + '已经注册，请重新输入！')\n        //         }else {\n        //             message.showInfo(data.mobile + '可以正常使用！');\n        //             isMobileReady = true\n        //         }\n        //     },\n        //     error: function (xhr, msg) {\n        //         message.showError('服务器超时，请重试！')\n        //     }\n        // });\n\n    }"
  },
  {
    "objectID": "posts/Django项目/index.html#获取短信验证码功能",
    "href": "posts/Django项目/index.html#获取短信验证码功能",
    "title": "Django项目",
    "section": "4.8 获取短信验证码功能",
    "text": "4.8 获取短信验证码功能\n\n4.8.1 业务流程分析\n\n检查图片验证码是否正确\n检查是否在60s内发送记录\n生成短信验证码\n发送短信\n保存短信验证码与发送记录\n\n\n\n4.8.2 接口设计\n接口说明：\n\n\n\n类目\n说明\n\n\n\n\n请求方法\nPOST\n\n\nurl定义\nverification/sms_code/\n\n\n参数格式\n表单\n\n\n\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n描述\n\n\n\n\nmoblie\n字符串\n是\n用户输入的手机号码\n\n\ncaptcha\n字符串\n是\n用户输入的验证码文本\n\n\n\n返回结果：\n {\n        'errno': '0',\n        'errmsg': '短信发送成功',\n        \n    }\n\n\n4.8.3 后端代码\n\n①verification/views.py代码如下：\nimport logging\nimport random\n\nfrom django.shortcuts import render\nfrom django.http import JsonResponse, HttpResponse\nfrom django.views import View\nfrom django_redis import get_redis_connection\n\nfrom utils.captcha.captcha import captcha\nfrom . import constants\nfrom user.models import User\nfrom utils.res_code import json_response, Code, error_map\nfrom .forms import CheckImageForm\n\n\n# 创建日志器\nlogger = logging.getLogger('django')\n\n# 检验手机验证码\nclass SmsCodeView(View):\n    \"\"\"\n    url: /sms_code/\n    \"\"\"\n\n    # 校验手机号码\n    def post(self, request):\n        \"\"\"\n        生成短信验证码\n        发送短信验证码\n        保存在什么地方\n        :param request:\n        :return:\n        \"\"\"\n        # 拿到checkImageForm里面的数据对象实例化给form\n        form = CheckImageForm(request.POST, request=request)\n\n        # 成功\n        if form.is_valid():\n            # 类似字典取值拿到mobile\n            mobile = form.cleaned_data.get('mobile')\n            # 随机生成4位数验证码，列表推导式\n            sms_code = ''.join([random.choice('0123456789') for i in range(constants.SMS_CODE_LENGTH)])\n            # 将生成的短信随机码打印出来\n            logger.info('发送短信验证码【成功】：{} 【验证码】:{}'.format(mobile, sms_code))\n            # print(sms_code)\n            # 短信验证码缓存到Redis中，用Redis，设置时限\n            # 创建短信验证码的发送记录的key\n            sms_flag_key = 'sms_flag_{}'.format(mobile)\n            # 创建短信验证码的值的发送记录的key\n            sms_text_key = 'sms_text_{}'.format(mobile)\n            # 保存验证码到Redis    alias是指哪一个库，之前在settings文件中配置的Redis缓存名字\n            redis_conn = get_redis_connection(alias='verification')\n            # 创建redis管道\n            pl = redis_conn.pipeline()\n            try:\n                pl.setex(sms_flag_key, constants.SMS_CODE_INTERVAL, 1)\n                pl.setex(sms_text_key, constants.SMS_CODE_EXPIRES*60, sms_code)\n                pl.execute()\n                return json_response(errmsg='短信验证码发送成功' )\n            except Exception as e:\n                logger.error('Redis执行异常: {}'.format(e))\n                return json_response(errno=Code.UNKOWNERR, errmsg=error_map[Code.UNKOWNERR])\n\n        # 失败\n        else:\n            # 将表单的报错信息拼接 可能不止一条\n            err_msg_list = []\n            # errors 是一个字典，通过values可以拿到所有值\n            for item in form.errors.values():\n                # 将拿到的item（值）添加到list中\n\n                err_msg_list.append(item[0])\n\n            # 这里加 的'/'是为了便于区分不同的报错信息\n            err_msg_str = '/'.join(err_msg_list)\n            print(err_msg_str)\n            return json_response(errno=Code.PARAMERR, errmsg=err_msg_str)\n\n\n② verification/forms.py文件代码如下：\nfrom django import forms\nfrom django.core.validators import RegexValidator\nfrom django_redis import get_redis_connection\n\nfrom user.models import User\n\n# 创建手机号码校验器\nmobile_validator = RegexValidator(r'^1[3-9]\\d{9}$', '手机号码格式不正确')\n\n\nclass CheckImageForm(forms.Form):\n    def __init__(self, *args, **kwargs):\n        self.request = kwargs.pop('request')\n        super().__init__(*args, **kwargs)\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    mobile = forms.CharField(max_length=11, min_length=11, validators=[mobile_validator, ], error_messages={\n        'min_length': '输入的手机号码长度有误',\n        'max_length': '输入的手机号码长度有误',\n        'required': '输入的手机号码不得为空',\n    })\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    captcha = forms.CharField(max_length=4, min_length=4, error_messages={\n        'min_length': '输入的图片验证码长度有误',\n        'max_length': '输入的图片验证码长度有误',\n        'required': '图片验证码不得为空',\n    })\n\n    def clean(self):\n        clean_data = super().clean()\n        mobile = clean_data.get('mobile')\n        captcha = clean_data.get('captcha')\n        # 如果校验失败就会返回 none的结果\n        # 如果前面的校验失败了的话就没有必要往下执行\n        if mobile and captcha:\n            # 拿到保存在session中的图形验证码的value\n            image_code = self.request.session.get('image_code')\n            # session中的图形验证码和request中发送过来的captcha不一样，返回'验证码错误'\n            if image_code.upper() != captcha.upper():\n                raise forms.ValidationError('图形验证码错误！')\n            # 如果超过设定时间，图形验证码失效\n            if not captcha:\n                raise forms.ValidationError('图形验证码失效')\n            # 判断短信验证码是否过期\n            redis_conn = get_redis_connection(alias='verification')\n            if redis_conn.get('sms_flag_{}'.format(mobile)):\n                raise forms.ValidationError('获取短信验证码过于频繁')\n            # 校验手机号码是否过期\n            if User.objects.filter(mobile=mobile).count():\n                raise forms.ValidationError('该手机号码已注册')\n            return clean_data\n\n\n4.8.verification/constants.py代码如下：\nfrom django import forms\nfrom django.core.validators import RegexValidator\nfrom django_redis import get_redis_connection\n\nfrom user.models import User\n\n# 创建手机号码校验器\nmobile_validator = RegexValidator(r'^1[3-9]\\d{9}$', '手机号码格式不正确')\n\n\nclass CheckImageForm(forms.Form):\n    def __init__(self, *args, **kwargs):\n        self.request = kwargs.pop('request')\n        super().__init__(*args, **kwargs)\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    mobile = forms.CharField(max_length=11, min_length=11, validators=[mobile_validator, ], error_messages={\n        'min_length': '输入的手机号码长度有误',\n        'max_length': '输入的手机号码长度有误',\n        'required': '输入的手机号码不得为空',\n    })\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    captcha = forms.CharField(max_length=4, min_length=4, error_messages={\n        'min_length': '输入的图片验证码长度有误',\n        'max_length': '输入的图片验证码长度有误',\n        'required': '图片验证码不得为空',\n    })\n\n    def clean(self):\n        clean_data = super().clean()\n        mobile = clean_data.get('mobile')\n        captcha = clean_data.get('captcha')\n        # 如果校验失败就会返回 none的结果\n        # 如果前面的校验失败了的话就没有必要往下执行\n        if mobile and captcha:\n            # 拿到保存在session中的图形验证码的value\n            image_code = self.request.session.get('image_code')\n            # session中的图形验证码和request中发送过来的captcha不一样，返回'验证码错误'\n            if image_code.upper() != captcha.upper():\n                raise forms.ValidationError('图形验证码错误！')\n            # 如果超过设定时间，图形验证码失效\n            if not captcha:\n                raise forms.ValidationError('图形验证码失效')\n            # 判断短信验证码是否过期\n            redis_conn = get_redis_connection(alias='verification')\n            if redis_conn.get('sms_flag_{}'.format(mobile)):\n                raise forms.ValidationError('获取短信验证码过于频繁')\n            # 校验手机号码是否过期\n            if User.objects.filter(mobile=mobile).count():\n                raise forms.ValidationError('该手机号码已注册')\n            return clean_data\n\n\n    mobile = clean_data.get('mobile')\n    captcha = clean_data.get('captcha')\n    # 如果校验失败就会返回 none的结果\n    # 如果前面的校验失败了的话就没有必要往下执行\n    if mobile and captcha:\n        # 拿到保存在session中的图形验证码的value\n        image_code = self.request.session.get('image_code')\n        # session中的图形验证码和request中发送过来的captcha不一样，返回'验证码错误'\n        if image_code.upper() != captcha.upper():\n            raise forms.ValidationError('图形验证码错误！')\n        # 如果超过设定时间，图形验证码失效\n        if not captcha:\n            raise forms.ValidationError('图形验证码失效')\n        # 判断短信验证码是否过期\n        redis_conn = get_redis_connection(alias='verification')\n        if redis_conn.get('sms_flag_{}'.format(mobile)):\n            raise forms.ValidationError('获取短信验证码过于频繁')\n        # 校验手机号码是否过期\n        if User.objects.filter(mobile=mobile).count():\n            raise forms.ValidationError('该手机号码已注册')\n        return clean_data\n\n4.8.verification/constants.py代码如下： \n\n```python\nfrom django import forms\nfrom django.core.validators import RegexValidator\nfrom django_redis import get_redis_connection\n\nfrom user.models import User\n\n# 创建手机号码校验器\nmobile_validator = RegexValidator(r'^1[3-9]\\d{9}$', '手机号码格式不正确')\n\n\nclass CheckImageForm(forms.Form):\n    def __init__(self, *args, **kwargs):\n        self.request = kwargs.pop('request')\n        super().__init__(*args, **kwargs)\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    mobile = forms.CharField(max_length=11, min_length=11, validators=[mobile_validator, ], error_messages={\n        'min_length': '输入的手机号码长度有误',\n        'max_length': '输入的手机号码长度有误',\n        'required': '输入的手机号码不得为空',\n    })\n\n    # 这里的名字要和register.js中的json中传递回来的name一致\n    captcha = forms.CharField(max_length=4, min_length=4, error_messages={\n        'min_length': '输入的图片验证码长度有误',\n        'max_length': '输入的图片验证码长度有误',\n        'required': '图片验证码不得为空',\n    })\n\n    def clean(self):\n        clean_data = super().clean()\n        mobile = clean_data.get('mobile')\n        captcha = clean_data.get('captcha')\n        # 如果校验失败就会返回 none的结果\n        # 如果前面的校验失败了的话就没有必要往下执行\n        if mobile and captcha:\n            # 拿到保存在session中的图形验证码的value\n            image_code = self.request.session.get('image_code')\n            # session中的图形验证码和request中发送过来的captcha不一样，返回'验证码错误'\n            if image_code.upper() != captcha.upper():\n                raise forms.ValidationError('图形验证码错误！')\n            # 如果超过设定时间，图形验证码失效\n            if not captcha:\n                raise forms.ValidationError('图形验证码失效')\n            # 判断短信验证码是否过期\n            redis_conn = get_redis_connection(alias='verification')\n            if redis_conn.get('sms_flag_{}'.format(mobile)):\n                raise forms.ValidationError('获取短信验证码过于频繁')\n            # 校验手机号码是否过期\n            if User.objects.filter(mobile=mobile).count():\n                raise forms.ValidationError('该手机号码已注册')\n            return clean_data"
  },
  {
    "objectID": "posts/nodejs安装--（npm安装）/index.html",
    "href": "posts/nodejs安装--（npm安装）/index.html",
    "title": "nodejs安装–（npm安装）",
    "section": "",
    "text": "nodejs下载地址https://nodejs.org/zh-cn/ ### 2、双击安装 一路next ### 3、查看是否安装成功 \n进入到安装目录：node -v  ### 4、建两个文件夹 再看看另外2个目录，npm的本地仓库跑在系统盘c盘的用户目录了(没见到npm-cache是因为没有用过， 一使用缓存目录就生成了)，我们试图把这2个目录移动回到D:  ### 5、然后运行以下2条命令\nnpm config set prefix \"D:\\nodejs\\node_global\"\nnpm config set cache \"D:\\nodejs\\node_cache\"\n ### 6、配置一个镜像站，为了提升速度\nnpm config set registry=http://registry.npm.taobao.org\n ### 7、输入命令npm config list 显示所有配置信息\n\n\n\n在这里插入图片描述\n\n\n\n注意，此时，默认的模块D:_modules 目录 将会改变为D:_global_modules 目录， 如果直接运行npm install等命令会报错的。 我们需要做1件事情： 增加环境变量NODE_PATH 内容是：D:\\nodejs\\node_global\\node_modules\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java--gui_简单计算器/index.html",
    "href": "posts/java--gui_简单计算器/index.html",
    "title": "java–gui_简单计算器",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.lesson02;\n\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class Calculator {\n\n    public static void main(String[] args) {\n        // 开始\n        new MyFrame01();\n    }\n}\n\nclass MyFrame01 extends Frame{\n    public MyFrame01(){\n        setLocation(400,400);\n        setVisible(true);\n        // 设置布局\n        setLayout(new FlowLayout());\n        // 设置文本框\n        TextField first = new TextField(10);    // 设置框的大小\n        TextField second = new TextField(10);\n        TextField result = new TextField(10);\n        // 按钮\n        Button button = new Button(\"=\");\n        button.addActionListener(new CalculatorActionListener(first,second,result));\n        // 添加进frame\n        add(first);\n        add(second);\n        add(button);\n        add(result);\n\n        pack();\n\n        // 点击关闭\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n\n    }\n}\n\n\n// 监听器\nclass  CalculatorActionListener implements ActionListener {\n    private TextField first,second,result;\n    public CalculatorActionListener(TextField first,TextField second,TextField result) {\n        this.first = first;\n        this.second = second;\n        this.result =result;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        // 获取字符值\n        int num1 = Integer.parseInt(first.getText());\n        int num2 = Integer.parseInt(second.getText());\n        // 进行运算\n        result.setText(\"\"+(num1+num2));\n        // 返回结果\n        first.setText(\"\");\n        second.setText(\"\");\n\n\n    }\n}"
  },
  {
    "objectID": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "href": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "title": "stm32H743+CubeMX+RtThread工程创建",
    "section": "",
    "text": "CubeMX\n\n时钟修改\n把时钟修改为非sysTicks \n\n\n外部高速时钟\n使能外部高速晶振\n 配置时钟树\n\n\n\n\n在这里插入图片描述\n\n\n\nDebug\n\n\n\n\n在这里插入图片描述\n\n\n\nUsart\n设置引脚, 使能usart\n\n\n\n\n在这里插入图片描述\n\n\n &gt;## RT-Thread &gt;添加rtt参考链接 &gt; \n &gt; 打开动态内存堆.否则无法使用rt_thread_create动态创建线程. &gt;  &gt; ## 生成项目  &gt; 生成keil项目 &gt; \n\n\n工程创建完成后修改\n\n工程创建完成后直接编译会有error无法通过编译\n 添加board.h 删除 rtconfig.h\n  board.h\n\n#ifndef __BOARD_H\n#define __BOARD_H\n\n#include \"main.h\" // 这里可以添加平台文件(stm32h743xx.h)替换\n\n\n\n#endif // !__BOARD_H\n\n修改rtconfig.h添加fish组件\n\n   &gt; ### 修改串口输出 &gt; H7的发送和接收是分开的\n\nboard.c\n  # 重复定义错误  ### 修改堆内存  ### main.c  ## 测试结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java冒泡排序/index.html",
    "href": "posts/java冒泡排序/index.html",
    "title": "java冒泡排序",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.arrayList;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: // 冒泡排序\n * @date ：2021/11/2 12:54\n */\npublic class SortMaoPao {\n    public static void main(String[] args) {\n        Book book1 = new Book(\"三国\", 15.5f, \"施耐庵\");\n        Book book2 = new Book(\"水浒\",55.8f,\"罗贯中\");\n        Book book3 = new Book(\"西游\",19.6f,\"吴承恩\");\n        Book book4 = new Book(\"红楼\",78.1f,\"曹雪芹\");\n\n        ArrayList aList = new ArrayList();\n        aList.add(book1);\n        aList.add(book2);\n        aList.add(book3);\n        aList.add(book4);\n\n        aList.forEach(obj -&gt; System.out.println(obj));\n\n        System.out.println(\"=============排序后==============\");\n        sort(aList);\n        aList.forEach(obj -&gt; System.out.println(obj));\n\n    }\n\n    // 冒泡排序\n    public static void sort(ArrayList arrayList){\n        int size = arrayList.size();\n        for (int i=0; i&lt;size-1;i++){ // 比较的次数\n            for (int j=0;j&lt;size-i-1;j++){ // 比较的元素\n                Book book1 =(Book) arrayList.get(j);\n                Book book2 =(Book) arrayList.get(j+1);\n                if (book1.getPrice()&gt;book2.getPrice()){\n                    arrayList.set(j,book2);\n                    arrayList.set(j+1,book1);\n                }\n            }\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    private float price;\n    private String auth;\n\n    @Override\n    public String toString() {\n        return  \"名称:\" + name +\n                \"\\t 价格:\" + price +\n                \"\\t 作者:\" + auth;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n\n    public String getAuth() {\n        return auth;\n    }\n\n    public void setAuth(String auth) {\n        this.auth = auth;\n    }\n\n    public Book() {\n    }\n\n    public Book(String name, float price, String auth) {\n        this.name = name;\n        this.price = price;\n        this.auth = auth;\n    }\n}"
  },
  {
    "objectID": "posts/java冒泡排序/index.html#冒泡排序",
    "href": "posts/java冒泡排序/index.html#冒泡排序",
    "title": "java冒泡排序",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.arrayList;\n\nimport java.util.ArrayList;\n\n/**\n * @author ：fly\n * @description: // 冒泡排序\n * @date ：2021/11/2 12:54\n */\npublic class SortMaoPao {\n    public static void main(String[] args) {\n        Book book1 = new Book(\"三国\", 15.5f, \"施耐庵\");\n        Book book2 = new Book(\"水浒\",55.8f,\"罗贯中\");\n        Book book3 = new Book(\"西游\",19.6f,\"吴承恩\");\n        Book book4 = new Book(\"红楼\",78.1f,\"曹雪芹\");\n\n        ArrayList aList = new ArrayList();\n        aList.add(book1);\n        aList.add(book2);\n        aList.add(book3);\n        aList.add(book4);\n\n        aList.forEach(obj -&gt; System.out.println(obj));\n\n        System.out.println(\"=============排序后==============\");\n        sort(aList);\n        aList.forEach(obj -&gt; System.out.println(obj));\n\n    }\n\n    // 冒泡排序\n    public static void sort(ArrayList arrayList){\n        int size = arrayList.size();\n        for (int i=0; i&lt;size-1;i++){ // 比较的次数\n            for (int j=0;j&lt;size-i-1;j++){ // 比较的元素\n                Book book1 =(Book) arrayList.get(j);\n                Book book2 =(Book) arrayList.get(j+1);\n                if (book1.getPrice()&gt;book2.getPrice()){\n                    arrayList.set(j,book2);\n                    arrayList.set(j+1,book1);\n                }\n            }\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    private float price;\n    private String auth;\n\n    @Override\n    public String toString() {\n        return  \"名称:\" + name +\n                \"\\t 价格:\" + price +\n                \"\\t 作者:\" + auth;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n\n    public String getAuth() {\n        return auth;\n    }\n\n    public void setAuth(String auth) {\n        this.auth = auth;\n    }\n\n    public Book() {\n    }\n\n    public Book(String name, float price, String auth) {\n        this.name = name;\n        this.price = price;\n        this.auth = auth;\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--布局练习/index.html",
    "href": "posts/javaGUI--布局练习/index.html",
    "title": "javaGUI–布局练习",
    "section": "",
    "text": "效果: \npackage cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class Ex01 {\n\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"练习\");\n        // 大小\n        frame.setSize(900,600);\n        frame.setBackground(Color.orange);\n        // 位置\n        frame.setLocation(500,500);\n        // 可见\n        frame.setVisible(true);\n        // 2*1\n        frame.setLayout(new GridLayout(2,1));\n\n        // ------------------------------------上半部分----------------------------------\n        Panel pup =new Panel(new BorderLayout());\n        Panel pup_in =new Panel(new GridLayout(2,1));\n\n        pup.add(new Button(\"up-west\"),BorderLayout.WEST);\n        pup.add(new Button(\"up-east\"),BorderLayout.EAST);\n\n        pup_in.add(new Button(\"up-center-01\"));\n        pup_in.add(new Button(\"up-center-02\"));\n\n        pup.add(pup_in,BorderLayout.CENTER);\n\n        frame.add(pup);\n\n        // ------------------------------------下半部分----------------------------------\n        Panel pdown = new Panel();\n        pdown.setLayout(new BorderLayout());\n        pdown.add(new Button(\"down-left-01\"),BorderLayout.WEST);\n        pdown.add(new Button(\"down-left-02\"),BorderLayout.EAST);\n\n        Panel pdwon_in = new Panel();\n        pdwon_in.setLayout(new GridLayout(2,2));\n        pdwon_in.add(new Button(\"down-center-01\"));\n        pdwon_in.add(new Button(\"down-center-02\"));\n        pdwon_in.add(new Button(\"down-center-03\"));\n        pdwon_in.add(new Button(\"down-center-04\"));\n\n        pdown.add(pdwon_in);\n\n        frame.add(pdown);\n    }\n}"
  },
  {
    "objectID": "posts/pyinstaller打包程序问题总结/index.html",
    "href": "posts/pyinstaller打包程序问题总结/index.html",
    "title": "pyinstaller打包程序问题总结",
    "section": "",
    "text": "pyinstaller打包exe 程序问题总结\n1.查看报错信息: 2.文件夹: 加入 init.py 3.导包顺序 Python内置包-&gt;pip install的包-&gt;自己的包 from A.b import c =&gt; import A.b as b =&gt; b.c 4.包的版本(关键) 不行就降版本"
  },
  {
    "objectID": "posts/java--创建Tomcat服务器/index.html",
    "href": "posts/java--创建Tomcat服务器/index.html",
    "title": "java–创建Tomcat服务器",
    "section": "",
    "text": "Tomcat7.0（蓝奏云） ## 2、选择安装位置解压缩 找个合适的位置 ## 3、运行Tomcat\n①windows双击apache-tomcat-7.0.73\\bin\\startup.bat文件 ②linux就打开apache-tomcat-7.0.73\\bin\\startup.sh文件"
  },
  {
    "objectID": "posts/java--创建Tomcat服务器/index.html#去官网下载安装包",
    "href": "posts/java--创建Tomcat服务器/index.html#去官网下载安装包",
    "title": "java–创建Tomcat服务器",
    "section": "",
    "text": "Tomcat7.0（蓝奏云） ## 2、选择安装位置解压缩 找个合适的位置 ## 3、运行Tomcat\n①windows双击apache-tomcat-7.0.73\\bin\\startup.bat文件 ②linux就打开apache-tomcat-7.0.73\\bin\\startup.sh文件"
  },
  {
    "objectID": "posts/java--创建Tomcat服务器/index.html#用浏览器访问",
    "href": "posts/java--创建Tomcat服务器/index.html#用浏览器访问",
    "title": "java–创建Tomcat服务器",
    "section": "4、用浏览器访问",
    "text": "4、用浏览器访问\nhttp://localhost:8080/ 出现以下页面即成功"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html",
    "href": "posts/springmvc-json-乱码解决/index.html",
    "title": "springmvc-json-乱码解决",
    "section": "",
    "text": "@Controller\npublic class UserController {\n\n//   \n    // 多数通过配置xml文件实现乱码过滤，这种方式不推荐，写起来太冗余\n    @RequestMapping(value = \"/json1\")\n    @ResponseBody // 让返回字符串对象，不走视图解析器\n    public String json1() throws JsonProcessingException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        User1 user1 = new User1(\"tom\",12,\"男\");\n        // 将对象转换为字符串对象，如果出现500错误多数是 打包没打jackson的包\n        String st = mapper.writeValueAsString(user1);\n        // 打印转换过的json数据\n        System.out.println(st);\n        return st;\n    }\n\n}"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#java对象转json",
    "href": "posts/springmvc-json-乱码解决/index.html#java对象转json",
    "title": "springmvc-json-乱码解决",
    "section": "",
    "text": "@Controller\npublic class UserController {\n\n//   \n    // 多数通过配置xml文件实现乱码过滤，这种方式不推荐，写起来太冗余\n    @RequestMapping(value = \"/json1\")\n    @ResponseBody // 让返回字符串对象，不走视图解析器\n    public String json1() throws JsonProcessingException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        User1 user1 = new User1(\"tom\",12,\"男\");\n        // 将对象转换为字符串对象，如果出现500错误多数是 打包没打jackson的包\n        String st = mapper.writeValueAsString(user1);\n        // 打印转换过的json数据\n        System.out.println(st);\n        return st;\n    }\n\n}"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "href": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "title": "springmvc-json-乱码解决",
    "section": "2、spring解决中文乱码-方法1：",
    "text": "2、spring解决中文乱码-方法1：\n @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\")  解决乱码问题"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "href": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "title": "springmvc-json-乱码解决",
    "section": "3、mvc框架解决中文乱码-方法2：",
    "text": "3、mvc框架解决中文乱码-方法2：\n修改springmvc-servlet.xml\n&lt;!--    json 编码过滤器--&gt;\n    &lt;mvc:annotation-driven&gt;\n        &lt;mvc:message-converters register-defaults=\"true\"&gt;\n            &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt;\n                &lt;constructor-arg value=\"UTF-8\"/&gt;\n            &lt;/bean&gt;\n            &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt;\n                &lt;property name=\"objectMapper\"&gt;\n                    &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt;\n                        &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt;\n                    &lt;/bean&gt;\n                &lt;/property&gt;\n            &lt;/bean&gt;\n        &lt;/mvc:message-converters&gt;\n    &lt;/mvc:annotation-driven&gt;"
  },
  {
    "objectID": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html",
    "href": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html",
    "title": "java EE 一行代码实现定时刷新，定时跳转",
    "section": "",
    "text": "response.addHeader(\"Refresh\",\"【跳转时间】;url=/【项目名】/【跳转页面名】.html\")\n//例：定时5秒跳转到myProject中的hello.html页面\nresponse.addHeader(\"Refresh\",\"5;url=/myProject/hello.html\")"
  },
  {
    "objectID": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时跳转",
    "href": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时跳转",
    "title": "java EE 一行代码实现定时刷新，定时跳转",
    "section": "",
    "text": "response.addHeader(\"Refresh\",\"【跳转时间】;url=/【项目名】/【跳转页面名】.html\")\n//例：定时5秒跳转到myProject中的hello.html页面\nresponse.addHeader(\"Refresh\",\"5;url=/myProject/hello.html\")"
  },
  {
    "objectID": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时刷新",
    "href": "posts/java EE 一行代码实现定时刷新，定时跳转/index.html#定时刷新",
    "title": "java EE 一行代码实现定时刷新，定时跳转",
    "section": "2、定时刷新",
    "text": "2、定时刷新\nresponse.addHeader(\"Refresh\",\"【刷新时间】\")\n// 每5秒钟刷新一下页面\nresponse.addHeader(\"Refresh\",'5')"
  },
  {
    "objectID": "posts/app反爬/index.html",
    "href": "posts/app反爬/index.html",
    "title": "app反爬",
    "section": "",
    "text": "根据崔庆才的爬虫书练习 https://scrape.center/ https://www.sojson.com/simple_json.html # app1(简单app无爬措施) 对地址直接发送get请求即可可以获取json数据:\n# -*- coding: utf-8 -*-\n# @Time : 2022/4/17 13:42\n\nimport requests\n\ndef get(url):\n    res = requests.get(url)\n    return res\n\nif __name__ == '__main__':\n    # 数据一共100条\n    res = get(\"https://app1.scrape.center:443/api/movie/?offset=0&limit=100\")\n    print(res.text)\n # app2"
  },
  {
    "objectID": "posts/clion+pico+调试(另一块pico做调试)环境搭建/index.html",
    "href": "posts/clion+pico+调试(另一块pico做调试)环境搭建/index.html",
    "title": "clion+pico+调试(另一块pico做调试)环境搭建",
    "section": "",
    "text": "下载arm编译器工具链: 官方地址: https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads\n\n 安装(这里是exe安装)，不过还是推荐zip压缩包, 下载后找好位置, 然后添加环境变量即可添加bin目录到环境变量\n 然后打开clion\n   &gt;下载并打开picoexamples项目: https://github.com/raspberrypi/pico-examples &gt; 导入项目后记得编译项目,直接点锤子\n &gt; 配置openOCD\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/clion+pico+调试(另一块pico做调试)环境搭建/index.html#clion打造pico开发环境",
    "href": "posts/clion+pico+调试(另一块pico做调试)环境搭建/index.html#clion打造pico开发环境",
    "title": "clion+pico+调试(另一块pico做调试)环境搭建",
    "section": "",
    "text": "下载arm编译器工具链: 官方地址: https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads\n\n 安装(这里是exe安装)，不过还是推荐zip压缩包, 下载后找好位置, 然后添加环境变量即可添加bin目录到环境变量\n 然后打开clion\n   &gt;下载并打开picoexamples项目: https://github.com/raspberrypi/pico-examples &gt; 导入项目后记得编译项目,直接点锤子\n &gt; 配置openOCD\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html",
    "title": "mmwave level sensing demo notes",
    "section": "",
    "text": "TI has developed the IWR1843 mmWave radar sensor for industrial and automotive applications, including level sensing. A guide with notes on how to design and implement level sensing systems using the IWR1843 is available, covering topics such as signal processing, antenna design, and calibration techniques. This guide helps users understand and optimize the IWR1843’s level sensing capabilities."
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#mailbox发送数据的操作流程",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#mailbox发送数据的操作流程",
    "title": "mmwave level sensing demo notes",
    "section": "1.2 MailBox发送数据的操作流程",
    "text": "1.2 MailBox发送数据的操作流程\nsrc: mss_main.c\n/*z:这个是mailbox的函数, dsp和mss进行通信的工具 */\nstatic void MmwDemo_mboxReadTask(UArg arg0, UArg arg1)\n{\n    MmwDemo_message      message;\n    int32_t              retVal = 0;\n    uint32_t             timeStart;\n\n    /* wait for new message and process all the messages received from the peer */\n    while(1)\n    {\n        /* 一直等待mailbox发送发过来数据, 如果没有数据就一直挂起. */\n        Semaphore_pend(gMmwMssMCB.mboxSemHandle, BIOS_WAIT_FOREVER);\n\n        /* Read the message from the peer mailbox: We are not trying to protect the read\n         * from the peer mailbox because this is only being invoked from a single thread */\n       \n        /* 这段代码是从一个消息邮箱 (Mailbox) 中读取消息，并将消息内容保存到一个名为 message \n         * 的变量中。在这段代码中，使用了 Mailbox_read() 函数来从名为 gMmwMssMCB 的全局变量所\n         * 表示的邮箱中读取消息。该函数的第一个参数是待读取的邮箱，第二个参数是存储消息的缓冲区\n         * 的指针，第三个参数是要读取的消息的长度。该函数将返回一个表示操作结果的值。在这段代码中，\n         * 变量 retVal 将被用于存储该函数的返回值。\n\n         * 需要注意的是，在这段代码中，并没有进行任何多线程保护措施，因为该代码被假定只会从一个\n         * 单一的线程中被调用。如果有多个线程可能会同时访问同一个邮箱，那么就需要在访问邮箱的过程\n         * 中采取适当的同步措施来确保线程安全性 */\n        retVal = Mailbox_read(gMmwMssMCB.peerMailbox, (uint8_t*)&message, sizeof(MmwDemo_message));\n        if (retVal &lt; 0)\n        {\n            /* Error: Unable to read the message. Setup the error code and return values */\n            System_printf (\"Error: Mailbox read failed [Error code %d]\\n\", retVal);\n        }\n        else if (retVal == 0)\n        {\n            /* We are done: There are no messages available from the peer execution domain. */\n            continue;\n        }\n        else\n        {\n            /* Flush out the contents of the mailbox to indicate that we are done with the message. This will\n             * allow us to receive another message in the mailbox while we process the received message. */\n            \n            /* 刷新邮箱准备后续接收 */\n            Mailbox_readFlush (gMmwMssMCB.peerMailbox);\n\n            /* Process the received message: */\n            /* 查看消息类型 */ \n            switch (message.type)\n            {\n                /* 如果类型是 \"MMWDEMO_DSS2MSS_DETOBJ_READY\" */\n                case MMWDEMO_DSS2MSS_DETOBJ_READY:\n                    /* Got detetced objectes , shipped out through UART */\n\n                    /* 把接收到的数据中的大小信息提取出来,提取到下面这个变量中 */\n                    gMmwMssMCB.mssDataPathObj.inputInfoBuffSize = message.body.detObj.detObjOutsize;\n\n                    /* 到共享内存中地址将检测的dsp处理好的数据拷贝到\"gMmwMssMCB.mssDataPathObj.inputInfo\"中*/\n                    memcpy((void *)&(gMmwMssMCB.mssDataPathObj.inputInfo),\n                            (uint8_t*)SOC_translateAddress(message.body.detObj.detObjOutAddress, SOC_TranslateAddr_Dir_FROM_OTHER_CPU,NULL),\n                            message.body.detObj.detObjOutsize);\n                    \n                    /* 记录时间戳 */\n                    timeStart = Cycleprofiler_getTimeStamp();\n                    /* 当前时间花费在将处理结果从 DSP 中的共享内存复制到主机内存中的时间, 这里有点疑问, 为什么直接设置1和2 */\n                    gMmwMssMCB.mssDataPathObj.cycleLog.copyResultsTimeCurrInusec = 1.f;\n                    /* uart发送数据 */\n                    MmwDemo_transmitProcessedOutput();\n                    gMmwMssMCB.mssDataPathObj.cycleLog.copyResultsTimeCurrInusec = 2.f;\n                    /* 计算发送时间 */\n                    gMmwMssMCB.mssDataPathObj.cycleLog.sendingToUARTTimeCurrInusec = ((float)(Cycleprofiler_getTimeStamp() -  timeStart)/(float)R4F_CLOCK_MHZ);\n\n\n                    /* Send a message to MSS to log the output data */\n                    /* 清空message中的数据为后续重新接收做准备 */\n                    memset((void *)&message, 0, sizeof(MmwDemo_message));\n\n                    /* 将消息设置为\"MMWDEMO_MSS2DSS_DETOBJ_SHIPPED\"为别的操作做准备 */\n                    message.type = MMWDEMO_MSS2DSS_DETOBJ_SHIPPED;\n\n                    if (MmwDemo_mboxWrite(&message) != 0)\n                    {\n                        System_printf (\"Error: Mailbox send message id=%d failed \\n\", message.type);\n                    }\n                    break;\n                default:\n                {\n                    /* Message not support */\n                    System_printf (\"Error: unsupport Mailbox message id=%d\\n\", message.type);\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#uart发送数据",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#uart发送数据",
    "title": "mmwave level sensing demo notes",
    "section": "1.2 UART发送数据",
    "text": "1.2 UART发送数据\n这里就是接收到数据后,将数据赋值给mss的变量然后调整通信格式(按照TLV的格式发送). TLV格式ti的文档中有说明. TLV format guide\n\n\n/** @brief Transmits detection data over UART\n*\n*    The following data is transmitted:\n*    1. Header (size = 32bytes), including \"Magic word\", (size = 8 bytes)\n*       and icluding the number of TLV items\n*    TLV Items:\n*    2. If detectedObjects flag is set, pbjOut structure containing range,\n*       doppler, and X,Y,Z location for detected objects,\n*       size = sizeof(objOut_t) * number of detected objects\n*    3. If logMagRange flag is set,  rangeProfile,\n*       size = number of range bins * sizeof(uint16_t)\n*    4. If noiseProfile flag is set,  noiseProfile,\n*       size = number of range bins * sizeof(uint16_t)\n*    7. If rangeAzimuthHeatMap flag is set, the zero Doppler column of the\n*       range cubed matrix, size = number of Rx Azimuth virtual antennas *\n*       number of chirps per frame * sizeof(uint32_t)\n*    8. If rangeDopplerHeatMap flag is set, the log magnitude range-Doppler matrix,\n*       size = number of range bins * number of Doppler bins * sizeof(uint16_t)\n*    9. If statsInfo flag is set, the stats information\n*   @param[in] uartHandle   UART driver handle\n*   @param[in] obj          Pointer data path object MmwDemo_DataPathObj\n*/\n\nvoid MmwDemo_transmitProcessedOutput()\n{\n    /* 创建header变量存储数据头(FrameHeader) */\n    MmwDemo_output_message_header header;\n    /* TLV的索引 */\n    uint32_t tlvIdx = 0;\n\n    uint32_t numPaddingBytes;\n    /* 数据包的长度信息 */\n    uint32_t packetLen;\n    /* 数据对齐填充的padding */\n    uint8_t padding[MMWDEMO_OUTPUT_MSG_SEGMENT_LEN];\n    /* 用来存放从mailBox接收到的数据头得信息 */\n    MmwDemo_detOutputHdr           *ptrDetOutputHdr;\n    /* 用来存放从mailBox接收到的数据值部分 */\n    radarProcessOutput_t * outputData;\n    /* 设置T(ype)L(ength) */\n    MmwDemo_output_message_tl   tl[MMWDEMO_OUTPUT_MSG_MAX];\n    /* 用来存放fft数据的长度 */\n    uint32_t fft1D_length;\n    /* 存数据对象从结构体中提取出来 */\n    MmwDemo_MSS_DataPathObj     *obj = &gMmwMssMCB.mssDataPathObj;\n    /* 该变量决定什么变量发送给gui */\n    MmwDemo_GuiMonSel   guiMonSel = gMmwMssMCB.cfg.guiMonSel;\n    /* 拿到mss的uart句柄 */\n    UART_Handle uartHandle = gMmwMssMCB.loggingUartHandle;\n\n    /* 将数据放fft处理的header(chirp处理时间, 目标数据, frame处理时间, chirp处理时的负载,frame处理时的负载 ) */\n    ptrDetOutputHdr = (MmwDemo_detOutputHdr *)&obj-&gt;inputInfo.header;\n    /* 存放处理fft后存储的相位变化量, 最大的range,fft输出等信息 */\n    outputData      = (radarProcessOutput_t *)&obj-&gt;inputInfo.pointCloudBuf;\n    /* 提取出1Dfft的长度信息 */\n    fft1D_length    =   outputData-&gt;fft1DSize;\n\n    /* Clear message header */\n    /* 清空数据头, 重新构造数据头, 每一帧的数据都重新构造, 防止出现脏数据 */\n    memset((void *)&header, 0, sizeof(MmwDemo_output_message_header));\n    /* Header: */\n    header.platform = 0xA1642;\n    header.magicWord[0] = 0x0102;\n    header.magicWord[1] = 0x0304;\n    header.magicWord[2] = 0x0506;\n    header.magicWord[3] = 0x0708;\n    header.numDetectedObj = 1;\n    header.version =    MMWAVE_SDK_VERSION_BUILD |   //DEBUG_VERSION\n                        (MMWAVE_SDK_VERSION_BUGFIX &lt;&lt; 8) |\n                        (MMWAVE_SDK_VERSION_MINOR &lt;&lt; 16) |\n                        (MMWAVE_SDK_VERSION_MAJOR &lt;&lt; 24);\n\n    packetLen = sizeof(MmwDemo_output_message_header);\n    //detectedObjects\n    {\n        tl[tlvIdx].type = MMWDEMO_OUTPUT_MSG_DETECTED_POINTS;\n        tl[tlvIdx].length = sizeof(MmwDemo_detectedObj) * 1 +\n                            sizeof(MmwDemo_output_message_dataObjDescr);\n        packetLen += sizeof(MmwDemo_output_message_tl) + tl[tlvIdx].length;\n        tlvIdx++;\n    }\n    //Range FFT input\n    if(guiMonSel.logRangeInput)\n    {\n        tl[tlvIdx].type = MMWDEMO_OUTPUT_MSG_RANGE_PROFILE;\n        tl[tlvIdx].length = 2 * sizeof(float) * fft1D_length;\n        packetLen += sizeof(MmwDemo_output_message_tl) + tl[tlvIdx].length;\n        tlvIdx++;\n    }\n    //statsInfo\n    {\n        tl[tlvIdx].type = MMWDEMO_OUTPUT_MSG_STATS;\n        tl[tlvIdx].length = sizeof(MmwDemo_output_message_stats);\n        packetLen += sizeof(MmwDemo_output_message_tl) + tl[tlvIdx].length;\n        tlvIdx++;\n    }\n\n    header.numTLVs = tlvIdx;\n    /* Round up packet length to multiple of MMWDEMO_OUTPUT_MSG_SEGMENT_LEN */\n    header.totalPacketLen = MMWDEMO_OUTPUT_MSG_SEGMENT_LEN *\n            ((packetLen + (MMWDEMO_OUTPUT_MSG_SEGMENT_LEN-1))/MMWDEMO_OUTPUT_MSG_SEGMENT_LEN);\n    header.timeCpuCycles =  Pmu_getCount(0);\n    header.frameNumber = 0;\n\n\n    UART_writePolling (uartHandle,\n                       (uint8_t*)&header,\n                       sizeof(MmwDemo_output_message_header));\n\n    tlvIdx = 0;\n    /* Send detected Objects */\n    {\n        MmwDemo_output_message_dataObjDescr descr;\n        MmwDemo_detectedObj dummyDetectionOut; //work around the current format\n        int32_t tempRange;\n\n        memset((void *)&dummyDetectionOut, 0, sizeof(MmwDemo_detectedObj));\n\n        tempRange                       =   (int32_t)(outputData-&gt;rangeEst * 1048576.f);\n\n        dummyDetectionOut.dopplerIdx    =   0;\n        dummyDetectionOut.peakVal       =   0;\n        dummyDetectionOut.rangeIdx      =   (uint16_t) tempRange & 0xFFFF;\n        dummyDetectionOut.x             =   tempRange &gt;&gt; 16;\n        dummyDetectionOut.y             =   0;\n        dummyDetectionOut.z             =   0;\n\n        UART_writePolling (uartHandle,\n                           (uint8_t*)&tl[tlvIdx],\n                           sizeof(MmwDemo_output_message_tl));\n        /* Send objects descriptor */\n        descr.numDetetedObj = 1;\n        descr.xyzQFormat = 20;\n        UART_writePolling (uartHandle, (uint8_t*)&descr, sizeof(MmwDemo_output_message_dataObjDescr));\n\n        /*Send array of objects */\n        UART_writePolling (uartHandle, (uint8_t*)&dummyDetectionOut, sizeof(MmwDemo_detectedObj) * 1);\n        tlvIdx++;\n    }\n\n    /* Send Range FFT input */\n    if(guiMonSel.logRangeInput)\n    {\n        UART_writePolling (uartHandle,\n                           (uint8_t*)&tl[tlvIdx],\n                           sizeof(MmwDemo_output_message_tl));\n\n        UART_writePolling (uartHandle, (uint8_t*)outputData-&gt;fft1Dinput, 2 * fft1D_length * sizeof(float));\n        tlvIdx++;\n    }\n\n    /* Send stats information */\n    {\n        MmwDemo_output_message_stats stats;\n        stats.interChirpProcessingMargin = (uint32_t) ptrDetOutputHdr-&gt;chirpProcessingMarginInUsec;\n        stats.interFrameProcessingMargin = (uint32_t) ptrDetOutputHdr-&gt;frameProcessingMarginInUsec;\n        stats.interFrameProcessingTime = 0;\n        stats.transmitOutputTime = (uint32_t) obj-&gt;cycleLog.sendingToUARTTimeCurrInusec;\n        stats.activeFrameCPULoad = (uint32_t) ptrDetOutputHdr-&gt;chirpProcessingLoading;\n        stats.interFrameCPULoad = (uint32_t) ptrDetOutputHdr-&gt;frameProcessingLoading;\n\n        UART_writePolling (uartHandle,\n                           (uint8_t*)&tl[tlvIdx],\n                           sizeof(MmwDemo_output_message_tl));\n        UART_writePolling (uartHandle,\n                           (uint8_t*)&stats,\n                           tl[tlvIdx].length);\n        tlvIdx++;\n    }\n\n    /* Send padding bytes */\n    numPaddingBytes = MMWDEMO_OUTPUT_MSG_SEGMENT_LEN - (packetLen & (MMWDEMO_OUTPUT_MSG_SEGMENT_LEN-1));\n    if (numPaddingBytes&lt;MMWDEMO_OUTPUT_MSG_SEGMENT_LEN)\n    {\n        UART_writePolling (uartHandle,\n                            (uint8_t*)padding,\n                            numPaddingBytes);\n    }\n\n\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#创建和初始化-液位高度demo",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#创建和初始化-液位高度demo",
    "title": "mmwave level sensing demo notes",
    "section": "2.1 创建和初始化 液位高度Demo",
    "text": "2.1 创建和初始化 液位高度Demo\n调制斜率为handle-&gt;chirpSlope、1D FFT尺寸为handle-&gt;fft1DSize时的距离分辨率。距离分辨率是雷达测距系统中的一个参数，表示能够分辨出两个物体之间的最小距离。\n距离分辨率公式\n\n其中，\\(\\Delta r\\)为距离分辨率，\\(c\\)为光速，\\(B\\)为调制带宽，\\(N\\)为FFT点数。在代码中，将光速\\(c\\)和调制带宽\\(B\\)用常数3.0e8和handle-&gt;adcSampleRate表示，FFT点数\\(N\\)用handle-&gt;fft1DSize表示。将这些参数代入距离分辨率公式计算即可.\nsrc: RADARDEMO_highAccuRangeProc.c\nvoid    * RADARDEMO_highAccuRangeProc_create(\n                            IN  RADARDEMO_highAccuRangeProc_config * moduleConfig, \n                            OUT RADARDEMO_highAccuRangeProc_errorCode * errorCode)\n                            \n{\n    int32_t     i, itemp;\n    double      real, imag;\n    double PI = 3.14159265358979323846;\n    double      denom;\n    uint8_t enableRangeLimit;\n    float skipMin;\n    float skipMax;\n    float rangeResolution;\n\n    RADARDEMO_highAccuRangeProc_handle * handle;\n    \n    *errorCode      =   RADARDEMO_HIGHACCURANGEPROC_NO_ERROR;\n\n    handle                      =   (RADARDEMO_highAccuRangeProc_handle *) radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, sizeof(RADARDEMO_highAccuRangeProc_handle), 1);\n    if (handle == NULL)\n    {\n        *errorCode  =   RADARDEMO_HIGHACCURANGEPROC_FAIL_ALLOCATE_HANDLE;\n        return (handle);\n    }\n    \n    handle-&gt;nSamplesPerChirp    =   moduleConfig-&gt;nSamplesPerChirp;//512\n    handle-&gt;fft1DSize           =   moduleConfig-&gt;fft1DSize;//512\n    handle-&gt;numChirpsPerFrame   =   moduleConfig-&gt;numChirpsPerFrame;//200\n    handle-&gt;win1DLength         =   moduleConfig-&gt;win1DLength;//16\n    handle-&gt;maxBeatFreq         =   moduleConfig-&gt;maxBeatFreq;//5000k\n    handle-&gt;chirpBandwidth      =   moduleConfig-&gt;chirpBandwidth;//3450805504Hz\n    handle-&gt;chirpRampTime       =   moduleConfig-&gt;chirpRampTime;//102.4us\n    handle-&gt;fc                  =   moduleConfig-&gt;fc;//77GHz\n    handle-&gt;chirpSlope          =   moduleConfig-&gt;chirpSlope;//33.699MHz/us\n    handle-&gt;adcStartTimeConst   =   moduleConfig-&gt;adcStartTimeConst;//0\n    handle-&gt;adcSampleRate       =   moduleConfig-&gt;adcSampleRate;//500K\n    handle-&gt;numRangeBinZoomIn   =   moduleConfig-&gt;numRangeBinZoomIn;//2\n    handle-&gt;enablePhaseEst      =   moduleConfig-&gt;enablePhaseEst;//0\n    handle-&gt;enableLinearFit     =   moduleConfig-&gt;enableLinearFit;//0\n    handle-&gt;enableFilter        =   moduleConfig-&gt;enableFilter;//0\n    handle-&gt;skipLeft            =   moduleConfig-&gt;skipLeft;//0\n    handle-&gt;skipRight           =   moduleConfig-&gt;skipRight;//0\n    enableRangeLimit            =   moduleConfig-&gt;enableRangeLimit;//0\n    skipMin                     =   moduleConfig-&gt;skipMin;//0.26\n    skipMax                     =   moduleConfig-&gt;skipMax;//6.00\n    itemp                       =   handle-&gt;fft1DSize;\n    i                           =   0;\n\n    /* 计算距离分辨率 */\n    rangeResolution = (3.0*1e8) * (float)handle-&gt;adcSampleRate/(2 * (float)handle-&gt;chirpSlope * (float)handle-&gt;fft1DSize);//0.043468\n\n//    printf(\"DSS:win1DLength=%d\\n\",handle-&gt;fft1DSize);\n//    printf(\"DSS:digOutSampleRate=%f\\n\",handle-&gt;adcSampleRate);\n//    printf(\"DSS:freqSlopeConst=%f\\n\",handle-&gt;chirpSlope);\n//    printf(\"DSS:rangeResolution=%f\\n\",rangeResolution);\n\n    uint16_t RangeBinfft1DSize,RangeBinMin,RangeBinMax;\n\n    /* 如果设置距离限制值 */\n    if(enableRangeLimit)\n    {\n        /* fft大小:512, 这里根据限制的距离范围进一步限制处理数据, 提高数据处理的效率 */\n        RangeBinfft1DSize           =   handle-&gt;fft1DSize;\n        /* 对计算出的rangebin进行四舍五入 */\n        RangeBinMin                 = (uint16_t)(skipMin/rangeResolution + 0.5);\n        RangeBinMax                 = (uint16_t)(skipMax/rangeResolution + 0.5);\n\n        /* 如果rangebin下溢就设置为0 */\n        if(RangeBinMin &gt; RangeBinfft1DSize)\n            RangeBinMin = 0;\n        /* 如果rangebin上溢就设置为rangebin最大值 */\n        if(RangeBinMax &gt; RangeBinfft1DSize)\n            RangeBinMax = RangeBinfft1DSize;\n\n        /* 限制的rangeBin左右区间 */\n        handle-&gt;skipLeft            =   RangeBinMin;//6\n        handle-&gt;skipRight           =   RangeBinfft1DSize - RangeBinMax;//374\n\n        printf(\"DSS:enableRangeLimit=%d,skipMin=%.2f,skipMax=%.2f,rangeResolution=%.4f,skipLeft=%d,skipRight=%d\\n\",enableRangeLimit,skipMin,skipMax,rangeResolution,handle-&gt;skipLeft,handle-&gt;skipRight);\n    }\n    else\n    {\n        printf(\"DSS:enableRangeLimit=%d\\n\",enableRangeLimit);\n\n    }\n\n\n    /* 同价itemp在二进制格式下有多少个1, 然后存储在i变量中 */\n    while(1)\n    {\n        if(itemp == 1) break;\n        itemp = itemp &gt;&gt; 1;\n        i++;\n    }\n    /* fft级联次数log2(64)=6 */\n    handle-&gt;log2fft1DSize       =   i;\n\n    /* 在L2内存中申请一块`窗`句柄空间 */\n    handle-&gt;win1D               =   (float *) radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, moduleConfig-&gt;win1DLength * sizeof(float), 8);\n     /* 返回错误码 */\n    if (handle-&gt;win1D == NULL)\n    {\n        *errorCode  =   RADARDEMO_HIGHACCURANGEPROC_FAIL_ALLOCATE_LOCALINSTMEM;\n        return (handle);\n    }\n    /* 拿到dss_data_path中的窗参数 */\n    for (i = 0; i &lt; (int32_t)moduleConfig-&gt;win1DLength; i++ )\n    {\n        handle-&gt;win1D[i]        =   moduleConfig-&gt;win1D[i];\n    }\n    \n    /* 首先在内存中为handle-&gt;twiddle(旋转因子, 为fft做准备)分配一块空间，大小为2 * handle-&gt;fft1DSize *sizeof(float) */\n    handle-&gt;twiddle         =   (float *)radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, 2 * handle-&gt;fft1DSize * sizeof(float), 8);\n    /* 判断并返回错误码 */\n\n    \n    /* 调用tw_gen_float函数生成1D FFT所需的旋转因子，存储在handle-&gt;twiddle中,旋转因子可以用于快速傅里叶变换（FFT）算法，它能够快速地将时域采样转换为频域信号 */\n    tw_gen_float(handle-&gt;twiddle, handle-&gt;fft1DSize);\n\n    /* 为即将做fft的输入信号(数据)申请空间 */\n    handle-&gt;inputSig        =   (float *)radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, 2 * handle-&gt;fft1DSize * sizeof(float), 8);\n    /* 判断并返回错误码 */\n    \n\n    /* 在L2中申请内存, 用作傅里叶变换运算过程中的中间计算结果 */\n    handle-&gt;scratchPad      =   (float *)radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 1, 2 * 2 * handle-&gt;fft1DSize * sizeof(float), 8);\n    /* 判断并返回错误码 */\n\n    /* `FFT1D输出结果` 和 `相位解调`的结果都存放在缓冲scratchPad变量中 */\n    handle-&gt;fft1DOutSig     =   handle-&gt;scratchPad;\n    /* 相位解调:将调制信号从复数域映射到实数域，并通过这种映射 `去除相位信息`。在解调之后，得到的信号 `只包含振幅信息` */\n    handle-&gt;demodSig        =   handle-&gt;scratchPad;\n    \n    /* 将所有的fft原始数据放到 `fft1DIn` 这个指针变量中带回去 */\n    moduleConfig-&gt;fft1DIn   = handle-&gt;inputSig;\n\n    /* 分配一块内存，用于存储 `粗` 调的旋转因子（wnCoarse） */\n    handle-&gt;wnCoarse        =   (float *)radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, 2 * handle-&gt;fft1DSize * sizeof(float), 8);\n    \n    /* 生成一组用于傅里叶变换的`粗`调旋转因子, 存储在 `wnCoarse` 中 */\n    denom = 1.0/((double)handle-&gt;fft1DSize);\n    for (i = 0; i &lt; (int32_t)handle-&gt;fft1DSize; i++)\n    {\n        real        =   cos(-2 * PI * i *denom);\n        imag        =   sin(-2 * PI * i *denom);\n        handle-&gt;wnCoarse[2*i]       =   imag;\n        handle-&gt;wnCoarse[2*i+ 1 ]   =   real;\n    }\n\n    /* 分配一块内存，用于存储 `细` 调的旋转因子（wnCoarse） */\n    handle-&gt;wnFine      =   (float *)radarOsal_memAlloc((uint8_t) RADARMEMOSAL_HEAPTYPE_LL2, 0, 2 * handle-&gt;fft1DSize * sizeof(float), 8);\n    \n\n    /* 用于生成一组用于傅里叶变换的`细`调旋转因子, 存储在 `wnFine` 中 */\n    denom = 1.0/ ((double)(handle-&gt;fft1DSize * handle-&gt;fft1DSize)); // 将旋转因子限制在单位圆上\n    for (i = 0; i &lt; (int32_t)handle-&gt;fft1DSize; i++)\n    {\n        real        =   cos(-2 * PI * i *denom);\n        imag        =   sin(-2 * PI * i *denom);\n        handle-&gt;wnFine[2*i]     =   imag;\n        handle-&gt;wnFine[2*i+ 1 ] =   real;\n    }\n\n    return((void *)handle);\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#释放所创建时申请的内存空间",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#释放所创建时申请的内存空间",
    "title": "mmwave level sensing demo notes",
    "section": "2.2 释放所创建时申请的内存空间",
    "text": "2.2 释放所创建时申请的内存空间\n/* 释放所有申请额空间 */\nvoid    RADARDEMO_highAccuRangeProc_delete(\n                            IN  void * handle)\n{\n    RADARDEMO_highAccuRangeProc_handle *rangeProcInst;\n    \n    rangeProcInst   =   (RADARDEMO_highAccuRangeProc_handle *) handle;\n\n    radarOsal_memFree(rangeProcInst-&gt;inputSig, rangeProcInst-&gt;fft1DSize * 2 * sizeof(float));\n    radarOsal_memFree(rangeProcInst-&gt;twiddle, rangeProcInst-&gt;fft1DSize * 2 * sizeof(float));\n    radarOsal_memFree(rangeProcInst-&gt;wnFine, rangeProcInst-&gt;fft1DSize * 2 * sizeof(float));\n    radarOsal_memFree(rangeProcInst-&gt;wnCoarse, rangeProcInst-&gt;fft1DSize * 2 * sizeof(float));\n    radarOsal_memFree(rangeProcInst-&gt;win1D, rangeProcInst-&gt;win1DLength * 2 * sizeof(float));\n    radarOsal_memFree(rangeProcInst-&gt;demodSig, rangeProcInst-&gt;nSamplesPerChirp * 2 * sizeof(float));\n    \n    radarOsal_memFree(handle, sizeof(RADARDEMO_highAccuRangeProc_handle));\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#运行",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#运行",
    "title": "mmwave level sensing demo notes",
    "section": "2.3 运行",
    "text": "2.3 运行\n\n“est” 是 “estimate” 的缩写，表示估计值。在这个函数中， “estRange” 表示范围估计值， “deltaPhaseEst” 表示相位差估计值， “estLinearSNR” 表示线性信噪比估计值。\n\n对输入信号进行高精度的距离处理。\n通过 handle 参数转换得到 rangeProcInst。检查 inputSignal 和 win1D 是否为空，若为空则返回错误码。\n接下来通过 rangeProcInput 参数获取 chirpNum，如果 chirpNum &gt;= 0，则调用 RADARDEMO_highAccuRangeProc_accumulateInput 函数进行多普勒累积，并转换到浮点数。\n否则调用 RADARDEMO_highAccuRangeProc_rangeEst函数进行距离估计，并将结果存储在 rangeProcOutput 参数中。\n最后返回错误码\n\nRADARDEMO_highAccuRangeProc_errorCode   RADARDEMO_highAccuRangeProc_run(\n                            IN  void * handle,\n                            IN  RADARDEMO_highAccuRangeProc_input * rangeProcInput, \n                            OUT RADARDEMO_highAccuRangeProc_output * rangeProcOutput)\n\n{\n    /* chirp数 */\n    int32_t     chirpNum;\n    /* 该函数的操作句柄 */\n    RADARDEMO_highAccuRangeProc_handle *rangeProcInst;\n    /* 存放原始ADC数据 */\n    cplx16_t    * inputSignal;\n    /* 设置错误码: 没有错误 */\n    RADARDEMO_highAccuRangeProc_errorCode errorCode = RADARDEMO_HIGHACCURANGEPROC_NO_ERROR;\n\n    /* 拿到传递过来的原始ADC数据放到inputSignal中 */\n    inputSignal     =   rangeProcInput-&gt;inputSignal;\n    /* 拿到传递过来的句柄(操作对象) */\n    rangeProcInst   =   (RADARDEMO_highAccuRangeProc_handle *) handle;\n\n    /* 判断是否接收到, 没有接收到数据就将状态码设置为xxx */\n    if (inputSignal == NULL)\n        errorCode   =   RADARDEMO_HIGHACCURANGEPROC_INOUTPTR_NOTCORRECT;\n\n    if (rangeProcInst-&gt;win1D == NULL)\n        errorCode   =   RADARDEMO_HIGHACCURANGEPROC_INOUTPTR_NOTCORRECT;\n\n    /* 如果存在错误,直接返回状态码, 结束该函数 */\n    if (errorCode &gt; RADARDEMO_HIGHACCURANGEPROC_NO_ERROR)\n        return(errorCode);\n    \n    /* 没有错误的处理 */\n    /* 拿到chirp数 */\n    chirpNum        =   (int32_t) rangeProcInput-&gt;chirpNumber;\n    /* 如果chirp数大于=0, 进行chirp信号累加和加窗操作(先累加, 最后加窗), interframe中会将chirpNum设置为`-1000`,这代表一帧的数据结束 */\n    if (chirpNum &gt;= 0)\n    { /*accumulating all the chirps and convert to float*/\n        /* 进行chirp信号累加和加窗操作(先累加, 最后加窗) */\n        RADARDEMO_highAccuRangeProc_accumulateInput(\n                            rangeProcInst-&gt;nSamplesPerChirp,\n                            rangeProcInst-&gt;fft1DSize,\n                            rangeProcInst-&gt;numChirpsPerFrame,\n                            rangeProcInst-&gt;win1D,\n                            rangeProcInst-&gt;win1DLength,\n                            rangeProcInput-&gt;inputSignal,\n                            chirpNum,\n                            rangeProcInst-&gt;inputSig);\n\n    }\n    /* 所有的chirp接收完了, 进行距离估计 */\n    else\n    { \n        /* range measurements*/\n        RADARDEMO_highAccuRangeProc_rangeEst(\n                            rangeProcInst, \n                            &(rangeProcOutput-&gt;rangeEst),\n                            &(rangeProcOutput-&gt;deltaPhaseEst),\n                            &(rangeProcOutput-&gt;linearSNREst));\n\n    }\n    /* 返回状态码 */\n    return(errorCode);\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#累加一帧内所有chirp的信号并加窗",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#累加一帧内所有chirp的信号并加窗",
    "title": "mmwave level sensing demo notes",
    "section": "2.3.1 累加一帧内所有chirp的信号并加窗",
    "text": "2.3.1 累加一帧内所有chirp的信号并加窗\nif是格式转换, else是chirp累加和加窗. 通过加窗和累加输入数据，实现了去除直流分量的效果。\n\nvoid    RADARDEMO_highAccuRangeProc_accumulateInput(\n                            IN  uint32_t nSamplesPerChirp, // 单个chirp中采样点数目\n                            IN  uint32_t fftSize1D, // 一维FFT点数\n                            IN  uint32_t nChirpPerFrame, // 每个帧的chirp数目\n                            IN  float   * RESTRICT fftWin1D, // 一维FFT窗口函数\n                            IN  int16_t  fftWin1DSize, // 一维FFT窗口函数大小\n                            IN  cplx16_t * RESTRICT inputPtr, // 采集数据指针\n                            IN  int32_t  chirpInd, // 当前chirp index\n                            OUT float * outputPtr) // 输出数据指针\n{\n    if(procStep != 0)\n    {\n        return;\n    }\n    int32_t i, itemp;\n    int64_t input;\n\n    /* 判断所有的chirp索引是不是0, 如果是0 */\n    if (chirpInd == 0)\n    {\n        // nSamplesPerchir是配置文件中的 `numAdcSamples` 这个值是采样的点数(假设这个值是256: 因为一个复数采样点包含两个实数采样点, 所以要除以二, 右移1位就是除以2,那就每个点进行递增 )\n        /* 右移一位相当于将其除以2，这是因为每个复数采样点包含两个实数采样点，而这段代码的目的是将复数形式的采样点转换为实数形式的采样点，所以需要将采样点数除以2 ,因此循环条件中使用了右移运算符 &gt;&gt;，这也是一种常见的快速除以2的方法*/\n        /* 将输入数据从Q15格式转换为IEEE-754格式的浮点数，并按照一定的规则存储到输出数组中 */\n        for( i = 0; i &lt; ((int32_t)nSamplesPerChirp&gt;&gt; 1); i++)\n        {\n            /* 拿到inputPtr中的数据地址, 然后将该地址存储在input中, input的大小为64bit,一个复数结构(float(32)+float(32)) */\n            input                           =   _amem8(&inputPtr[2 * i]);\n            /* `_ftof2`是一个DSP库函数，用于将两个32位浮点数打包成一个64位浮点数,\n            float64_t _ftof2(float32_t a, float32_t b);\n            其中，a和b分别是要打包的两个32位浮点数。函数的返回值是一个64位浮点数，由a和b的位构成\n            (float)_ext(_loll(input), 16, 16)提取了input的低32位中的高16位，并将结果强制转换成32位浮点数.\n            (float)_ext(_loll(input), 0, 16)提取了input的低32位中的低16位，并将结果强制转换成32位浮点数\n            \n            --------------------------------------------------------------------------------\n            将16是因为adc采样的数据是16位采样, 所以这里的操作是将adc的采样数据转换为32位float类型,然后按照采样点进行拼凑, 一个采样点由2个数组成(实部虚部,各占一个flot, 所以是2个float, 这里实际上就是将ADC采样的Q格式数据转换为complex格式(real+image))\n            */\n            /* 这里实际上就是一个complex格式的采样点 */\n            /* _loll: 用于提取一个64位整数中低32位  */\n            /* _ext(x,  0, 16)表示提取x中的 高 16位作为输出 */\n            /* _ext(x, 16, 16)表示提取x中的 低 16位作为输出 */\n            /* _ext(x, msb, lsb)表示将32位整数x中的第msb到第lsb位（包括msb和lsb）提取出来组成一个新的32位整数. */\n            _amem8_f2(&outputPtr[4*i])      =   _ftof2((float)_ext(_loll(input), 16, 16), (float)_ext(_loll(input), 0, 16)); // 实部 将复数的实部转换为浮点数的高16位，将虚部转换为浮点数的低16位，然后存储在outputPtr数组中，\n            _amem8_f2(&outputPtr[4*i + 2])  =   _ftof2((float)_ext(_hill(input), 16, 16), (float)_ext(_hill(input), 0, 16)); // 虚部\n        }\n        /* 如果采样点是奇数, 那么Q格式中只有 */\n        if((int32_t)nSamplesPerChirp & 1)\n        {\n            /* 在这种情况下，最后一个采样点只有一个float存储，而不是两个 */\n            itemp                           =   _amem4(&inputPtr[nSamplesPerChirp - 1]);\n            _amem8_f2(&outputPtr[2*(nSamplesPerChirp - 1)]) =   _ftof2((float)_ext(itemp, 16, 16), (float)_ext(itemp, 0, 16));\n        }\n    }\n    /* 如果不是第一个chirp的话, (主要目的是为了去除直流分量) */\n    else\n    {\n        /* 将每个输入数据的实部和虚部累加到输出数组的对应位置上 */\n        for( i = 0; i &lt; ((int32_t)nSamplesPerChirp&gt;&gt; 1); i++)\n        {\n            input                           =   _amem8(&inputPtr[2 * i]);\n            _amem8_f2(&outputPtr[4*i])      =   _daddsp(_amem8_f2(&outputPtr[4*i]), _ftof2((float)_ext(_loll(input), 16, 16), (float)_ext(_loll(input), 0, 16)));\n            _amem8_f2(&outputPtr[4*i + 2])  =   _daddsp(_amem8_f2(&outputPtr[4*i + 2]), _ftof2((float)_ext(_hill(input), 16, 16), (float)_ext(_hill(input), 0, 16)));\n        }\n        // 如果样本数为奇数，则处理最后一个样本, 内存对齐, 奇数只保留一个float\n        if((int32_t)nSamplesPerChirp & 1)\n        {\n            itemp                           =   _amem4(&inputPtr[nSamplesPerChirp - 1]);\n            _amem8_f2(&outputPtr[2*(nSamplesPerChirp - 1)]) = _daddsp(_amem8_f2(&outputPtr[2*(nSamplesPerChirp - 1)]), _ftof2((float)_ext(itemp, 16, 16), (float)_ext(itemp, 0, 16)));\n        }\n        // 如果是每帧的最后一个 chirp，则需要进行窗函数操作\n        if (chirpInd == ((int32_t)nChirpPerFrame - 1))\n        {\n            __float2_t f2win1D;\n            // 如果是每帧的最后一个 chirp，则需要进行窗函数操作\n            /* 将加窗后的数据分别乘以窗函数并存回 outputPtr 数组中 */\n            for( i = 0; i &lt; fftWin1DSize; i++)\n            {\n                f2win1D                     =   _ftof2(fftWin1D[i], fftWin1D[i]);\n                _amem8_f2(&outputPtr[2*i])  =   _dmpysp(_amem8_f2(&outputPtr[2*i]), f2win1D);\n                _amem8_f2(&outputPtr[2*(nSamplesPerChirp - i - 1)]) =   _dmpysp(_amem8_f2(&outputPtr[2*(nSamplesPerChirp - i - 1)]), f2win1D);\n            }\n            // 如果一个 chirp 中的样本点数 nSamplesPerChirp 小于 FFT 点数 fftSize1D，则将 outputPtr 数组中多余的部分填充为 0 \n            if (((int32_t)fftSize1D - (int32_t)nSamplesPerChirp) &gt; 0)\n            {\n                // 对多余部分进行填零操作\n                for( i = 0; i &lt; ((int32_t)fftSize1D - (int32_t)nSamplesPerChirp); i++);\n                {\n                    _amem8_f2(&outputPtr[2*nSamplesPerChirp + 2*i]) =   _ftof2(0.f, 0.f);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#配置文件解析",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#配置文件解析",
    "title": "mmwave level sensing demo notes",
    "section": "1. 配置文件解析",
    "text": "1. 配置文件解析\n                                IWR6843vitalsign配置解析                                                            \n                                                                -2022-11-15 dd21\nsensorStop\n    - 传感器停止\n\nflushCfg\n    - 刷新配置\n    \ndfeDataOutputMode 1\n     - 数据输出模式\n        |-1 基于帧的chirp模式\n        |-2 连续chirp模式\n        |-3 高级帧模式       \n    \n    \nchannelCfg 15 3 0\n    - 通道设置\n        |-15 =&gt; (0x1111)b 接收天线掩码, 表示打开 4个接收天线  \n        |-3  =&gt; (0x11)b   发射天线掩码, 表示打开 2个发射天线\n        |-0 soc级联(目前不可用[V3.5.4]), 设置为0\n        \n\nadcCfg 2 1\n    - ADC配置\n        |-&lt;具体信息查看mmwaveLink 文档&gt;\n        |-2 adc采样位数(只支持16bits)\n            |-0 12bits\n            |-1 14bits\n            |-2 16bits\n            \n        |-1 adc输出格式\n            |-0 real(实数)\n            |-1 complex 1x (image band filtered output)\n            |-2 complex 2x (image band visible)\n            \n \nadcbufCfg -1 0 0 1 0\n    - Adc_buffer配置\n        |--1子帧索引\n            |-传统模式 设置为-1\n            |-高级帧模式 根据需求配置, 若依旧设置为-1, 则表示子帧采取相同的配置\n            \n        |- 0 ADCBUF adcBuffer输出模式\n            |-0 复数模式\n            |-1 实数模式\n            \n        |- 1 采样交换选择(只支持1)\n            |-0-I in LSB, Q in MSB\n            |-1-Q in LSB, I in MSB\n            \n        |- 1 ADCbuffer通道交错(只支持1)\n            |-0 交错\n            |-1 不交错\n            \n        |- 1 chrip 阈值, 用于 ADCBUF 缓冲区触发 ping /pong 缓冲区开关的 Chirp 阈值配置\n            |-[0-8] 16xx, 将dsp用于1D-fft处理,如果使用lvds使用的话, 1也是可以的\n            |-[1] 68xx,64xx,18xx, 有HWA(fft硬件加速) \n    \nprofileCfg 0 60 7 6 60 0 0 65 1 100 2000 0 0 40\nprofileCfg 0 77 7 7 114.4 0 0  33.71 1 256 2500 0 0 48\n    - 雷达前段和数据处理配置\n        |-0    标识符, 区别第几个配置\n        |-60   起始频率(GHz,允许浮点数)\n        |-7    idle time  空闲时间(us)\n        |-6    adc有效起始时间(us)\n        |-60   斜坡结束时间(us)\n        |-0    发射天线功率返回码(只有0测试过)\n        |-0    发射天线移相器(只有0测试过)\n        |-65   每个chirp的变化率,MHz/us\n        |-1    发射天线开始时间(us)\n        |-100  adc采样数\n        |-2000 adc采样率\n        |-0    高通滤波器1\n            |-0: 175 KHz\n            |-1: 235 KHz\n            |-2: 350 KHz\n            |-3: 700 KHz\n        |-0    高通滤波器2\n            |-0: 350 KHz\n            |-1: 700 KHz\n            |-2: 1.4 MHz\n            |-3: 2.8 MHz\n        |-40  接收增益 以 dB 为单位的 RX 增益和 RF 增益目标的或值\n        \n\nchirpCfg 0 0 0 0 0 0 0 1\nchirpCfg 1 1 0 0 0 0 0 2\n    - 对雷达前段和数据处理的chirp配置\n        |- 0 chirp开始索引\n        |- 0 chirp结束索引\n        |- 0 配置文件标识符\n        |- 0 起始频率变化(Hz)     [只支持0]\n        |- 0 频率斜率变化(kHz/us) [只支持0]\n        |- 0 空闲时间(us)           [只支持0]\n        |- 0 ADC 启动时间变化(us) [只支持0]\n        |- 1 (0x01)b =&gt; tx 天线掩码, 打开天线1\n        \n\nframeCfg 0 1 1 0 50 1 0\n    - fram配置\n        |-0  chrip 开始索引(0-511)\n        |-1  chrip 结束索引(开始索引-511)\n        |-1  循环次数(1-255), 如果用dsp进行计算多普勒chirp, 循环次数必须是4的倍数, 否则需要调整窗的大小\n        |-0  frame的数量(0-65535),0表示无穷\n        |-50 frame的周期50ms\n        |-1  触发选择\n            |-1:软件触发(只支持软件触发) \n            |-2:硬件触发\n        |-0  frame触发延时(ms)\n        \n        \nlowPower 0 0\n    - 低功耗模式\n        |- 0 don’t_care\n        |-ADC Mode\n            |-0 : 常规模式\n            |-1 : 低功耗adc模式 (不支持 xwr6xxx)\n            \nguiMonitor -1 0 0 0 0 0 1\n    - 图形界面监视器(所有配置0表示关闭, 1表示开启)\n        |- -1  所有frame配置相同(-1)\n        |- 0   检测到的物体\n        |- 0   log magnitude range\n        |- 0   noise profile\n        |- 0   各种热图\n        |- 0   距离多普勒热图\n        |- 1   CPU 负载、余量、设备温度读数等\n        \n        \ncalibDcRangeSig -1 0 0 0 0\n    - 补偿参数\n        |- -1  所有frame配置相同(-1)\n        |- Enable DC removal using first few chirps\n        |-\n        |-\n        |-\n        |-\n        \n\n\nvitalSignsCfg 0.3 0.9 256 512 4 0.1 0.05 100000 300000\nmotionDetection 1 20 2.0 0\nsensorStart"
  },
  {
    "objectID": "posts/ti_mmwave_demo_level_sensing/index.html#多普勒累积",
    "href": "posts/ti_mmwave_demo_level_sensing/index.html#多普勒累积",
    "title": "mmwave level sensing demo notes",
    "section": "1. 多普勒累积",
    "text": "1. 多普勒累积\n\n多普勒累积（Doppler accumulation）是一种信号处理技术，用于增强雷达系统对运动目标的探测和跟踪能力。在雷达系统中，目标的运动会导致回波信号的频率发生偏移，这种频率偏移称为多普勒频移。通过多普勒累积，可以将多个时刻收到的回波信号进行累加，以增加对目标多普勒频移的测量精度和信噪比。\n具体来说，多普勒累积的过程包括以下步骤：\n\n将多个时刻的回波信号进行FFT变换，得到频域信息。\n对于每个目标，将它在多个时刻的频域信息进行累加，得到一个累加后的频谱。\n对于每个目标，从累加后的频谱中提取出多普勒频移信息。\n通过多普勒累积，可以提高雷达系统对运动目标的探测和跟踪能力，特别是在低信噪比环境下。"
  },
  {
    "objectID": "posts/javaGUI--文本框JTextField_密码框JPasswordField()_文本域 JTextArea/index.html",
    "href": "posts/javaGUI--文本框JTextField_密码框JPasswordField()_文本域 JTextArea/index.html",
    "title": "javaGUI–文本框JTextField_密码框JPasswordField()_文本域 JTextArea",
    "section": "",
    "text": "文本框,密码框,文本域 panel.add(scrollPane);// 加上文本域就会让之前的鼠标悬停显示没了,不知道是什么问题\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JComboBoxDemo03 extends JFrame {\n    public JComboBoxDemo03() {\n        this.setBounds(100,100,500,500);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        // 文本框\n        JTextField field01 = new JTextField();\n        field01.setToolTipText(\"text01\");\n        JTextField field02 = new JTextField();\n        field02.setToolTipText(\"text02\");\n\n        // 密码框\n        JPasswordField passwordField01 = new JPasswordField();\n        passwordField01.setToolTipText(\"password01\");// 悬停显示\n        passwordField01.setEchoChar('*');// 设置显示的内容\n        JPasswordField passwordField02 = new JPasswordField();\n        passwordField02.setEchoChar('x');// 设置显示的内容\n        passwordField02.setToolTipText(\"password02\");// 悬停显示\n\n        // 文本域\n        JTextArea textArea = new JTextArea();\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        scrollPane.setToolTipText(\"文本域\"); \n\n        // 布局\n        Panel panel = new Panel(new GridLayout(3,2,20,20));\n        panel.add(field01);\n        panel.add(field02);\n        panel.add(passwordField01);\n        panel.add(passwordField02);\n        panel.add(scrollPane);// 加上文本域就会让之前的鼠标悬停显示没了,不知道是什么问题\n        this.add(panel);\n    }\n\n    public static void main(String[] args) {\n        new JComboBoxDemo03();\n    }\n}"
  },
  {
    "objectID": "posts/java EE 简单登陆跳转逻辑/index.html",
    "href": "posts/java EE 简单登陆跳转逻辑/index.html",
    "title": "java EE 简单登陆跳转逻辑",
    "section": "",
    "text": "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--把表单内容提交到myProject工程下的login--&gt;\n    &lt;form action=\"/myProject/login\" method=\"post\"&gt;\n        用户名： &lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt;\n        密  &nbsp;&nbsp;&nbsp;码：   &lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; \n        &lt;input type=\"submit\" value=\"登录\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/java EE 简单登陆跳转逻辑/index.html#登陆页面",
    "href": "posts/java EE 简单登陆跳转逻辑/index.html#登陆页面",
    "title": "java EE 简单登陆跳转逻辑",
    "section": "",
    "text": "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--把表单内容提交到myProject工程下的login--&gt;\n    &lt;form action=\"/myProject/login\" method=\"post\"&gt;\n        用户名： &lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt;\n        密  &nbsp;&nbsp;&nbsp;码：   &lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; \n        &lt;input type=\"submit\" value=\"登录\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/java EE 简单登陆跳转逻辑/index.html#login-servlet",
    "href": "posts/java EE 简单登陆跳转逻辑/index.html#login-servlet",
    "title": "java EE 简单登陆跳转逻辑",
    "section": "2、login Servlet",
    "text": "2、login Servlet\n        //获取用户名和密码\n        String username =  request.getParameter(\"username\");\n        String password= request.getParameter(\"password\");\n        //在控制台打印\n        System.out.println(username);\n        System.out.println(password);\n        \n        //判断\n        if(username.equals(\"admin\") && password.equals(\"123\")){\n            response.sendRedirect(\"/myProject/welcom.html\");\n        }\n        else{\n            response.sendRedirect(\"/myProject/login.html\");\n        }"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html",
    "href": "posts/infineon_BGTR13C_shield/idnex.html",
    "title": "infineon BTGR13C Radar shield",
    "section": "",
    "text": "对雷达核心板进行具体描述, 主要包括\n\n概念描述(shield, Avian,LTR11,ATR22,)\n功耗信息\n上电描述\n电源信号干扰\n驱动雷达芯片\n外围电路设计要点\n相位噪声测量"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html#功耗信息",
    "href": "posts/infineon_BGTR13C_shield/idnex.html#功耗信息",
    "title": "infineon BTGR13C Radar shield",
    "section": "功耗信息",
    "text": "功耗信息"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html#上电描述",
    "href": "posts/infineon_BGTR13C_shield/idnex.html#上电描述",
    "title": "infineon BTGR13C Radar shield",
    "section": "上电描述",
    "text": "上电描述\n为了为 MCU 板提供正确的电平转换器电压，1.8 V 传感器电源线与 Vdigital 相连——请参阅 (RS, 2019) 的第 2.3 节\n当扩展板插入雷达底板 MCU7 时，传感器的电源最初处于停用状态。只有 EEPROM 被供电。 MCU 将读取 EEPROM 存储器的内容以确定哪个传感器插入传感器接口。只有当电路板被正确识别时，传感器的电源才会被激活"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html#电源信号干扰",
    "href": "posts/infineon_BGTR13C_shield/idnex.html#电源信号干扰",
    "title": "infineon BTGR13C Radar shield",
    "section": "电源信号干扰",
    "text": "电源信号干扰\n雷达传感器对电源域中的噪声和串扰非常敏感。因此，不同的电源域必须去耦。在 BGT60TR13C 核心板上，这是通过每个电源域（和振荡器电源）上的 pi 形低通滤波器实现的。"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html#驱动雷达芯片",
    "href": "posts/infineon_BGTR13C_shield/idnex.html#驱动雷达芯片",
    "title": "infineon BTGR13C Radar shield",
    "section": "驱动雷达芯片",
    "text": "驱动雷达芯片\n与雷达传感器的通信主要通过串行外设接口 (SPI) 总线执行。\n除spi总线外，操作雷达还需要两条数字线, 当需要获取新数据时,\n\n一根线会向 MCU 发出信号\n另一个允许 MCU 执行传感器的硬件重置\n\n此外，板上还安装了一个 MCU 可控 LED, 这允许 MCU 显示状态，例如传感器是激活还是停用"
  },
  {
    "objectID": "posts/infineon_BGTR13C_shield/idnex.html#时钟源",
    "href": "posts/infineon_BGTR13C_shield/idnex.html#时钟源",
    "title": "infineon BTGR13C Radar shield",
    "section": "时钟源",
    "text": "时钟源\nBGT60TR13C雷达传感器需要稳定的时钟源，可提供低电平相位抖动和低相位噪声. 特性应与BGT60TR13C上使用的Kyocera KC2016相似.\n选择振荡器最重要的参数是相位抖动和相位噪声, 其他振荡器应具有与京瓷KC2016相似的相位抖动和相位噪声.\n\n\n\n\n\n\n如果重新设计的电路板包含不同的信号源或设计了截然不同的布局，则可能需要调整 R1 (150 Ω) 的值。\n\n\n\n如果信号电平太低，传感器的相位噪声会恶化——有关相位噪声测量的详细信息，请参见第 5.3 节。电阻低时，传感器的信号电平会很高，在雷达数据的距离多普勒图中，近距离会出现峰值（或虚假目标）\n\n出于这个原因，需要测量相位噪声以及需要用距离多普勒图说明的雷达数据，以优化布局的串联电阻。必须通过将不同的电阻器焊接到电路中来改变串联电阻。优化的串联电阻将显示传感器的理想相位噪声行为以及干净的距离多普勒图。如果相位噪声行为不理想，则电阻值必须更低。如果在距离-多普勒图中出现峰值，则电阻必须更高."
  },
  {
    "objectID": "posts/stm32H743使用/index.html",
    "href": "posts/stm32H743使用/index.html",
    "title": "stm32H743使用",
    "section": "",
    "text": "0. 所需材料\n\n\n\n材料\n数量\n\n\n\n\nST-Link V2\n1\n\n\n战舰扩展板\n1\n\n\nstm32H743核心板\n1\n\n\n\n\n\n1. 安装仿真器驱动程序\n # 1. 安装芯片包 \n\n\n\n在这里插入图片描述\n\n\n\n\n1. 使用MX-Cube配置工程\n时钟配置  串口设置:"
  },
  {
    "objectID": "posts/javaGUI-- JPanel/index.html",
    "href": "posts/javaGUI-- JPanel/index.html",
    "title": "javaGUI– JPanel",
    "section": "",
    "text": "JPanel容器 \npackage cn.usts.edu.lesson05;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JPanelDemo extends JFrame {\n\n    public JPanelDemo() {\n        this.setTitle(\"JPanel\");\n        this.setBounds(100,100,400,400);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        this.setLayout(new GridLayout(2,2,10,20));// 后边的两个参数都是  行间距  和  列间距\n        JPanel panel01 = new JPanel(new GridLayout(1,3));\n        JPanel panel02 = new JPanel(new GridLayout(3,1));\n        JPanel panel03 = new JPanel(new GridLayout(2,3,10,10));\n        JPanel panel04 = new JPanel(new GridLayout(2,2));\n\n        JButton button1 = new JButton(\"1\");\n        JButton button2 = new JButton(\"1\");\n        JButton button3 = new JButton(\"1\");\n\n        JButton button4 = new JButton(\"2\");\n        JButton button5 = new JButton(\"2\");\n        JButton button6 = new JButton(\"2\");\n\n        JButton button7 = new JButton(\"3\");\n        JButton button8 = new JButton(\"3\");\n        JButton button9 = new JButton(\"3\");\n        JButton button10 = new JButton(\"3\");\n        JButton button11 = new JButton(\"3\");\n        JButton button12 = new JButton(\"3\");\n\n        JButton button13 = new JButton(\"4\");\n        JButton button14 = new JButton(\"4\");\n        JButton button15 = new JButton(\"4\");\n        JButton button16 = new JButton(\"4\");\n\n        panel01.add(button1);\n        panel01.add(button2);\n        panel01.add(button3);\n\n        panel02.add(button4);\n        panel02.add(button5);\n        panel02.add(button6);\n\n        panel03.add(button7);\n        panel03.add(button8);\n        panel03.add(button9);\n        panel03.add(button10);\n        panel03.add(button11);\n        panel03.add(button12);\n\n        panel04.add(button13);\n        panel04.add(button14);\n        panel04.add(button15);\n        panel04.add(button16);\n\n\n        Container container = this.getContentPane();\n        container.add(panel01);\n        container.add(panel02);\n        container.add(panel03);\n        container.add(panel04);\n\n    }\n\n    public static void main(String[] args) {\n        new JPanelDemo();\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程停止/index.html",
    "href": "posts/java多线程-- 线程停止/index.html",
    "title": "java多线程– 线程停止",
    "section": "",
    "text": "测试线程停止\n建议线程正常停止,非强行停止—-&gt;利用次数控制,不建议死循环\n建议使用标志位(flag)—&gt;设置一个标志位\n不要使用stop和destroy方法和jdk不建议使用的方法\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 测试线程stop\n * 建议线程正常停止,非强行停止----&gt;利用次数控制,不建议死循环\n * 建议使用标志位(flag)---&gt;设置一个标志位\n * 不要使用stop和destroy方法和jdk不建议使用的方法\n * \n * 本实例是实现当main线程跑到500时,B线程也就停止了.\n * */\n\npublic class ThreadStopDemo implements Runnable{\n\n    private boolean flag = true;//设置标志位\n\n    @Override\n    public void run() {\n        int i=0;\n        while (flag){\n            System.out.println(Thread.currentThread().getName()+\"----&gt;\"+i++);\n        }\n    }\n\n    // 自定义的stop方法\n    public void stop(){\n        flag=false;\n    }\n\n    public static void main(String[] args) {\n\n        ThreadStopDemo demo = new ThreadStopDemo();\n        new Thread(demo,\"B线程\").start();\n        for (int i = 0; i &lt; 1000; i++) {\n            System.out.println(\"main线程\"+i);\n            if (i==500){\n                demo.stop();// 当main线程跑到500就停止另外一个再跑的线程\n            }\n        }\n    }\n\n\n}"
  },
  {
    "objectID": "posts/linux入门基操作/index.html",
    "href": "posts/linux入门基操作/index.html",
    "title": "linux入门操作",
    "section": "",
    "text": "zsh，zshrc，zprofile，zshenv区别"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#学会使用命令帮助",
    "href": "posts/linux入门基操作/index.html#学会使用命令帮助",
    "title": "linux入门操作",
    "section": "1. 学会使用命令帮助",
    "text": "1. 学会使用命令帮助\nman -k xxx          // 忘记具体命令 \nwhatis xxx          // 查看具体信息,info也可\nwhatis -w \"ca*\"     // 正则表达式查找\ninfo xxx            // 同whatis\nman xxx             // 查看具体参数 \nLinux分\n(1)、用户可以操作的命令或者是可执行文件\n(2)、系统核心可调用的函数与工具等\n(3)、一些常用的函数与数据库\n(4)、设备文件的说明\n(5)、设置文件或者某些文件的格式\n(6)、游戏\n(7)、惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容\n(8)、系统管理员可用的管理条令\n(9)、与内核有关的文件\n查找程序的bin文件夹所在位置\nwhich xxxx\n查看程序的搜索路径(查看执行的是哪一个程序)\nwhereis xxx"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#文件及目录管理",
    "href": "posts/linux入门基操作/index.html#文件及目录管理",
    "title": "linux入门操作",
    "section": "2. 文件及目录管理",
    "text": "2. 文件及目录管理\n文件,文件夹基本操作\nls                          // 列出当前目录下的所有文件\ntouch xx.x                  // 创建一个文件\nmkdir xxx                   // 创建一个文件夹\nmv FILE PATH                // 移动文件到指定位置\ncp SRC  DESC                // 复制文件到那个文件(可以写路径)\ncp -r ./aaa ./bbb           // 复制文件夹\nrm -rf                      // 删除(加单粗暴的删除)          \n查看文件个数\nfind ./ |wc -l              // 官方写法,个人觉得不太方便记忆\nls | cat -n                 // 文件前面加序号\n目录切换\ncd xxx                      // 进入到xx目录\ncd -                        // 进入到场次的路径\ncd ~                        // 进入到家目录\ncd /                        // 记入到根目录\npwd                         // 显示当前路径\n列出文件\nls                          // 列出所有文件\nll                          // 列出详细信息\nls -lrt                     // 时间排序\n别名修改 修改家目录下的bachrc文件设置命令别名,想当于快捷方式\nalias lt='ls -lrt'          // 修改别名为lt \n文件查找\nfind ./ -name \"xxx\"         // 在当前目录查找xxx, xxx可以是正则表达式\n文件内容查看\ncat\nvim\nhead\nhead -10 xxx                // 看前10行\ntail -10 xxx                // 看倒数10行\ntail -f xxx                 // 动态显示文本最新信息\ndiff xx-1 xx-2              // 文件对比\n查找文件内容\negrep 'str' file            // 查找文件内容\negrep 'str' file &gt; outFile  // 将查找到的内容输出到outFile\n权限修改\nchown user file             // 修改文件拥有者\nchmod a+x  file             // 所用用户添加可执行权限a(all) u(user) g(group) o(other)\n文件创建别名(快捷方式)\nln file-1 file-2            // 硬连接, 相当于复制\nln -s file1 file2           // 软连接, 相当于快捷方式\n管道和重定向 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&& 前面失败，则后一条执行: ||\nls ./ && echo ok || echo failed\n\nif ls ./;then echo ok; else echo failed;fi          // 和上面等同\n\n:&gt; a.txt                                            // 清空文件\nls a.text &gt;&gt; a.out                                  // 重定向, 就是将原本输出到控制台的信息, 重新输出到别的地方\n环境变量设置 bashrc: 系统启动时执行的文件 profile: 用户登陆后执行的文件\nvim ~/.bashrc\nvim /etc/profile\n\n//修改其中的PATH变量\nPATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH\nbash快捷键\nCtl-U   删除光标到行首的所有字符,在某些设置下,删除全行\nCtl-K   删除光标到行尾的所有字符\nCtl-W   删除当前光标到前边的最近一个空格之间的字符\nCtl-H   backspace,删除光标前边的字符\n\nCtl-R   匹配最相近的一个执行过的命令，然后输出\nCtl-J   回车\nCtl-B   左移一个字符\nalt-B   左移一个单词(ubuntu失败)\nCtl-F   右移一个字符\nalt-F   右移一个单词(ubuntu失败)\nCtl-A   移动到最前面\nCtl-E   移动到最后面\nCtl-P   上一条指令\nCtl-N   下一条指令(执行过的指令中上翻下翻,==&gt;上/下 键: 终于不用按上下了, 太爽了!!!)\nCtl-L   清屏(不用clear了, 解决痛点+1,爽+1)\n综合应用 查找record.log中包含AAA，但不包含BBB的记录的总数:\ncat -v record.log | grep AAA | grep -v BBB | wc -l // cat -v 显示文件原本在中的数据, 对中文字符有影响 直接翻译成acsii字符"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#文本处理",
    "href": "posts/linux入门基操作/index.html#文本处理",
    "title": "linux入门操作",
    "section": "3. 文本处理",
    "text": "3. 文本处理\n文件查找\nfind ./ -name \"*.txt\"               // 文件名查找\nfind ./ -regex \".*?.txt\"            // 正则表达式查找\nfind ./ ! -name \"*.txt\"             // 文件名反向查找\nfind . -maxdepth 1 -type f          // 指定深度查找, 深度为1 \n文件操作时间查询 -atime 访问时间 (单位是天，分钟单位则是-amin，以下类似） -mtime 修改时间 （内容被修改） -ctime 变化时间 （元数据或权限变化）\nfind ./ -atime 7 -type f            // 查找最近第7天修改的文件 f(file)\nfind ./ -atime -7 -type f           // 最近7天内\nfind ./ -atime +7 -type f           // 最近7天前 \n按照大小查询文件\nfind ./ -type f -size +2            // 查找大于2k的文件\nfind ./ -type f -size -2            // 查找小于2k的文件\n按照文件创建用户查找\nfind ./ -type f -user root          // root用户创建的文件\n删除指定条件的文件\nfind ./ -type f -name \"*.txt\" -delete                       // 删除当前目录下的xxx.txt文件\n动作执行 exec后面可以跟执行的命令, {}代表符合条件的所有文件\nfind ./ -type f -name \"*.txt\" -exec cp {} ./OtherDir \\ ;    // 将当前文件夹中的所有txt文件复制到当前目录下的OtherDir中 \n结合多个命令 如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:\n-exec ./commands.sh {} \\;\n-print的定界符 默认使用’’作为文件的定界符； -print0 使用’\\0’作为文件的定界符，这样就可以搜索包含空格的文件；\ngrep文本搜索 -o 只输出匹配的文本行 -v 只输出没有匹配的文本行 -c 统计文件中包含文本的次数 grep -c “text” filename -n 打印匹配的行号 -i 搜索时忽略大小写 -l 只打印文件名\ngrep -i -n 'hello' a.txt                        // 查找文本中hello的位置, 忽略大小写\n在多级目录中对文本递归搜索(程序员搜代码的最爱）:\ngrep \"class\" . -R -n\nxargs命令行参数转换\n-d 定义定界符 （默认为空格 多行的定界符为 n） -n 指定输出为多行 -I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时 -0：指定0为输入定界\ncat xxx.txt | xargs -n 3                        // 将内容三行在一行显示\ncat xxx.txt | xargs -i echo -{}                 // 将xx.txt中的数据按行读取,通过echo输出,并在前加 - \nsort排序 -n 按数字进行排序 VS -d 按字典序进行排序 -r 逆序排序 -k N 指定按第N列排序\nsort -n xxx.txt                                 // 默认n排序\nsort -r xxx.txt                                 // 逆序\nsort -d xxx.txt                                 // 字典排序\n\nsort xxx.txt | uniq                             // 去重\nsort xxx.txt | uniq -c                          // 每行出现次数\nsort xxx.txt | uniq -d\n文本拼接\npaste F1 F2                                     // F1和F2进行拼接, 是对应行进行拼接,不知直接拼到下面, 默认分割是以tab进行分割的\npast F1 F2 -d \",\"                               // 使用\",\"进行分割\n字数统计\nwc -l xxxx                                      // 统计行数\nwc -w xxxx                                      // 统计单词数\nwc -c xxxx                                      // 统计字符数\nwc xxx                                          // 返回[行数, 单词数, 字符数]\n文本替换 - sed\nsed 's/xxx/***/' FILE                           // 替换每行第一个匹配的字符[将FILE中的xxx替换为***]\nsed 's/xxx/***/g' FILE                          // 替换匹配到的所有的字符\nsed -i 's/xxx/***/' FILE                        // 直接修改原文[上面的写法需要将修改后的内容重定位输出到新的文件才可以保存]\nsed -i '/^$/d' FILE                             // 直接将文件中的空白行删除[文本末尾的空白行没有删除]                   \n\nstr = 9999\nsed  \"s/xx/$str/\" FILE                          // 双引号会替换变量的值, 单引号不会, 会将str替换为9999\nawk数据流处理 awk脚本结构\nawk ' BEGIN{ statements } statements2 END{ statements } '\n\n工作方式 1.执行begin中语句块； 2.从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕； 3.执行end语句块；\n\necho 123 | awk 'BEGIN {print \"Start\"}{ print } END{print \"END\"}'    // 格式很关键,标点,大小写\n print 以逗号分割时，参数以空格定界;\necho|awk '{a=1;b=2;c=\"dasdsa\";print a,b,c;}'\n print字符串拼接\necho|awk '{a=1;b=2;c=\"dasdsa\";print a\" ----***\" b\"----**   \" c;}'\n\n// 输出\n1 ----***2----**   dasdsa\nawk - 特殊变量： NR NF $0 $1 $2 NR:表示记录数量，在执行过程中对应当前行号；\ncat xxx.txt | awk '{print NR}'                          // 输出执行到的行数\ncat xxx.txt | awk '{print NF}'                          // 输出执行的当前行的单词数\ncat xxx.txt | awk '{print $2}'                          // 输出当前行的第2个单词\nNF:表示字段数量，在执行过程总对应当前行的字段数；\n$0:这个变量包含执行过程中当前行的文本内容；\n$1:第一个字段的文本内容；\n$2:第二个字段的文本内容；\n// 每行求和 -e是将转移字符输出出来\necho -e \"1\\n 2\\n 3\\n 4\\n\" |awk 'BEGIN{sum=0;}{sum+=$1;}END{print sum}'          // 输出10\nawk - 传递外部变量\nvar = 9999\necho | awk vara=$var '{print vara}'                     // 传递外部变量, 变量放前后都行,但是不能加括号, 默认来自输入\necho | awk vara=$var '{print vara}' FILE                // 个人使用失败,可能是语法哪里写错了\n用样式对awk处理的行进行过滤\nawk 'NR &lt; 5' #行号小于5\nawk 'NR==1,NR==4 {print}' file #行号等于1和4的打印出来\nawk '/linux/' #包含linux文本的行（可以用正则表达式来指定，超级强大）\nawk '!/linux/' #不包含linux文本的行\n使用-F来设置定界符（默认为空格）\nawk -F: '{print $NF}' /etc/passwd"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#磁盘管理",
    "href": "posts/linux入门基操作/index.html#磁盘管理",
    "title": "linux入门操作",
    "section": "4. 磁盘管理",
    "text": "4. 磁盘管理\n查看磁盘大小以及使用情况 -h: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位\ndf -h                                               // 查看磁盘信息\n当前目录所占大小 -h 人性化显示 -s 递归整个目录的大小\ndu -sh                                              // 当前文件夹占用磁盘大小\n查看当前目录下所有子文件夹排序后的大小:\ndu -sh `ls`| sort                                   // 当前文件夹中的文件按照大小排序\n打包,压缩,解压缩 tar -cvf example.tar example -&gt;将example文件夹归档变成了example.tar - c: create创建档案 - v: verbose显示详情 - f: file表示文件\ntar -cvf example.tar example                        // 只打包不压缩\ngzip xxx.tar                                        // 压缩后生成-&gt; xxx.tar.gz\ngunzip xxx.tar.gz                                   // 解压后-&gt; xxx.tar\ntar -xvf xxx.tar.gz                                 // 解压后-&gt; xxx\ntar 解压参数 -z 解压gz文件 -j 解压bz2文件 -J 解压xz文件"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#进程管理工具",
    "href": "posts/linux入门基操作/index.html#进程管理工具",
    "title": "linux入门操作",
    "section": "5. 进程管理工具",
    "text": "5. 进程管理工具\n查询正在运行的进程\nps -ef                                  // 查询所有进程\nps -ef|prep root                        // 查询root用户的进程\n\npgrep -l ba                             // 查询含有ba关键字的进程-&gt;查询进程ID（适合只记得部分进程字段）\n\nps -ajx                                 // 查看所有信息的完整信息\n\ntop                                     // 实时查看进程信息 实时更新\n查看端口占用情况\nlsof -i:3306                            // 查看3306的端口占用情况\n查看用户username的进程所打开的文件\nlsof -u username\n利用进程名 查看进程使用的文件\nlsof -c mysql                           // 查看mysql进程占用的文件\n利用pid 查看进程使用的文件\nls -i 22                                // 查询占用22号端口的进程\nlsof -p 774                             // 根据进程pid号774查询 文件使用情况\n查询制定文件夹内文件夹的使用进程\nlsof +d ./                              // 查询当前文件夹内的文件使用情况(进程信息)\n结束进程\nlsof -c NAME                            // 查询进程的pid\nkill PID                                // 结束PID进程\n\nCTRL+Z挂起进程并放入后台\njobs 显示当前暂停的进程\nbg %N 使第N个任务在后台运行(%前有空格)\nfg %N 使第N个任务在前台运行 默认bg,fg不带%N时表示对最后一个进程操作! 动态查看-top P：根据CPU使用百分比大小进行排序。 M：根据驻留内存大小进行排序。 i：使top不显示任何闲置或者僵死进程。\n\ntop                                     // top之后按下p/m/i"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#性能监控",
    "href": "posts/linux入门基操作/index.html#性能监控",
    "title": "linux入门操作",
    "section": "6. 性能监控",
    "text": "6. 性能监控\n监控cpu\nsat -u 1 2                              // 查看cpu使用情况, 一秒钟采样两次, ubuntu没有sar需要安装\nvmstart 1 2                             // 和上面等效\n查看内存\nfree                                    // 硬盘使用情况\nfree -m                                 // 内存使用情况"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#网络工具",
    "href": "posts/linux入门基操作/index.html#网络工具",
    "title": "linux入门操作",
    "section": "7. 网络工具",
    "text": "7. 网络工具\n查询网络服务和端口\nnetstat -a                              // 查看所有端口\nnetstat -at                             // 列出所有tcp端口\nnetstat -au                             // 列出所有udp端口\n列出所有监听的服务 - netstat -x [ netstat ] -a 显示所有连接和侦听端口，默认不显示LISTEN相关 -b 显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。在此情况下，可执行程序的名称位于底部 [] 中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在你没有足够权限时可能失败。 -e 显示以太网统计信息。此选项可以与 -s 选项结合使用。\n-i 显示网络接口列表 -n 以数字形式显示地址和端口号。 -o 显示拥有的与每个连接关联的进程 ID。 -p proto 显示 proto 指定的协议的连接；proto可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。 -q 显示所有连接、侦听端口和绑定的非侦听 TCP 端口。绑定的非侦听端口不一定与活动连接相关联。 -r 显示路由表。 -s 显示每个协议的统计信息。默认情况下，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息;-p 选项可用于指定默认的子网。 interval 重新显示选定的统计信息，各个显示间暂停的间隔秒数。按 CTRL+C 停止重新显示统计信息。如果省略，则 netstat 将打印当前的配置信息一次。 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -c 每隔一个固定时间，执行该netstat命令，netstat 将每隔一秒输出网络信息。\nnetstat -l                              // 列出所有监听的服务"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#用户管理工具",
    "href": "posts/linux入门基操作/index.html#用户管理工具",
    "title": "linux入门操作",
    "section": "8. 用户管理工具",
    "text": "8. 用户管理工具\n添加用户\nuseradd -m xxx                          // 添加xxx用户, 单独的添加,没有任何权限 以及密码\n用户切换\nsu xxx                                  // 切换xxx用户\nsu root                                 // 切换root用户\n删除用户\nuserdel -r xxx                          // 删除用户xxx\nlsof -u xxx                             // 查询xxx用户PID \nkill -9 PID                             // 用户无法删除,显示进程占用, 先结束进程, 然后重新删除用户\n权限管理 使用chmod命令更改文件的读写权限，更改读写权限有两种方法，一种是字母方式，一种是数字方式\n分组 - u：用户 - g：组 - o：其它用户 - a：所有用户\n权限 - r:读 - w：写 - x：执行 数字方式：\n数字方式直接设置所有权限，相比字母方式，更加简洁方便；\n使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。\nchmod a+x FILE                          // 对FILE文件的所用户添加可执行程序\nchmod g+x FILE                          // 对组用户添加可执行权限\nchmod 777 FILE                          // 所有权限打开\n修改拥有者\nchown USER File                         // 修改拥有者\nchown -R USER FILE                      // 递归所有文件夹修改拥有者\n环境变量\nbashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。\n\n\n\n全局\n用户\n\n\n\n\nbashrc(不登录) / profile(登录)\nbashrc (不登录) / profile (登录)\n\n\n\n/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile ~/.bashrc用户目录下的私有环境变量设定\n\n\n\n全局\n用户\n\n\n\n\n/etc/profile，/etc/bashrc\n~/.profile ~/.bashrc\n\n\n\n当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:\n首先读入的是全局环境变量设置文件/etc/profile，然后根据其内容读取额外的文档，如/etc/profile.d和/etc/inputrc 读取当前登录用户Home目录下的文件/.bash_profile，其次读取/.bash_login，最后读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系 读取~/.bashrc /.profile与/.bashrc的区别:\n这两者都具有个性化定制功能 ~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次 ~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次"
  },
  {
    "objectID": "posts/linux入门基操作/index.html#系统管理及ipc资源管理",
    "href": "posts/linux入门基操作/index.html#系统管理及ipc资源管理",
    "title": "linux入门操作",
    "section": "9. 系统管理及IPC资源管理",
    "text": "9. 系统管理及IPC资源管理\n查看cpu信息\ncat /etc/cpuinfo                            // 查看cpu信息\n查看内存信息\ncat /etc/meminfo                            // 查看内存信息\n查看cpu架构\narch                                        // 查案CPU架构\nipcs资源查询\nipcs    \n参考: https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html",
    "href": "posts/Ubuntu18版本换源/index.html",
    "title": "Ubuntu18版本换源",
    "section": "",
    "text": "【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 ## 0. Ubuntu版本必须匹配 查看Ubuntu版本命令"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "href": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "title": "Ubuntu18版本换源",
    "section": "1.备份sources.list",
    "text": "1.备份sources.list\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "href": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "title": "Ubuntu18版本换源",
    "section": "2.编辑sources.list（换源）",
    "text": "2.编辑sources.list（换源）\nsudo gedit /etc/apt/sources.list"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "href": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "title": "Ubuntu18版本换源",
    "section": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。",
    "text": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#更新源",
    "href": "posts/Ubuntu18版本换源/index.html#更新源",
    "title": "Ubuntu18版本换源",
    "section": "4.更新源",
    "text": "4.更新源\nsudo apt-get update"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#完成换源",
    "href": "posts/Ubuntu18版本换源/index.html#完成换源",
    "title": "Ubuntu18版本换源",
    "section": "5.完成换源",
    "text": "5.完成换源"
  },
  {
    "objectID": "posts/fdatool/index.html",
    "href": "posts/fdatool/index.html",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "",
    "text": "learning how to use fdatool to design filter."
  },
  {
    "objectID": "posts/fdatool/index.html#低通滤波器",
    "href": "posts/fdatool/index.html#低通滤波器",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "1. 低通滤波器",
    "text": "1. 低通滤波器\n\n用于从信号中删除高频成分，从而只保留低频成分. [高频成分的幅度变小，而低频成分的幅度则不变或变大。]"
  },
  {
    "objectID": "posts/fdatool/index.html#高通滤波器",
    "href": "posts/fdatool/index.html#高通滤波器",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "2. 高通滤波器",
    "text": "2. 高通滤波器\n\n用于从信号中删除低频成分，从而只保留高频成分.[使得低频成分的幅度变小，而高频成分的幅度则不变或变大。]"
  },
  {
    "objectID": "posts/fdatool/index.html#带通滤波器",
    "href": "posts/fdatool/index.html#带通滤波器",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "3. 带通滤波器",
    "text": "3. 带通滤波器\n\n让某一个连续范围内的通过, 旁边的都是要衰减的.(凸)"
  },
  {
    "objectID": "posts/fdatool/index.html#带阻滤波器",
    "href": "posts/fdatool/index.html#带阻滤波器",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "4. 带阻滤波器",
    "text": "4. 带阻滤波器\n\n和带通滤波器相反, 让某一个连续范围内阻碍其通过,旁边的让其通过. (凹)"
  },
  {
    "objectID": "posts/fdatool/index.html#陷波滤波器",
    "href": "posts/fdatool/index.html#陷波滤波器",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "5. 陷波滤波器",
    "text": "5. 陷波滤波器\n\n特殊的滤波器"
  },
  {
    "objectID": "posts/fdatool/index.html#iir-infinite-impulse-response",
    "href": "posts/fdatool/index.html#iir-infinite-impulse-response",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "1. IIR (Infinite Impulse Response)",
    "text": "1. IIR (Infinite Impulse Response)\nIIR 滤波器的输出不仅与其当前输入样本有关，还与其过去的输出样本有关，因此它是一种无限冲激响应滤波器。它通常具有非线性相位，并且比 FIR 滤波器具有更低的时延。\n\n响应快, 输出和当前和过去都有关,具有反馈的, 能够对滤波进行很好的调节, 弊端是不稳定.  各频率之间的相位变化是非线性的"
  },
  {
    "objectID": "posts/fdatool/index.html#fir-finite-impulse-response",
    "href": "posts/fdatool/index.html#fir-finite-impulse-response",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "2. FIR (Finite Impulse Response)",
    "text": "2. FIR (Finite Impulse Response)\nFIR 滤波器的输出只与其输入的有限个样本有关，因此它是一种有限冲激响应滤波器。它通常具有线性相位，但可以实现任意频率响应。\n\n有限脉冲内进行响应, 没有反馈, 所以输出稳定, 但是弊端是计算量大.  各频率之间的相位变化是线性的(a,b 滤波前相差 90 度, 滤波后 a,b 之间的相位差还是 90 度.iir 就不一定是了.[这里有勘误说是 fir 的设计通常是设计成线性的,并不是 fir 本身就是线性的.])"
  },
  {
    "objectID": "posts/fdatool/index.html#阶数",
    "href": "posts/fdatool/index.html#阶数",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "阶数",
    "text": "阶数\n\n\n1. IIR\nIIR 通常不超过 5 阶. 通常选 Minimal, 如果设置阶数太高了就会发散,无法实现效果 \n\n\n2. FIR\n阶数越高越好, 阶数和算力成正比.通常 50,100,200 都是常见的."
  },
  {
    "objectID": "posts/fdatool/index.html#频率域",
    "href": "posts/fdatool/index.html#频率域",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "频率域",
    "text": "频率域\n通过频率域进行滤波."
  },
  {
    "objectID": "posts/fdatool/index.html#低通滤波器案例",
    "href": "posts/fdatool/index.html#低通滤波器案例",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "低通滤波器案例",
    "text": "低通滤波器案例\n\n低通滤波器的 IIR 方法\n\n\n相位变化\n\n\n\n\n低通滤波器的 FIR 方法\n\n\n相位变化"
  },
  {
    "objectID": "posts/fdatool/index.html#高通滤波器-1",
    "href": "posts/fdatool/index.html#高通滤波器-1",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "高通滤波器",
    "text": "高通滤波器\n\n阶数越大效果越好, 但是算力要求也越高"
  },
  {
    "objectID": "posts/fdatool/index.html#带通滤波器-1",
    "href": "posts/fdatool/index.html#带通滤波器-1",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "带通滤波器",
    "text": "带通滤波器"
  },
  {
    "objectID": "posts/fdatool/index.html#带阻滤波器-1",
    "href": "posts/fdatool/index.html#带阻滤波器-1",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "带阻滤波器",
    "text": "带阻滤波器"
  },
  {
    "objectID": "posts/fdatool/index.html#other",
    "href": "posts/fdatool/index.html#other",
    "title": "Filter Design & Analysis Tool(FdaTool)",
    "section": "Other",
    "text": "Other\n\n在实际应用中，FIR 滤波器通常用于实现精确的频率响应，例如在图像处理和音频处理中；而 IIR 滤波器通常用于实现低时延的动态信号处理，例如在通信系统和生物医学工程中。\n总之，FIR 和 IIR 滤波器的选择取决于特定应用的需求和性能要求，应该根据实际需要进行合理选择。"
  },
  {
    "objectID": "posts/小米刷机/index.html",
    "href": "posts/小米刷机/index.html",
    "title": "小米刷机",
    "section": "",
    "text": "https://miuiver.com/how-to-flash-xiaomi-phone/"
  },
  {
    "objectID": "posts/小米刷机/index.html#右下角注意别选择第三项重新上bl锁",
    "href": "posts/小米刷机/index.html#右下角注意别选择第三项重新上bl锁",
    "title": "小米刷机",
    "section": "右下角注意别选择第三项(重新上BL锁)",
    "text": "右下角注意别选择第三项(重新上BL锁)\n # bilibili视频地址 https://www.bilibili.com/video/BV1BY4y1H7Mc?spm_id_from=333.337.search-card.all.click&vd_source=c0157a4afd2e47c7662431fd9d2739fb"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "",
    "text": "编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n账户上有100, A取要90,B要取80;\n连个人同时看到都有100.都可以取出,\n所以问题就产生了.\n解决方案:\n锁块,对account上锁,只能一个线程对account操作.[同步块]\n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n * 账户上有100, A取要90,B要取80;\n * 连个人同时看到都有100.都可以取出,\n * 所以问题就产生了.\n *\n * 解决方案:\n *    锁块,对account上锁,只能一个线程对account操作.[同步块]\n * */\n\npublic class UnSafeBank {\n\n    public static void main(String[] args) {\n        Account account = new Account(100,\"旅游基金\");\n        Drawing a = new Drawing(account, 90);\n        Drawing b = new Drawing(account, 80);\n        new Thread(a, \"A\").start();\n        new Thread(b, \"B\").start();\n    }\n}\n\n// 账户\nclass Account {\n    int money;\n    String name;\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n\n// 银行\nclass Drawing implements Runnable{\n\n    final Account account;\n    int drawMoney;\n    int nowMoney=0;\n\n\n    public Drawing(Account account, int drawMoney) {\n        this.account = account;\n        this.drawMoney = drawMoney;\n\n    }\n\n    @Override\n    public void run() {\n        synchronized (account){   // 锁块,对account上锁,只能一个线程对account操作.\n            System.out.println(Thread.currentThread().getName()+\"要取出\"+drawMoney);\n            // 判断是否够取出的\n            if (account.money-drawMoney&lt;0){\n                System.out.println(Thread.currentThread().getName()+\"==输入的金额有问题,取不了\");\n                return;\n            }\n\n            // 现在手上的钱\n            nowMoney = nowMoney+drawMoney;\n            System.out.println(Thread.currentThread().getName()+\"现在手上:\"+nowMoney);\n\n            // 现在的卡内余额\n            account.money=account.money-drawMoney;\n            System.out.println(account.name+\"余额:\"+account.money);\n        }\n\n\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#银行账户同时取钱问题",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#银行账户同时取钱问题",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "",
    "text": "编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n账户上有100, A取要90,B要取80;\n连个人同时看到都有100.都可以取出,\n所以问题就产生了.\n解决方案:\n锁块,对account上锁,只能一个线程对account操作.[同步块]\n\npackage cn.usts.edu.lesson07;\n\n/**\n * 编程模型: A,B共有一个账户,俩人一块要取钱,都在手机上操作\n * 账户上有100, A取要90,B要取80;\n * 连个人同时看到都有100.都可以取出,\n * 所以问题就产生了.\n *\n * 解决方案:\n *    锁块,对account上锁,只能一个线程对account操作.[同步块]\n * */\n\npublic class UnSafeBank {\n\n    public static void main(String[] args) {\n        Account account = new Account(100,\"旅游基金\");\n        Drawing a = new Drawing(account, 90);\n        Drawing b = new Drawing(account, 80);\n        new Thread(a, \"A\").start();\n        new Thread(b, \"B\").start();\n    }\n}\n\n// 账户\nclass Account {\n    int money;\n    String name;\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n\n// 银行\nclass Drawing implements Runnable{\n\n    final Account account;\n    int drawMoney;\n    int nowMoney=0;\n\n\n    public Drawing(Account account, int drawMoney) {\n        this.account = account;\n        this.drawMoney = drawMoney;\n\n    }\n\n    @Override\n    public void run() {\n        synchronized (account){   // 锁块,对account上锁,只能一个线程对account操作.\n            System.out.println(Thread.currentThread().getName()+\"要取出\"+drawMoney);\n            // 判断是否够取出的\n            if (account.money-drawMoney&lt;0){\n                System.out.println(Thread.currentThread().getName()+\"==输入的金额有问题,取不了\");\n                return;\n            }\n\n            // 现在手上的钱\n            nowMoney = nowMoney+drawMoney;\n            System.out.println(Thread.currentThread().getName()+\"现在手上:\"+nowMoney);\n\n            // 现在的卡内余额\n            account.money=account.money-drawMoney;\n            System.out.println(account.name+\"余额:\"+account.money);\n        }\n\n\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#网上买票问题",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#网上买票问题",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "网上买票问题",
    "text": "网上买票问题\n不安全的买票机制 * 如果网络拥堵导致网络延时,会使得对于tickets的读取有问题, * 对于并发生的问题就是排队和上锁 * 解决方案: * 在方法前加上 synchronized 同步方法,锁的是this  [同步方法]\npackage cn.usts.edu.lesson07;\n\n/**\n * 不安全的买票机制\n * 如果网络拥堵导致网络延时,会使得对于tickets的读取有问题,\n * 对于并发生的问题就是排队和上锁\n *\n * 解决方案:\n *   在方法前加上 synchronized 同步方法,锁的是this  [同步方法]\n * */\n\npublic class UnSafeBuyTickets {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets,\"小明\").start();\n        new Thread(buyTickets,\"小红\").start();\n        new Thread(buyTickets,\"黄牛\").start();\n\n    }\n}\n\nclass  BuyTickets implements Runnable{\n    // 100张票\n    int tickets = 10;\n    boolean flag = true;\n\n    @Override\n    public void run() {\n        while (flag){\n            buy();\n        }\n    }\n\n\n    // 在方法前加上 synchronized 同步方法,锁的是this\n    public  void buy(){\n\n        if (tickets&lt;=0){\n            flag=false;\n            return; // 程序到这结束\n        }\n        try {\n            Thread.sleep(100);// 模拟网络延时,放大问题\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName()+tickets--);\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#线程不安全集合",
    "href": "posts/java多线程-- 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)/index.html#线程不安全集合",
    "title": "java多线程– 线程不安全三大案例(银行账户同时取钱问题 、 网上买票问题 、 线程不安全集合)(同步块,同步方法)",
    "section": "线程不安全集合",
    "text": "线程不安全集合\n\n每次执行都无法达到理想的数字,是什么原因,\n是因为反应太快,导致不同线程对同一个list中的位置进行修改,导致了覆盖.\n解决方案:\n添加锁块,等待线程结束\n\npackage cn.usts.edu.lesson07;\n\n/**\n * 每次执行都无法达到理想的数字,是什么原因,\n * 是因为反应太快,导致不同线程对同一个list中的位置进行修改,导致了覆盖.\n *\n * 解决方案:\n *      添加锁块,等待线程结束.\n * */\n\nimport java.util.ArrayList;\n\npublic class UnSafeList {\n    public static void main(String[] args) {\n        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();\n\n\n        for (int i = 0; i &lt; 10000; i++) {\n\n\n                new Thread(()-&gt;{// 每次循环启动一个线程,并写线程名\n                    synchronized (arrayList){\n                        arrayList.add(Thread.currentThread().getName());//写入线程名\n                    }\n\n                }).start();\n        }\n        try {\n            Thread.sleep(1000);//等待线程跑完,不加可能线程没跑完就打印出来了\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(arrayList.size());// 查看list的大小(list中有多少个线程名)\n    }\n}"
  },
  {
    "objectID": "posts/elf文件解析/index.html",
    "href": "posts/elf文件解析/index.html",
    "title": "elf 文件解析",
    "section": "",
    "text": "Abstract\n对elf文件的解析, 具体包括:elfhead, 节头表, 程序头表\n\n\nReferance\n计算机系统基础(袁春风)\n\n\nELF文件\n\n\n\nELF文件类型\n\n节（section）是ELF 文件中具有相同特征的最小可处理单位.text节: 代码.data节: 数据.rodata: 只读数据.bss: 未初始化数据\n\n\n由不同的段（segment）组成，描述节如何映射到存储段中，可多个节映射到同一段，如：可合并.data节和.bss节,并映射到一个可读可写数据段中\n\n总结: 节是在链接视图的时候的概念, 段是在执行视图的时候的概念, 段就是将许多个相同的节放在一起就构成了段.\n\n\nELF头（ELF Header）\nELF头位于ELF文件开始，包含文件结构说明信息 。分32位系统对应结构 和64位系统对应结构（32位版本、64位版本）\n\n\n以下是32位系统对应的数据结构\n#define EI_NIDENT 16\n\ntypedef struct {\nunsigned char e_ident[EI_NIDENT];\nElf32_Half e_type;\nElf32_Half e_machine;\nElf32_Word e_version;\nElf32_Addr e_entry;\nElf32_Off e_phoff;\nElf32_Off e_shoff;\nElf32_Word e_flags;\nElf32_Half e_ehsize;\nElf32_Half e_phentsize;\nElf32_Half e_phnum;\nElf32_Half e_shentsize;\nElf32_Half e_shnum;\nElf32_Half e_shstrndx;\n} Elf32_Ehdr;\n对应到下面的头文件中\nreadelf -h mian.o (//可重定位文件)\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          824 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           40 (bytes)\n  Number of section headers:         16\n  Section header string table index: 15\nMagic：文件开头几个字节通常用来确定文件的类型或格式a.out的魔数：01H 07HPE格式魔数：4DH 5AH加载或读取文件时，可用魔数确认文件类型是否正确"
  },
  {
    "objectID": "posts/linux_device_auth/index.html",
    "href": "posts/linux_device_auth/index.html",
    "title": "linux usb or other device auth how to control",
    "section": "",
    "text": "debug with pico in linux i meet such trouble. the auth of usb is a big trouble. i got some answer from chatGpt,and stolve the proublem."
  },
  {
    "objectID": "posts/linux_device_auth/index.html#why-named-the-file-like-99-xxxxx.rules",
    "href": "posts/linux_device_auth/index.html#why-named-the-file-like-99-xxxxx.rules",
    "title": "linux usb or other device auth how to control",
    "section": "why named the file like 99-xxxxx.rules",
    "text": "why named the file like 99-xxxxx.rules\n\n99 means priority of those rules file of this dir. 0 means the highest priority."
  },
  {
    "objectID": "posts/linux_device_auth/index.html#what-is-udevpath",
    "href": "posts/linux_device_auth/index.html#what-is-udevpath",
    "title": "linux usb or other device auth how to control",
    "section": "what is udevpath",
    "text": "what is udevpath\n\nudev 是 Linux 系统中的一个动态设备管理系统。udev 系统的主要目的是为了方便内核中的驱动程序管理和设备节点的创建与删除。在 Linux 系统中，udev 系统会负责将 Linux 系统中所有的硬件设备（包括磁盘、USB 设备、网卡、键盘、鼠标等等）都转换成相应的设备文件（如/dev/sda、/dev/ttyUSB0 等等）。\nudev 系统的配置文件和规则文件都存放在 /etc/udev/rules.d/ 目录下。在这个目录下，可以添加或修改 udev 规则文件，以便根据需要对设备进行自定义的配置和管理"
  },
  {
    "objectID": "posts/linux_device_auth/index.html#how-many-kinds-of-subsystem",
    "href": "posts/linux_device_auth/index.html#how-many-kinds-of-subsystem",
    "title": "linux usb or other device auth how to control",
    "section": "how many kinds of SUBSYSTEM",
    "text": "how many kinds of SUBSYSTEM\n\nSUBSYSTEM 参数的取值可以有很多种，以下是一些常见的取值及其含义：\n\n\nblock：块设备，如硬盘、U 盘等。\ninput：输入设备，如鼠标、键盘等。\nnet：网络设备，如网卡、无线网卡等。\ntty：终端设备，如串口、串口转 USB 等。\nusb：USB 设备。\nsound：声音设备，如扬声器、麦克风等。\n\n\n除了以上这些常见的子系统外，还有一些其他的子系统，如 drm、hid、video4linux 等，它们的含义和用途也各不相同。\n需要注意的是，SUBSYSTEM 参数的取值不是固定的，具体取值取决于您要匹配的设备类型。可以通过 lsusb、lspci 等命令查看设备的相关信息，来确定要使用哪种子系统进行匹配。"
  },
  {
    "objectID": "posts/linux_device_auth/index.html#why-is-0666-not-666",
    "href": "posts/linux_device_auth/index.html#why-is-0666-not-666",
    "title": "linux usb or other device auth how to control",
    "section": "why is 0666 not 666",
    "text": "why is 0666 not 666\n\n在 udev 规则中，使用 MODE 来指定设备节点的权限。MODE 的值必须是八进制数。因此，如果要设置一个文件或设备节点的权限为 666，在八进制中就是 0666。\n因此，MODE=“0666” 与 MODE=“666” 的效果是一样的，都是将文件或设备节点的权限设置为所有用户都可读可写。"
  },
  {
    "objectID": "posts/linux_device_auth/index.html#auth-of-node",
    "href": "posts/linux_device_auth/index.html#auth-of-node",
    "title": "linux usb or other device auth how to control",
    "section": "auth of NODE",
    "text": "auth of NODE\n\n在 Linux 系统中，mode 是一种用于控制文件和目录权限的参数。它的取值是一串三位数字，分别代表文件所有者、文件所有者所在组、其他用户对文件或目录的权限。其中，每一位的值分别可以是以下几个值：\n\n\n0：表示没有任何权限。\n1：表示执行权限。\n2：表示写权限。\n3：表示执行权限和写权限。\n4：表示读权限。\n5：表示执行权限和读权限。\n6：表示读权限和写权限。\n7：表示读权限、写权限和执行权限。\n\n\n使用 chmod 命令可以修改文件或目录的权限，例如：\nchmod 777 file.txt：将 file.txt 文件的权限设置为所有用户都可以读、写、执行。 chmod 755 dir：将 dir 目录的权限设置为所有者可读、写、执行，其他用户可读、执行。 chmod u+x script.sh：将 script.sh 脚本文件的权限添加给文件所有者，即添加执行权限。 除了上述的基本权限之外，还有一些特殊权限，如 SUID、SGID、SBIT 等，可以用于特殊的权限管理需求"
  },
  {
    "objectID": "posts/vscode_tab_candidate/index.html",
    "href": "posts/vscode_tab_candidate/index.html",
    "title": "vscode candidate key: tab && shift tab",
    "section": "",
    "text": "Abstract\nvscode use ↑↓↔︎ to choose the candidate item, that makes me so crazy. i want to candidate as vim: tab\n\n\nReferance\ntexthttps://blog.csdn.net/juzipidemimi/article/details/106755117\n\n\nfix the proublem\nwe need to config the keyboard shortcuts\nconfig -&gt; keyboard shortcuts –&gt; append the following code block to keyboard shortcuts.json\n{\n       \"key\": \"tab\",\n       \"command\": \"selectnextsuggestion\",\n       \"when\": \"editorTextFocus && suggestWidgetMultipleSuggestions && suggestWidgetVisible\"\n},\n{\n       \"key\": \"shift+tab\",\n       \"command\": \"selectPrevSuggestion\",\n       \"when\": \"editorTextFocus && suggestWidgetMultipleSuggestions && suggestWidgetVisible\"\n}"
  },
  {
    "objectID": "posts/alu整数加法_减法/index.html",
    "href": "posts/alu整数加法_减法/index.html",
    "title": "alu整数加法_减法",
    "section": "",
    "text": "加法:\n无符号: - cf 最高进位和sub位, 异或\n有符号: - of: 最高为是否相同, 符号位溢出 - 最高位进位和次高位进位 异或 1溢出,0不溢出 \n\n\n总结:\n有符号看of: 看最高位进位和次高位进行异或(相异为1)结果 为1溢出 无符号看cf: 看最高位进位和sub位(被+数是否为负的那个位), 进行异或, 结果 为1溢出"
  },
  {
    "objectID": "posts/pyqt5 --04QObje对象的父子关系使用/index.html",
    "href": "posts/pyqt5 --04QObje对象的父子关系使用/index.html",
    "title": "pyqt5 –04QObje对象的父子关系使用",
    "section": "",
    "text": "from PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject父子对象学习')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        objA = QObject()\n        objA.setObjectName('A对象')\n\n        objB = QObject()\n        objB.setObjectName('B对象')\n\n        objC = QObject()\n        objC.setObjectName('C对象')\n\n        # B---&gt;A\n        objB.setParent(objA)\n\n        # C---&gt;B\n        objC.setParent(objB)\n        # objC.children(objA) # 设置子类\n        \n        print('B----&gt;',objB.parent().objectName())\n        print('C----&gt;',objC.parent().objectName())\n        print(objA.findChild(QObject))# A的【直接】QObject类型的子类是\n        print(objA.findChildren(QObject))# A的【所有】QObject类型的子类是\n        \n\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Linux下_终端_终端模拟器_shell_bash的区别/index.html",
    "href": "posts/Linux下_终端_终端模拟器_shell_bash的区别/index.html",
    "title": "Linux下_终端_终端模拟器_shell_bash的区别",
    "section": "",
    "text": "总结\n\n终端: 发送并接收键盘输入, 并渲染处理后的结果 shell: 执行终端发送过来的命令, 并把结果返回给终端. 终端模拟器: 由于在图形界面上第一个终端已经运行图形界面程序了, 所以需要使用第二个终端, 于是终端模拟器的作用就是模拟终端键盘输入发送给shell,渲染返回结果, 但是终端模拟器的出现有种种原因, 速度更快, 显示更好….. bash: 实际是shell的一种实现.\n\n\n\n番外\n\n任何一个linux下都有多个终端\n切换终端ctrl+clt+F1切换别的终端进行 把F1替换为F2 ,F3….\n\n\n图形界面(xserver)的linux\n默认第一个终端运行的就是xserver(图形界面)程序\n\n\n没有xserver的Linux\n默认运行的就是一个命令行 #### shell shell接收终端发送过来的命令并解析, 然后将结果返回给终端"
  },
  {
    "objectID": "posts/java- 贪吃蛇/index.html",
    "href": "posts/java- 贪吃蛇/index.html",
    "title": "java- 贪吃蛇",
    "section": "",
    "text": "贪吃蛇小游戏\n\n效果截图\n\n\n\n在这里插入图片描述\n\n\n\n\n过程中遇到的问题\n1、frame.setVisible(true);// 一定要放最后!!!!!!! 否则会在程序运行时出现灰色界面，需要动一下框才行。 2、食物的随机刷新就会导致食物随机刷新会刷新到蛇的身体上【还未解决】 3、maven项目的静态资源加载问题，无法让文件加载到classes文件夹中。需要修改pom.xml文件\n&lt;!--所有文件复制到classes下--&gt;\n    &lt;build&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;**/*.java&lt;/exclude&gt;\n                &lt;/excludes&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n项目上传在码云上: 项目地址"
  },
  {
    "objectID": "posts/java EE请求转发（转发和重定向）/index.html",
    "href": "posts/java EE请求转发（转发和重定向）/index.html",
    "title": "java EE请求转发（转发和重定向）",
    "section": "",
    "text": "请求转发和请求重定向的区别是： 请求转发只有一次请求，请求重定向有两次请求。 # 1、 请求转发 方法实现 将RequestFrowardServlet里的company的值转发给ResaultServlet展示  域对象：在一定范围内可以存值和取值 request域对象：在一次请求中可以存值和取值。\n存值： request.setAttribute(String key, Object obj)\n取值： Object obj = request.getAttribute(String key, Object obj)\n删除值： request.removeAttRibute(String key)\nRequestFrowardServlet\n// 获取转发对象\nRequestDispatcher  rd = request.getRequestDispatcher(\"/resault\");\n// 调用转发方法，实现转发效果\nrequest.setAttribute(\"company\",\"abc公司\");\nrd.forward(request, response);\nResaultServlet\n// 处理响应中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取并转换获取的company所对应的的值\nString name = (String) request.getAttribute(\"company\");\n// 输出到页面\nresponse.getWriter().write(name);\n\n2、 请求重定向 方法实现\n将RequestFrowardServlet里的company的值转发给ResaultServlet展示 RequestFrowardServlet\n// 重定向\nresponse.sendRedirect(\"welcom\");\nResaultServlet\n// 处理响应中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取转发过来的参数\nString usr = request.getParameter(\"username\");\nString psd = request.getParameter(\"password\");\n// 打印参数\nresponse.getWriter().write(usr+\"&lt;br&gt;\");\nresponse.getWriter().write(psd+\"&lt;br&gt;\");"
  },
  {
    "objectID": "posts/darknet-配置部署/index.html",
    "href": "posts/darknet-配置部署/index.html",
    "title": "darknet-配置部署",
    "section": "",
    "text": "项目测试图片：  # 运行环境 系统：win11 CPU：AMD Ryzen 7 5800 GPU：nvidia3060 OpenCV：4.5.3 VsStudio：2022 # clone项目\ngit clone https://github.com/AlexeyAB/darknet.git\n #"
  },
  {
    "objectID": "posts/darknet用公共数据集训练自己的模型/index.html",
    "href": "posts/darknet用公共数据集训练自己的模型/index.html",
    "title": "darknet用公共数据集训练自己的模型",
    "section": "",
    "text": "### 修改配置train_label.py保修需要的类.然后执行\npython train_label.py # 执行后即可出线`.txt`文件,如果遇到报错请查看数据集的位置是否正确.\n ### 修改v3_tiny_obj.names文件  ### 修改v3_tiny_obj.data文件  ### 生成yolov3-tiny.conv.15文件 (预训练权重的提取)\ndarknet partial data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.weights data/voc/yolov3-tiny.conv.15 15\n #### 修改yolov3-tiny_obj.cfg 锚点计算,普通版本9, tiny 6\ndarknet detector calc_anchors data/voc/v3_tiny_obj.data -num_of_clusters 6 -width 416 -height 416\n修改内容如下\n[net]\n# Testing\n#batch=1\n#subdivisions=1\n# Training\n# 根据电脑性能修改大小,  batch = 8*n\nbatch=64\n# 根据电脑性能调整大小\nsubdivisions=2    \nwidth=416\nheight=416\nchannels=3\nmomentum=0.9\ndecay=0.0005\nangle=0\nsaturation = 1.5\nexposure = 1.5\nhue=.1\n\nlearning_rate=0.001\nburn_in=1000\n#max_batches = 500200\n#steps=400000,450000\n# 训练步数\nmax_batches = 10000\npolicy=steps\n# 训练到相应次数后学习率变化\nsteps=4000,8000\nscales=.1,.1\n\n[convolutional]\nbatch_normalize=1\nfilters=16\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=2\n\n[convolutional]\nbatch_normalize=1\nfilters=32\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=2\n\n[convolutional]\nbatch_normalize=1\nfilters=64\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=2\n\n[convolutional]\nbatch_normalize=1\nfilters=128\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=2\n\n[convolutional]\nbatch_normalize=1\nfilters=256\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=2\n\n[convolutional]\nbatch_normalize=1\nfilters=512\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[maxpool]\nsize=2\nstride=1\n\n[convolutional]\nbatch_normalize=1\nfilters=1024\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n###########\n\n[convolutional]\nbatch_normalize=1\nfilters=256\nsize=1\nstride=1\npad=1\nactivation=leaky\n\n[convolutional]\nbatch_normalize=1\nfilters=512\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[convolutional]\nsize=1\nstride=1\npad=1\n# classes:训练类别数:   filters=3*((classes+5)\nfilters=18\nactivation=linear\n\n\n\n[yolo]\nmask = 3,4,5\n# 锚点位置计算\nanchors = 23, 63,  57,138,  90,255, 160,179, 165,321, 310,361\n# 根据自己设定的类别数修改\nclasses=1\nnum=6\njitter=.3\nignore_thresh = .7\ntruth_thresh = 1\nrandom=1\n\n[route]\nlayers = -4\n\n[convolutional]\nbatch_normalize=1\nfilters=128\nsize=1\nstride=1\npad=1\nactivation=leaky\n\n[upsample]\nstride=2\n\n[route]\nlayers = -1, 8\n\n[convolutional]\nbatch_normalize=1\nfilters=256\nsize=3\nstride=1\npad=1\nactivation=leaky\n\n[convolutional]\nsize=1\nstride=1\npad=1\n# classes:训练类别数:   filters=3*((classes+5)\nfilters=18\nactivation=linear\n\n[yolo]\n# mask = 0,1,2\nmask = 1,2,3\n# 锚点位置计算\nanchors = 23, 63,  57,138,  90,255, 160,179, 165,321, 310,361\nclasses=1\nnum=6\njitter=.3\nignore_thresh = .7\ntruth_thresh = 1\nrandom=1\n\n\n\n\n\n\n\n\n\ndarknet_no_gpu detector train data/voc/v3_tiny_obj.data data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.conv.15\n\n\n\n在这里插入图片描述\n\n\n\n\n修改工程文件中的makeFile文件  #### makeFile中修改内容如下  ### 开始训练 ## 在darknet.exe所在的路径下打开cmd执行一下命令!!!!!!!\ndarknet detector train data/voc/v3_tiny_obj.data data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.conv.15\n训练效果:   ### 训练完权重文件存放路径"
  },
  {
    "objectID": "posts/darknet用公共数据集训练自己的模型/index.html#在darknet.exe所在的路径下打开cmd执行一下命令",
    "href": "posts/darknet用公共数据集训练自己的模型/index.html#在darknet.exe所在的路径下打开cmd执行一下命令",
    "title": "darknet用公共数据集训练自己的模型",
    "section": "",
    "text": "darknet_no_gpu detector train data/voc/v3_tiny_obj.data data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.conv.15\n\n\n\n在这里插入图片描述\n\n\n\n\n修改工程文件中的makeFile文件  #### makeFile中修改内容如下  ### 开始训练 ## 在darknet.exe所在的路径下打开cmd执行一下命令!!!!!!!\ndarknet detector train data/voc/v3_tiny_obj.data data/voc/yolov3-tiny_obj.cfg data/voc/yolov3-tiny.conv.15\n训练效果:   ### 训练完权重文件存放路径"
  },
  {
    "objectID": "posts/quarto/index.html",
    "href": "posts/quarto/index.html",
    "title": "quarto",
    "section": "",
    "text": "picgo（图床）\n    // picogo config\n    \"picgo.picBed.current\": \"github\",\n    \"picgo.picBed.github.token\": \"gxxxxxxxx\",\n    \"picgo.picBed.github.repo\": \"fly-t/blog\",\n    \"picgo.picBed.github.branch\": \"master\",\n    \"picgo.customUploadName\": \"${mdFileName}-${dateTime}${extName}\",\n    \"picgo.picBed.github.path\": \"images/\",\n    \"picgo.customOutputFormat\": \"![](${url})\",\n\n\ngithu连接问题\ngithub push不支持账号密码，使用token\n[core]\n    repositoryformatversion = 0\n    filemode = false\n    bare = false\n    logallrefupdates = true\n    ignorecase = true\n[remote \"origin\"]\n    url = https://ellisonpei:这里填access_token@github.com/项目名/项目名.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\n    remote = origin\n    merge = refs/heads/master\n[user]\n    name = aa5279aa\n    email = xxxx@qq.com\n[branch \"develop\"]\n    remote = origin\n    merge = refs/heads/develop\n[credential]\n    helper =\n\n\n这里没有反应， 关掉代理重新尝试\nquarto publish gh-pages\n\n\ngithub action 自动部署\n_quarto.yml\nexecute: \n  freeze: auto\n创建该目录并创建文件\n// 项目根目录\nmkdir .github/workflows\ncd \ntouch .github/workflows/publish.yml\n.github/workflows/publish.yml\non:\n  workflow_dispatch:\n  push:\n    branches: main\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v2\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n git config --global credential.helper store                              \n vim .gitconfig\n// close\ngit config --system --unset credential.helper\n\ngit config --global http.proxy 'http://127.0.0.1:7890'\ngit config --global https.proxy 'http://127.0.0.1:7890'\n修改上传快捷键 \n\n\n参考\n设置github push https://www.jianshu.com/p/3b4f7619999e 显示。git：https://blog.csdn.net/Mrs_chens/article/details/101191893\nQuarto 官方部署流程：https://quarto.org/docs/publishing/github-pages.html GitHub Pages: https://docs.github.com/cn/pages GitHub Actions: https://docs.github.com/cn/actions workflows 字段介绍：https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions"
  },
  {
    "objectID": "posts/pyqt5 --02面向对象的设计思想/index.html",
    "href": "posts/pyqt5 --02面向对象的设计思想/index.html",
    "title": "pyqt5 –02面向对象的设计思想",
    "section": "",
    "text": "import sys\nfrom PyQt5.Qt import *\n\"\"\"\n    面向对象的设计思想\n\"\"\"\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('标题名称')\n        self.resize(600,700)\n        self.func_list()\n\n    # 方法通过func_list调用\n    def func_list(self):\n        self.func1()\n        self.func2()\n\n    # 标签控件\n    def func1(self):\n        label = QLabel(self)\n        label.setText('标签上的文字')\n        label.move(100,100)\n        label.setStyleSheet('background-color:red;')\n\n    # 按钮控件\n    def func2(self):\n        btn = QPushButton(self)\n        btn.setStyleSheet('background:blue;')\n        btn.resize(100,100)\n        btn.setText('按钮文字')\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n\n    # sys.argv可以接收用户命令行启动时所输入的参数，根据参数执行不同程序\n    # qApp 为全局对象\n    print(sys.argv)\n    print(app.arguments())\n    print(qApp.arguments())\n    # 以上三个输出结果是一样的\n\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())  # 0是正常退出\n    # app.exec_()  进行循环\n    # sys.exit()   检测退出原因\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html",
    "href": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html",
    "title": "java注解和反射– 利用反射来 实例化对象,调用功能方法,设置属性",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.setClassMethod06;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 利用反射来  实例化对象,调用功能方法,设置属性\n *                 newInstance() 的本质是利用无参构造器,构造对象的,没有无参构造器,是无法构造的\n *                 参数用private修饰的要 修改程序安全监测为ture,默认false是开启检测\n * @date ：2021/10/28 15:51\n */\npublic class SetClass {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        // 获取Class对象\n        Class&lt;?&gt; c1 = Class.forName(\"cn.usts.edu.setClassMethod06.User\");\n        // 反射实例化对象 Object o = c1.newInstance();\n        User user = (User) c1.newInstance();//将Object对象转化成我们的User对象\n        System.out.println(user);\n\n        // 通过构造器构造\n        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class,String.class);\n        User user1 = (User) declaredConstructor.newInstance(15, \"小明\");\n        System.out.println(\"反射构造器构造\"+user1);\n\n        //通过反射调用方法\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        method03.setAccessible(true); //  参数用private修改的要 修改程序安全监测为ture,默认false是开启检测\n        method03.invoke(user1,\"利用反射调用方法\");//invoke激活, (操作对象,方法中的参数)\n\n        // 通过反射设置属性\n        Field name = c1.getDeclaredField(\"name\");\n        Field age = c1.getDeclaredField(\"age\");\n        age.setAccessible(true);\n        name.setAccessible(true); // 每修改一个就要设置一个\n        name.set(user1,\"反射直接修改属性的值\");\n        age.set(user1,18);\n        System.out.println(user1.getAge());\n        System.out.println(user1.getName());\n\n\n\n    }\n}\n\n// pojo 实体类\nclass User {\n    public int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html#利用反射来-实例化对象调用功能方法设置属性",
    "href": "posts/java注解和反射-- 利用反射来 实例化对象,调用功能方法,设置属性/index.html#利用反射来-实例化对象调用功能方法设置属性",
    "title": "java注解和反射– 利用反射来 实例化对象,调用功能方法,设置属性",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.setClassMethod06;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：fly\n * @description: 利用反射来  实例化对象,调用功能方法,设置属性\n *                 newInstance() 的本质是利用无参构造器,构造对象的,没有无参构造器,是无法构造的\n *                 参数用private修饰的要 修改程序安全监测为ture,默认false是开启检测\n * @date ：2021/10/28 15:51\n */\npublic class SetClass {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        // 获取Class对象\n        Class&lt;?&gt; c1 = Class.forName(\"cn.usts.edu.setClassMethod06.User\");\n        // 反射实例化对象 Object o = c1.newInstance();\n        User user = (User) c1.newInstance();//将Object对象转化成我们的User对象\n        System.out.println(user);\n\n        // 通过构造器构造\n        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class,String.class);\n        User user1 = (User) declaredConstructor.newInstance(15, \"小明\");\n        System.out.println(\"反射构造器构造\"+user1);\n\n        //通过反射调用方法\n        Method method03 = c1.getDeclaredMethod(\"method03\", String.class);\n        method03.setAccessible(true); //  参数用private修改的要 修改程序安全监测为ture,默认false是开启检测\n        method03.invoke(user1,\"利用反射调用方法\");//invoke激活, (操作对象,方法中的参数)\n\n        // 通过反射设置属性\n        Field name = c1.getDeclaredField(\"name\");\n        Field age = c1.getDeclaredField(\"age\");\n        age.setAccessible(true);\n        name.setAccessible(true); // 每修改一个就要设置一个\n        name.set(user1,\"反射直接修改属性的值\");\n        age.set(user1,18);\n        System.out.println(user1.getAge());\n        System.out.println(user1.getName());\n\n\n\n    }\n}\n\n// pojo 实体类\nclass User {\n    public int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public void method01(){\n        System.out.println(\"method01\");\n    }\n\n    public void method01(int age){\n        System.out.println(\"method02\"+this.age+age);\n    }\n\n    private void method03(String name){\n        System.out.println(name+\"method03\"+this.name);\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name=\" + name +\n                '}';\n    }\n}"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "cat /etc/group/ | grep 查询字段\n\n\n\nadduser a\ngroupadd GroupName\nusermod -g GroupName a\n\n\n\n# 默认初始位置位改为/home/test/\nusermod -d /home/test/\n\n\n\nid 用户名"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#查看分组",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#查看分组",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "cat /etc/group/ | grep 查询字段"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#改变用户所在组",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#改变用户所在组",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "adduser a\ngroupadd GroupName\nusermod -g GroupName a"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#改变初始登陆位置",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#改变初始登陆位置",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "# 默认初始位置位改为/home/test/\nusermod -d /home/test/"
  },
  {
    "objectID": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#查看分组-1",
    "href": "posts/linux--改变用户所在组(改变登陆初始位置)/index.html#查看分组-1",
    "title": "linux–改变用户所在组(改变登陆初始位置)",
    "section": "",
    "text": "id 用户名"
  },
  {
    "objectID": "posts/nvim打造c语言环境/index.html",
    "href": "posts/nvim打造c语言环境/index.html",
    "title": "nvim打造c语言环境",
    "section": "",
    "text": "sudo apt update\nsudo apt -y upgrade\nsudo apt install -y neovim\nsudo apt install -y vim \n# 修改bashrc文件\nnvim ~/.bashrc\n# 修改内容如下\nalias vm='vim'\nalias nm='nvim'\nsource ~/.bashrc\n# 刷新\nsource ~/.bashrc\n\n创建配置文件夹\nmkdir ~/.config/nvim\nnvim ~/.config/nvim/init.vim"
  },
  {
    "objectID": "posts/java多线程--龟兔赛跑/index.html",
    "href": "posts/java多线程--龟兔赛跑/index.html",
    "title": "java多线程–龟兔赛跑",
    "section": "",
    "text": "package cn.usts.edu.lesson03;\n\n/**\n * 龟兔赛跑多线程来实现\n * 乌龟和兔子分别在不同的线程,同时开始\n * */\n\npublic class TortoiseRabbitRace implements Runnable{\n    String winner;\n\n    @Override\n    public void run() {\n        for (int i = 1; i &lt; 101; i++) {\n            boolean flag = gameIsOver(i);\n            System.out.println(Thread.currentThread().getName()+\"跑了\"+i+\"步\");\n\n            // 兔子会偷懒,兔子偷懒100毫秒\n            if (Thread.currentThread().getName().equals(\"兔子\")){\n                try {\n                    Thread.sleep(100);//偷懒0.1秒\n                    i+=30;// 兔子跑的快\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (flag){\n                break;\n            }\n        }\n    }\n\n    // 判断比赛是否结束\n    public boolean gameIsOver(int steps){\n        if (winner!=null){   // 没有获胜者----&gt;gameIsOver=ture;\n            return true;\n        }else if(steps&gt;=100) {\n             // 有人到达终点\n                winner = Thread.currentThread().getName();\n                System.out.println(\"winner is -----&gt;\"+winner);\n                return true;\n            }\n        return false;\n    }\n\n\n    public static void main(String[] args) {\n        TortoiseRabbitRace race = new TortoiseRabbitRace();\n        new Thread(race,\"兔子\").start();\n        new Thread(race,\"乌龟\").start();\n    }\n}"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html",
    "href": "posts/Eclipse中配置Tomcat/index.html",
    "title": "Eclipse中配置Tomcat",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#windowpreferences",
    "href": "posts/Eclipse中配置Tomcat/index.html#windowpreferences",
    "title": "Eclipse中配置Tomcat",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#serverruntime-environmentsadd",
    "href": "posts/Eclipse中配置Tomcat/index.html#serverruntime-environmentsadd",
    "title": "Eclipse中配置Tomcat",
    "section": "2、【Server】—>【Runtime Environments】—>【Add】",
    "text": "2、【Server】—&gt;【Runtime Environments】—&gt;【Add】\n 选择对应版本的Tomcat"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#apache-tomcat-vx.xnext",
    "href": "posts/Eclipse中配置Tomcat/index.html#apache-tomcat-vx.xnext",
    "title": "Eclipse中配置Tomcat",
    "section": "3、【Apache Tomcat vX.x】—>【Next】",
    "text": "3、【Apache Tomcat vX.x】—&gt;【Next】\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#browse选择tomcat安装位置根目录",
    "href": "posts/Eclipse中配置Tomcat/index.html#browse选择tomcat安装位置根目录",
    "title": "Eclipse中配置Tomcat",
    "section": "4、【Browse】——>选择Tomcat安装位置（根目录）",
    "text": "4、【Browse】——&gt;选择Tomcat安装位置（根目录）\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#servers双击tomcat-vx.x-server-at-localhost",
    "href": "posts/Eclipse中配置Tomcat/index.html#servers双击tomcat-vx.x-server-at-localhost",
    "title": "Eclipse中配置Tomcat",
    "section": "5、Servers—–>双击Tomcat vX.x Server at localhost…",
    "text": "5、Servers—–&gt;双击Tomcat vX.x Server at localhost…\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#选择use-tomcat-installation并将deploy-path文本框内容修改为webapps",
    "href": "posts/Eclipse中配置Tomcat/index.html#选择use-tomcat-installation并将deploy-path文本框内容修改为webapps",
    "title": "Eclipse中配置Tomcat",
    "section": "6、选择Use Tomcat installation，并将【Deploy path】文本框内容修改为webapps",
    "text": "6、选择Use Tomcat installation，并将【Deploy path】文本框内容修改为webapps\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Eclipse中配置Tomcat/index.html#启动tomcatok",
    "href": "posts/Eclipse中配置Tomcat/index.html#启动tomcatok",
    "title": "Eclipse中配置Tomcat",
    "section": "7、启动Tomcat—–>ok",
    "text": "7、启动Tomcat—–&gt;ok\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/TI_ccs修改环境变量/index.html",
    "href": "posts/TI_ccs修改环境变量/index.html",
    "title": "TI_ccs修改环境变量",
    "section": "",
    "text": "项目右键 \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html",
    "href": "posts/Cisco思科交换机Vlan划分/index.html",
    "title": "Cisco思科交换机Vlan划分",
    "section": "",
    "text": "vlan技术是通过交换机上的端口进行划分不同的局域网，使得连接在同一个交换机的计算机实现计算机与计算机之间的隔离（不在同一个vlan中无法ping通），也可以使多个交换机进行网络划分。"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#vlan技术",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#vlan技术",
    "title": "Cisco思科交换机Vlan划分",
    "section": "",
    "text": "vlan技术是通过交换机上的端口进行划分不同的局域网，使得连接在同一个交换机的计算机实现计算机与计算机之间的隔离（不在同一个vlan中无法ping通），也可以使多个交换机进行网络划分。"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#试验目的",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#试验目的",
    "title": "Cisco思科交换机Vlan划分",
    "section": "1、试验目的",
    "text": "1、试验目的\n**实现同颜色计算机之间可以访问，不同颜色之间无法访问。**\n\n\n\n在这里插入图片描述\n\n\n\n\n\n名称\n相连的端口\nip地址\n\n\n\n\npc0\nF0/4\n172.1.1.2\n\n\npc1\nF0/5\n172.1.1.3\n\n\npc2\nF0/6\n172.1.1.4\n\n\npc3\nF0/4\n172.1.1.12\n\n\npc4\nF0/5\n172.1.1.13\n\n\npc5\nF0/6\n172.1.1.14"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#创建vlan",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#创建vlan",
    "title": "Cisco思科交换机Vlan划分",
    "section": "2、创建vlan",
    "text": "2、创建vlan\nswitchA\nSwitchA&gt;enable\nSwitchA#configure terminal \nSwitchA(config)#vlan 5\nSwitchA(config-vlan)#name valan5\nSwitchA(config-vlan)#exit\nSwitchA#\nswitchB\nSwitchB&gt;enable\nSwitchB#configure terminal \n    \nSwitchB(config)#vlan 5\nSwitchB(config-vlan)#name valan5\nSwitchB(config-vlan)#exit\nSwitchB#"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#把端口划分到vlan中",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#把端口划分到vlan中",
    "title": "Cisco思科交换机Vlan划分",
    "section": "3、把端口划分到vlan中",
    "text": "3、把端口划分到vlan中\n把交换机上的F0/5端口添加到vlan5中 switchA\nswitchA(config)#interface f0/5\nswitchA(config-if)#switchport mode access \nswitchA(config-if)#switchport access vlan 5\nswitchA(config-if)#exit\nswitchA(config)#\nswitchB\nswitchB(config)#interface f0/5\nswitchB(config-if)#switchport mode access \nswitchB(config-if)#switchport access vlan 5\nswitchB(config-if)#exit\nswitchB(config)#\n查看vlan划分情况"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#交换机配置",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#交换机配置",
    "title": "Cisco思科交换机Vlan划分",
    "section": "4、交换机配置",
    "text": "4、交换机配置\nvlan划分完成，需要将两个交换机所划分的网络进行“拼接”拼接成一个网络。 将switchA的F0/1端口 设置trunk模式\nswitchA(config)#interface f0/1\nswitchA(config-if)#switch mode trunk \nswitchA(config-if)#exit\nswitchA(config)#\n将switchB的F0/1端口 设置trunk模式\nswitchB(config)#interface f0/1\nswitchB(config-if)#switch mode trunk \nswitchB(config-if)#exit\nswitchB(config)#"
  },
  {
    "objectID": "posts/Cisco思科交换机Vlan划分/index.html#配置ip",
    "href": "posts/Cisco思科交换机Vlan划分/index.html#配置ip",
    "title": "Cisco思科交换机Vlan划分",
    "section": "5、配置ip",
    "text": "5、配置ip\n  测试连通性"
  },
  {
    "objectID": "posts/pyqt5 --05对象类型判定和控件继承类型/index.html",
    "href": "posts/pyqt5 --05对象类型判定和控件继承类型/index.html",
    "title": "pyqt5 –05对象类型判定和控件继承类型",
    "section": "",
    "text": "print(o.inherits('QLabel'))# 是否是继承自QLabel类\n            print(o.isWidgetType())# 判断类型是否是Widget\nfrom PyQt5.Qt import *\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle('QObject对象类型判断，子类判断')\n        self.resize(500, 500)\n        self.func_list()\n\n    def func_list(self):\n        self.func1()\n\n    def func1(self):\n        obj = QObject()\n        widget = QWidget()\n        label = QLabel()\n\n        li = [obj,widget,label]\n        for o in li:\n            # print(o.inherits('QLabel'))# 是否是继承自QLabel类\n            print(o.isWidgetType())# 判断类型是否是Widget\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())"
  },
  {
    "objectID": "posts/clion破解/index.html",
    "href": "posts/clion破解/index.html",
    "title": "clion破解",
    "section": "",
    "text": "打开C:\\Users\\z\\AppData\\Roaming\\JetBrains找到想要破解的ide删除文件夹"
  },
  {
    "objectID": "posts/esp8266--04wifi开关/index.html",
    "href": "posts/esp8266--04wifi开关/index.html",
    "title": "esp8266–04wifi开关",
    "section": "",
    "text": "远程开关\n\n#define BLINKER_WIFI\n\n#include &lt;Blinker.h&gt;\n\nchar auth[] = \"xxxx\";\nchar ssid[] = \"Netcore\";\nchar pswd[] = \"12345678\";\n\n// 新建组件对象\nBlinkerButton Button_light(\"btn-abc\");\n\n\n// 设置针脚\nint relaySwitch = 14;\n\n\n// 按下按键即会执行该函数\nvoid button_light_callback(const String & state)\n{\n    BLINKER_LOG(\"get button state: \", state);\n    if(state==\"on\"){\n       digitalWrite(relaySwitch,LOW); //设置继电器状态\n       Button_light.print(\"on\"); //反馈按钮状态\n      }\n    else if(state == \"off\"){\n      digitalWrite(relaySwitch,HIGH);\n      Button_light.print(\"off\");\n      }\n}\n\n\n\nvoid setup()\n{\n    // 初始化串口\n    Serial.begin(115200);\n    BLINKER_DEBUG.stream(Serial);\n    BLINKER_DEBUG.debugAll();\n    \n    // 初始化有LED的IO\n    pinMode(relaySwitch, OUTPUT);\n    digitalWrite(relaySwitch, LOW);\n    // 初始化blinker\n    Blinker.begin(auth, ssid, pswd);\n    //Blinker.attachData(dataRead);\n\n    Button_light.attach(button_light_callback);\n}\n\nvoid loop() {\n    Blinker.run();\n}"
  },
  {
    "objectID": "posts/linux-- linux忘记密码(修改root密码)/index.html",
    "href": "posts/linux-- linux忘记密码(修改root密码)/index.html",
    "title": "linux– linux忘记密码(修改root密码)",
    "section": "",
    "text": "在这里插入图片描述\n\n\n ## 2.在这里输入init = /bin/sh 进入单用户状态  ## 3.按ctrl+x进入单用户模式 接着，在光标闪烁的位置中输入: mount -o remount,rw /(注意:各个单词间有空格,中间的逗号)，完成后按键盘的回车键(Enter)。  ## 4.在新的一行最后面输入: passwd 完成后按键盘的回车键（Enter)。输入密码，然后再次确认密码即可(密码长度最好8位以上,但不是必须的)。密码修改成功后，会显示passw…..的样式，说明密码修改成功\n\n\n\n(注意: touch与 /后面有一个空格)，完成后按键盘的回车键 ## 7.继续在光标闪烁的位置中，输入：exec /sbin/init(注意：exec与/后面有一个空格)，完成后按键盘的回车键(Enter)， 等待系统自动修改密码(这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启,新的密码生效了"
  },
  {
    "objectID": "posts/linux-- linux忘记密码(修改root密码)/index.html#开机按e进入编辑页面",
    "href": "posts/linux-- linux忘记密码(修改root密码)/index.html#开机按e进入编辑页面",
    "title": "linux– linux忘记密码(修改root密码)",
    "section": "",
    "text": "在这里插入图片描述\n\n\n ## 2.在这里输入init = /bin/sh 进入单用户状态  ## 3.按ctrl+x进入单用户模式 接着，在光标闪烁的位置中输入: mount -o remount,rw /(注意:各个单词间有空格,中间的逗号)，完成后按键盘的回车键(Enter)。  ## 4.在新的一行最后面输入: passwd 完成后按键盘的回车键（Enter)。输入密码，然后再次确认密码即可(密码长度最好8位以上,但不是必须的)。密码修改成功后，会显示passw…..的样式，说明密码修改成功"
  },
  {
    "objectID": "posts/linux-- linux忘记密码(修改root密码)/index.html#接着在鼠标闪烁的位置中最后一行中输入-touch-.autorelabel",
    "href": "posts/linux-- linux忘记密码(修改root密码)/index.html#接着在鼠标闪烁的位置中最后一行中输入-touch-.autorelabel",
    "title": "linux– linux忘记密码(修改root密码)",
    "section": "",
    "text": "(注意: touch与 /后面有一个空格)，完成后按键盘的回车键 ## 7.继续在光标闪烁的位置中，输入：exec /sbin/init(注意：exec与/后面有一个空格)，完成后按键盘的回车键(Enter)， 等待系统自动修改密码(这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启,新的密码生效了"
  },
  {
    "objectID": "posts/java EE 解决请求中的缓冲区中文乱码问题/index.html",
    "href": "posts/java EE 解决请求中的缓冲区中文乱码问题/index.html",
    "title": "java EE 解决请求中的缓冲区中文乱码问题",
    "section": "",
    "text": "1、GET请求\n利用字符串构造方法，解决缓冲区中文乱码问题。\n核心处理代码\nString newString = new String(usr_name.getBytes(\"ISO8859-1\"), \"UTF-8\");\n实例：\n// 处理响应的中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 处理get请求发送过来的数据\nString usr_name = request.getParameter(\"username\");\n// 解决缓冲区中文乱码\nString newString = new String(usr_name.getBytes(\"ISO8859-1\"), \"UTF-8\");\n// 打印get缓冲区没处理的数据\nresponse.getWriter().print(\"没处理的数据：\"+usr_name+\"&lt;br&gt;\");\n// 打印get缓冲区处理过的数据\nresponse.getWriter().print(\"处理完的数据：\"+newString+\"&lt;br&gt;\");\n测试：  \n\n\n2、POST请求\npost方法发送过来的数据保存在reques缓冲区对象中，但是request对象默认使用ISO-8859-1编码方式，不支持中文，所以会导致中文乱码。 解决方案：\n// 一定要写在处理之前！！！！！\nrequest.setCharacterEncoding(\"utf-8\");\n实例：\n// 处理响应区乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 处理缓冲区乱码\nrequest.setCharacterEncoding(\"utf-8\");\n// 取到缓冲区的属性值\nString post_name = request.getParameter(\"username\");\n// 打印\nresponse.getWriter().print(post_name);\n测试："
  },
  {
    "objectID": "posts/java注解和反射-- 元注解/index.html",
    "href": "posts/java注解和反射-- 元注解/index.html",
    "title": "java注解和反射– 元注解",
    "section": "",
    "text": "创建注解的注解\npackage cn.usts.edu.InnerAnnotation;\n\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解\n * 用于创建注解的注解\n * */\n\n@MyAnnotation\npublic class OriginAnnotation {\n    @MyAnnotation\n    public void test(){\n    }\n}\n\n// 定义一个注解\n//@Target(value = ElementType.METHOD) // 只能在方法上生效\n@Target(value = { ElementType.METHOD, ElementType.TYPE}) // 在方法和类上都生效\n@Retention(value = RetentionPolicy.RUNTIME)//表示我们的注解在什么地方还有效   通常自己写的都是runtime   runtime&gt;class&gt;sources\n@Documented() // 是否将我们的注解加入到javaDoc中\n@Inherited // 子类可继承父类的注解\n    \n@interface MyAnnotation{\n\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 元注解/index.html#元注解用于",
    "href": "posts/java注解和反射-- 元注解/index.html#元注解用于",
    "title": "java注解和反射– 元注解",
    "section": "",
    "text": "创建注解的注解\npackage cn.usts.edu.InnerAnnotation;\n\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解\n * 用于创建注解的注解\n * */\n\n@MyAnnotation\npublic class OriginAnnotation {\n    @MyAnnotation\n    public void test(){\n    }\n}\n\n// 定义一个注解\n//@Target(value = ElementType.METHOD) // 只能在方法上生效\n@Target(value = { ElementType.METHOD, ElementType.TYPE}) // 在方法和类上都生效\n@Retention(value = RetentionPolicy.RUNTIME)//表示我们的注解在什么地方还有效   通常自己写的都是runtime   runtime&gt;class&gt;sources\n@Documented() // 是否将我们的注解加入到javaDoc中\n@Inherited // 子类可继承父类的注解\n    \n@interface MyAnnotation{\n\n}"
  },
  {
    "objectID": "posts/java多线程-- 简单实现多线程/index.html",
    "href": "posts/java多线程-- 简单实现多线程/index.html",
    "title": "java多线程– 简单实现多线程",
    "section": "",
    "text": "注意start() 和run()的区别\npackage cn.usts.edu.lesson01;\n\n/**\n * 实现多线程要\n * 1:继承Thread类,\n * 2:重写run()方法\n * 3:实现类.start()\n *\n * 【以吃馒头喝水为例】\n *  吃馒头和喝水同时进行\n *  \n *  thread.start();// 同时执行\n *  thread.run();//使用run()方法就是按顺序执行\n * */\npublic class ThreadCreateDemo01 extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 20; i++) {\n            System.out.println(\"吃第\"+i+\"个馒头\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadCreateDemo01 thread = new ThreadCreateDemo01();\n        thread.start();// 同时执行\n        //thread.run();//使用run()方法就是按顺序执行\n\n        for (int i = 0; i &lt; 20; i++) {\n            System.out.println(\"喝第\"+i+\"口水\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/manjaro install/index.html",
    "href": "posts/manjaro install/index.html",
    "title": "manjaro install",
    "section": "",
    "text": "mirror\nexeuted then select by yourself\npacman-mirrors -i -c China -m rank\n中科大源 https://blog.csdn.net/weixin_49927493/article/details/125616726?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-125616726-blog-84486753.t0_edu_mlt&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-125616726-blog-84486753.t0_edu_mlt&utm_relevant_index=6\narch-fcitx安装链接 gonme可以使用fcitx-configtool pacman -S fcitx fcitx-im kcm-fcitx fcitx安装第一个fcitx即可 vim ~/.pam_environment\nGTK_IM_MODULE DEFAULT=fcitx\nQT_IM_MODULE  DEFAULT=fcitx\nXMODIFIERS    DEFAULT=\\@im=fcitx\n注销 yay -S fcitx-sogoupinyin 右键键盘重启\n\n\n美化\n视频教学 视频文档\n卸载\nsudo pacman -R k3b kcalc kget konversation kwalletmanager qbittorent khelpercenter steam elisa htop yakuake timeshift timeshift-autosnap-manjaro matray manjaro-hello ksystemlog manjaro-documentation-en ksysguard onlyoffice-desktopeditors kfind kwrite okular\n\n\n中文家目录修改为英文\n修改参考\nvim .config/user-dirs.dirs\n\n修改为如下：\n# This file is written by xdg-user-dirs-update\n# If you want to change or add directories, just edit the line you're\n# interested in. All local changes will be retained on the next run.\n# Format is XDG_xxx_DIR=\"$HOME/yyy\", where yyy is a shell-escaped\n# homedir-relative path, or XDG_xxx_DIR=\"/yyy\", where /yyy is an\n# absolute path. No other format is supported.\n# \nXDG_DESKTOP_DIR=\"$HOME/Desktop\"\nXDG_DOWNLOAD_DIR=\"$HOME/Downloads\"\nXDG_TEMPLATES_DIR=\"$HOME/Templates\"\nXDG_PUBLICSHARE_DIR=\"$HOME/Public\"\nXDG_DOCUMENTS_DIR=\"$HOME/Documents\"\nXDG_MUSIC_DIR=\"$HOME/Music\"\nXDG_PICTURES_DIR=\"$HOME/Pictures\"\nXDG_VIDEOS_DIR=\"$HOME/Videos\"\n\ntouch ~/.config/user-dirs.conf\n写入：\nenabled=False\n\n\n安装clash\nclash for windows 下载 修改代理 \n修改浏览器代理, 否则代理一直无效\n # 安装浏览器插件 ad tempmonkey vimium 知呼登录屏蔽\n\n\n键盘f1-f12修改\nhttps://editor.csdn.net/md/?articleId=127000333\n\n\n安装主题\nyay -S ocs-url\n\n然后打开\nhttps://store.kde.org/p/1477945\n\n--&gt; install \n\n\n安装c语言环境\nsudo pacman -Sy base-devel"
  },
  {
    "objectID": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html",
    "href": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html",
    "title": "Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？",
    "section": "",
    "text": "## TreeSet的lambda写法个人理解"
  },
  {
    "objectID": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html#treeset提供的构造器",
    "href": "posts/Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？/index.html#treeset提供的构造器",
    "title": "Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？",
    "section": "TreeSet提供的构造器",
    "text": "TreeSet提供的构造器\n这么多的构造器lambda怎么确定是Compartor的呢 一个一个点进去看,会发现只有Compartor是函数是接口  点击到Compartor中发现,里面有很多方法啊,为什么就是函数式接口了呢  有两个抽象方法,查资料才发现,equals是Object类的方法,这里不属于Compartor,所以最后定位到了compare了"
  },
  {
    "objectID": "posts/protobuf协议-- 01使用（js简单实现）/index.html",
    "href": "posts/protobuf协议-- 01使用（js简单实现）/index.html",
    "title": "protobuf协议– 01使用（js简单实现）",
    "section": "",
    "text": "官网\n\n\n\n\n\n在这里插入图片描述\n\n\n   ### 解压完成  ### 添加环境变量 \n\n\n\n在这里插入图片描述\n\n\n .proto文件\n\nsyntax = \"proto3\";\n\nmessage Student {\n  string username = 1;\n  int32 password = 2;\n}\n\n\n\n将依赖库打包成js文件 然后直接导入这个新的js文件即可使用插件js\n# comm js\nprotoc --proto_path=D:\\code\\plug\\protocbuf\\protocMsg --js_out=import_style=commonjs,binary:D:\\code\\plug\\protocbuf\\protocMsg\\jsout Student.proto3"
  },
  {
    "objectID": "posts/protobuf协议-- 01使用（js简单实现）/index.html#protocol-buffer",
    "href": "posts/protobuf协议-- 01使用（js简单实现）/index.html#protocol-buffer",
    "title": "protobuf协议– 01使用（js简单实现）",
    "section": "",
    "text": "官网\n\n\n\n\n\n在这里插入图片描述\n\n\n   ### 解压完成  ### 添加环境变量 \n\n\n\n在这里插入图片描述\n\n\n .proto文件\n\nsyntax = \"proto3\";\n\nmessage Student {\n  string username = 1;\n  int32 password = 2;\n}\n\n\n\n将依赖库打包成js文件 然后直接导入这个新的js文件即可使用插件js\n# comm js\nprotoc --proto_path=D:\\code\\plug\\protocbuf\\protocMsg --js_out=import_style=commonjs,binary:D:\\code\\plug\\protocbuf\\protocMsg\\jsout Student.proto3"
  },
  {
    "objectID": "posts/南大操作系统基础-ics/index.html",
    "href": "posts/南大操作系统基础-ics/index.html",
    "title": "南大操作系统基础-ics",
    "section": "",
    "text": "nes模拟器\nhttps://github.com/NJU-ProjectN/fceux-am # https://nju-projectn.github.io/ics-pa-gitbook/ics2020/1.2.html"
  },
  {
    "objectID": "posts/Linux-- 查看和修改文件所在组/index.html",
    "href": "posts/Linux-- 查看和修改文件所在组/index.html",
    "title": "Linux– 查看和修改文件所在组",
    "section": "",
    "text": "查看和修改文件所在组\nls -alh\n\n4 drwxr-xr-x   2 root root 4096 Nov 23 10:15 a\n修改所有者\nchown amdin a\n4 drwxr-xr-x   2 admin root 4096 Nov 23 10:15 a"
  },
  {
    "objectID": "posts/java常用类-- Math和Random/index.html",
    "href": "posts/java常用类-- Math和Random/index.html",
    "title": "java常用类– Math和Random",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.MathAndRondom;\n\n/**\n * @author ：fly\n * @description: Math类常用方法\n * @date ：2021/10/31 15:52\n */\npublic class MathDemo {\n    public static void main(String[] args) {\n        System.out.println(Math.abs(-12));\n        System.out.println(Math.sin(45));//sin cos tan ....\n        System.out.println(Math.pow(2,3));// 2^3\n        System.out.println(Math.ceil(2.6));//向下取整 最小\n        System.out.println(Math.floor(3.2));//向上取整 最大\n        System.out.println(Math.round(3.5));//四舍五入\n        System.out.println(Math.max(1.1,22.2));//最大值\n        System.out.println(Math.min(1.1,22.2));//最小值\n        System.out.println(Math.random());// 随机0-1\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- Math和Random/index.html#math类常用方法",
    "href": "posts/java常用类-- Math和Random/index.html#math类常用方法",
    "title": "java常用类– Math和Random",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.fly.MathAndRondom;\n\n/**\n * @author ：fly\n * @description: Math类常用方法\n * @date ：2021/10/31 15:52\n */\npublic class MathDemo {\n    public static void main(String[] args) {\n        System.out.println(Math.abs(-12));\n        System.out.println(Math.sin(45));//sin cos tan ....\n        System.out.println(Math.pow(2,3));// 2^3\n        System.out.println(Math.ceil(2.6));//向下取整 最小\n        System.out.println(Math.floor(3.2));//向上取整 最大\n        System.out.println(Math.round(3.5));//四舍五入\n        System.out.println(Math.max(1.1,22.2));//最大值\n        System.out.println(Math.min(1.1,22.2));//最小值\n        System.out.println(Math.random());// 随机0-1\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- Math和Random/index.html#random类的常用方法",
    "href": "posts/java常用类-- Math和Random/index.html#random类的常用方法",
    "title": "java常用类– Math和Random",
    "section": "Random类的常用方法",
    "text": "Random类的常用方法\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.fly.MathAndRondom;\n\nimport java.util.Random;\n\n/**\n * @author ：fly\n * @description: Random类的常用方法\n * @date ：2021/10/31 16:04\n */\npublic class RandomDemo {\n    public static void main(String[] args) {\n        Random random = new Random();\n        System.out.println(\"随机的布尔值:\"+random.nextBoolean());\n        System.out.println(\"随机的布尔值:\"+random.nextDouble());\n        System.out.println(\"随机的Float:\"+random.nextFloat());\n        System.out.println(\"随机的Int():\"+random.nextInt());\n        System.out.println(\"随机的0-10 int:\"+random.nextInt(10));\n        System.out.println(\"随机的Long值:\"+random.nextLong());\n        \n\n\n    }\n}"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 统一编码方式防止中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取请求方法\nString method = request.getMethod();\n\n\n\n// 获取请求的协议\nString protocol = request.getProtocol();\n\n\n\n// 获取项目名称\nString conttextPath = request.getContextPath();\n        \n\n\n\n// 获取servlet路径\nString servletPath = request.getServletPath();      \n\n\n\n// 获取请求路径\nString requestURI = request.getRequestURI();\nString requestURL = request.getRequestURL().toString();\n\n\n\nresponse.getWriter().write(\"请求方法：\"+method+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求协议：\"+protocol+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求项目名称：\"+conttextPath+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求servlet路径：\"+servletPath+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求路径URI：\"+requestURI+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求路径URL：\"+requestURL+\"&lt;br&gt;\");\n # 2、常用请求头中信息获取的方法\n\n\n\n// 请求头信息获取\n        \nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取所有的消息头名称\nEnumeration&lt;String&gt; er = request.getHeaderNames();\n// 遍历\nwhile(er.hasMoreElements()){\n// 3、获取消息头\n    String name = er.nextElement();\n    // 4、获取消息头对应值\n    String value = request.getHeader(name);\n    esponse.getWriter().write(\"消息头：\"+name+\" \"+value+\"&lt;br&gt;\");\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n// 获取请求头中的\"user-agent\"对应的值\nString value = request.getHeader(\"user-agent\");\nresponse.getWriter().write(value);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求提交的方式",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求提交的方式",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 统一编码方式防止中文乱码\nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取请求方法\nString method = request.getMethod();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求的协议",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求的协议",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 获取请求的协议\nString protocol = request.getProtocol();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取项目名称",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取项目名称",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 获取项目名称\nString conttextPath = request.getContextPath();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取servlet路径",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取servlet路径",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 获取servlet路径\nString servletPath = request.getServletPath();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求路径",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取请求路径",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 获取请求路径\nString requestURI = request.getRequestURI();\nString requestURL = request.getRequestURL().toString();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#输出",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#输出",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "response.getWriter().write(\"请求方法：\"+method+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求协议：\"+protocol+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求项目名称：\"+conttextPath+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求servlet路径：\"+servletPath+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求路径URI：\"+requestURI+\"&lt;br&gt;\");\nresponse.getWriter().write(\"请求路径URL：\"+requestURL+\"&lt;br&gt;\");\n # 2、常用请求头中信息获取的方法"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取所有请求头名称",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取所有请求头名称",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 请求头信息获取\n        \nresponse.setContentType(\"text/html;charset=utf-8\");\n// 获取所有的消息头名称\nEnumeration&lt;String&gt; er = request.getHeaderNames();\n// 遍历\nwhile(er.hasMoreElements()){\n// 3、获取消息头\n    String name = er.nextElement();\n    // 4、获取消息头对应值\n    String value = request.getHeader(name);\n    esponse.getWriter().write(\"消息头：\"+name+\" \"+value+\"&lt;br&gt;\");\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "",
    "text": "// 获取请求头中的\"user-agent\"对应的值\nString value = request.getHeader(\"user-agent\");\nresponse.getWriter().write(value);\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值-1",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#获取值-1",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.1 获取值",
    "text": "3.1 获取值\n// 根据name属性值获取用户输入的值\nString value = request.getParamerter(\"name属性对应的值\");\n\n// 根据name属性值 获取用户选择的值（复选框等）\nString[] values = request.getParamerterValues(\"name属性对应的值\");\n\n// 没有参数获取所有值\nmap&lt;String, String[]&gt; map = request.getParamerterMap();"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#测试",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#测试",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.2 测试",
    "text": "3.2 测试\nresponse.getWriter().write(\"username:\"+value+ \"&lt;br&gt;\");\nresponse.getWriter().write(\"password:\"+psd+ \"&lt;br&gt;\");\nresponse.getWriter().write(\"hobby:\"+Arrays.toString(hobby)+ \"&lt;br&gt;\");\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java EE 获取请求行、请求头、请求正文/index.html#form表单",
    "href": "posts/java EE 获取请求行、请求头、请求正文/index.html#form表单",
    "title": "java EE 获取请求行、请求头、请求正文",
    "section": "3.3 form表单",
    "text": "3.3 form表单\n&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n                              \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"/myProject/para\" method=\"GET\"&gt;\n        用户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;\n        密  &nbsp;&nbsp;&nbsp;码：&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt;\n        爱好：\n        &lt;input type=\"checkbox\" name=\"hobby\" value=\"sing\"&gt;唱歌\n        &lt;input type=\"checkbox\" name=\"hobby\" value=\"dance\"&gt;跳舞\n        &lt;input type=\"checkbox\" name=\"hobby\" value=\"football\"&gt;足球&lt;br&gt;\n        &lt;input type=\"submit\" value=\"提交\"&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java集合-- HashSet小练习/index.html",
    "href": "posts/java集合-- HashSet小练习/index.html",
    "title": "java集合– HashSet小练习",
    "section": "",
    "text": "Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你 * 如果name+birthday相同判断为统一个对象\n注意点 * birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法 \npackage cn.usts.edu.hashSet;\n\nimport java.util.HashSet;\nimport java.util.Objects;\n\n/**\n * @author ：fly\n * @description: Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你\n *                 如果name+birthday相同判断为统一个对象\n *                 \n *               注意点:\n *                     birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法\n *                 \n * @date ：2021/11/2 15:24\n */\npublic class Employee {\n    private String name;\n    private float sal;\n    private MyDate birthday;\n\n    public static void main(String[] args) {\n        Employee jack = new Employee(\"jack\", 4500.22f, new MyDate(1999, 10, 5));\n        Employee jack1 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 5));// sal 不同\n        Employee jack2 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 6));// day不同\n        Employee jack3 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 11, 5));// month不同\n        Employee jack4 = new Employee(\"jack\", 3500.22f, new MyDate(1998, 10, 5));// year不同\n\n        Employee luck = new Employee(\"luck\", 5500.22f, new MyDate(1999, 10, 5));\n        Employee luck2 = new Employee(\"luck2\", 5500.22f, new MyDate(1999, 10, 5));\n\n        HashSet set = new HashSet();\n        set.add(jack);\n        set.add(jack1);\n        set.add(jack2);\n        set.add(jack3);\n        set.add(jack4);\n        set.add(luck);\n        set.add(luck2);\n        set.forEach(obj-&gt; System.out.println(obj));\n\n    }\n\n\n    public Employee() {\n    }\n\n    public Employee(String name, float sal, MyDate birthday) {\n        this.name = name;\n        this.sal = sal;\n        this.birthday = birthday;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getSal() {\n        return sal;\n    }\n\n    public void setSal(float sal) {\n        this.sal = sal;\n    }\n\n    public MyDate getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(MyDate birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"name='\" + name + '\\'' +\n                \", sal=\" + sal +\n                \", date=\" + birthday +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Employee employee = (Employee) o;\n        return Objects.equals(name, employee.name) && Objects.equals(birthday, employee.birthday);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, birthday);\n    }\n}\n\nclass MyDate{\n    private int year;\n    private int moth;\n    private int day;\n\n    public MyDate(int year, int moth, int day) {\n        this.year = year;\n        this.moth = moth;\n        this.day = day;\n    }\n\n    public MyDate() {\n    }\n\n    public int getYear() {\n        return year;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    public int getMoth() {\n        return moth;\n    }\n\n    public void setMoth(int moth) {\n        this.moth = moth;\n    }\n\n    public int getDay() {\n        return day;\n    }\n\n    public void setDay(int day) {\n        this.day = day;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"MyDate{\" +\n                \"year=\" + year +\n                \", moth=\" + moth +\n                \", day=\" + day +\n                '}';\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MyDate myDate = (MyDate) o;\n        return year == myDate.year && moth == myDate.moth && day == myDate.day;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(year, moth, day);\n    }\n}"
  },
  {
    "objectID": "posts/java集合-- HashSet小练习/index.html#hashset小练习",
    "href": "posts/java集合-- HashSet小练习/index.html#hashset小练习",
    "title": "java集合– HashSet小练习",
    "section": "",
    "text": "Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你 * 如果name+birthday相同判断为统一个对象\n注意点 * birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法 \npackage cn.usts.edu.hashSet;\n\nimport java.util.HashSet;\nimport java.util.Objects;\n\n/**\n * @author ：fly\n * @description: Employee类有name sal birthday(MyDate[year,moth,day]) 三个属性你\n *                 如果name+birthday相同判断为统一个对象\n *                 \n *               注意点:\n *                     birthday的不同取决于MyDate的不同,所以要先重写MyDate的hashcode()和equals()方法\n *                 \n * @date ：2021/11/2 15:24\n */\npublic class Employee {\n    private String name;\n    private float sal;\n    private MyDate birthday;\n\n    public static void main(String[] args) {\n        Employee jack = new Employee(\"jack\", 4500.22f, new MyDate(1999, 10, 5));\n        Employee jack1 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 5));// sal 不同\n        Employee jack2 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 10, 6));// day不同\n        Employee jack3 = new Employee(\"jack\", 5500.22f, new MyDate(1999, 11, 5));// month不同\n        Employee jack4 = new Employee(\"jack\", 3500.22f, new MyDate(1998, 10, 5));// year不同\n\n        Employee luck = new Employee(\"luck\", 5500.22f, new MyDate(1999, 10, 5));\n        Employee luck2 = new Employee(\"luck2\", 5500.22f, new MyDate(1999, 10, 5));\n\n        HashSet set = new HashSet();\n        set.add(jack);\n        set.add(jack1);\n        set.add(jack2);\n        set.add(jack3);\n        set.add(jack4);\n        set.add(luck);\n        set.add(luck2);\n        set.forEach(obj-&gt; System.out.println(obj));\n\n    }\n\n\n    public Employee() {\n    }\n\n    public Employee(String name, float sal, MyDate birthday) {\n        this.name = name;\n        this.sal = sal;\n        this.birthday = birthday;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public float getSal() {\n        return sal;\n    }\n\n    public void setSal(float sal) {\n        this.sal = sal;\n    }\n\n    public MyDate getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(MyDate birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"name='\" + name + '\\'' +\n                \", sal=\" + sal +\n                \", date=\" + birthday +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Employee employee = (Employee) o;\n        return Objects.equals(name, employee.name) && Objects.equals(birthday, employee.birthday);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, birthday);\n    }\n}\n\nclass MyDate{\n    private int year;\n    private int moth;\n    private int day;\n\n    public MyDate(int year, int moth, int day) {\n        this.year = year;\n        this.moth = moth;\n        this.day = day;\n    }\n\n    public MyDate() {\n    }\n\n    public int getYear() {\n        return year;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    public int getMoth() {\n        return moth;\n    }\n\n    public void setMoth(int moth) {\n        this.moth = moth;\n    }\n\n    public int getDay() {\n        return day;\n    }\n\n    public void setDay(int day) {\n        this.day = day;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"MyDate{\" +\n                \"year=\" + year +\n                \", moth=\" + moth +\n                \", day=\" + day +\n                '}';\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MyDate myDate = (MyDate) o;\n        return year == myDate.year && moth == myDate.moth && day == myDate.day;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(year, moth, day);\n    }\n}"
  },
  {
    "objectID": "posts/Django-- 0_从零开始(创建)/index.html",
    "href": "posts/Django-- 0_从零开始(创建)/index.html",
    "title": "Django– 0_从零开始(创建)",
    "section": "",
    "text": "1.准备环境\n安装虚拟环境\npip install virtualenv \n复制本地Python环境\n                        本地python.exe位置                                      环境名\nmkvirtualenv -p C:\\Users\\msi\\AppData\\Local\\Programs\\Python\\Python39\\python.exe  lice\n\n\n安装Django\npip install django==3.1  \n\n\n3.创建Django项目\ndjango-admin startproject lice\n\n\n4.运行\n进入到创建的文件夹中,有manger.py的那个文件夹\npython manage.py runserver127.0.0.1:8000\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html",
    "href": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html",
    "title": "infineon radar usecase (RBB7 Demo)",
    "section": "",
    "text": "上个文档描述的是整个项目的创建原因, 工程创建, 工程导入.\n这个文档是进行具体的项目的配置, 根据原理图进行引脚信息, 从代码进行梳理, 一步一步确认引脚, 以及代码框架\n\n我们需要配置的项:\n\nuart\nspi\nldo\nRST\nIRQ"
  },
  {
    "objectID": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html#配置-spi",
    "href": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html#配置-spi",
    "title": "infineon radar usecase (RBB7 Demo)",
    "section": "配置 SPI",
    "text": "配置 SPI\n\nSpi Key Word MISO : Master In Slave Out MOSI : Master Out Slave In CS: Chip Select\n\nSPI 的几种模式\n\n\n\n\n\n\n\nmode\ndescription\n\n\n\n\nSPI_Master_Sync\n同步模式下的串行外设接口 （SPI） 主机通信\n\n\nSPI_Slave_Sync\n同步模式下的串行外设接口 （SPI）从机通信\n\n\nSPI_Master_Async\n中断的异步模式下串行外设接口（SPI）主机通信\n\n\nSPI_Slave_Async\n中断的异步模式下的串行外设接口（SPI）从机通信\n\n\nSPI_Master_DMA\nDMA 模式下的串行外设接口 （SPI） 主机通信\n\n\nSPI_Master_RTOS\n支持 RTOS模式下串行外设接口 （SPI） 主机通信，\n\n\n\n\nSPI 分配\n在rbb7代码中的QSPI是原理图上的S1_SPI, 代码中的SPI1是原理图的S2_SPI, 代码中的SPI2是原理图中的 SPI0 分配如下.\n\n\n\n代码\n原理图\n\n\n\n\nQspi\nS1_SPI\n\n\nspi1\nS2_SPI\n\n\nspi2\nSPI0\n\n\n\n在项目中的配置是按照如下代码部分进行配置的, MCU7是Legacy版本, 所以对应的是两个链接器. debug 和代码中显示的都是两个, 链接器, HatvanPlus 只有一个 LDO. ( 代码中的注释有点迷惑, 一直以为是 HatvanPlus 其实是 Legacy )\n按照如下配置进行配置雷达的驱动引脚配置, 就是没问题的. 调整 mcu 也只需调整这几个配置即可.\n // detect board type\n    const bool isHatvanLegacy = Board_isHatvanLegacy();\n    if (isHatvanLegacy)\n    {\n        ShieldConnectorDefinition = &ShieldConnectorDefinitionHatvanLegacy[0];\n        BoardSpiDefinition        = &BoardSpiDefinitionHatvanLegacy[0];\n        BoardRadarPinsConfigAvian = &BoardRadarPinsConfigAvianHatvanLegacy[0];\n        m_shieldConnectorCount    = ARRAY_SIZE(ShieldConnectorDefinitionHatvanLegacy);\n    }\nHatvan Legacy Board Connector Definition, 我们这个是对HatvanLegacy的连接器做配置.\nShieldConnectorDefinition_t ShieldConnectorDefinitionHatvanLegacy[] = {\n    [0] = {\n        .en_ldo      = GPIO_ID('C', 30),\n        .ls_spi_oe   = GPIO_ID('D', 24),\n        .ls_gpio_oe  = GPIO_ID('D', 14),\n        .ls_gpio_dir = GPIO_ID('D', 18),\n        .oc_led      = GPIO_ID('C', 1),\n        .oc1         = GPIO_ID('D', 16),\n        .oc2         = GPIO_ID('C', 9),\n        .oc3         = GPIO_ID('C', 28),\n        .oc4         = GPIO_ID('A', 27),\n    },  \n    [1] = {\n        .en_ldo      = GPIO_ID('C', 31),\n        .ls_spi_oe   = GPIO_ID('C', 3),\n        .ls_gpio_oe  = GPIO_ID('A', 1),\n        .ls_gpio_dir = GPIO_ID('C', 10),\n        .oc_led      = GPIO_ID('C', 2),\n        .oc1         = GPIO_ID('A', 22),\n        .oc2         = GPIO_ID('D', 10),\n        .oc3         = GPIO_ID('C', 29),\n        .oc4         = GPIO_ID('D', 15),\n    },\nspi配置\nPlatformSpiDefinition_t BoardSpiDefinitionHatvanLegacy[] = {\n    [0] = {\n        .peripheral_id   = ID_QSPI,\n        .baudrate        = 50000000,\n        .setup_interface = setup_qspi,\n\n        .addr = {\n            .peripheral = QSPI,\n            .tdr        = (uint32_t)&QSPI-&gt;QSPI_TDR,\n            .rdr        = (uint32_t)&QSPI-&gt;QSPI_RDR,\n        },\n        .pins = {\n            .csn        = PIO_PA11_IDX,\n            .clk        = PIO_PA14_IDX,\n            .clk_flags  = IOPORT_MODE_MUX_A,\n            .miso       = PIO_PA12_IDX,\n            .miso_flags = IOPORT_MODE_MUX_A,\n            .mosi       = PIO_PA13_IDX,\n            .mosi_flags = IOPORT_MODE_MUX_A,\n        },\n        .dma = {\n            .tx_dma_channel = HV_DMA_HW_CH_TX_1,\n            .tx_dma_hw_id   = HV_DMA_HW_INTF_TX_1,\n            .rx_dma_channel = HV_DMA_HW_CH_RX_1,\n            .rx_dma_hw_id   = HV_DMA_HW_INTF_RX_1,\n        },\n    },\n    [1] = {\n        .peripheral_id   = ID_SPI1,\n        .baudrate        = 50000000,\n        .setup_interface = setup_spi,\n\n        .addr = {\n            .peripheral = SPI1,\n            .tdr        = (uint32_t)&SPI1-&gt;SPI_TDR,\n            .rdr        = (uint32_t)&SPI1-&gt;SPI_RDR,\n        },\n        .pins = {\n            .csn        = PIO_PC25_IDX,\n            .clk        = PIO_PC24_IDX,\n            .clk_flags  = IOPORT_MODE_MUX_C,\n            .miso       = PIO_PC26_IDX,\n            .miso_flags = IOPORT_MODE_MUX_C,\n            .mosi       = PIO_PC27_IDX,\n            .mosi_flags = IOPORT_MODE_MUX_C,\n        },\n        .dma = {\n            .tx_dma_channel = HV_DMA_HW_CH_TX_2,\n            .tx_dma_hw_id   = HV_DMA_HW_INTF_TX_2,\n            .rx_dma_channel = HV_DMA_HW_CH_RX_2,\n            .rx_dma_hw_id   = HV_DMA_HW_INTF_RX_2,\n        },\n    },\n};\n中断和复位设置\nstatic const IPinsAvianConfig_t BoardRadarPinsConfigAvianHatvanLegacy[] = {\n    [0] = {\n        .gpioReset = GPIO_ID('A', 0),\n        .gpioIrq   = GPIO_ID('C', 6),\n    },\n    [1] = {\n        .gpioReset = GPIO_ID('A', 17),\n        .gpioIrq   = GPIO_ID('C', 11),\n    },\n};\n平台初始化, 这里有点迷惑, 通常初始化都是按照上面的配置进行初始化, 但是这里的init是将所有的spi, ldo , LevelShifter, connector都初始化. 就是全都配置出来, 没有连接的那边的引脚(另外一个connector)其实都是打开的, 只不过没有数据通路.\nPlatformSpi_initialize(BoardSpiDefinition, m_shieldConnectorCount);\n\n--&gt; inter  PlatformSpi_initialize :\n for (unsigned int i = 0; i &lt; m_count; i++)\n    {\n        PlatformSpiDefinition_t *device = &m_definition[i];\n\n\n\n    return E_SUCCESS;\n接下来就是对LED的常规设置\n// initialize LedSequence to be used for potential error signaling during detection\n    LedSequence_Constructor();\n    LedSequence_setStatus(LED_STATUS_OPERATING);\n再往后就是shield的错误检测, 如果shield没有错误就把LDO打开, 电平转换打开(使能connector)\nstatic sr_t Board_detectShields(void)\n{\n    /* Checks both connectors for unsupported or wrongly connected shields.\n     * In case no errors are detected, both connectors will be enabled,\n     * in order to allow radar device detection.\n     */\n    for (uint8_t shieldId = 0; shieldId &lt; m_shieldConnectorCount; shieldId++)\n    {\n        // detect the presence of a shield by probing the I2C lines\n        const sr_t detection = ShieldConnector_detect(&ShieldConnectorDefinition[shieldId], shieldId);\n        switch (detection)\n        {\n            case E_NOT_AVAILABLE:  // allow shields without I2C bus\n                /*  no break */\n            case E_SUCCESS:\n                break;\n            case E_NOT_POSSIBLE:\n                LedSequence_setRbbStatus(RBB_ERROR_HARDWARE_CONNECTED_WRONG);\n                return E_NOT_POSSIBLE;\n                break;\n            case E_NOT_SUPPORTED:\n                LedSequence_setRbbStatus(RBB_ERROR_HARDWARE_NOT_SUPPORTED);\n                return E_NOT_SUPPORTED;\n                break;\n            default:\n                LedSequence_setRbbStatus(RBB_ERROR_HARDWARE_INTERNAL_ERROR);\n                return detection;\n                break;\n        }\n\n        // power-up shield and configure its level shifters\n        ShieldConnector_enable(&ShieldConnectorDefinition[shieldId], shieldId, true);\n    }\n\n    return E_SUCCESS;\n}\nshield没有问题利用所有配置创建雷达对象,\n radar = Board_detectRadar(gpio, spi, i2c, &m_data);\n下面是具体雷达对象创建\nstatic IRadar *Board_detectRadar(IGpio *gpio, ISpi *spi, II2c *i2c, IData **data)\n{\n   // 遍历所有shield\n    for (uint8_t shieldId = 0; shieldId &lt; m_shieldConnectorCount; shieldId++)\n    {\n        // 如果要是第二个shield, 就交换配置, 将配置交换到第一个配置位置\n        if (m_shieldConnectorCount == 2)\n        {\n            if (shieldId == 1)\n            {\n                PlatformInterfaces_swapI2cIds();\n                Board_swapSpiIds();\n            }\n        }\n\n        const sr_t avianDetection = Avian_Detect(spi, gpio, &BoardRadarConfigAvian[shieldId], &BoardRadarPinsConfigAvian[shieldId]);\n        if (avianDetection == E_SUCCESS)\n        {\n            Avian_Constructor(&m_avian, &DataAvian, gpio, spi, &BoardRadarConfigAvian[shieldId], &BoardRadarPinsConfigAvian[shieldId]);\n            DataAvian_Constructor(Board_acquisitionStatusCallback);\n            DataAvian_setBuffer(BoardRadarConfigAvian[shieldId].dataIndex, m_dataBuffer, DATA_BUFFER_SIZE);\n            DataAvian_registerInterrupt(BoardRadarConfigAvian[shieldId].dataIndex, &BoardIrqPinsConfigAvian[shieldId]);\n            *data = &DataAvian;\n\n            // 如果这里第一次配置成功就直接跳出该函数了, 就不会执行shield2 的配置.\n            return (IRadar *)&m_avian;\n        }\n到此所有的脚位配置信息完成"
  },
  {
    "objectID": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html#shield-型号判断",
    "href": "posts/infineon_atmel_SAMS70Q21_microChip_usecase/index.html#shield-型号判断",
    "title": "infineon radar usecase (RBB7 Demo)",
    "section": "shield 型号判断",
    "text": "shield 型号判断\n如果无法判断型号是 HatvanLegacy 和 HatvanPlus 时可以使能ldo_en 引脚, 这里是个人提供的方案.\n\n官方方案是使能LDO2然后检测PA8引脚是否拉高来判断是否为Legacy\n\n\n\n\nversion\nLDO_en\n\n\n\n\nHatvanLegacy\nC31\n\n\nHatvanPlus\nC30\n\n\n\n\nconnector.h\n\n\n然后到connecter 测量电压, 电平转换默认是正确配置, 查看是否能够检测到 LDO 电源(最好使能前后对比测量)."
  },
  {
    "objectID": "posts/powershell获取脚本执行权限/index.html",
    "href": "posts/powershell获取脚本执行权限/index.html",
    "title": "powershell获取脚本执行权限",
    "section": "",
    "text": "管理员权限执行powershell\nSet-ExecutionPolicy -ExecutionPolicy Unrestricted\n\n参考地址:https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2"
  },
  {
    "objectID": "posts/java注解和反射-- 内置注解/index.html",
    "href": "posts/java注解和反射-- 内置注解/index.html",
    "title": "java注解和反射– 内置注解",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.InnerAnnotation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 内置注解\n * */\npublic class InnerAnnotation extends Object{\n\n    @Override  // 重写注解\n    public String toString() {\n        return \"重写的toString\";\n    }\n\n    @Deprecated // 不推荐程序员使用,或者有更好的方法\n    public void test01(){\n        System.out.println(\"test01\");\n    }\n\n    @SuppressWarnings(\"all\") // 镇压警告\n    public void test02(){\n        List list = new ArrayList(); // 要不然这里会警告\n        System.out.println(\"test03\");\n    }\n\n    public static void main(String[] args) {\n        InnerAnnotation innerAnnotation = new InnerAnnotation();\n        innerAnnotation.test01();\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 内置注解/index.html#内置注解",
    "href": "posts/java注解和反射-- 内置注解/index.html#内置注解",
    "title": "java注解和反射– 内置注解",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.InnerAnnotation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 内置注解\n * */\npublic class InnerAnnotation extends Object{\n\n    @Override  // 重写注解\n    public String toString() {\n        return \"重写的toString\";\n    }\n\n    @Deprecated // 不推荐程序员使用,或者有更好的方法\n    public void test01(){\n        System.out.println(\"test01\");\n    }\n\n    @SuppressWarnings(\"all\") // 镇压警告\n    public void test02(){\n        List list = new ArrayList(); // 要不然这里会警告\n        System.out.println(\"test03\");\n    }\n\n    public static void main(String[] args) {\n        InnerAnnotation innerAnnotation = new InnerAnnotation();\n        innerAnnotation.test01();\n    }\n}"
  },
  {
    "objectID": "posts/模仿网易严选(vant)/index.html",
    "href": "posts/模仿网易严选(vant)/index.html",
    "title": "模仿网易严选(vant)",
    "section": "",
    "text": "vue2+vant2+express\n简单使用(模仿网易严选) 地址:https://gitee.com/itengfei/you-163 \n \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/linux-- 提权/index.html",
    "href": "posts/linux-- 提权/index.html",
    "title": "linux– 提权",
    "section": "",
    "text": "linux提权\nvim /ect/sudoers 修改内容如下\nroot    ALL=(ALL:ALL) ALL\n# 添加的用户\nfly     ALL=(ALL:ALL) ALL"
  },
  {
    "objectID": "posts/javaGUI--浮动布局(FlowLayOut)/index.html",
    "href": "posts/javaGUI--浮动布局(FlowLayOut)/index.html",
    "title": "javaGUI–浮动布局(FlowLayOut)",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestFlowLayOut {\n\n    public static void main(String[] args) {\n        // 窗口\n        Frame frame = new Frame(\"myFlowLayOut\");\n\n        // 按钮\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n\n        frame.setSize(350,350);\n        frame.setVisible(true);\n\n        // 设置流失布局(默认居中)\n        frame.setLayout(new FlowLayout());\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.add(button4);\n    }\n}\n\n\n\n在这里插入图片描述\n\n\n// 左对齐(右对齐......)\nframe.setLayout(new FlowLayout(FlowLayout.LEFT));\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/springmvc-hellomvc-02/index.html",
    "href": "posts/springmvc-hellomvc-02/index.html",
    "title": "springmvc-hellomvc-02",
    "section": "",
    "text": "1、web.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\"&gt;\n\n    &lt;!--1.注册DispatcherServlet--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;!--启动级别-1--&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;\n    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n2、springmvc-servlet.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n\n\n\n&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt;\n\n\n&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt;\n\n\n        &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;\n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt;\n&lt;!--前缀--&gt;\n&lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;\n&lt;!--后缀--&gt;\n&lt;property name=\"suffix\" value=\".jsp\"/&gt;\n&lt;/bean&gt;\n\n&lt;!--    handler--&gt;\n    &lt;bean id=\"/hello\" class=\"cn.usts.edu.controller.HelloController\" /&gt;\n&lt;/beans&gt;\n3、HelloController.java\npackage cn.usts.edu.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class HelloController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        ModelAndView mav = new ModelAndView();\n        // 封装对象\n        mav.addObject(\"msg\",\"helloMVC\");\n        // 跳转的视图名\n        mav.setViewName(\"hello\"); // 拼接前后缀\n        return  mav;\n    }\n}"
  },
  {
    "objectID": "posts/frida对java hash类型打印/index.html",
    "href": "posts/frida对java hash类型打印/index.html",
    "title": "frida对java hash类型打印",
    "section": "",
    "text": "frida对java hash类型打印"
  },
  {
    "objectID": "posts/Django中配置mysql数据库/index.html",
    "href": "posts/Django中配置mysql数据库/index.html",
    "title": "Django中配置mysql数据库",
    "section": "",
    "text": "pip install mysqlclient -i https://pypi.doubanio.com/simple\n方法一：修改settings配置文件\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',           # 数据库引擎\n        'NAME': 'first_project',                        # 数据库名\n        'USER': 'fly',                                  # 用户名\n        'PASSWORD': '123456',                           # 密码\n        'HOST': '127.0.0.1',                            # 主机IP\n        'PORT': 3306                                    # 端口\n    }\n}\n方法二：\n创建utils工具文件夹，存放工具\n\n将数据库配置信息存到一个文件，在settings文件中将其引入。修改起来方便（推荐）\n\n新建数据库配置文件db.cnf(名字随意)\n[client]\ndatabase = first_project\nuser = fly\npassword = 123456\nhost = 127.0.0.1\nport = 3306\ndefault-character-set = utf8\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Django中配置mysql数据库/index.html#一mysqlclient的安装和配置",
    "href": "posts/Django中配置mysql数据库/index.html#一mysqlclient的安装和配置",
    "title": "Django中配置mysql数据库",
    "section": "",
    "text": "pip install mysqlclient -i https://pypi.doubanio.com/simple\n方法一：修改settings配置文件\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',           # 数据库引擎\n        'NAME': 'first_project',                        # 数据库名\n        'USER': 'fly',                                  # 用户名\n        'PASSWORD': '123456',                           # 密码\n        'HOST': '127.0.0.1',                            # 主机IP\n        'PORT': 3306                                    # 端口\n    }\n}\n方法二：\n创建utils工具文件夹，存放工具\n\n将数据库配置信息存到一个文件，在settings文件中将其引入。修改起来方便（推荐）\n\n新建数据库配置文件db.cnf(名字随意)\n[client]\ndatabase = first_project\nuser = fly\npassword = 123456\nhost = 127.0.0.1\nport = 3306\ndefault-character-set = utf8\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Django中配置mysql数据库/index.html#二pymysql的使用推荐mysqlclient安全",
    "href": "posts/Django中配置mysql数据库/index.html#二pymysql的使用推荐mysqlclient安全",
    "title": "Django中配置mysql数据库",
    "section": "二、pymysql的使用（推荐mysqlclient，安全）",
    "text": "二、pymysql的使用（推荐mysqlclient，安全）\n安装pymysql\npip install pymysql -i https://pypi.doubanio.com/simple\n__init__文件配置信息：\nimport pymysql\npymysql.install_as_MySQLdb()\n\n\n\n在这里插入图片描述\n\n\n最后修改settings文件中的数据库配置信息\n\n\n\n在这里插入图片描述\n\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME':'库名',\n        'USER':'用户名',\n        'PASSWORD':'密码',\n        'HOST':'主机地址',\n        'PORT':3306,\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 所有类的Class类型/index.html",
    "href": "posts/java注解和反射-- 所有类的Class类型/index.html",
    "title": "java注解和反射– 所有类的Class类型",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.theClassOfAllClasses;\n\nimport java.lang.annotation.ElementType;\n\n/**\n * @author ：fly\n * @description: 所有类的Class类型\n * @date ：2021/10/27 16:26\n */\npublic class AllClasses {\n    public static void main(String[] args) {\n        Class c1 = Object.class;\n        Class c2 = Comparable.class;\n        Class c3 = String[].class;\n        Class c4 = int[][].class;\n        Class c5 = Override.class;\n        Class c6 = ElementType.class;\n        Class c7 = Integer.class;\n        Class c8 = void.class;\n        Class c9 = Class.class;\n\n        System.out.println(c1);\n        System.out.println(c2);\n        System.out.println(c3);\n        System.out.println(c4);\n        System.out.println(c5);\n        System.out.println(c6);\n        System.out.println(c7);\n        System.out.println(c8);\n        System.out.println(c9);\n\n        int[] a = new int[10];\n        int[] b = new int[100];\n        // 如果hashcode相同就说明他们是同一个class类\n        System.out.println(a.getClass().hashCode());\n        System.out.println(b.getClass().hashCode());\n    }\n}"
  },
  {
    "objectID": "posts/java注解和反射-- 所有类的Class类型/index.html#所有类的class类型",
    "href": "posts/java注解和反射-- 所有类的Class类型/index.html#所有类的class类型",
    "title": "java注解和反射– 所有类的Class类型",
    "section": "",
    "text": "在这里插入图片描述\n\n\npackage cn.usts.edu.theClassOfAllClasses;\n\nimport java.lang.annotation.ElementType;\n\n/**\n * @author ：fly\n * @description: 所有类的Class类型\n * @date ：2021/10/27 16:26\n */\npublic class AllClasses {\n    public static void main(String[] args) {\n        Class c1 = Object.class;\n        Class c2 = Comparable.class;\n        Class c3 = String[].class;\n        Class c4 = int[][].class;\n        Class c5 = Override.class;\n        Class c6 = ElementType.class;\n        Class c7 = Integer.class;\n        Class c8 = void.class;\n        Class c9 = Class.class;\n\n        System.out.println(c1);\n        System.out.println(c2);\n        System.out.println(c3);\n        System.out.println(c4);\n        System.out.println(c5);\n        System.out.println(c6);\n        System.out.println(c7);\n        System.out.println(c8);\n        System.out.println(c9);\n\n        int[] a = new int[10];\n        int[] b = new int[100];\n        // 如果hashcode相同就说明他们是同一个class类\n        System.out.println(a.getClass().hashCode());\n        System.out.println(b.getClass().hashCode());\n    }\n}"
  },
  {
    "objectID": "posts/南大ics课程/index.html",
    "href": "posts/南大ics课程/index.html",
    "title": "南大ics课程",
    "section": "",
    "text": "http://jyywiki.cn/ 该课程主要是通过手把手编写一个模拟器, 来了解计算机底层原理(编译,链接….) # P2-C语言拾遗 &gt;总结: &gt; - 编译链接过程 &gt; - 预编译指令 &gt; - 宏的使用 &gt; - 内存模型 &gt;\n\ngcc hello.c                             // complier c file\nvim a.out                               // see the bin file\n:%!xxd                                  // show with hex\nwe can see .ELF at the begin, this tell us this is an executeable file 我们可以看到开头的.ELF, 这表示这是一个(linux中)可执行文件  &gt;可执行文件可以通过file打开\nfile a.out\n\n\n\n在这里插入图片描述\n\n\n\n上述过程直接通过gcc 实现了从.c到.out 的过程 上述过程拆解: - gcc -S hello.c =&gt; 生成.s汇编文件 - gcc -c hello.c =&gt; 生成.o文件,但是没有链接 - objdump -d hello.o =&gt; 将.o文件反汇编成我们可以看的懂的文件\n\n\n\n\n\n#include 表示将代码复制粘贴进来\n\n\n\n\n\nhello.inc\n\nprintf(\"hello world\\n\");\n\nhello.c\n\n#include &lt;stdio.h&gt;    \n    \nint main(int argc, char* argv[])    \n{    \n    \n    #include \"hello.inc\"    \n    return 0;    \n} \ngcc -E hello.c\n gcc --verbose hello.c 查看include文件是否在包含的目录中\n可以看到#include \"xxx\"和#include &lt;xxx&gt;\"的位置  &gt;使用#include &lt;xxx&gt;\"进行包含文件挥发现找不到这个文件, 系统目录中没有包含该文件. &gt; 可以使用gcc -I./进行将目录添加到系统目录中\n问题演示  解决方案  gcc -I. --verbose hello.c查看日志中是否包含目录  gcc -m32 hello.c 将项目编译为32位机器的目标文件\n\n有趣的预编译, 因为aa和bb都没有定义所以都是NULL, NULL==NULL 得到True,所以输出yes\n\n#include &lt;stdio.h&gt;      \n                                                                             \nint main(int argc, char* argv[])                                             \n{                                                                            \n    #if aa == bb                                                             \n    ¦   printf(\"yes\\n\");                     \n    #else                                                                                                                     \n    ¦   printf(\"no\\n\");                            \n    #endif                                                                                                                                                                       \n}  \n gcc -E aabb.c 查看预编译后的代码.  直接放入extern int printf (const char *__restrict __format, ...);不用全部include也是可以的\nextern int printf (const char *__restrict __format, ...);     \nint main(int argc, char* argv[])    \n{                  \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n} \n编译32位项目,出现报错:https://blog.csdn.net/wzzushx/article/details/119453099\nsudo apt-get install build-essential module-assistant  \nsudo apt-get install gcc-multilib g++-multilib  \n预编译参数依旧添加进去了\nextern int printf (const char *__restrict __format, ...);    \n    \nint main(int argc, char* argv[])    \n{    \n    #ifdef __x86_64__     \n    ¦   printf(\"__x86_64__\\n\");    \n    #else    \n    ¦   printf(\"__x86__\\n\");    \n    #endif    \n    \n    \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n}  \n\n\n\nsystem.c\n  #define SYSTEM sys ## tem      \n                     \n  int main(){        \n     SYSTEM(\"echo hello world\\n\");    \n  }\ngcc system.c                        // 虽然这会报错， 但是没有影响\n./a.out\n\nhello world\n\n\n\n// 奇数行输出ture\n#define true    (__LINE__%2!=0)\n\n\n\nnames.c\n#include &lt;stdio.h&gt;    \n#define NAMES(X) X(TOM) X(Jerry) X(Lcc) X(Hig) X(lcu)    \n#define HELLO(M) M(Hello) M(world) M(\\n)    \n    \nint main(int argc, char* argv[])    \n{    \n    #define PRINT(x) puts(\"hello,\" #x \"!\");    \n    NAMES(PRINT)    \n    HELLO(PRINT)    \n    return 0;    \n} \ngcc -E names.c 使用gcc -E 进行查看预编译的代码。\n# 5 \"namex.c\"\nint main(int argc, char* argv[])\n{\n\n    puts(\"hello,\" \"TOM\" \"!\"); puts(\"hello,\" \"Jerry\" \"!\"); puts(\"hello,\" \"Lcc\" \"!\"); puts(\"hello,\" \"Hig\" \"!\"); puts(\"hello,\" \"lcu\" \"!\");\n    puts(\"hello,\" \"Hello\" \"!\"); puts(\"hello,\" \"world\" \"!\"); puts(\"hello,\" \"\\n\" \"!\");\n    return 0;\n}\n\n\n\n连个函数文件，一个sum.c和main.c先对这两个文件进行编译，没有链接， 然后手动指定链接，最后运行a.out同样产生相同结果。\nsum.c\nint foo(int n){                                                             \n    int sum = 0;                                                                                   \n    for(int i=0;i&lt;=n;i++){                                                                         \n    ¦   sum+=i;                                                                                     \n    }                                                                                               \n    return sum;                                                                                     \n}\nmain.c\n#include &lt;stdio.h&gt;    \n    \nint foo(int n);    \n    \n    \nint main(int argc, char* argv[])    \n{    \n    printf(\"%d\\n\",foo(100));    \n    return 0;    \n}\n ### 链接\n gcc {main,sum}.o -static\n ## 内存 &gt;总结 &gt; - 代码存储的位置最低, 然后是只读变量(const修饰的变量), RO上面就是非零的变量, RW上边就是0变量和为被初始化的变量.上面就是堆栈. &gt;  &gt; 参考代码\n#include &lt;stdio.h&gt;\nvoid printptr(void *p){\n    printf(\"p = %p; *p = %016lx\\n\",p, *(long *)p);\n}\n \nchar bss_1[10];\n \nstatic int _static_1=65535;// ffff\nstatic int _static_2;\n \nint glab_1=65535;\nint glab_2;\nint glab_3=0;\n \nconst char _const = 'a';\nint main(int argc,char *argv[]){\n    int b;\n    static int _static_3=65535;\n    static int _static_4=0;\n    \n    printf(\"------- [code] ------\\n\");\n    printf(\"main:\\t\");\n    printptr(main); // 代码\n    printf(\"main:\\t\");\n    printptr(&main);\n \n    printf(\"------- [data] ------\\n\");\n    printf(\"_____________[data-RO]_____________\\n\");\n    printf(\"&const:\\t\");\n    printf(\"p = %p;\\n\",&_const);\n    printf(\"_____________[data-RW]_____________\\n\");\n    printf(\"stac_1:\\t\");\n    printptr(&_static_1);\n    printf(\"stac_2:\\t\");\n    printptr(&_static_2);\n    printf(\"stac_3:\\t\");\n    printptr(&_static_3);\n    printf(\"stac_4:\\t\");\n    printptr(&_static_4);\n \n    printf(\"glab_1:\\t\");\n    printptr(&glab_1); // 数据\n    printf(\"glab_2:\\t\");\n    printptr(&glab_2); // 数据\n    printf(\"glab_3:\\t\");\n    printptr(&glab_3);\n    printf(\"&bss_1:\\t\");\n    printf(\"p = %p;\\n\",&bss_1);\n    printf(\"b:\\t\");\n    printptr(&b);\n    printf(\"------- [heap] ------\\n\");\n\n    printf(\"\\n\");\n\n    printf(\"------- [stack] ------\\n\");\n    printf(\"argc:\\t\");\n    printptr(&argc); // 堆栈\n    printf(\"argv\\t\");\n    printptr(argv); \n    printf(\"&argv:\\t\");\n    printptr(&argv); \n    printf(\"argv[0:\\t\");\n    printptr(argv[0]);\n}\n # p3- C 语言拾遗(2): 编程实践 &gt; 总结: &gt; - 提升代码的可读性(Readable),明确代码的可维护性 &gt; - 函数指针 &gt; - 实战yemu(计算机系统运行原理)\n\n\n\n通过signal的例子来说明如何提升代码的可读性.\n// 这样的代码可读性就比较差(顺时针螺旋法则)\nvoid (*signal (int sig, void (*func)(int)))(int);\n优化后的代码, 大大提升了代码的可阅读性\n// 定义一个函数指针类型 sighandler_t, 表示他是一个接收参数数int的函数\ntypedef void (*sighandler_t)(int);\n// 返回值是sighandler_t类型(返回函数类型),接收参数为一个int和一个接收为int的一个函数.\nsighandler_t signal(int, sighandler_t);\n\n\nNEMU就是YEMU的增强.(通过YEMU的案例进一步说明代码的可读性和可维护性的重要性)\n\n\n第2,3位表示 rt -&gt; register target(猜测)目标寄存器,\n第0,1位表示 rs -&gt; register source (猜测)源寄存器\n0123 表示的是指令的位置(第0,1,2,3位,4567类似)\n0000 表示mov\n0001 表示add\n1110 表示load(默认加载到RA(R0)寄存器)\n1111 表示store(默认将RA(R0)中的数据存储到制定地址)\n\n &gt; ## extern 将一个文件内的变量扩展到其他文件也可以使用\n.\n├── a.c    // 变量所在位置\n├── a.h\n├── a.out\n└── main.c  // 将要使用的位置\n\n\na.h\n\nvoid hello(int num);\nextern int num;  // 添加外部变量\na.c\n#include &lt;stdio.h&gt;\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\n\nint main(void){\n    // method 2:在头文件中声明exter所需变量 \n    // method 1: 解除下面的注释.\n    //    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\na.h\n\nvoid hello(int num);\na.c\n#include &lt;stdio.h&gt;\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\nint main(void){\n    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\n将变量类型组合, 公用一个结构,个人感觉有点像是一个大的结构体(但是其所占用的大小是最大的那个变量的大小),将所有类型进行组合,大大提升代码的可阅读性和可维护性.\n\n#include &lt;stdio.h&gt;\n\nunion data{\n    long age;\n    char ch;\n};\n\nint main(int argc, char* argv[])\n{\n      \n    union data stu1;\n    stu1.age = 18;\n    stu1.ch = 'a';\n    printf(\"union.age:%ld,sizeof:%ld\\n\",stu1.age,sizeof(stu1));\n    printf(\"union.ch:%d,sizeof:%ld\\n\",stu1.ch,sizeof(stu1));\n    return 0;\n}\n对bit位进行操作,\n#include &lt;stdio.h&gt;\n\ntypedef union inst{\n    //  type(int is 16bit)  part1:size, part2:size\n    struct {int a:8, b:8; } atype;\n    struct {int a:8, b:8; } btype;\n}intst_t;\n\nstruct {int a:8, b:8; } ctype;\n\nint main(int argc, char* argv[])\n{\n    ctype.a = 0b01111111;\n    ctype.b = 0b10000011;\n    printf(\"%d %d size:%ld\\n\",ctype.a,ctype.b,sizeof(ctype));   \n    return 0;\n}\n\n\n使用makefile进行文件的构建对整个项目进行托管, 提升开发效率\n\n.PHONY: run clean test\n\nCFLAGS = -Wall -Werror -std=c11 -O2\nCC = gcc\nLD = gcc\n\n# 构建yemu所需要yemu.o 和idex.o\nyemu: yemu.o idex.o\n    # 使用的命令为:gcc -Wall -Werror -std=c11 -O2 -o yemu yemu.o idex.o\n    $(LD) $(LDFLAGS) -o yemu yemu.o idex.o\n\nyemu.o: yemu.c yemu.h\n    $(CC) $(CFLAGS) -c -o yemu.o yemu.c\n\nidex.o: idex.c yemu.h\n    $(CC) $(CFLAGS) -c -o idex.o idex.c\n\n# make run\nrun: yemu\n    # @表示将该cmd不输出到终端\n    @./yemu\n# make clean\nclean:\n    # 使用make clean所执行的命令\n    rm -f test yemu *.o\n\n# make test\ntest: yemu\n    $(CC) $(CFLAGS) -o test idex.o test.c && ./test"
  },
  {
    "objectID": "posts/南大ics课程/index.html#预编译指令",
    "href": "posts/南大ics课程/index.html#预编译指令",
    "title": "南大ics课程",
    "section": "",
    "text": "#include 表示将代码复制粘贴进来"
  },
  {
    "objectID": "posts/南大ics课程/index.html#eg1",
    "href": "posts/南大ics课程/index.html#eg1",
    "title": "南大ics课程",
    "section": "",
    "text": "hello.inc\n\nprintf(\"hello world\\n\");\n\nhello.c\n\n#include &lt;stdio.h&gt;    \n    \nint main(int argc, char* argv[])    \n{    \n    \n    #include \"hello.inc\"    \n    return 0;    \n} \ngcc -E hello.c\n gcc --verbose hello.c 查看include文件是否在包含的目录中\n可以看到#include \"xxx\"和#include &lt;xxx&gt;\"的位置  &gt;使用#include &lt;xxx&gt;\"进行包含文件挥发现找不到这个文件, 系统目录中没有包含该文件. &gt; 可以使用gcc -I./进行将目录添加到系统目录中\n问题演示  解决方案  gcc -I. --verbose hello.c查看日志中是否包含目录  gcc -m32 hello.c 将项目编译为32位机器的目标文件\n\n有趣的预编译, 因为aa和bb都没有定义所以都是NULL, NULL==NULL 得到True,所以输出yes\n\n#include &lt;stdio.h&gt;      \n                                                                             \nint main(int argc, char* argv[])                                             \n{                                                                            \n    #if aa == bb                                                             \n    ¦   printf(\"yes\\n\");                     \n    #else                                                                                                                     \n    ¦   printf(\"no\\n\");                            \n    #endif                                                                                                                                                                       \n}  \n gcc -E aabb.c 查看预编译后的代码.  直接放入extern int printf (const char *__restrict __format, ...);不用全部include也是可以的\nextern int printf (const char *__restrict __format, ...);     \nint main(int argc, char* argv[])    \n{                  \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n} \n编译32位项目,出现报错:https://blog.csdn.net/wzzushx/article/details/119453099\nsudo apt-get install build-essential module-assistant  \nsudo apt-get install gcc-multilib g++-multilib  \n预编译参数依旧添加进去了\nextern int printf (const char *__restrict __format, ...);    \n    \nint main(int argc, char* argv[])    \n{    \n    #ifdef __x86_64__     \n    ¦   printf(\"__x86_64__\\n\");    \n    #else    \n    ¦   printf(\"__x86__\\n\");    \n    #endif    \n    \n    \n    #if aa == bb    \n    ¦   printf(\"yes\\n\");    \n    #else    \n    ¦   printf(\"no\\n\");    \n    #endif    \n}"
  },
  {
    "objectID": "posts/南大ics课程/index.html#调用系统接口",
    "href": "posts/南大ics课程/index.html#调用系统接口",
    "title": "南大ics课程",
    "section": "",
    "text": "system.c\n  #define SYSTEM sys ## tem      \n                     \n  int main(){        \n     SYSTEM(\"echo hello world\\n\");    \n  }\ngcc system.c                        // 虽然这会报错， 但是没有影响\n./a.out\n\nhello world"
  },
  {
    "objectID": "posts/南大ics课程/index.html#宏定义的展开",
    "href": "posts/南大ics课程/index.html#宏定义的展开",
    "title": "南大ics课程",
    "section": "",
    "text": "// 奇数行输出ture\n#define true    (__LINE__%2!=0)"
  },
  {
    "objectID": "posts/南大ics课程/index.html#x-macros",
    "href": "posts/南大ics课程/index.html#x-macros",
    "title": "南大ics课程",
    "section": "",
    "text": "names.c\n#include &lt;stdio.h&gt;    \n#define NAMES(X) X(TOM) X(Jerry) X(Lcc) X(Hig) X(lcu)    \n#define HELLO(M) M(Hello) M(world) M(\\n)    \n    \nint main(int argc, char* argv[])    \n{    \n    #define PRINT(x) puts(\"hello,\" #x \"!\");    \n    NAMES(PRINT)    \n    HELLO(PRINT)    \n    return 0;    \n} \ngcc -E names.c 使用gcc -E 进行查看预编译的代码。\n# 5 \"namex.c\"\nint main(int argc, char* argv[])\n{\n\n    puts(\"hello,\" \"TOM\" \"!\"); puts(\"hello,\" \"Jerry\" \"!\"); puts(\"hello,\" \"Lcc\" \"!\"); puts(\"hello,\" \"Hig\" \"!\"); puts(\"hello,\" \"lcu\" \"!\");\n    puts(\"hello,\" \"Hello\" \"!\"); puts(\"hello,\" \"world\" \"!\"); puts(\"hello,\" \"\\n\" \"!\");\n    return 0;\n}"
  },
  {
    "objectID": "posts/南大ics课程/index.html#编译链接",
    "href": "posts/南大ics课程/index.html#编译链接",
    "title": "南大ics课程",
    "section": "",
    "text": "连个函数文件，一个sum.c和main.c先对这两个文件进行编译，没有链接， 然后手动指定链接，最后运行a.out同样产生相同结果。\nsum.c\nint foo(int n){                                                             \n    int sum = 0;                                                                                   \n    for(int i=0;i&lt;=n;i++){                                                                         \n    ¦   sum+=i;                                                                                     \n    }                                                                                               \n    return sum;                                                                                     \n}\nmain.c\n#include &lt;stdio.h&gt;    \n    \nint foo(int n);    \n    \n    \nint main(int argc, char* argv[])    \n{    \n    printf(\"%d\\n\",foo(100));    \n    return 0;    \n}\n ### 链接\n gcc {main,sum}.o -static\n ## 内存 &gt;总结 &gt; - 代码存储的位置最低, 然后是只读变量(const修饰的变量), RO上面就是非零的变量, RW上边就是0变量和为被初始化的变量.上面就是堆栈. &gt;  &gt; 参考代码\n#include &lt;stdio.h&gt;\nvoid printptr(void *p){\n    printf(\"p = %p; *p = %016lx\\n\",p, *(long *)p);\n}\n \nchar bss_1[10];\n \nstatic int _static_1=65535;// ffff\nstatic int _static_2;\n \nint glab_1=65535;\nint glab_2;\nint glab_3=0;\n \nconst char _const = 'a';\nint main(int argc,char *argv[]){\n    int b;\n    static int _static_3=65535;\n    static int _static_4=0;\n    \n    printf(\"------- [code] ------\\n\");\n    printf(\"main:\\t\");\n    printptr(main); // 代码\n    printf(\"main:\\t\");\n    printptr(&main);\n \n    printf(\"------- [data] ------\\n\");\n    printf(\"_____________[data-RO]_____________\\n\");\n    printf(\"&const:\\t\");\n    printf(\"p = %p;\\n\",&_const);\n    printf(\"_____________[data-RW]_____________\\n\");\n    printf(\"stac_1:\\t\");\n    printptr(&_static_1);\n    printf(\"stac_2:\\t\");\n    printptr(&_static_2);\n    printf(\"stac_3:\\t\");\n    printptr(&_static_3);\n    printf(\"stac_4:\\t\");\n    printptr(&_static_4);\n \n    printf(\"glab_1:\\t\");\n    printptr(&glab_1); // 数据\n    printf(\"glab_2:\\t\");\n    printptr(&glab_2); // 数据\n    printf(\"glab_3:\\t\");\n    printptr(&glab_3);\n    printf(\"&bss_1:\\t\");\n    printf(\"p = %p;\\n\",&bss_1);\n    printf(\"b:\\t\");\n    printptr(&b);\n    printf(\"------- [heap] ------\\n\");\n\n    printf(\"\\n\");\n\n    printf(\"------- [stack] ------\\n\");\n    printf(\"argc:\\t\");\n    printptr(&argc); // 堆栈\n    printf(\"argv\\t\");\n    printptr(argv); \n    printf(\"&argv:\\t\");\n    printptr(&argv); \n    printf(\"argv[0:\\t\");\n    printptr(argv[0]);\n}\n # p3- C 语言拾遗(2): 编程实践 &gt; 总结: &gt; - 提升代码的可读性(Readable),明确代码的可维护性 &gt; - 函数指针 &gt; - 实战yemu(计算机系统运行原理)\n\n\n\n通过signal的例子来说明如何提升代码的可读性.\n// 这样的代码可读性就比较差(顺时针螺旋法则)\nvoid (*signal (int sig, void (*func)(int)))(int);\n优化后的代码, 大大提升了代码的可阅读性\n// 定义一个函数指针类型 sighandler_t, 表示他是一个接收参数数int的函数\ntypedef void (*sighandler_t)(int);\n// 返回值是sighandler_t类型(返回函数类型),接收参数为一个int和一个接收为int的一个函数.\nsighandler_t signal(int, sighandler_t);\n\n\nNEMU就是YEMU的增强.(通过YEMU的案例进一步说明代码的可读性和可维护性的重要性)\n\n\n第2,3位表示 rt -&gt; register target(猜测)目标寄存器,\n第0,1位表示 rs -&gt; register source (猜测)源寄存器\n0123 表示的是指令的位置(第0,1,2,3位,4567类似)\n0000 表示mov\n0001 表示add\n1110 表示load(默认加载到RA(R0)寄存器)\n1111 表示store(默认将RA(R0)中的数据存储到制定地址)\n\n &gt; ## extern 将一个文件内的变量扩展到其他文件也可以使用\n.\n├── a.c    // 变量所在位置\n├── a.h\n├── a.out\n└── main.c  // 将要使用的位置\n\n\na.h\n\nvoid hello(int num);\nextern int num;  // 添加外部变量\na.c\n#include &lt;stdio.h&gt;\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\n\nint main(void){\n    // method 2:在头文件中声明exter所需变量 \n    // method 1: 解除下面的注释.\n    //    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\na.h\n\nvoid hello(int num);\na.c\n#include &lt;stdio.h&gt;\n\nint num = 100;\n\nvoid hello(int num){\n    printf(\"%d\\n\",num);\n}\nmain.c\n#include \"a.h\"\n\nint main(void){\n    extern int num;\n    int a = num;\n    hello(a);\n    return 0;\n}\n\n\n将变量类型组合, 公用一个结构,个人感觉有点像是一个大的结构体(但是其所占用的大小是最大的那个变量的大小),将所有类型进行组合,大大提升代码的可阅读性和可维护性.\n\n#include &lt;stdio.h&gt;\n\nunion data{\n    long age;\n    char ch;\n};\n\nint main(int argc, char* argv[])\n{\n      \n    union data stu1;\n    stu1.age = 18;\n    stu1.ch = 'a';\n    printf(\"union.age:%ld,sizeof:%ld\\n\",stu1.age,sizeof(stu1));\n    printf(\"union.ch:%d,sizeof:%ld\\n\",stu1.ch,sizeof(stu1));\n    return 0;\n}\n对bit位进行操作,\n#include &lt;stdio.h&gt;\n\ntypedef union inst{\n    //  type(int is 16bit)  part1:size, part2:size\n    struct {int a:8, b:8; } atype;\n    struct {int a:8, b:8; } btype;\n}intst_t;\n\nstruct {int a:8, b:8; } ctype;\n\nint main(int argc, char* argv[])\n{\n    ctype.a = 0b01111111;\n    ctype.b = 0b10000011;\n    printf(\"%d %d size:%ld\\n\",ctype.a,ctype.b,sizeof(ctype));   \n    return 0;\n}\n\n\n使用makefile进行文件的构建对整个项目进行托管, 提升开发效率\n\n.PHONY: run clean test\n\nCFLAGS = -Wall -Werror -std=c11 -O2\nCC = gcc\nLD = gcc\n\n# 构建yemu所需要yemu.o 和idex.o\nyemu: yemu.o idex.o\n    # 使用的命令为:gcc -Wall -Werror -std=c11 -O2 -o yemu yemu.o idex.o\n    $(LD) $(LDFLAGS) -o yemu yemu.o idex.o\n\nyemu.o: yemu.c yemu.h\n    $(CC) $(CFLAGS) -c -o yemu.o yemu.c\n\nidex.o: idex.c yemu.h\n    $(CC) $(CFLAGS) -c -o idex.o idex.c\n\n# make run\nrun: yemu\n    # @表示将该cmd不输出到终端\n    @./yemu\n# make clean\nclean:\n    # 使用make clean所执行的命令\n    rm -f test yemu *.o\n\n# make test\ntest: yemu\n    $(CC) $(CFLAGS) -o test idex.o test.c && ./test"
  },
  {
    "objectID": "posts/usb_cdc_stm32/index.html",
    "href": "posts/usb_cdc_stm32/index.html",
    "title": "stm32 usb cdc vitural serial port",
    "section": "",
    "text": "when we are using stm32 development, we offen used the usart, but we don’t want to add the usb2serial mode. we hope we can use the usb liner to connect with pc and stm32.\nthis usb cdc stolve the proublem, we can use the usart easily."
  },
  {
    "objectID": "posts/usb_cdc_stm32/index.html#config-usb-clock",
    "href": "posts/usb_cdc_stm32/index.html#config-usb-clock",
    "title": "stm32 usb cdc vitural serial port",
    "section": "config usb clock",
    "text": "config usb clock\nthe clock must be set to 48Mhz"
  },
  {
    "objectID": "posts/usb_cdc_stm32/index.html#fix-usb_cdc-continues-send-bug",
    "href": "posts/usb_cdc_stm32/index.html#fix-usb_cdc-continues-send-bug",
    "title": "stm32 usb cdc vitural serial port",
    "section": "fix usb_cdc continues send bug",
    "text": "fix usb_cdc continues send bug\nupdate the the CDC_Transmit_FS function. if you don’t want to fix you can try hal_delay()\nuint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)\n{\n  uint8_t result = USBD_OK;\n    uint32_t Timeout = HAL_GetTick();\n  /* USER CODE BEGIN 7 */\n  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;\n  if (hcdc-&gt;TxState != 0){\n    return USBD_BUSY;\n  }\n  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);\n  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);\n  /* USER CODE END 7 */\n    while(hcdc-&gt;TxState)\n    {\n        if(HAL_GetTick() - Timeout &gt;=10)//超时\n        {\n            break;\n        }\n    }\n  return result;\n}"
  },
  {
    "objectID": "posts/frida安装/index.html",
    "href": "posts/frida安装/index.html",
    "title": "frida安装",
    "section": "",
    "text": "frida的安装\n\nPC端 - frida - frida-tools\n\npip install frida\npip install frida-tools\n\n手机端 - frida-server-arm-15.2.2-x68-64 下载地址: https://github.com/frida/frida/releases 蓝奏云地址:\n\n文件传输到手机然后移动到/data/local/tmp/\nchmod 755 /data/local/tmp/frida-server\n/data/local/tmp/frida-server &\n\n# 测试查看进程\nfrida-ps -U\n\n\nfrida使用\n参考:https://frida.re/docs/quickstart/"
  },
  {
    "objectID": "posts/java网络编程-- 端口/index.html",
    "href": "posts/java网络编程-- 端口/index.html",
    "title": "java网络编程– 端口",
    "section": "",
    "text": "端口是为了定位到计算机内的软件所在位置\nnetstat -an  # 查看素有端口\nnetstat -an|findstr \"5900\"  # 查看指定的端口\ntasklist|findstr \"8696\"     # 查看指定端口的进程\npackage cn.usts.edu.lesson01;\n\nimport java.net.InetSocketAddress;\n\npublic class TestSocketAddress {\n    public static void main(String[] args) {\n        InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080);\n        System.out.println(socketAddress);\n        System.out.println(socketAddress.getAddress());// 地址\n        System.out.println(socketAddress.getPort());    // 端口\n        System.out.println(socketAddress.getHostName());  // 域名//C:\\Windows\\System32\\drivers\\etc\\hosts文件中\n    }\n}"
  },
  {
    "objectID": "posts/javaGUI--东西南北中布局/index.html",
    "href": "posts/javaGUI--东西南北中布局/index.html",
    "title": "javaGUI–东西南北中布局",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\n\npublic class TestBorderLauOut {\n\n    // 东西南北中布局\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"BorderLayout\");\n        frame.setSize(500,500);\n        frame.setVisible(true);\n        Button button1 = new Button(\"button1\");\n        Button button2 = new Button(\"button2\");\n        Button button3 = new Button(\"button3\");\n        Button button4 = new Button(\"button4\");\n        Button button5 = new Button(\"button5\");\n\n        frame.add(button1,BorderLayout.CENTER);\n        frame.add(button2,BorderLayout.NORTH);\n        frame.add(button3,BorderLayout.EAST);\n        frame.add(button4,BorderLayout.SOUTH);\n        frame.add(button5,BorderLayout.WEST);\n\n\n    }\n\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "href": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "title": "qt –问题总结(头文件问题,QString转换,查找组件)",
    "section": "",
    "text": "项目问题解决\n在使用过程中无法使用控件的大多数原因就是因为没有在.h文件中创建方法. 只有集成的类中才会有组件,单独的cpp中没有组件.所以会报错.如果已经使用继承类,已经可以跳转.但是还是报错,大多刷新解决方案即可.  ### 查找QObject\n  QString objectNameBtn = sender()-&gt;objectName();\n    QPushButton *tempButton = this-&gt;findChild&lt;QPushButton *&gt;(objectNameBtn);\n\n字符串转换QString &lt; == &gt; std::string\nQString qstr;\nstd::string str;\n//===============================\n//QString转std::string\nstr = qstr.toStdString();\n//===============================\n//std::string转QString\nqstr = QString::fromStdString(str);\n\n\n找到父对象控件\nparent , parentWidget, setParent\nuserFrame-&gt;parentWidget()-&gt;setWindowFlags(Qt::WindowMinMaxButtonsHint);\n// 用管道符添加多个属性\nuserFrame-&gt;parentWidget()-&gt;setWindowFlags(Qt::Dialog|Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint);\n\n\n找到子组件\nfindChild,findChildren ### windowFlags参数 原文:https://blog.csdn.net/xuebing1995/article/details/96478891\nQt::Widget               //是一个窗口或部件，有父窗口就是部件，没有就是窗口\nQt::Window               //是一个窗口，有窗口边框和标题\nQt::Dialog               //是一个对话框窗口\nQt::Sheet                //是一个窗口或部件Macintosh表单\nQt::Drawer               //是一个窗口或部件Macintosh抽屉，去掉窗口左上角的图标\nQt::Popup                //是一个弹出式顶层窗口\nQt::Tool                 //是一个工具窗口\nQt::ToolTip              //是一个提示窗口，没有标题栏和窗口边框\nQt::SplashScreen         //是一个欢迎窗口，是QSplashScreen构造函数的默认值\nQt::Desktop              //是一个桌面窗口或部件\nQt::SubWindow            //是一个子窗口\n\n窗口属性\nQt::CustomizeWindowHint          //关闭默认窗口标题提示\nQt::WindowTitleHint              //为窗口修饰一个标题栏\nQt::WindowSystemMenuHint         //为窗口修饰一个窗口菜单系统\nQt::WindowMinimizeButtonHint     //为窗口添加最小化按钮\nQt::WindowMaximizeButtonHint     //为窗口添加最大化按钮\nQt::WindowMinMaxButtonsHint      //为窗口添加最大化和最小化按钮\nQt::WindowCloseButtonHint           //窗口只有一个关闭按钮\nQt::WindowContextHelpButtonHint\nQt::MacWindowToolBarButtonHint\nQt::WindowFullscreenButtonHint\nQt::BypassGraphicsProxyWidget\nQt::WindowShadeButtonHint\nQt::WindowStaysOnTopHint    //总在最上面的窗口,置前\nQt::WindowStaysOnBottomHint\nQt::WindowOkButtonHint\nQt::WindowCancelButtonHint\nQt::WindowTransparentForInput"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread定时器/index.html",
    "href": "posts/stm32F103-RT-Thread定时器/index.html",
    "title": "stm32F103-RT-Thread定时器",
    "section": "",
    "text": "创建两个动态定时器，一个是单次定时，一个是周期性定时,并让周期定时器运行一段时间后停止运行 硬件定时器，定时器的回调函数将在系统时钟中断里调用。 软件定时器，定时器的回调函数将在定时器线程中调用。\n\n\n\n\n在这里插入图片描述\n\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nstatic rt_timer_t timer_1;\nstatic rt_timer_t timer_2;\nstatic int count_c = 0;\nstatic int short_c = 0;\n\n\nstatic void timeout_1(void *parameter);\nstatic void timeout_2(void *parameter);\n\n/* timer_1 is run 10 times then stop  */\nstatic void timeout_1(void *parameter){\n    \n    rt_kprintf(\"periodic timer_[1] is start. --&gt; count is [%d]\\n\",count_c);\n    if(count_c++&gt;=90){\n        rt_timer_stop(timer_1);\n        rt_kprintf(\"timer_[1] was stoped!\\n\");\n    }\n}\n\nstatic void timeout_2(void *parameter){\n    short_c++;\n    \n    rt_kprintf(\"short timer_[2] is start. --&gt;short is [%d]\\n\", short_c);\n}\n\nint main(void)\n{\n    // create timer_1 and flag is periodic model\n    timer_1 = rt_timer_create(\"timer1\", timeout_1,RT_NULL,90,RT_TIMER_FLAG_PERIODIC);\n    \n    // create timer_2 and flag is short model(count only once then stop)\n    timer_2 = rt_timer_create(\"timer2\", timeout_2, RT_NULL, 30, RT_TIMER_FLAG_PERIODIC);\n\n    if(timer_1!=RT_NULL){\n        rt_timer_start(timer_1);\n    }\n\n    if (timer_2 != RT_NULL)\n    {\n        rt_timer_start(timer_2);\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread定时器/index.html#定时器timer",
    "href": "posts/stm32F103-RT-Thread定时器/index.html#定时器timer",
    "title": "stm32F103-RT-Thread定时器",
    "section": "",
    "text": "创建两个动态定时器，一个是单次定时，一个是周期性定时,并让周期定时器运行一段时间后停止运行 硬件定时器，定时器的回调函数将在系统时钟中断里调用。 软件定时器，定时器的回调函数将在定时器线程中调用。\n\n\n\n\n在这里插入图片描述\n\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nstatic rt_timer_t timer_1;\nstatic rt_timer_t timer_2;\nstatic int count_c = 0;\nstatic int short_c = 0;\n\n\nstatic void timeout_1(void *parameter);\nstatic void timeout_2(void *parameter);\n\n/* timer_1 is run 10 times then stop  */\nstatic void timeout_1(void *parameter){\n    \n    rt_kprintf(\"periodic timer_[1] is start. --&gt; count is [%d]\\n\",count_c);\n    if(count_c++&gt;=90){\n        rt_timer_stop(timer_1);\n        rt_kprintf(\"timer_[1] was stoped!\\n\");\n    }\n}\n\nstatic void timeout_2(void *parameter){\n    short_c++;\n    \n    rt_kprintf(\"short timer_[2] is start. --&gt;short is [%d]\\n\", short_c);\n}\n\nint main(void)\n{\n    // create timer_1 and flag is periodic model\n    timer_1 = rt_timer_create(\"timer1\", timeout_1,RT_NULL,90,RT_TIMER_FLAG_PERIODIC);\n    \n    // create timer_2 and flag is short model(count only once then stop)\n    timer_2 = rt_timer_create(\"timer2\", timeout_2, RT_NULL, 30, RT_TIMER_FLAG_PERIODIC);\n\n    if(timer_1!=RT_NULL){\n        rt_timer_start(timer_1);\n    }\n\n    if (timer_2 != RT_NULL)\n    {\n        rt_timer_start(timer_2);\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/java多线程-- Callable接口简单应用/index.html",
    "href": "posts/java多线程-- Callable接口简单应用/index.html",
    "title": "java多线程– Callable接口简单应用",
    "section": "",
    "text": "使用callable接口的四个步骤 * 1.创建执行服务 * 2.提交执行服务 * 3.获取执行结果 * 4.关闭服务\npackage cn.usts.edu.lesson03;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.concurrent.*;\n\n/**\n * 使用callable接口\n * 1.创建执行服务\n * 2.提交执行服务\n * 3.获取执行结果\n * 4.关闭服务\n * */\n\npublic class CallableDemo implements Callable {\n    String file;\n    String url;\n    String filename;\n\n    public CallableDemo(String file, String url) {\n        this.file = file;\n        this.url = url;\n    }\n\n    @Override\n    public Boolean call() {\n        ImageDownload imageDownload = new ImageDownload();\n        imageDownload.downLoad(url,file);\n        filename = file.split(\"\\\\\\\\\")[11];//获取文件名\n        System.out.println(filename+\"下载完成\");\n        return true;\n    }\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CallableDemo t1 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\a.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/1c3eb5a6f1d59adaa9b608c7da64d95a.jpg\");\n        CallableDemo t2 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\b.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/6d254e56adf9094cc003c815d3d6d3e1.jpg\");\n        CallableDemo t3 = new CallableDemo(\n                \"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\ThreadStudy\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson01\\\\c.jpg\"\n                ,\"https://bbs.qn.img-space.com/202110/18/72d862d6074bb2edc1e6df61ce78455f.jpg\"\n        );\n\n        //        *1.创建执行服务\n        ExecutorService service = Executors.newFixedThreadPool(3);\n\n        //        * 2.提交执行服务\n        Future&lt;Boolean&gt; r1 = service.submit(t1);\n        Future&lt;Boolean&gt; r2 = service.submit(t2);\n        Future&lt;Boolean&gt; r3 = service.submit(t3);\n\n        //        * 3.获取执行结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //        * 4.关闭服务\n        service.shutdown();\n\n    }\n\n}\n\nclass  ImageDownload{\n\n    public void downLoad(String url,String file)  {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(file));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downLoad()方法出错\");\n        }\n    }\n}"
  },
  {
    "objectID": "posts/jdbc-- PreparedStatement( DML语句)insert,delete,update/index.html",
    "href": "posts/jdbc-- PreparedStatement( DML语句)insert,delete,update/index.html",
    "title": "jdbc– PreparedStatement( DML语句)insert,delete,update",
    "section": "",
    "text": "PreparedStatement( DML语句)insert,delete,update\npackage cn.usts.edu.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n/**\n * @author ：fly\n * @description:  测试PreparedStatement\n *                 对sql注入的解决\n *                 以及常用方法  DML语句\n * @date ：2021/11/5 16:06\n */\npublic class PreparedStatementDemo {\n\n    // CRUD\n    @Test\n    public void crud() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {\n\n        // 注册驱动\n        Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver =(Driver) aClass.newInstance();\n        DriverManager.registerDriver(driver);\n        FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\Jdbc\\\\src\\\\cn\\\\usts\\\\edu\\\\config\\\\db.properties\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        String url=(String) properties.get(\"url\");\n        String user=(String) properties.get(\"user\");\n        String password=(String) properties.get(\"password\");\n\n        // 建立连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        // 执行sql\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入用户名\");//\n        String name = scanner.nextLine();// nextLine不会空格切断    用户名 1' or\n        System.out.println(\"输入密码\");\n        String psd = scanner.nextLine();// nextLine不会空格切断   万能密码 or '1' = 1'\n\n\n        //String sql =\"insert into admin (amin, psd) values (?,?);\";// insert\n        //String sql =\"update admin set psd = ? where ? = amin\";  // update\n        String sql =\"delete from admin where amin=?\";   // delete\n\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setString(1,name);\n        //preparedStatement.setString(2,name); // 占位符位置\n        //preparedStatement.setString(1,psd);\n        int rows = preparedStatement.executeUpdate();// 这里不用在给sql了 返回修改行数\n\n        System.out.println(\"执行行数\"+rows);\n\n        // 切断链接\n        preparedStatement.close();\n        connection.close();\n\n\n    }\n\n\n\n\n}"
  },
  {
    "objectID": "posts/qt无法输出/index.html",
    "href": "posts/qt无法输出/index.html",
    "title": "qt无法输出",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/vs studio添加include和依赖库/index.html",
    "href": "posts/vs studio添加include和依赖库/index.html",
    "title": "vs studio添加include和依赖库",
    "section": "",
    "text": "无法打开 源 文件 “xxxxxx”\n解决办法: 添加include文件夹\n\n\n\n在这里插入图片描述\n\n\n项目右键属性,c/c++,添加附加包含目录, 找到你所需要的头文件的位置,\n\n\n\n在这里插入图片描述\n\n\n添加lib库: * 链接器-&gt;常规-&gt;附加库目录-&gt;\n\n\n链接器-&gt;输入-&gt;附加依赖-&gt;输入需要的依赖项.\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/web-packet --01/index.html",
    "href": "posts/web-packet --01/index.html",
    "title": "web-packet –01",
    "section": "",
    "text": "进入\nnpm -init -y\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n&lt;!--        ul&gt;li{这是$}*9--&gt;\n        &lt;ul&gt;\n            &lt;li&gt;这是第1个li&lt;/li&gt;\n            &lt;li&gt;这是第2个li&lt;/li&gt;\n            &lt;li&gt;这是第3个li&lt;/li&gt;\n            &lt;li&gt;这是第4个li&lt;/li&gt;\n            &lt;li&gt;这是第5个li&lt;/li&gt;\n            &lt;li&gt;这是第6个li&lt;/li&gt;\n            &lt;li&gt;这是第7个li&lt;/li&gt;\n            &lt;li&gt;这是第8个li&lt;/li&gt;\n            &lt;li&gt;这是第9个li&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nindex.js\nimport $ from 'jquery'\n\n// 实现隔行变色\n$(function (){\n    // 奇数行\n    $('li:odd').css('backgroundColor','red')\n    // 偶数行\n    $('li:even').css('backgroundColor','red')\n})\n 安装 jQuery，webpack\nnpm install jquery -S\nnpm install webpack\n// 开发时存在\nnpm install webpack-cli -D\n创建名为 webpack.config.js 的 webpack 配置文件\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n  output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  }\n};\n在 package.json 的 scripts 节点下，新增 dev 脚本如下  ## 添加插件（修改自动同步） 安装\nnpm install webpack-dev-server -D\n配置 出现 使用webpack插件webpack-dev-server 出现Cannot GET/的解决办法\n \ndevServer: {\n        static:'./', // webpack can not GET /\n    }\nwebpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n\n    output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  },\n    devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:false,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    }\n};\n\n\n在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ * css-loader 可以打包处理 .css 相关的文件 * less-loader 可以打包处理 .less 相关的文件 * babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 ### 安准css-loader：\nnpm i style-loader@2.0.0 css-loader@5.0.1 -D\n# less-loader\nnpm i less less-loader -D\n\n\n\nmodule: {// 设置loader规则,从后往前生效\n    rules: [\n        { test: /\\.css$/, use: ['style-loader','css-loader'] },\n        { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] },\n    ],\n  },\n ### 打包处理样式表中与 url 路径相关的文件\nnpm i url-loader file-loader -D\n\nwebpack.config.js\n// 体积小于limit: 8192就会转成base64\n{ test: /\\.(png|jpg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 8192}}]},\n\n\n\n就要用到bable-loader webpack-loader配置 # 打包发布\n\"build\": \"webpack --mode production\"\n\n\n\n开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致：  ### 完成整 webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst path = require('path');\n\n// 1. 导入插件，得到构造函数\nconst HtmlPlugin = require('html-webpack-plugin')\n// 2. 创建插件的实例对象\nconst htmlPlugin = new HtmlPlugin({\n  template: './src/index.html',\n  filename: './index.html',\n})\n\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst cleanPlugin = new CleanWebpackPlugin()\n\nmodule.exports = {\n  mode: 'development', // development  production\n  // eval-source-map 仅限在开发模式下使用\n   devtool: 'eval-source-map',\n  // 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map\n  // devtool: 'nosources-source-map',\n  // devtool: 'source-map',\n  // 指定打包的入口\n  entry: path.join(__dirname, './src/index.js'),\n  // 指定打包的出口\n  output: {\n    // 表示输出文件的存放路径\n    path: path.join(__dirname, './dist'),\n    // 表示输出文件的名称\n    filename: 'js/bundle.js',\n  },\n  plugins: [htmlPlugin, cleanPlugin], // 3. 挂载插件的实例对象\n  devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:true,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    },\n  module: {\n    rules: [\n      { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n      { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n      // { test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22228' }\n      {test: /\\.jpg|png|gif$/, use: {loader: 'url-loader', options: {limit: 22228,outputPath: 'image',},},},\n      {test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: ['@babel/plugin-proposal-class-properties'],\n          },\n        },\n      },//babel-loader\n    ],\n  },\n\n};"
  },
  {
    "objectID": "posts/web-packet --01/index.html#新建项目文件夹",
    "href": "posts/web-packet --01/index.html#新建项目文件夹",
    "title": "web-packet –01",
    "section": "",
    "text": "进入\nnpm -init -y\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n&lt;!--        ul&gt;li{这是$}*9--&gt;\n        &lt;ul&gt;\n            &lt;li&gt;这是第1个li&lt;/li&gt;\n            &lt;li&gt;这是第2个li&lt;/li&gt;\n            &lt;li&gt;这是第3个li&lt;/li&gt;\n            &lt;li&gt;这是第4个li&lt;/li&gt;\n            &lt;li&gt;这是第5个li&lt;/li&gt;\n            &lt;li&gt;这是第6个li&lt;/li&gt;\n            &lt;li&gt;这是第7个li&lt;/li&gt;\n            &lt;li&gt;这是第8个li&lt;/li&gt;\n            &lt;li&gt;这是第9个li&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nindex.js\nimport $ from 'jquery'\n\n// 实现隔行变色\n$(function (){\n    // 奇数行\n    $('li:odd').css('backgroundColor','red')\n    // 偶数行\n    $('li:even').css('backgroundColor','red')\n})\n 安装 jQuery，webpack\nnpm install jquery -S\nnpm install webpack\n// 开发时存在\nnpm install webpack-cli -D\n创建名为 webpack.config.js 的 webpack 配置文件\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n  output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  }\n};\n在 package.json 的 scripts 节点下，新增 dev 脚本如下  ## 添加插件（修改自动同步） 安装\nnpm install webpack-dev-server -D\n配置 出现 使用webpack插件webpack-dev-server 出现Cannot GET/的解决办法\n \ndevServer: {\n        static:'./', // webpack can not GET /\n    }\nwebpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n\n    output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  },\n    devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:false,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    }\n};\n\n\n在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ * css-loader 可以打包处理 .css 相关的文件 * less-loader 可以打包处理 .less 相关的文件 * babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 ### 安准css-loader：\nnpm i style-loader@2.0.0 css-loader@5.0.1 -D\n# less-loader\nnpm i less less-loader -D\n\n\n\nmodule: {// 设置loader规则,从后往前生效\n    rules: [\n        { test: /\\.css$/, use: ['style-loader','css-loader'] },\n        { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] },\n    ],\n  },\n ### 打包处理样式表中与 url 路径相关的文件\nnpm i url-loader file-loader -D\n\nwebpack.config.js\n// 体积小于limit: 8192就会转成base64\n{ test: /\\.(png|jpg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 8192}}]},\n\n\n\n就要用到bable-loader webpack-loader配置 # 打包发布\n\"build\": \"webpack --mode production\"\n\n\n\n开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致：  ### 完成整 webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst path = require('path');\n\n// 1. 导入插件，得到构造函数\nconst HtmlPlugin = require('html-webpack-plugin')\n// 2. 创建插件的实例对象\nconst htmlPlugin = new HtmlPlugin({\n  template: './src/index.html',\n  filename: './index.html',\n})\n\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst cleanPlugin = new CleanWebpackPlugin()\n\nmodule.exports = {\n  mode: 'development', // development  production\n  // eval-source-map 仅限在开发模式下使用\n   devtool: 'eval-source-map',\n  // 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map\n  // devtool: 'nosources-source-map',\n  // devtool: 'source-map',\n  // 指定打包的入口\n  entry: path.join(__dirname, './src/index.js'),\n  // 指定打包的出口\n  output: {\n    // 表示输出文件的存放路径\n    path: path.join(__dirname, './dist'),\n    // 表示输出文件的名称\n    filename: 'js/bundle.js',\n  },\n  plugins: [htmlPlugin, cleanPlugin], // 3. 挂载插件的实例对象\n  devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:true,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    },\n  module: {\n    rules: [\n      { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n      { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n      // { test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22228' }\n      {test: /\\.jpg|png|gif$/, use: {loader: 'url-loader', options: {limit: 22228,outputPath: 'image',},},},\n      {test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: ['@babel/plugin-proposal-class-properties'],\n          },\n        },\n      },//babel-loader\n    ],\n  },\n\n};"
  },
  {
    "objectID": "posts/java网络编程-- IP地址/index.html",
    "href": "posts/java网络编程-- IP地址/index.html",
    "title": "java网络编程– IP地址",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class TestInetAddress {\n    public static void main(String[] args) {\n        try {\n            // 获取本机地址\n            InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\");\n            System.out.println(inetAddress);\n\n            InetAddress inetAddress02 = InetAddress.getByName(\"localhost\");\n            System.out.println(inetAddress02);\n\n            InetAddress inetAddress03 = InetAddress.getLocalHost();\n            System.out.println(inetAddress03);\n\n            // 查询网络ip地址\n            InetAddress inetAddress01 = InetAddress.getByName(\"www.baidu.com\");\n            System.out.println(inetAddress01);\n\n            // 常用方法\n            //System.out.println(inetAddress01.getAddress()); 不常用\n            System.out.println(inetAddress01.getHostAddress());// ip地址\n            System.out.println(inetAddress01.getCanonicalHostName()); // 规范名字\n            System.out.println(inetAddress01.getHostName()); // 域名/主机名\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "objectID": "posts/java常用类-- 包装类/index.html",
    "href": "posts/java常用类-- 包装类/index.html",
    "title": "java常用类– 包装类",
    "section": "",
    "text": "package cn.usts.edu.fly.packingClass;\n\n/**\n * @author ：fly\n * @description: 包装类:\n *                     java中有8大基本数据类型,但是没有属性和和方法,于是jdk出现了包装类\n *                     byte Byte   char Char   int Integer   short    Short\n *                     long Long   float  Float  double Double  boolean  Boolean\n *\n *                     自动装箱\n *                     基本类型  ---&gt;  包装类型\n *                     int      --&gt;    Integer   自动装箱\n *\n *\n *                     自动拆箱\n *                     基本类型  &lt;---  包装类型\n *                     int      &lt;--    Integer   自动拆箱\n *\n *\n *                     valueOf:返回的是个包装类\n *                     parseInt：返回的就是基本数据类型\n * @date ：2021/10/31 16:15\n */\npublic class PackingDemo {\n    public static void main(String[] args) {\n        String a = \"123\";\n        int i = Integer.parseInt(a);// 把string类型转换为int类型\n        System.out.println(i+1);\n        int b = 456;\n        System.out.println(123+String.valueOf(b)+\"789\");// int转换为字符串\n    }\n\n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/bug--Pyqt5+openCV报错(QObject__moveToThread_)/index.html",
    "href": "posts/bug--Pyqt5+openCV报错(QObject__moveToThread_)/index.html",
    "title": "bug – Pyqt5+openCV报错(QObject_moveToThread)",
    "section": "",
    "text": "报错什么线程无法移动，妈个鸡狗屁不是\n使用pyqt和opencv的做的GUI程序中出线的问题\n就是opcv-python的版本对不上\n\n\n\n系统\npy版本（conda）\n报错\n\n\n\n\nUbuntu21\n3.9\nCannot move to target thread\n\n\n\nQObject::moveToThread: Current thread (0x5560b72388b0) is not the object's thread (0x5560b74641b0).\nCannot move to target thread (0x5560b72388b0)\n\n\n这个报错是上面的报错引起的\nqt.qpa.plugin: Could not load the Qt platform plugin \"xcb\" in \"/home/fly/anaconda3/envs/video/lib/python3.9/site-packages/cv2/qt/plugins\" even though it was found.\nThis application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.（\n\nAvailable platform plugins are: xcb, eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland, wayland-xcomposite-egl, wayland-xcomposite-glx, webgl.\n\n\n解决方案：降版本，网上的都是说降opencv版本，这里推荐降python（血泪记忆）\nopencv-python4.1.2.30 把上面的文件下载，本地安装即可(虚拟环境切换到相应的虚拟环境)\npip install opencv_python-4.1.2.30-cp38-cp38-manylinux1_x86_64.whl \n\n\n成功解决\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java网络编程-- 文件传输/index.html",
    "href": "posts/java网络编程-- 文件传输/index.html",
    "title": "java网络编程– 文件传输",
    "section": "",
    "text": "客户端发送\npackage cn.usts.edu.lesson03;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TcpFileClientDemo {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9999);\n            OutputStream outputStream = socket.getOutputStream();\n            // 读取文件\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson03\\\\hello.txt\");\n            //FileInputStream fileInputStream = new FileInputStream(new File(\"D:\\\\all_projects\\\\java_projects\\\\java_ij\\\\springMVC\\\\NetWork\\\\src\\\\cn\\\\usts\\\\edu\\\\lesson03\\\\hello.txt\"));\n            // 写出文件\n            byte[] buffer=new byte[1024];\n            int len;\n            while ((len=fileInputStream.read(buffer))!=-1){\n                outputStream.write(buffer,0,len);\n            }\n\n            // 如果没有这句,客户端又进入了等待接收的状态,可是服务器那边没有断开文件的连接,没有办法发送东西过来,所以要先切断输出流\n            socket.shutdownOutput();\n\n            // 服务器告诉客户端的话\"文件接收完毕\"\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            InputStream inputStream = socket.getInputStream();\n            int len2;\n            byte[] buffer2=new byte[1024];\n            while ((len2=inputStream.read(buffer2))!=-1){\n                byteArrayOutputStream.write(buffer2,0,len2);\n            }\n            System.out.println(byteArrayOutputStream.toString());\n\n            //关闭\n            byteArrayOutputStream.close();\n            outputStream.close();\n            fileInputStream.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n服务端接收\npackage cn.usts.edu.lesson03;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpFileServerDemo {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(9999);\n            Socket socket = serverSocket.accept();//侦听\n            InputStream inputStream = socket.getInputStream(); // 文件输入流\n            // 读取字节流\n            FileOutputStream fileOutputStream = new FileOutputStream(\"receive.txt\");\n            int len;\n            byte[] buffer=new byte[1024];\n            while ((len=inputStream.read(buffer))!=-1){\n                fileOutputStream.write(buffer,0,len);\n            }\n\n\n            // 告诉客户端文件传输完毕\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(\"文件传输完毕\".getBytes());\n\n            // 关闭\n            outputStream.close();\n            fileOutputStream.close();\n            inputStream.close();\n            socket.close();\n            serverSocket.close();\n\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "",
    "text": "这里以test2.sh为例\nvim test2.sh"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#创建一个xxx.sh文件",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#创建一个xxx.sh文件",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "",
    "text": "这里以test2.sh为例\nvim test2.sh"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "2、主体程序",
    "text": "2、主体程序\n#!/bin/bash\n#filename:test_2\n\n# 设置文件存储路径\npath=./space/\n\n# 判断路径是否存在\nif [ -d $path ]\nthen\n        echo $path\nelse\n        mkdir $path\nfi\n\n# 程序主体\ni=1\nwhile(($i&lt;=9))\n\n# 程序主体循环\ndo\n        # 文件名格式\n        number=$[ \"183500110\"$i\"\" ]\n        filename=$number\n        #mkdir $path/$filename\n        let \"i++\"\ndone\n\n# 避免0不占位置导致的格式不对齐\nwhile(($i&lt;=20))\ndo\n        number=$[ \"18350011\"$i\"\" ]\n        filename=$number\n        mkdir $path/$filename\n        let \"i++\"\ndone"
  },
  {
    "objectID": "posts/java注解和反射--通过反射获取到注解的值/index.html",
    "href": "posts/java注解和反射--通过反射获取到注解的值/index.html",
    "title": "java注解和反射–通过反射获取到注解的值",
    "section": "",
    "text": "java的注解原理 \npackage cn.usts.edu.ReflectionGetAndSetAnnotation;\n\n\nimport java.lang.annotation.*;\nimport java.lang.reflect.Field;\n\n/**\n * @author ：fly\n * @description: 利用反射操作注解\n * @date ：2021/10/29 15:36\n */\npublic class GetSetAnnotation {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        // 通过反射获取对象\n        Class&lt;?&gt; u1 = Class.forName(\"cn.usts.edu.ReflectionGetAndSetAnnotation.User\");\n\n        // 通过反射对象获取注解\n        Annotation[] annotations = u1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        //   获取注解对象                                         注解名子.class\n        testAnnotation1 testAnnotation1 =u1.getAnnotation(testAnnotation1.class);\n        // 获取注解的value         注解对象.属性()\n        System.out.println(testAnnotation1.tableName());\n\n        // 获取指定属性\n        Field age = u1.getDeclaredField(\"age\");\n        // 指定属性上的注解\n        testFiledAnnotation ageAnnotation = age.getAnnotation(testFiledAnnotation.class);\n        System.out.println(\"columnName--&gt;\"+ageAnnotation.columnName());\n        System.out.println(\"type--&gt;\"+ageAnnotation.type());\n        System.out.println(\"length--&gt;\"+ageAnnotation.length());\n    }\n\n\n}\n\n@testAnnotation1(tableName = \"tb_User\")\nclass User{\n    @testFiledAnnotation(columnName = \"User_age\",type = \"int\",length = 10)\n    int age;\n    @testFiledAnnotation(columnName = \"User_name\",type = \"varChar\",length = 20)\n    String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// 类注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testAnnotation1{\n    String tableName();\n}\n\n// 属性注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testFiledAnnotation{\n    String columnName();\n    int length();\n    String type();\n}"
  },
  {
    "objectID": "posts/java注解和反射--通过反射获取到注解的值/index.html#反射操作注解",
    "href": "posts/java注解和反射--通过反射获取到注解的值/index.html#反射操作注解",
    "title": "java注解和反射–通过反射获取到注解的值",
    "section": "",
    "text": "java的注解原理 \npackage cn.usts.edu.ReflectionGetAndSetAnnotation;\n\n\nimport java.lang.annotation.*;\nimport java.lang.reflect.Field;\n\n/**\n * @author ：fly\n * @description: 利用反射操作注解\n * @date ：2021/10/29 15:36\n */\npublic class GetSetAnnotation {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        // 通过反射获取对象\n        Class&lt;?&gt; u1 = Class.forName(\"cn.usts.edu.ReflectionGetAndSetAnnotation.User\");\n\n        // 通过反射对象获取注解\n        Annotation[] annotations = u1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        //   获取注解对象                                         注解名子.class\n        testAnnotation1 testAnnotation1 =u1.getAnnotation(testAnnotation1.class);\n        // 获取注解的value         注解对象.属性()\n        System.out.println(testAnnotation1.tableName());\n\n        // 获取指定属性\n        Field age = u1.getDeclaredField(\"age\");\n        // 指定属性上的注解\n        testFiledAnnotation ageAnnotation = age.getAnnotation(testFiledAnnotation.class);\n        System.out.println(\"columnName--&gt;\"+ageAnnotation.columnName());\n        System.out.println(\"type--&gt;\"+ageAnnotation.type());\n        System.out.println(\"length--&gt;\"+ageAnnotation.length());\n    }\n\n\n}\n\n@testAnnotation1(tableName = \"tb_User\")\nclass User{\n    @testFiledAnnotation(columnName = \"User_age\",type = \"int\",length = 10)\n    int age;\n    @testFiledAnnotation(columnName = \"User_name\",type = \"varChar\",length = 20)\n    String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User() {\n    }\n\n    public User(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// 类注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testAnnotation1{\n    String tableName();\n}\n\n// 属性注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface testFiledAnnotation{\n    String columnName();\n    int length();\n    String type();\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html",
    "href": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html",
    "title": "java多线程– 线程池( Executors.newFixedThreadPool() )",
    "section": "",
    "text": "执行结果 \npackage cn.usts.edu.lesson08;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n/**\n * 线程池:\n * 线程的创建和销毁很烦,于是就出现了线程池,当线程闲置的时候就放置到池子中\n * 当需要线程的时候就到池子中去取出\n * 提高线程的利用率\n * */\npublic class ThreadPoolDemo {\n    public static void main(String[] args) {\n        // 创建池子  最大线程数\n        ExecutorService service = Executors.newFixedThreadPool(10);\n\n        //启动池子\n        for (int i = 0; i &lt; 20; i++) {\n            service.execute(new TestThread());\n        }\n\n        // 关闭池子\n        service.shutdown();\n    }\n}\n\n\nclass TestThread implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}"
  },
  {
    "objectID": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html#线程池",
    "href": "posts/java多线程-- 线程池( Executors.newFixedThreadPool() )/index.html#线程池",
    "title": "java多线程– 线程池( Executors.newFixedThreadPool() )",
    "section": "",
    "text": "执行结果 \npackage cn.usts.edu.lesson08;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n/**\n * 线程池:\n * 线程的创建和销毁很烦,于是就出现了线程池,当线程闲置的时候就放置到池子中\n * 当需要线程的时候就到池子中去取出\n * 提高线程的利用率\n * */\npublic class ThreadPoolDemo {\n    public static void main(String[] args) {\n        // 创建池子  最大线程数\n        ExecutorService service = Executors.newFixedThreadPool(10);\n\n        //启动池子\n        for (int i = 0; i &lt; 20; i++) {\n            service.execute(new TestThread());\n        }\n\n        // 关闭池子\n        service.shutdown();\n    }\n}\n\n\nclass TestThread implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html",
    "href": "posts/shell编程的简单实现/index.html",
    "title": "shell编程的简单实现",
    "section": "",
    "text": "这里以 bashscript.sh 为例\nvim bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#新建一个xxxx.sh文件",
    "href": "posts/shell编程的简单实现/index.html#新建一个xxxx.sh文件",
    "title": "shell编程的简单实现",
    "section": "",
    "text": "这里以 bashscript.sh 为例\nvim bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "href": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "title": "shell编程的简单实现",
    "section": "2、在文件中编写简单的输出指令",
    "text": "2、在文件中编写简单的输出指令\n#！ /bin/bash                           // 脚本解释器程序路径\n#filename:bashscript                       // 注释\necho  “这是一个bash脚本程序。”                   // 输出指令\necho “---------------------------------------“"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#给文件赋权",
    "href": "posts/shell编程的简单实现/index.html#给文件赋权",
    "title": "shell编程的简单实现",
    "section": "3、给文件赋权",
    "text": "3、给文件赋权\nchmod u+x bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "href": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "title": "shell编程的简单实现",
    "section": "4、运行.sh文件",
    "text": "4、运行.sh文件\n执行程序bashscript.sh\n./bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行结果",
    "href": "posts/shell编程的简单实现/index.html#运行结果",
    "title": "shell编程的简单实现",
    "section": "99、运行结果",
    "text": "99、运行结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/java GUI编程--panel/index.html",
    "href": "posts/java GUI编程--panel/index.html",
    "title": "java GUI编程–panel",
    "section": "",
    "text": "package cn.usts.edu.lesson01;\n\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestPanel {\n\n    public static void main(String[] args) {\n\n\n        Frame frame = new Frame();\n        // 设置标题\n        frame.setTitle(\"firstFrame\");\n        // 设置布局\n        frame.setLayout(null);\n        // 设置位置\n        frame.setBounds(100,100,800,800);\n        // 设置背景色\n        frame.setBackground(Color.orange);\n        // 设置可见性\n        frame.setVisible(true);\n        \n        Panel panel01 = new Panel();\n        // 设置布局\n        panel01.setBounds(50,50,200,200);\n        panel01.setBackground(Color.PINK);\n        // 把组件添加到frame中\n        frame.add(panel01);\n        panel01.setVisible(true);\n\n\n        Panel panel02 = new Panel();\n        // 设置布局\n        panel02.setBounds(210,280,200,200);\n        panel02.setBackground(Color.BLUE);\n        panel02.setVisible(true);\n\n        // 把组件添加到frame中\n        frame.add(panel01);\n        frame.add(panel02);\n\n        // 监听事件,监听窗口关闭实践\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}"
  },
  {
    "objectID": "posts/中断-轮询/index.html",
    "href": "posts/中断-轮询/index.html",
    "title": "中断-轮询",
    "section": "",
    "text": "阻塞: 等待处理完再处理别的事情\n\n\n轮询: 每隔一段时间查看是否满足处理条件\n- 优点: 实时性较好\n- 缺点: 占用cpu性能\n\n\n中断: 收到信号后处理\n- 优点: cpu利用率高\n- 缺点: 并行处理的中断容易导致cpu无法响应,缓冲区数据较多的时候,cpu会消耗大量时间处理."
  },
  {
    "objectID": "posts/linux--创建用户修改&修改密码/index.html",
    "href": "posts/linux--创建用户修改&修改密码/index.html",
    "title": "linux–创建用户修改&修改密码",
    "section": "",
    "text": "创建用户\nadduser amdin\n修改密码\nbash-4.2# passwd admin\nChanging password for user admin.\nNew password: \nBAD PASSWORD: The password is a palindrome\nRetype new password: \npasswd: all authentication tokens updated successfully.\n注销\nlogout\n创建用户,并分配组\nadduser -g 组名 用户名\npasswd 用户名\n创建组\ngroupadd 组名\n例子\n修改a.txt从root组分到b组\ntouch a.txt\ngroupadd b\nchgrp b a.txt"
  },
  {
    "objectID": "posts/linux--创建用户修改&修改密码/index.html#创建用户修改修改密码",
    "href": "posts/linux--创建用户修改&修改密码/index.html#创建用户修改修改密码",
    "title": "linux–创建用户修改&修改密码",
    "section": "",
    "text": "创建用户\nadduser amdin\n修改密码\nbash-4.2# passwd admin\nChanging password for user admin.\nNew password: \nBAD PASSWORD: The password is a palindrome\nRetype new password: \npasswd: all authentication tokens updated successfully.\n注销\nlogout\n创建用户,并分配组\nadduser -g 组名 用户名\npasswd 用户名\n创建组\ngroupadd 组名\n例子\n修改a.txt从root组分到b组\ntouch a.txt\ngroupadd b\nchgrp b a.txt"
  },
  {
    "objectID": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "href": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "title": "qtQByteArry以二进制写入多n个字节",
    "section": "",
    "text": "问题描述\n使用qt串口接收数据，将数据保存成二进制数数据数据中会有多出的字节。但是将数据存储为文本模式（ascii字符·txt·）时没有问题，数据量正确。 # 原因 是因为QByteArry在写入文件时，会默认加上个长度字节，在原始数据中。\n\n\n解决方案\n使用QDataStream进行写入\nQFile qfile_save_adc_bin(\"./out/file.bin\"); \nQDataStream out_adc(&qfile_save_adc_bin);\n\n# 串口接收数据\nQByteArray data_serial = serialRead-&gt;readAll();\n# 写入\nout_adc.writeRawData(data_serial,data_serial.size());\nqfile_save_adc_bin.close(); // 关闭文件"
  },
  {
    "objectID": "posts/fft_demo/index.html",
    "href": "posts/fft_demo/index.html",
    "title": "fft demo",
    "section": "",
    "text": "learning how to use fft of matlab."
  },
  {
    "objectID": "posts/fft_demo/index.html#幅值矫正",
    "href": "posts/fft_demo/index.html#幅值矫正",
    "title": "fft demo",
    "section": "幅值矫正",
    "text": "幅值矫正\n为什么要将 fft 变换后的值进行矫正才能得到正确的幅值, 是因为横坐标是以时间为单位划分的频率, 也就意味着将频率也划分同样的份数,\nP1 = P1/(L);                 % 幅值矫正, 时间为单位\nf = fs*(0:L/2)/L;            % 频率矫正. 100hz分成500份,/L没明白.\nfigure ;plot(f,P1);\n\n可以使用doc fft调出 fft 手册."
  },
  {
    "objectID": "posts/esp8266_create_env/index.html",
    "href": "posts/esp8266_create_env/index.html",
    "title": "create esp8266 env with IDF",
    "section": "",
    "text": "Abstract\ncreate esp8266 env with IDF on ArchLinux.\n\n\nReferance\nesp8266 linux env\ngithub repo\ntool-chain\nai-thinker # add ESP8266_RTOS_SDK and tool to env\nvim ~/.zshrc\n\nexport IDF_PATH =  ~/esp/ESP8266_RTOS_SDK/\nexpoer PATH=\"$PATH:~/esp/xtensa-lx106....\"\n\ncd ESP8266_RTOS_SDK \ngit submodule update --init\n\ncd ~/esp/ESP8266_RTOS_SDK/examples/get-started/hello_world\nmake menuconfig\n\nspi flash size 4MB\n\npip install -r request.txt\n\nmake all\n\nsudo -E make flash\n\n# serial Assistant\nyay -S cutecom\n\n# set baud is 74880\nsudo cutecom\n\nyou can see like this\nload 0x40100000, len 7544, room 16 tail 8 chksum 0xc3 load 0x3ffe8408, len 24, room 0 tail 8 chksum 0x2a load 0x3ffe8420, len 3468, room 0 tail 12 chksum 0x47 csum 0x47 &lt;0x1b&gt;[0;32mI (46) boot: ESP-IDF v3.4-75-g7973d71b 2nd stage bootloader&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (46) boot: compile time 19:49:47&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (46) qio_mode: Enabling default flash chip QIO&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (54) boot: SPI Speed : 40MHz&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (60) boot: SPI Mode : QIO&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (67) boot: SPI Flash Size : 4MB&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (73) boot: Partition Table:&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (78) boot: ## Label Usage Type ST Offset &gt; Length&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (90) boot: 0 nvs WiFi data 01 02 00009000 &gt; 00006000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (101) boot: 1 phy_init RF data 01 01 0000f000 &gt; 00001000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (113) boot: 2 factory factory app 00 00 00010000 &gt; 000f0000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (124) boot: End of partition table&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (131) esp_image: segment 0: paddr=0x00010010 vaddr=0x40210010 &gt; size=0x1cca0 (117920) map&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (184) esp_image: segment 1: paddr=0x0002ccb8 vaddr=0x4022ccb0 &gt; size=0x07188 ( 29064) map&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (194) esp_image: segment 2: paddr=0x00033e48 vaddr=0x3ffe8000 &gt; size=0x00544 ( 1348) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (195) esp_image: segment 3: paddr=0x00034394 vaddr=0x40100000 &gt; size=0x00080 ( 128) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (209) esp_image: segment 4: paddr=0x0003441c vaddr=0x40100080 &gt; size=0x050c0 ( 20672) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (229) boot: Loaded app from partition at offset 0x10000&lt;0x1b&gt;[0m Hello world! This is ESP8266 chip with 1 CPU cores, WiFi, silicon revision 1, 4MB external flash Restarting in 10 seconds… Restarting in 9 seconds… Restarting in 8 seconds… Restarting in 7 seconds… Restarting in 6 seconds… Restarting in 5 seconds… Restarting in 4 seconds… Restarting in 3 seconds… Restarting in 2 seconds… Restarting in 1 seconds… Restarting in 0 seconds… Restarting now.\nets Jan 8 2013,rst cause:2, boot mode:(3,6)\nload 0x40100000, len 7544, room 16 tail 8 chksum 0xc3 load 0x3ffe8408, len 24, room 0 tail 8 chksum 0x2a load 0x3ffe8420, len 3468, room 0 tail 12 chksum 0x47 csum 0x47 &lt;0x1b&gt;[0;32mI (86) boot: ESP-IDF v3.4-75-g7973d71b 2nd stage bootloader&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (86) boot: compile time 19:49:47&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (86) qio_mode: Enabling default flash chip QIO&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (102) boot: SPI Speed : 40MHz&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (115) boot: SPI Mode : QIO&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (128) boot: SPI Flash Size : 4MB&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (140) boot: Partition Table:&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (152) boot: ## Label Usage Type ST Offset &gt; Length&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (174) boot: 0 nvs WiFi data 01 02 00009000 &gt; 00006000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (198) boot: 1 phy_init RF data 01 01 0000f000 &gt; 00001000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (221) boot: 2 factory factory app 00 00 00010000 &gt; 000f0000&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (244) boot: End of partition table&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (257) esp_image: segment 0: paddr=0x00010010 vaddr=0x40210010 &gt; size=0x1cca0 (117920) map&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (340) esp_image: segment 1: paddr=0x0002ccb8 vaddr=0x4022ccb0 &gt; size=0x07188 ( 29064) map&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (355) esp_image: segment 2: paddr=0x00033e48 vaddr=0x3ffe8000 &gt; size=0x00544 ( 1348) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (363) esp_image: segment 3: paddr=0x00034394 vaddr=0x40100000 &gt; size=0x00080 ( 128) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (390) esp_image: segment 4: paddr=0x0003441c vaddr=0x40100080 &gt; size=0x050c0 ( 20672) load&lt;0x1b&gt;[0m &lt;0x1b&gt;[0;32mI (426) boot: Loaded app from partition at offset 0x10000&lt;0x1b&gt;[0m Hello world! This is ESP8266 chip with 1 CPU cores, WiFi, silicon revision 1, 4MB external flash Restarting in 10 seconds… Restarting in 9 seconds… Restarting in 8 seconds… Restarting in 7 seconds… Restarting in 6 seconds… Restarting in 5 seconds… Restarting in 4 seconds… Restarting in 3 seconds… Restarting in 2 seconds…"
  },
  {
    "objectID": "posts/多普勒原理/index.html",
    "href": "posts/多普勒原理/index.html",
    "title": "多普勒原理",
    "section": "",
    "text": "多普勒原理：\n高中知识点，麻了，选修失误， 让我和多普勒失之交臂，相见恨晚的多普勒。"
  },
  {
    "objectID": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html",
    "href": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html",
    "title": "github总数换dns,总是修改hosts,双击Python脚本直接秒修改",
    "section": "",
    "text": "带来的体验很不爽 直接上下载地址"
  },
  {
    "objectID": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html#国内访问github总是出问题",
    "href": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html#国内访问github总是出问题",
    "title": "github总数换dns,总是修改hosts,双击Python脚本直接秒修改",
    "section": "",
    "text": "带来的体验很不爽 直接上下载地址"
  },
  {
    "objectID": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html#大多数给出的解决方案",
    "href": "posts/github总数换dns,总是修改hosts,双击Python脚本直接秒修改/index.html#大多数给出的解决方案",
    "title": "github总数换dns,总是修改hosts,双击Python脚本直接秒修改",
    "section": "大多数给出的解决方案",
    "text": "大多数给出的解决方案\n每次无法访问就要去重新手动查询修改hosts文件, 烦的一批 于是就到github上找到了个fastHost的项目,修改了一点点, 双击直接运行(前提是安装了python3),简直无脑,放到桌面上,爽的一批\n # 运行结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html",
    "href": "posts/Ubuntu21 美化/index.html",
    "title": "Ubuntu21 美化",
    "section": "",
    "text": "sudo apt update\n\nsudo apt-get install gnome-tweak-tool\n\nsudo apt-get install gnome-shell-extensions\n\nsudo apt-get install gnome-shell-extension-dashtodock\n\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#搜索优化",
    "href": "posts/Ubuntu21 美化/index.html#搜索优化",
    "title": "Ubuntu21 美化",
    "section": "2、搜索优化",
    "text": "2、搜索优化\n打开Dash to dock 根据需求修改设置 打开user theams\n# 重启\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#挑选主题",
    "href": "posts/Ubuntu21 美化/index.html#挑选主题",
    "title": "Ubuntu21 美化",
    "section": "3、挑选主题",
    "text": "3、挑选主题\ngnome网站：主题网站"
  },
  {
    "objectID": "posts/java多线程-- 线程休眠(sleep)/index.html",
    "href": "posts/java多线程-- 线程休眠(sleep)/index.html",
    "title": "java多线程– 线程休眠(sleep)",
    "section": "",
    "text": "模拟延时,放大问题\n\n\n\n\n在这里插入图片描述\n\n\npackage cn.usts.edu.lesson06;\n\n/**\n * 模拟延时,放大问题\n * */\npublic class ThreadSleepDemo implements Runnable{\n    private int tickets =10; // 设置10张票\n\n    @Override\n    public void run() {\n        while (true){\n            if (tickets&gt;0){\n                System.out.println(Thread.currentThread().getName()+\"拿到了票号-----+\"+tickets--);\n            }\n            else {\n                break;\n            }\n            try {\n                Thread.sleep(200);//模拟网络延迟200ms\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n\n    }\n\n    // 模拟三个人抢票\n    public static void main(String[] args) {\n        ThreadSleepDemo t = new ThreadSleepDemo();\n        new Thread(t,\"小红\").start();\n        new Thread(t,\"小明\").start();\n        new Thread(t,\"黄牛\").start();\n    }\n\n\n}"
  },
  {
    "objectID": "posts/esp8266--00GPIO引脚对应关系(nodeMCU)/index.html",
    "href": "posts/esp8266--00GPIO引脚对应关系(nodeMCU)/index.html",
    "title": "esp8266–00GPIO引脚对应关系(nodeMCU)",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html",
    "title": "ti mmwave sdk notes",
    "section": "",
    "text": "do some notes of learing ti mmwave sdk."
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#毫米波雷达套件",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#毫米波雷达套件",
    "title": "ti mmwave sdk notes",
    "section": "2.1 毫米波雷达套件",
    "text": "2.1 毫米波雷达套件\n\n驱动 (Drivers)\nOSAL(OSAL)\nmmWaveLink(mmWaveLink)\nmmWaveLib(mmWaveLib)\nmmWave API(mmWave API)\n数据处理层(Data processing layer (manager, processing units))\n雷达固件(RADARSS Firmware)\n板子设置和烧写程序(Board Setup and Flash Utilities)"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#雷达示例",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#雷达示例",
    "title": "ti mmwave sdk notes",
    "section": "2.2 雷达示例",
    "text": "2.2 雷达示例\nSDK提供了描述mmWave应用程序的各种控制和数据处理方面的演示。演示输出在PC上的数据可视化是这些演示的一部分。这些演示是提供给客户的示例代码，用于了解毫米波设备和SDK的内部工作原理，并帮助他们开始开发自己的应用程序\n\noutOfBoxdemo的图形界面程序 https://dev.ti.com/mmWaveDemoVisualizer"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#额外的依赖",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#额外的依赖",
    "title": "ti mmwave sdk notes",
    "section": "2.3 额外的依赖",
    "text": "2.3 额外的依赖\n构建mmwave sdk的所有工具和组件都在mmwave sdk的安装目录下.但是以下组件不在包括在目录中.\n\nccs\nDCA100EVM cli in mmwave studio"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#本文档中使用的术语",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#本文档中使用的术语",
    "title": "ti mmwave sdk notes",
    "section": "2.4 本文档中使用的术语",
    "text": "2.4 本文档中使用的术语\n\n\n\n\n\n\n\n术语\n解释\n\n\n\n\nxWR\n各WR系列(IWR, AWR..)\n\n\nBSS\n这在源代码中使用，在本文档中很少使用, 文档中使用RADARS表示。它也可替换地称为毫米波前端\n\n\nMSS\nMaster Sub-system控制端, 负责数据发送和外部交互等操作,内核是Cortex R4F\n\n\nDSS\nDSP Sub-system数据处理端, 内核C674x core"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#相关文档链接",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#相关文档链接",
    "title": "ti mmwave sdk notes",
    "section": "2.5 相关文档链接",
    "text": "2.5 相关文档链接\n除了mmwave_sdk包中包含的文档外，以下文档/链接是重要的参考资料。 - 芯片链接 (SoC links) - 汽车毫米波雷达芯片(Automotive mmWave radar sensors=&gt;AWR) - 工业毫米波雷达芯片(Industrial mmWave radar sensors=&gt;IWR) - 开发板链接(Evaluation Modules (EVM) links) - 汽车毫米波雷达开发板 - 工业毫米波雷达开发板"
  },
  {
    "objectID": "posts/ti_mmwave_sdk_user_guide_notes/index.html#设备编程",
    "href": "posts/ti_mmwave_sdk_user_guide_notes/index.html#设备编程",
    "title": "ti mmwave sdk notes",
    "section": "3.1 设备编程",
    "text": "3.1 设备编程\n在ccs中有个Getting started,有些指南.\nxWR14xx\n只有一个R4F的内核, 具体编程细节查看R4F的编程手册\nxWR16xx/xWR18xx/xWR68xx/xWR64xx\n有连个内核cortex R4F,DSP C674x, 编程细节分别查看对应的编程手册.示例程序中放了两个部分的文件, 一个用于mss/R4F, 一个用于dss/C674, 这两个部分都是独立的, 他们之间的通信是通过MailBox进行通信, MailBox有一个测试单元叫test_mss_dss_msg_exchange, 有很多测试包括datapath manager (DPM), 完整测试, 最小测试等\n\n\nLoading images onto mmWave EVM"
  },
  {
    "objectID": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "href": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "title": "qt上位机 – 自己开发出口助手",
    "section": "",
    "text": "概要\n利用qt编写一个串口助手\n\n\n成品效果\n代码地址:https://gitee.com/itengfei/serial-assistant\n\n\n\n在这里插入图片描述\n\n\n\n\nui布局\n代码链接:\n\n\n\n在这里插入图片描述\n\n\n\n\n编码\n\n\n\n在这里插入图片描述\n\n\n串口助手 虚拟串口\nserialAssistant.h代码\n#pragma once\n\n#include &lt;QtWidgets/QWidget&gt;\n#include \"ui_serialassistant.h\"\n\n#include &lt;QSerialPort&gt;        //提供访问串口的功能\n#include &lt;QSerialPortInfo&gt;    //提供系统中存在的串口的信息\n#include&lt;qmessagebox.h&gt;\n\nclass serialAssistant : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    serialAssistant(QWidget* parent = Q_NULLPTR) ;\n    ~serialAssistant() {};\n   \n  \n    QSerialPort* serialPort;\n    QSerialPort::BaudRate baudRate{};\n    QSerialPort::StopBits stopBits{};\n    QSerialPort::DataBits dataBits{};\n    QSerialPort::Parity checkBits{};\n\npublic slots:\n    void start();\n    void stop();\n    void clear();\n    void send();\n    void receive();\n\n\nprivate:\n    Ui::serialAssistantClass ui;\n};\nserialAssistant.cpp代码\n#include \"serialassistant.h\"\n#include &lt;iostream&gt;\n\n\n\nserialAssistant::serialAssistant(QWidget *parent)\n    : QWidget(parent)\n{\n    \n    ui.setupUi(this);\n\n    serialPort = new QSerialPort(this);\n    \n    // get and show  ports\n    for each (const QSerialPortInfo &info in QSerialPortInfo::availablePorts())\n    {\n        ui.serialPortComBox-&gt;addItem(info.portName());\n    }\n    \n    connect(serialPort, SIGNAL(readyRead()),this, SLOT(receive()));\n}\n\nvoid serialAssistant::start() {\n    if (ui.baudRatCombox-&gt;currentText() == \"4800\") {\n        serialAssistant::baudRate = QSerialPort::Baud4800;\n    }\n    else if (ui.baudRatCombox-&gt;currentText() == \"9600\") {\n        serialAssistant::baudRate = QSerialPort::Baud9600;\n    }\n    else if (ui.baudRatCombox-&gt;currentText() == \"115200\") {\n        serialAssistant::baudRate = QSerialPort::Baud115200;\n    }\n\n\n    if (ui.dataBitComBox-&gt;currentText() == \"5\") {\n        serialAssistant::dataBits = QSerialPort::Data5;\n    }\n    else if (ui.dataBitComBox-&gt;currentText() == \"6\") {\n        serialAssistant::dataBits = QSerialPort::Data6;\n    }\n    else if (ui.dataBitComBox-&gt;currentText() == \"7\") {\n        serialAssistant::dataBits = QSerialPort::Data7;\n    }\n    else if (ui.dataBitComBox-&gt;currentText() == \"8\") {\n        serialAssistant::dataBits = QSerialPort::Data8;\n    }\n\n\n    if (ui.stopBitComBox-&gt;currentText() == \"1\") {\n        serialAssistant::stopBits = QSerialPort::OneStop;\n    }\n    else if (ui.stopBitComBox-&gt;currentText() == \"1.5\") {\n        serialAssistant::stopBits = QSerialPort::OneAndHalfStop;\n    }\n    else if (ui.stopBitComBox-&gt;currentText() == \"2\") {\n        serialAssistant::stopBits = QSerialPort::TwoStop;\n    }\n\n    if (ui.checkComBox-&gt;currentText() == \"none\") {\n        serialAssistant::checkBits = QSerialPort::NoParity;\n    }\n   \n    serialPort-&gt;setPortName(ui.serialPortComBox-&gt;currentText());\n    serialPort-&gt;setBaudRate(serialAssistant::baudRate);\n    serialPort-&gt;setDataBits(serialAssistant::dataBits);\n    serialPort-&gt;setStopBits(serialAssistant::stopBits);\n    serialPort-&gt;setParity(serialAssistant::checkBits);\n \n   // std::cout &lt;&lt; serialAssistant::baudRate &lt;&lt; std::endl;\n    // std::cout &lt;&lt; serialAssistant::dataBits &lt;&lt; std::endl;\n    // std::cout &lt;&lt; serialAssistant::stopBits &lt;&lt; std::endl;\n    // std::cout &lt;&lt; serialAssistant::checkBits &lt;&lt; std::endl;\n\n    // chek status \n    if (serialPort-&gt;open(QIODevice::ReadWrite) == true) {\n       \n        QMessageBox::information(this, \"tip\", \"ok\");\n    }\n    else {\n        QMessageBox::critical(this, \"tip\", \"fail\");\n    }\n\n}\n\nvoid serialAssistant::stop()\n{\n    QMessageBox::information(this, \"tip\", \"closed\");\n    serialPort-&gt;close();\n}\n\nvoid serialAssistant::clear()\n{\n    ui.sendLineEdit-&gt;clear();\n}\n\nvoid serialAssistant::send()\n{\n    serialPort-&gt;write(ui.sendLineEdit-&gt;text().toLocal8Bit().data());\n    //std::cout &lt;&lt; ui.sendLineEdit-&gt;text().toLocal8Bit().data() &lt;&lt; std::endl;\n}\n\nvoid serialAssistant::receive()\n{\n    QString buffer;\n    buffer =  QString(serialPort-&gt;readAll());\n    ui.receivePlainTextEdit-&gt;appendPlainText(buffer);\n    //std::cout &lt;&lt; buffer.toStdString() &lt;&lt; std::endl;\n}"
  },
  {
    "objectID": "posts/keil5激活---＞2032年/index.html",
    "href": "posts/keil5激活---＞2032年/index.html",
    "title": "keil5激活—＞2032年",
    "section": "",
    "text": "keil5激活 蓝奏云下载\n\n\n\n在这里插入图片描述\n\n\nfile-&gt; lice"
  },
  {
    "objectID": "posts/java注解和反射--类加的载/index.html",
    "href": "posts/java注解和反射--类加的载/index.html",
    "title": "java注解和反射–类加的载",
    "section": "",
    "text": "类的加载有三个过程:  正是由于只能有一个clinit操作,所以他们只有一个公共的Class,所以可以实现反射,从而拿到属性,方法,构造器等等"
  },
  {
    "objectID": "posts/java注解和反射--类加的载/index.html#类加载器",
    "href": "posts/java注解和反射--类加的载/index.html#类加载器",
    "title": "java注解和反射–类加的载",
    "section": "",
    "text": "类的加载有三个过程:  正是由于只能有一个clinit操作,所以他们只有一个公共的Class,所以可以实现反射,从而拿到属性,方法,构造器等等"
  },
  {
    "objectID": "posts/linux键盘f1-f12功能键盘失效/index.html",
    "href": "posts/linux键盘f1-f12功能键盘失效/index.html",
    "title": "linux键盘f1-f12功能键盘失效",
    "section": "",
    "text": "echo 0 | sudo tee /sys/module/hid_apple/parameters/fnmode\n\necho \"options hid_apple fnmode=0\" | sudo tee -a /etc/modprobe.d/hid_apple.conf\n\nsudo update-initramfs -u    //Ubuntu\nsudo mkinitcpio -P          //ArchLinux\n参考：https://www.cnblogs.com/orochihuang/p/15193699.html"
  },
  {
    "objectID": "posts/darknet--使用yolo算法进行目标检测（保姆教程）/index.html",
    "href": "posts/darknet--使用yolo算法进行目标检测（保姆教程）/index.html",
    "title": "darknet–使用yolo算法进行目标检测（保姆教程）",
    "section": "",
    "text": "0.最终效果\n\n\n\n在这里插入图片描述\n\n\n\n\n1.原始项目代码准备\n\n相同的标题号只选一个操作即可，相同的效果!!!!!\n\n\n相同的标题号只选一个操作即可，相同的效果!!!!!\n\n\n相同的标题号只选一个操作即可，相同的效果!!!!!\n\n\n1.1 git方式下载代码\n选择自己想存放的位置执行一下代码  \ngit clone https://github.91chi.fun/https://github.com/AlexeyAB/darknet.git\n\n\n1.1 下载zip方式下载代码（srart）\nAB大神的代码地址：https://github.com/AlexeyAB/darknet  ### 1.1 解压下载的zip  ### 1.2 执行完以上步骤将会得到一下代码 \n\n\n\n2.环境搭建\n需要准备的安装包： |所需安装包| 版本 | |–|–| | 显卡（硬件） | 3060 | | CUDA | 511.65 | | CUDNN | 8.3.2.44 | | OpenCv | 4.5.3 | | CMake | 3.23.0 | | VS Studio | 2022 |\n(没有gpu可以跳过cudnn和cuda的安装，只安装OPenCv和CMake即可) ### 2.1 CUDA安装 #### 根据自己的显卡型号来选择自己cuda和cudnn的版本！！！！！ win(键盘上微软的标志的那个按键)+x – &gt;设备管理器  cuda驱动版本选择：https://www.nvidia.cn/Download/index.aspx?lang=cn  \n\n下载完成，双击安装，全部默认，一直下一步，直到安装结束。\n  安装（更新）好了显卡驱动以后。win+R组合键，打开cmd命令窗口。输入如下的命令\nnvidia-smi\n显示如下即表示安装成功 \n\n\n2.2 CUDNN安装\n这里需要登录账号才能下载，下载靠近的版本即可。 cudnn下载地址：https://developer.nvidia.com/rdp/cudnn-download   解压缩，进入到cudnn-windows-x86_64-8.3.2.44_cuda11.5-archive文件夹\n cuda位置（默认安装位置，版本号可能存在差别，根据自己的版本来）\nC:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.6\n复制途中如果弹出窗口，点全部替换即可。  查看环境变量： 此电脑 – &gt;右键 – &gt;属性 – &gt;高级设置 – &gt;环境变量   这时候的环境变量中应该如图： 如果没有手动指定即可。  ### 2.3 OpenCv安装 地址：https://github.com/opencv/opencv/releases  \n\n\n\n在这里插入图片描述\n\n\n \n结束后进到自己的opencv安装目录，复制目录进行配置环境变量  打开环境变量配置页面  创建如下环境变量\n 接下来在path中添加如下opencv的bin目录和lib目录 \n opencv配置结束 ### 2.4 VS Studio安装 这里安装的2022版本 \n\n\n2.5Cmake安装\ncmake下载地址：https://cmake.org/download/ 下载完成双击全部默认安装。 \n\n\n\n在这里插入图片描述\n\n\n   根据自己的vs studio版本来  可能会遇到如下错误：   一劳永逸的做法是：修改环境变量中的OpenCV_DIR的路径。 我们这里直接修改的是cmake的OpenCV_DIR的路径。  delete cache – &gt;重新再来一遍。    vs下载地址  生成解决方案  打开项目文件夹 —&gt;Release  \n 把.cfg he weight文件放到darknet.exe同级目录  # 3.运行 执行以下命令\n# 图片预测命令\ndarknet detect yolov3-tiny.cfg yolov3-tiny.weights dog.jpg\n# 视频命令\ndarknet detector demo data/coco.data yolov3-tiny.cfg yolov3-tiny.weights test.flv\n# 摄像头命令\ndarknet detector demo data/coco.data yolov3-tiny.cfg yolov3-tiny.weights -i 0\n\n\n\n在这里插入图片描述\n\n\n\n\n\n在这里插入图片描述"
  }
]