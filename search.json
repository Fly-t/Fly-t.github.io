[
  {
    "objectID": "posts/matlab-coder/index.html",
    "href": "posts/matlab-coder/index.html",
    "title": "Matlab Coder",
    "section": "",
    "text": "matlab Coder 可以将matlab脚本转换为c or C++代码, 极大程度让用户专注算法的设计\n\n可以指定接口类型, 但是无法指定中间变量的类型\n在转换后注意tmwtypes.h和rtwtypes.h的include\n接口参数类型的指定\n\n\n\n\nfunction [data_MCA] = MultiChannelAverage(data_radar)\n% 输入data_radar: numADCSamples * 8\n% 输出data_MCA: numADCSamples * 1\n\ndata_MCA = mean(data_radar,2);\nend\n\n\n\n/*\n * File: MultiChannelAverage.c\n *\n * MATLAB Coder version            : 5.2\n * C/C++ source code generated on  : 29-Nov-2022 14:55:50\n */\n\n/* Include Files */\n#include \"MultiChannelAverage.h\"\n\n/* Function Definitions */\n/*\n * 输入data_radar: numADCSamples * 8\n *  输出data_MCA: numADCSamples * 1\n *\n * Arguments    : const cint16_T data_radar[1024]\n *                creal_T data_MCA[128]\n * Return Type  : void\n */\nvoid MultiChannelAverage(const cint16_T data_radar[1024], creal_T data_MCA[128])\n{\n  double ai;\n  double im;\n  double re;\n  int data_radar_re_tmp;\n  int k;\n  int xj;\n  int xoffset;\n  for (xj = 0; xj < 128; xj++) {\n    data_MCA[xj].re = data_radar[xj].re;\n    data_MCA[xj].im = data_radar[xj].im;\n  }\n  for (k = 0; k < 7; k++) {\n    xoffset = (k + 1) << 7;\n    for (xj = 0; xj < 128; xj++) {\n      data_radar_re_tmp = xoffset + xj;\n      data_MCA[xj].re += (double)data_radar[data_radar_re_tmp].re;\n      data_MCA[xj].im += (double)data_radar[data_radar_re_tmp].im;\n    }\n  }\n  for (xj = 0; xj < 128; xj++) {\n    im = data_MCA[xj].re;\n    ai = data_MCA[xj].im;\n    if (ai == 0.0) {\n      re = im / 8.0;\n      im = 0.0;\n    } else if (im == 0.0) {\n      re = 0.0;\n      im = ai / 8.0;\n    } else {\n      re = im / 8.0;\n      im = ai / 8.0;\n    }\n    data_MCA[xj].re = re;\n    data_MCA[xj].im = im;\n  }\n}\n\n/*\n * File trailer for MultiChannelAverage.c\n *\n * [EOF]\n */"
  },
  {
    "objectID": "posts/qt线程问题(耗时操作)/index.html",
    "href": "posts/qt线程问题(耗时操作)/index.html",
    "title": "qt线程问题(耗时操作)",
    "section": "",
    "text": "qt多线程问题: 方法1: qtsignal 启动线程,避免界面卡死 方法2: 使用QApplication.processEvents() 方法3: 使用QThread"
  },
  {
    "objectID": "posts/stm32--io口拉高还是拉低/index.html",
    "href": "posts/stm32--io口拉高还是拉低/index.html",
    "title": "stm32–io口拉高还是拉低",
    "section": "",
    "text": "https://zhuanlan.zhihu.com/p/458067480\n1.2GPIO_Mode_IPD (Pull-down):\n输入下拉就是把电压拉低，拉到GND。与上拉原理相似。\n\n简单的说，如果你希望你的引脚平时处于高电平用于检测低电平，你就使用Pull-up。\n\n如果你希望你的引脚平时处于低电平用于检测高电平，你就使用Pull-down。\n\n按键未按下时端口接低电平，即低电平 0 状态---0v\n\n按键按下时端口接高电平，即高电平 1 状态------3.3v"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html",
    "href": "posts/shell脚本批量创建多个用户/index.html",
    "title": "shell脚本批量创建多个用户",
    "section": "",
    "text": "执行以下命令\nvim adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "href": "posts/shell脚本批量创建多个用户/index.html#编写shell代码",
    "title": "shell脚本批量创建多个用户",
    "section": "2、编写shell代码",
    "text": "2、编写shell代码\n#! /bin/bash\n#filename:add_user\ni=1\ngroupadd user1\nwhile [ $i -le 20 ]\ndo\n        if [ $i -le 9 ]; then\n                USERNAME=student0${i}\n        else\n                USERNAME=student${i}\n        fi\n        useradd $USERNAME\n        mkdir /home/$USERNAME\n        chown -R $USERNAME /home/$USERNAME\n        chgrp -R user1 /home/$USERNAME\n        i=$(($i+1))\ndone"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "href": "posts/shell脚本批量创建多个用户/index.html#赋权",
    "title": "shell脚本批量创建多个用户",
    "section": "3、赋权",
    "text": "3、赋权\nchmod u+x adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#执行",
    "href": "posts/shell脚本批量创建多个用户/index.html#执行",
    "title": "shell脚本批量创建多个用户",
    "section": "4、执行",
    "text": "4、执行\n创建用户需要管理员权限，需要加上sudo\nsudo ./adduser.sh"
  },
  {
    "objectID": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "href": "posts/shell脚本批量创建多个用户/index.html#运行结果",
    "title": "shell脚本批量创建多个用户",
    "section": "99、运行结果",
    "text": "99、运行结果\n查看是否创建成功\ncat /etc/passwd\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "href": "posts/qtQByteArry以二进制写入多n个字节/index.html",
    "title": "qtQByteArry以二进制写入多n个字节",
    "section": "",
    "text": "问题描述\n使用qt串口接收数据，将数据保存成二进制数数据数据中会有多出的字节。但是将数据存储为文本模式（ascii字符·txt·）时没有问题，数据量正确。 # 原因 是因为QByteArry在写入文件时，会默认加上个长度字节，在原始数据中。\n\n\n解决方案\n使用QDataStream进行写入\nQFile qfile_save_adc_bin(\"./out/file.bin\"); \nQDataStream out_adc(&qfile_save_adc_bin);\n\n# 串口接收数据\nQByteArray data_serial = serialRead->readAll();\n# 写入\nout_adc.writeRawData(data_serial,data_serial.size());\nqfile_save_adc_bin.close(); // 关闭文件"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程管理/index.html",
    "href": "posts/stm32F103-RT-Thread线程管理/index.html",
    "title": "stm32F103-RT-Thread线程管理",
    "section": "",
    "text": "系统总共支持 256 个优先 (0 ~ 255，数值越小的优先级越高，0 为最高优先级，255 分配给空闲线程使用,默认优先级32个，一般用户不使用)。\n\n在一些资源比较紧张的系统中，可以根据实,际情况选择只支持 8 个或 32 个优先级的系统配置。\n\n\n在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行\n\n\nRT-Thread 内核中也允许创建相同优先级的线程。相同优先级的线程采用时间片轮转方式进行调 度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪线程存在 的情况下才有效。\n\n\n\n/*********************key1挂起线程,key2恢复线程*********************/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;               // thread1 control block\nstatic rt_thread_t led2_thread = RT_NULL;               // thread2 control block\nstatic rt_thread_t pause_thread = RT_NULL;              // thread3 control block\n\nstatic rt_thread_t send_thread = RT_NULL;               // message queue send thread\nstatic rt_thread_t receive_thread = RT_NULL;            // messge queue receive thread\n\nint count = 0;\n\n\n\n\n\n\n\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\nstatic void pause_thread_entry(void *parameter);\n\n/*\n*************************************************************************\n*                             main ����\n*************************************************************************\n*/\n/**\n * @brief  ������\n * @param  ��\n * @retval ��\n */\nint main(void)\n{\n    \n    // if (led1_thread != RT_NULL)\n    //  rt_thread_startup(led1_thread);\n    // else\n    //  return -1;\n\n\n\n    // thread 2\n    // led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    // if (led2_thread != RT_NULL)\n    //  rt_thread_startup(led2_thread);\n    // else\n    //  return -1;\n\n    // thread 3 [pause thread]\n    pause_thread = rt_thread_create(\"pause\", pause_thread_entry,RT_NULL,512,2,20);\n    if(pause_thread != RT_NULL){\n        rt_thread_startup(pause_thread);\n    }\n    else{\n        return -1;\n    }\n    \n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED1_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[1], Red  --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* ��ʱ 500 �� tick */\n        rt_kprintf(\"thread --[2], Green --count[%d]\\r\\n\",count);\n    }\n}\n\nstatic void pause_thread_entry(void *parameter)\n{\n    rt_err_t uwRet_1 = RT_EOK; // monitor the status\n\n    while (1)\n    {\n        \n        if (Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_suspend(led1_thread); /* �0�1�0�6�0�4�0�8LED1�0�3�0�8�0�6�0�0 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[suspend-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[suspend-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n\n        \n\n        if (Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON) /* K1 ���0�3��0�7�0�3�0�0 */\n        {\n            \n            uwRet_1 = rt_thread_resume(led1_thread); /* �0�3�0�0�0�0�0�7LED1�0�3�0�8�0�6�0�0�0�5�0�3 */\n            if (RT_EOK == uwRet_1)\n            {\n                rt_kprintf(\"[resume-][succes] led1\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"[resume-][faild] led1 Error Code is :%lx\\n\", uwRet_1);\n            }\n        }\n      rt_thread_delay(20);\n    }\n}"
  },
  {
    "objectID": "posts/TI_js脚本自动调试/index.html",
    "href": "posts/TI_js脚本自动调试/index.html",
    "title": "TI_js脚本自动调试",
    "section": "",
    "text": "脚本执行\n手动创建调试器1642.xml 修改执行脚本ccsdebug.js - 修改脚本中的工作区 - 修改脚本中的项目位置, 和编译后的img位置\n\n\n\n\n在这里插入图片描述\n\n\nccsdebug.js\n// Import the DSS packages into our namespace to save on typing\n\nimportPackage(Packages.com.ti.debug.engine.scripting);\n\nimportPackage(Packages.com.ti.ccstudio.scripting.environment);\n\nimportPackage(Packages.java.lang);\n\nimportPackage(Packages.java.io);\n\n\n\nfunction run_test(){\n//*******User must specify WORKSPACE_DIR***********\n\nvar WORKSPACE_DIR = \"D:/project/board/workspace_v10/\";\n\n//*******User must specify WORKSPACE_DIR***********\n\nvar PROJECT_DIR = WORKSPACE_DIR+\"sdk_demo/\";\n\nvar R4F_OUT_FILE_PATH = PROJECT_DIR+\"mmw_mss_16xx/Debug/xwr16xx_mmw_mss.xer4f\";\n\nvar DSS_OUT_FILE_PATH = PROJECT_DIR+\"mmw_dss_16xx/Debug/xwr16xx_mmw_dss.xe674\";\n\nvar CCS_TARGET_CONFIGURATION_FILE = \"AWR1642.ccxml\";\n\nvar script = ScriptingEnvironment.instance();\n\n//script.traceBegin(\"BreakpointsTestLog.xml\", \"DefaultStylesheet.xsl\");\n//script.traceSetConsoleLevel(TraceLevel.ALL);\n//script.traceSetFileLevel(TraceLevel.ALL);\n\n\nscript.setCurrentDirectory(PROJECT_DIR);\ndebugServer = script.getServer(\"DebugServer.1\");\n\n\ndebugServer.setConfig(CCS_TARGET_CONFIGURATION_FILE);\n\n\n// debug session R4F\nprint(\"Debug session R4F...\");\ndebugSession_MSS = debugServer.openSession(\"*\",\"Cortex_R4_0\");\nprint(\"Connecting to R4F Core...\");\ndebugSession_MSS.target.connect();\ndebugSession_MSS.target.reset();\nprint(\"Done.\");\n\n\n\n\n// debug session C674x\nprint(\"Debug session C674x...\");\ndebugSession_DSS = debugServer.openSession(\"*\",\"C674X_0\");\nprint(\"Connecting to C674x Core...\");\ndebugSession_DSS.target.connect();\ndebugSession_DSS.target.reset();\nprint(\"Done.\");\n\n\n// Loading program - R4F...\nprint(\"Loading program - R4F...\");\ndebugSession_MSS.memory.loadProgram(R4F_OUT_FILE_PATH);\nprint(\"load R4F Done.\");\n\n// Loading program - C674x...\nprint(\"Loading program - C674x...\");\ndebugSession_DSS.memory.loadProgram(DSS_OUT_FILE_PATH);\nprint(\"Loading C674x Done.\");\n\n// run target\nvar dsArray = new Array();\ndsArray[0] = debugSession_MSS;\ndsArray[1] = debugSession_DSS;\n\n//debugServer.simultaneous.run(dsArray); // Run CPUs 1 and 2\nprint(\"please click run...\");\n//debugServer.stop();\n\n//script.traceEnd();\n}\n\nhotmenu.addJSFunction(\"Run Test\",\"run_test()\");\n\nView ->Scripting Console\n\n\n\n在这里插入图片描述\n\n\n\n在终端中输入以下指令,根据脚本所在位置填写脚本\n// 脚本位置\nloadJSFile \"D:\\project\\board\\workspace_v10\\sdk_demo\\ccsdebug.js\"\n >## 点击script,然后运行脚本 \n\n程序启动需手动点击run按钮\n\n > ## 断点调试 > 需要设置hardware breakpoint, 普通的断点无法在mss上停止. 然后就可查看到变量和单步调试了\n 稍微高级点的用法可以查看tools里面的工具"
  },
  {
    "objectID": "posts/vs studio添加include和依赖库/index.html",
    "href": "posts/vs studio添加include和依赖库/index.html",
    "title": "vs studio添加include和依赖库",
    "section": "",
    "text": "无法打开 源 文件 “xxxxxx”\n解决办法: 添加include文件夹\n\n\n\n在这里插入图片描述\n\n\n项目右键属性,c/c++,添加附加包含目录, 找到你所需要的头文件的位置,\n\n\n\n在这里插入图片描述\n\n\n添加lib库: * 链接器->常规->附加库目录->\n\n\n链接器->输入->附加依赖->输入需要的依赖项.\n\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "href": "posts/qt --问题总结(头文件问题,QString转换,查找组件)/index.html",
    "title": "qt –问题总结(头文件问题,QString转换,查找组件)",
    "section": "",
    "text": "项目问题解决\n在使用过程中无法使用控件的大多数原因就是因为没有在.h文件中创建方法. 只有集成的类中才会有组件,单独的cpp中没有组件.所以会报错.如果已经使用继承类,已经可以跳转.但是还是报错,大多刷新解决方案即可.  ### 查找QObject\n  QString objectNameBtn = sender()->objectName();\n    QPushButton *tempButton = this->findChild<QPushButton *>(objectNameBtn);\n\n字符串转换QString < == > std::string\nQString qstr;\nstd::string str;\n//===============================\n//QString转std::string\nstr = qstr.toStdString();\n//===============================\n//std::string转QString\nqstr = QString::fromStdString(str);\n\n\n找到父对象控件\nparent , parentWidget, setParent\nuserFrame->parentWidget()->setWindowFlags(Qt::WindowMinMaxButtonsHint);\n// 用管道符添加多个属性\nuserFrame->parentWidget()->setWindowFlags(Qt::Dialog|Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint);\n\n\n找到子组件\nfindChild,findChildren ### windowFlags参数 原文:https://blog.csdn.net/xuebing1995/article/details/96478891\nQt::Widget               //是一个窗口或部件，有父窗口就是部件，没有就是窗口\nQt::Window               //是一个窗口，有窗口边框和标题\nQt::Dialog               //是一个对话框窗口\nQt::Sheet                //是一个窗口或部件Macintosh表单\nQt::Drawer               //是一个窗口或部件Macintosh抽屉，去掉窗口左上角的图标\nQt::Popup                //是一个弹出式顶层窗口\nQt::Tool                 //是一个工具窗口\nQt::ToolTip              //是一个提示窗口，没有标题栏和窗口边框\nQt::SplashScreen         //是一个欢迎窗口，是QSplashScreen构造函数的默认值\nQt::Desktop              //是一个桌面窗口或部件\nQt::SubWindow            //是一个子窗口\n\n窗口属性\nQt::CustomizeWindowHint          //关闭默认窗口标题提示\nQt::WindowTitleHint              //为窗口修饰一个标题栏\nQt::WindowSystemMenuHint         //为窗口修饰一个窗口菜单系统\nQt::WindowMinimizeButtonHint     //为窗口添加最小化按钮\nQt::WindowMaximizeButtonHint     //为窗口添加最大化按钮\nQt::WindowMinMaxButtonsHint      //为窗口添加最大化和最小化按钮\nQt::WindowCloseButtonHint           //窗口只有一个关闭按钮\nQt::WindowContextHelpButtonHint\nQt::MacWindowToolBarButtonHint\nQt::WindowFullscreenButtonHint\nQt::BypassGraphicsProxyWidget\nQt::WindowShadeButtonHint\nQt::WindowStaysOnTopHint    //总在最上面的窗口,置前\nQt::WindowStaysOnBottomHint\nQt::WindowOkButtonHint\nQt::WindowCancelButtonHint\nQt::WindowTransparentForInput"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "href": "posts/stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数/index.html",
    "title": "stm32F103-RT-Thread 重映射串口到 rt_kprintf 函数",
    "section": "",
    "text": "在 RT-Thread 中，有一个打印函数 rt_kprintf() 供用户使用，方便在调试的时候输出各种信息。如果 要想使用 rt_kprintf()，则必须将控制台重映射到 rt_kprintf()，这个控制台可以是串口、CAN、USB、 以太网等输出设备，用的最多的就是串口，接下来我们讲解下如何将串口重定向到 rt_kprintf()。[参考野火F103]\n\n\n\n添加bsp_usart.c, bsp_usart.h\n\nbsp_usart.c\n#include \"bsp_usart.h\"\n\n /**\n  * @brief  配置嵌套向量中断控制器NVIC\n  * @param  无\n  * @retval 无\n  */\nstatic void NVIC_Configuration(void)\n{\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  /* 嵌套向量中断控制器组选择 */\n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  /* 配置USART为中断源 */\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  /* 抢断优先级*/\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\n  /* 子优先级 */\n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  /* 使能中断 */\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  /* 初始化配置NVIC */\n  NVIC_Init(&NVIC_InitStructure);\n}\n\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n  // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 串口中断优先级配置\n    NVIC_Configuration();\n    \n    // 使能串口接收中断\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);    \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);        \n}\n\n/*****************  发送一个字节 **********************/\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)\n{\n    /* 发送一个字节数据到USART */\n    USART_SendData(pUSARTx,ch);\n        \n    /* 等待发送数据寄存器为空 */\n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n/****************** 发送8位的数组 ************************/\nvoid Usart_SendArray( USART_TypeDef * pUSARTx, uint8_t *array, uint16_t num)\n{\n  uint8_t i;\n    \n    for(i=0; i<num; i++)\n  {\n        /* 发送一个字节数据到USART */\n        Usart_SendByte(pUSARTx,array[i]);   \n  \n  }\n    /* 等待发送完成 */\n    while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET);\n}\n\n/*****************  发送字符串 **********************/\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str)\n{\n    unsigned int k=0;\n  do \n  {\n      Usart_SendByte( pUSARTx, *(str + k) );\n      k++;\n  } while(*(str + k)!='\\0');\n  \n  /* 等待发送完成 */\n  while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET)\n  {}\n}\n\n/*****************  发送一个16位数 **********************/\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch)\n{\n    uint8_t temp_h, temp_l;\n    \n    /* 取出高八位 */\n    temp_h = (ch&0XFF00)>>8;\n    /* 取出低八位 */\n    temp_l = ch&0XFF;\n    \n    /* 发送高八位 */\n    USART_SendData(pUSARTx,temp_h); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);\n    \n    /* 发送低八位 */\n    USART_SendData(pUSARTx,temp_l); \n    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);  \n}\n\n///重定向c库函数printf到串口，重定向后可使用printf函数\nint fputc(int ch, FILE *f)\n{\n        /* 发送一个字节数据到串口 */\n        USART_SendData(DEBUG_USARTx, (uint8_t) ch);\n        \n        /* 等待发送完毕 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);     \n    \n        return (ch);\n}\n\n///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\nint fgetc(FILE *f)\n{\n        /* 等待串口输入数据 */\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);\n\n        return (int)USART_ReceiveData(DEBUG_USARTx);\n}\n\n\n\nbsp_usart.h\n#ifndef __USART_H\n#define __USART_H\n\n\n#include \"stm32f10x.h\"\n#include <stdio.h>\n\n/** \n  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏\n    * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线\n    * 2-修改GPIO的宏\n  */\n    \n// 串口1-USART1\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n    \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define  DEBUG_USART_IRQ                USART1_IRQn\n#define  DEBUG_USART_IRQHandler         USART1_IRQHandler\n\n\n// 串口2-USART2\n//#define  DEBUG_USARTx                   USART2\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3\n\n//#define  DEBUG_USART_IRQ                USART2_IRQn\n//#define  DEBUG_USART_IRQHandler         USART2_IRQHandler\n\n// 串口3-USART3\n//#define  DEBUG_USARTx                   USART3\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_USART3\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOB   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOB\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                USART3_IRQn\n//#define  DEBUG_USART_IRQHandler         USART3_IRQHandler\n\n// 串口4-UART4\n//#define  DEBUG_USARTx                   UART4\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART4\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOC\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n//#define  DEBUG_USART_IRQ                UART4_IRQn\n//#define  DEBUG_USART_IRQHandler         UART4_IRQHandler\n\n\n// 串口5-UART5\n//#define  DEBUG_USARTx                   UART5\n//#define  DEBUG_USART_CLK                RCC_APB1Periph_UART5\n//#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n//#define  DEBUG_USART_BAUDRATE           115200\n\n//// USART GPIO 引脚宏定义\n//#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)\n//#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n//    \n//#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n//#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12\n//#define  DEBUG_USART_RX_GPIO_PORT       GPIOD\n//#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2\n\n//#define  DEBUG_USART_IRQ                UART5_IRQn\n//#define  DEBUG_USART_IRQHandler         UART5_IRQHandler\n\n\nvoid USART_Config(void);\nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch);\nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str);\nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch);\n\n#endif /* __USART_H */\n\n\n\n重构void rt_hw_console_output(const char *str)函数\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include <rthw.h>\n#include <rtthread.h>\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n    // 初始化串口\n    USART_Config();\n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}\n\n\n/**************************重写rtthread控制台输出, 通过串口发送*************************************/\nvoid rt_hw_console_output(const char *str)\n{\n    /*进入临界区*/\n    rt_enter_critical();\n\n    /* 直到将字符串发送完 */\n    while (*str != '\\0')\n    {\n        /* 换行 */\n        if (*str == '\\n')\n        {\n            USART_SendData(DEBUG_USARTx, '\\r');\n            while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n        }\n\n        USART_SendData(DEBUG_USARTx, *str++);\n        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);\n    }\n\n    /* 退出临界区 */\n    rt_exit_critical();\n}   \n  \n\n\n\n初始化串口配置\n\nboard.c\nUSART_Config();\n\n\n\n调用\n\nmian.c\n/**\n *********************************************************************\n * @file    main.c\n * @author  fire\n * @version V1.0\n * @date    2018-xx-xx\n * @brief   RT-Thread 3.0 + STM32 工程模版\n *********************************************************************\n * @attention\n *\n * 实验平台:野火 F103-指南者 STM32 开发板\n * 论坛    :http://www.firebbs.cn\n * 淘宝    :https://fire-stm32.taobao.com\n *\n **********************************************************************\n */\n\n/*\n*************************************************************************\n*                             包含的头文件\n*************************************************************************\n*/\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n*/\n/**\n * @brief  主函数\n * @param  无\n * @retval 无\n */\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[1], Red\\r\\n\");\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        rt_kprintf(\"thread --[2], Green\\r\\n\");\n    }\n}"
  },
  {
    "objectID": "posts/TI_dsp入门-ti c660/index.html",
    "href": "posts/TI_dsp入门-ti c660/index.html",
    "title": "TI_dsp入门-ti c660",
    "section": "",
    "text": "dps分类: 都可以进行浮点数的预算 定点 : 无法使用硬件加速, 软件模拟, 性能消耗, 开发耗时(q格式) 浮点 :"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread定时器/index.html",
    "href": "posts/stm32F103-RT-Thread定时器/index.html",
    "title": "stm32F103-RT-Thread定时器",
    "section": "",
    "text": "创建两个动态定时器，一个是单次定时，一个是周期性定时,并让周期定时器运行一段时间后停止运行 硬件定时器，定时器的回调函数将在系统时钟中断里调用。 软件定时器，定时器的回调函数将在定时器线程中调用。\n\n\n\n\n在这里插入图片描述\n\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nstatic rt_timer_t timer_1;\nstatic rt_timer_t timer_2;\nstatic int count_c = 0;\nstatic int short_c = 0;\n\n\nstatic void timeout_1(void *parameter);\nstatic void timeout_2(void *parameter);\n\n/* timer_1 is run 10 times then stop  */\nstatic void timeout_1(void *parameter){\n    \n    rt_kprintf(\"periodic timer_[1] is start. --> count is [%d]\\n\",count_c);\n    if(count_c++>=90){\n        rt_timer_stop(timer_1);\n        rt_kprintf(\"timer_[1] was stoped!\\n\");\n    }\n}\n\nstatic void timeout_2(void *parameter){\n    short_c++;\n    \n    rt_kprintf(\"short timer_[2] is start. -->short is [%d]\\n\", short_c);\n}\n\nint main(void)\n{\n    // create timer_1 and flag is periodic model\n    timer_1 = rt_timer_create(\"timer1\", timeout_1,RT_NULL,90,RT_TIMER_FLAG_PERIODIC);\n    \n    // create timer_2 and flag is short model(count only once then stop)\n    timer_2 = rt_timer_create(\"timer2\", timeout_2, RT_NULL, 30, RT_TIMER_FLAG_PERIODIC);\n\n    if(timer_1!=RT_NULL){\n        rt_timer_start(timer_1);\n    }\n\n    if (timer_2 != RT_NULL)\n    {\n        rt_timer_start(timer_2);\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html",
    "href": "posts/Spring简单使用（依赖注入）/index.html",
    "title": "Spring简单使用（依赖注入）",
    "section": "",
    "text": "IOC（Inversion of Control）:控制反转\n 创建对象的方式改变了，以前是new创建对象，现在时通过Spring创建对象\nAOP（Aspect Oriented Programming）:面向切片编程\n创建代码会有很多重复的部分，如异常处理、日志等。只需要写一遍，利用aop写入程序中"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring核心包",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring核心包",
    "text": "spring核心包\nbeans：bean管理 Context：上下文（体现在xml配置） Expression Language：spring EL表达式 Core：spring框架核心"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "href": "posts/Spring简单使用（依赖注入）/index.html#spring入门程序",
    "title": "Spring简单使用（依赖注入）",
    "section": "spring入门程序",
    "text": "spring入门程序\nUserDao.java\npackage cn.edu.usts.spring;\n\npublic class UserDao {\npublic  void say() {\n    System.out.println(\"spring test！！\");\n}\n}\napplicationContext.xml\nspring-framework-4.3.6.RELEASE-dist\\spring-framework-4.3.6.RELEASE\\docs\\spring-framework-reference\\html\\index.html------>7.2.1\n\n\n\n在这里插入图片描述\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\">\n\n    <bean id=\"userDao\" class=\"cn.edu.usts.spring.UserDao\"></bean>\n\n</beans>\n\nTest,java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport cn.edu.usts.spring.UserDao;\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        // 实例化容器\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        // 通过容器获取实例\n        UserDao userDao = (UserDao)applicationContext.getBean(\"userDao\");\n        // 使用实例中方法\n        userDao.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "href": "posts/Spring简单使用（依赖注入）/index.html#通过set方法进行依赖注入",
    "title": "Spring简单使用（依赖注入）",
    "section": "通过set方法进行依赖注入",
    "text": "通过set方法进行依赖注入\nUserService.java\npackage cn.edu.usts.spring;\n\npublic class UserService {\n    public UserDao userDao;\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n\n\n    public void say(){\n        System.out.println(\"userService say test!!!\");\n        this.userDao.say();\n    }\n}\napplicationContext.xml\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}\nTest.java\npackage cn.edu.usts.spring;\n\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\n\npublic class Test {\n    \n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = (UserService)applicationContext.getBean(\"userService\");\n        userService.say();\n    }\n    \n}"
  },
  {
    "objectID": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "href": "posts/qt上位机 -- 自己开发出口助手/index.html",
    "title": "qt上位机 – 自己开发出口助手",
    "section": "",
    "text": "概要\n利用qt编写一个串口助手\n\n\n成品效果\n代码地址:https://gitee.com/itengfei/serial-assistant\n\n\n\n在这里插入图片描述\n\n\n\n\nui布局\n代码链接:\n\n\n\n在这里插入图片描述\n\n\n\n\n编码\n\n\n\n在这里插入图片描述\n\n\n串口助手 虚拟串口\nserialAssistant.h代码\n#pragma once\n\n#include <QtWidgets/QWidget>\n#include \"ui_serialassistant.h\"\n\n#include <QSerialPort>        //提供访问串口的功能\n#include <QSerialPortInfo>    //提供系统中存在的串口的信息\n#include<qmessagebox.h>\n\nclass serialAssistant : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    serialAssistant(QWidget* parent = Q_NULLPTR) ;\n    ~serialAssistant() {};\n   \n  \n    QSerialPort* serialPort;\n    QSerialPort::BaudRate baudRate{};\n    QSerialPort::StopBits stopBits{};\n    QSerialPort::DataBits dataBits{};\n    QSerialPort::Parity checkBits{};\n\npublic slots:\n    void start();\n    void stop();\n    void clear();\n    void send();\n    void receive();\n\n\nprivate:\n    Ui::serialAssistantClass ui;\n};\nserialAssistant.cpp代码\n#include \"serialassistant.h\"\n#include <iostream>\n\n\n\nserialAssistant::serialAssistant(QWidget *parent)\n    : QWidget(parent)\n{\n    \n    ui.setupUi(this);\n\n    serialPort = new QSerialPort(this);\n    \n    // get and show  ports\n    for each (const QSerialPortInfo &info in QSerialPortInfo::availablePorts())\n    {\n        ui.serialPortComBox->addItem(info.portName());\n    }\n    \n    connect(serialPort, SIGNAL(readyRead()),this, SLOT(receive()));\n}\n\nvoid serialAssistant::start() {\n    if (ui.baudRatCombox->currentText() == \"4800\") {\n        serialAssistant::baudRate = QSerialPort::Baud4800;\n    }\n    else if (ui.baudRatCombox->currentText() == \"9600\") {\n        serialAssistant::baudRate = QSerialPort::Baud9600;\n    }\n    else if (ui.baudRatCombox->currentText() == \"115200\") {\n        serialAssistant::baudRate = QSerialPort::Baud115200;\n    }\n\n\n    if (ui.dataBitComBox->currentText() == \"5\") {\n        serialAssistant::dataBits = QSerialPort::Data5;\n    }\n    else if (ui.dataBitComBox->currentText() == \"6\") {\n        serialAssistant::dataBits = QSerialPort::Data6;\n    }\n    else if (ui.dataBitComBox->currentText() == \"7\") {\n        serialAssistant::dataBits = QSerialPort::Data7;\n    }\n    else if (ui.dataBitComBox->currentText() == \"8\") {\n        serialAssistant::dataBits = QSerialPort::Data8;\n    }\n\n\n    if (ui.stopBitComBox->currentText() == \"1\") {\n        serialAssistant::stopBits = QSerialPort::OneStop;\n    }\n    else if (ui.stopBitComBox->currentText() == \"1.5\") {\n        serialAssistant::stopBits = QSerialPort::OneAndHalfStop;\n    }\n    else if (ui.stopBitComBox->currentText() == \"2\") {\n        serialAssistant::stopBits = QSerialPort::TwoStop;\n    }\n\n    if (ui.checkComBox->currentText() == \"none\") {\n        serialAssistant::checkBits = QSerialPort::NoParity;\n    }\n   \n    serialPort->setPortName(ui.serialPortComBox->currentText());\n    serialPort->setBaudRate(serialAssistant::baudRate);\n    serialPort->setDataBits(serialAssistant::dataBits);\n    serialPort->setStopBits(serialAssistant::stopBits);\n    serialPort->setParity(serialAssistant::checkBits);\n \n   // std::cout << serialAssistant::baudRate << std::endl;\n    // std::cout << serialAssistant::dataBits << std::endl;\n    // std::cout << serialAssistant::stopBits << std::endl;\n    // std::cout << serialAssistant::checkBits << std::endl;\n\n    // chek status \n    if (serialPort->open(QIODevice::ReadWrite) == true) {\n       \n        QMessageBox::information(this, \"tip\", \"ok\");\n    }\n    else {\n        QMessageBox::critical(this, \"tip\", \"fail\");\n    }\n\n}\n\nvoid serialAssistant::stop()\n{\n    QMessageBox::information(this, \"tip\", \"closed\");\n    serialPort->close();\n}\n\nvoid serialAssistant::clear()\n{\n    ui.sendLineEdit->clear();\n}\n\nvoid serialAssistant::send()\n{\n    serialPort->write(ui.sendLineEdit->text().toLocal8Bit().data());\n    //std::cout << ui.sendLineEdit->text().toLocal8Bit().data() << std::endl;\n}\n\nvoid serialAssistant::receive()\n{\n    QString buffer;\n    buffer =  QString(serialPort->readAll());\n    ui.receivePlainTextEdit->appendPlainText(buffer);\n    //std::cout << buffer.toStdString() << std::endl;\n}"
  },
  {
    "objectID": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "href": "posts/stm32H743+CubeMX+RtThread工程创建/index.html",
    "title": "stm32H743+CubeMX+RtThread工程创建",
    "section": "",
    "text": "CubeMX\n\n时钟修改\n把时钟修改为非sysTicks \n\n\n外部高速时钟\n使能外部高速晶振\n 配置时钟树\n\n\n\n\n在这里插入图片描述\n\n\n\nDebug\n\n\n\n\n在这里插入图片描述\n\n\n\nUsart\n设置引脚, 使能usart\n\n\n\n\n在这里插入图片描述\n\n\n >## RT-Thread >添加rtt参考链接 > \n > 打开动态内存堆.否则无法使用rt_thread_create动态创建线程. >  > ## 生成项目  > 生成keil项目 > \n\n\n工程创建完成后修改\n\n工程创建完成后直接编译会有error无法通过编译\n 添加board.h 删除 rtconfig.h\n  board.h\n\n#ifndef __BOARD_H\n#define __BOARD_H\n\n#include \"main.h\" // 这里可以添加平台文件(stm32h743xx.h)替换\n\n\n\n#endif // !__BOARD_H\n\n修改rtconfig.h添加fish组件\n\n   > ### 修改串口输出 > H7的发送和接收是分开的\n\nboard.c\n  # 重复定义错误  ### 修改堆内存  ### main.c  ## 测试结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html",
    "href": "posts/vue -- 01安装、创建、跑通/index.html",
    "title": "vue – 01安装、创建、跑通",
    "section": "",
    "text": "查看版本\n\nvue/cli --version\n\n查看2.xx版本\n\nnpm view vue-cli versions --json\n\nvue init webpack vue2xx\n\n查看3.xx以上版本\n\nnpm view @vue/cli versions --json\n\nvue create my-project\n\n卸载\n\nnpm uninstall -g @vue/cli\n\n安装指定版本（2.xx）\n\nnpm install -g vue-cli@2.9.6\n\n安装指定版本（3.xx）\n\nnpm install -g @vue/cli@3.9.3\n\n安装最新版本\n\nnpm install -g @vue/cli\n\n作者：铁有情\n链接：https://www.jianshu.com/p/cd5dc9aad773\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
  },
  {
    "objectID": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "href": "posts/vue -- 01安装、创建、跑通/index.html#scss在这里插入图片描述",
    "title": "vue – 01安装、创建、跑通",
    "section": "scss",
    "text": "scss"
  },
  {
    "objectID": "posts/qt多线程QThread()/index.html",
    "href": "posts/qt多线程QThread()/index.html",
    "title": "qt多线程QThread()",
    "section": "",
    "text": "创建\nclass MyThread : public QThread\n{\nprotected:\n    void run()\n    {\n        /* 线程的相关代码 */\n    }\n};\n\n\n调用\nThread *thread = new Thread;\n\nthread->start();"
  },
  {
    "objectID": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "href": "posts/win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）/index.html",
    "title": "win11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）",
    "section": "",
    "text": "问题描述：\n直接点击了删除账户，导致系统无用户存在，重启系统完发现之前账户依旧存在，但是输入密码无法进入系统。 # 解决方案（进入windows自带的启动修复） 登录页面点击电源按钮（关机，重启，注销）选择重启（①在点击重启的同时点击键盘上的shift按键） ，将会进入到下面的界面 ### ①在点击重启的同时点击键盘上的shift按键 ### ②选择系统还原\n ### ③选择还原点\n ### ④windows11需要输入硬盘密码（登录微软账户查询密码：https://account.microsoft.com/devices/recoverykey?refd=account.microsoft.com）  ### 输入以上密钥后系统将进入还原点进行还原，等待系统重启即可恢复。"
  },
  {
    "objectID": "posts/vs打包qt程序/index.html",
    "href": "posts/vs打包qt程序/index.html",
    "title": "vs打包qt程序",
    "section": "",
    "text": "把vs切换到Release模式,编译程序  # 进入到项目的Release文件夹中把*.exe文件拷贝出来  # 进入到新建的空文件夹package_demo把.exe文件复制进去.  # 打开qt的MSVC编译器(编译成windows平台的可执行程序) 用windows自带的应用搜索功能搜索即可, 版本号根据所装版本而定 这里用32位的,方便在32和64位机器上运行.因为64位机器是兼容32机器的,方便在两个系统运行  # 进入到exe所在文件夹,执行以下命令\nwindeployqt *.exe\n\n\n\n在这里插入图片描述\n\n\nwindeployqt VitalSignsRadar_Demo.exe\n 执行完效果:   # 到这里在开发环境是运行是没有问题的 打包的目的是为了在用户的环境上使用,所以我们要把开发环境下qt之外的包也打包进来 这里用EnigmaVirtualBox打包额外的需要的包 \n  # 点击 添加 -> 添加文件夹递归"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html",
    "href": "posts/springmvc-json-乱码解决/index.html",
    "title": "springmvc-json-乱码解决",
    "section": "",
    "text": "@Controller\npublic class UserController {\n\n//   \n    // 多数通过配置xml文件实现乱码过滤，这种方式不推荐，写起来太冗余\n    @RequestMapping(value = \"/json1\")\n    @ResponseBody // 让返回字符串对象，不走视图解析器\n    public String json1() throws JsonProcessingException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        User1 user1 = new User1(\"tom\",12,\"男\");\n        // 将对象转换为字符串对象，如果出现500错误多数是 打包没打jackson的包\n        String st = mapper.writeValueAsString(user1);\n        // 打印转换过的json数据\n        System.out.println(st);\n        return st;\n    }\n\n}"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "href": "posts/springmvc-json-乱码解决/index.html#spring解决中文乱码-方法1",
    "title": "springmvc-json-乱码解决",
    "section": "2、spring解决中文乱码-方法1：",
    "text": "2、spring解决中文乱码-方法1：\n @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\")  解决乱码问题"
  },
  {
    "objectID": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "href": "posts/springmvc-json-乱码解决/index.html#mvc框架解决中文乱码-方法2",
    "title": "springmvc-json-乱码解决",
    "section": "3、mvc框架解决中文乱码-方法2：",
    "text": "3、mvc框架解决中文乱码-方法2：\n修改springmvc-servlet.xml\n<!--    json 编码过滤器-->\n    <mvc:annotation-driven>\n        <mvc:message-converters register-defaults=\"true\">\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <constructor-arg value=\"UTF-8\"/>\n            </bean>\n            <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n                <property name=\"objectMapper\">\n                    <bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\">\n                        <property name=\"failOnEmptyBeans\" value=\"false\"/>\n                    </bean>\n                </property>\n            </bean>\n        </mvc:message-converters>\n    </mvc:annotation-driven>"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html",
    "href": "posts/Ubuntu21 美化/index.html",
    "title": "Ubuntu21 美化",
    "section": "",
    "text": "sudo apt update\n\nsudo apt-get install gnome-tweak-tool\n\nsudo apt-get install gnome-shell-extensions\n\nsudo apt-get install gnome-shell-extension-dashtodock\n\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#搜索优化",
    "href": "posts/Ubuntu21 美化/index.html#搜索优化",
    "title": "Ubuntu21 美化",
    "section": "2、搜索优化",
    "text": "2、搜索优化\n打开Dash to dock 根据需求修改设置 打开user theams\n# 重启\nreboot"
  },
  {
    "objectID": "posts/Ubuntu21 美化/index.html#挑选主题",
    "href": "posts/Ubuntu21 美化/index.html#挑选主题",
    "title": "Ubuntu21 美化",
    "section": "3、挑选主题",
    "text": "3、挑选主题\ngnome网站：主题网站"
  },
  {
    "objectID": "posts/spring整合SSM/index.html",
    "href": "posts/spring整合SSM/index.html",
    "title": "spring整合SSM",
    "section": "",
    "text": "CREATE DATABASE `ssmbuild`;\n\nUSE `ssmbuild`;\n\nDROP TABLE IF EXISTS `books`;\n\nCREATE TABLE `books` (\n`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',\n`bookName` VARCHAR(100) NOT NULL COMMENT '书名',\n`bookCounts` INT(11) NOT NULL COMMENT '数量',\n`detail` VARCHAR(200) NOT NULL COMMENT '描述',\nKEY `bookID` (`bookID`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES\n(1,'Java',1,'从入门到放弃'),\n(2,'MySQL',10,'从删库到跑路'),\n(3,'Linux',5,'从进门到进牢');"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "href": "posts/spring整合SSM/index.html#新建一maven项目ssmbuild-添加web的支持",
    "title": "spring整合SSM",
    "section": "2.1新建一Maven项目！ssmbuild ， 添加web的支持",
    "text": "2.1新建一Maven项目！ssmbuild ， 添加web的支持"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "href": "posts/spring整合SSM/index.html#导入相关的pom依赖",
    "title": "spring整合SSM",
    "section": "2.2导入相关的pom依赖！",
    "text": "2.2导入相关的pom依赖！\n<dependencies>\n   <!--Junit-->\n   <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>\n       <version>4.12</version>\n   </dependency>\n   <!--数据库驱动-->\n   <dependency>\n       <groupId>mysql</groupId>\n       <artifactId>mysql-connector-java</artifactId>\n       <version>5.1.47</version>\n   </dependency>\n   <!-- 数据库连接池 -->\n   <dependency>\n       <groupId>com.mchange</groupId>\n       <artifactId>c3p0</artifactId>\n       <version>0.9.5.2</version>\n   </dependency>\n\n   <!--Servlet - JSP -->\n   <dependency>\n       <groupId>javax.servlet</groupId>\n       <artifactId>servlet-api</artifactId>\n       <version>2.5</version>\n   </dependency>\n   <dependency>\n       <groupId>javax.servlet.jsp</groupId>\n       <artifactId>jsp-api</artifactId>\n       <version>2.2</version>\n   </dependency>\n   <dependency>\n       <groupId>javax.servlet</groupId>\n       <artifactId>jstl</artifactId>\n       <version>1.2</version>\n   </dependency>\n\n   <!--Mybatis-->\n   <dependency>\n       <groupId>org.mybatis</groupId>\n       <artifactId>mybatis</artifactId>\n       <version>3.5.2</version>\n   </dependency>\n   <dependency>\n       <groupId>org.mybatis</groupId>\n       <artifactId>mybatis-spring</artifactId>\n       <version>2.0.2</version>\n   </dependency>\n\n   <!--Spring-->\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-webmvc</artifactId>\n       <version>5.1.9.RELEASE</version>\n   </dependency>\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-jdbc</artifactId>\n       <version>5.1.9.RELEASE</version>\n   </dependency>\n   \n   <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.16.22</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>RELEASE</version>\n            <scope>compile</scope>\n        </dependency>\n</dependencies>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "href": "posts/spring整合SSM/index.html#maven资源过滤设置",
    "title": "spring整合SSM",
    "section": "3、Maven资源过滤设置",
    "text": "3、Maven资源过滤设置\n静态资源没有导出记得加上\n<build>\n   <resources>\n       <resource>\n           <directory>src/main/java</directory>\n           <includes>\n               <include>**/*.properties</include>\n               <include>**/*.xml</include>\n           </includes>\n           <filtering>false</filtering>\n       </resource>\n       <resource>\n           <directory>src/main/resources</directory>\n           <includes>\n               <include>**/*.properties</include>\n               <include>**/*.xml</include>\n           </includes>\n           <filtering>false</filtering>\n       </resource>\n   </resources>\n</build>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置包",
    "href": "posts/spring整合SSM/index.html#配置包",
    "title": "spring整合SSM",
    "section": "4、配置包",
    "text": "4、配置包\ncn.usts.pojo\n\ncn.usts.dao\n\ncn.usts.service\n\ncn.usts.controller"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#mybatis-config.xml",
    "title": "spring整合SSM",
    "section": "5、mybatis-config.xml",
    "text": "5、mybatis-config.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n       PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n</configuration>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "href": "posts/spring整合SSM/index.html#applicationcontext.xml",
    "title": "spring整合SSM",
    "section": "6、applicationContext.xml",
    "text": "6、applicationContext.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "href": "posts/spring整合SSM/index.html#数据库配置文件-database.properties",
    "title": "spring整合SSM",
    "section": "7、数据库配置文件 database.properties",
    "text": "7、数据库配置文件 database.properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&useUnicode=true&characterEncoding=utf8\njdbc.username=root\njdbc.password=123321"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#books.class",
    "href": "posts/spring整合SSM/index.html#books.class",
    "title": "spring整合SSM",
    "section": "8、Books.class",
    "text": "8、Books.class\npackage cn.usts.edu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Books {\n    private int bookID;\n    private String bookName;\n    private int bookCounts;\n    private String detail;\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper接口",
    "href": "posts/spring整合SSM/index.html#bookmapper接口",
    "title": "spring整合SSM",
    "section": "9、bookMapper接口",
    "text": "9、bookMapper接口\npackage cn.usts.edu.dao;\n\nimport cn.usts.edu.pojo.Books;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\npublic interface bookMapper {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook(@Param(\"bookId\") int id);\n    // 根据id查询一本书\n    Books queryBook(@Param(\"bookId\") int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List<Books> queryAllBooks();\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#bookmapper.xml",
    "href": "posts/spring整合SSM/index.html#bookmapper.xml",
    "title": "spring整合SSM",
    "section": "10、bookMapper.xml",
    "text": "10、bookMapper.xml\nPUBLIC “-//mybatis.org//DTD mapper 3.0//EN”别写错了\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"cn.usts.edu.dao.bookMapper\">\n    <insert id=\"addBook\" parameterType=\"Books\">\n        insert into ssmbuild.books(bookName, bookCounts, detail)\n        values(#{bookName},#{bookCounts},#{detail});\n    </insert>\n\n    <delete id=\"deleteBook\" parameterType=\"int\">\n        delete from ssmbuild.books where bookID=#{bookId};\n    </delete>\n\n    <update id=\"updateBook\" parameterType=\"Books\">\n        update ssmbuild.books\n        set bookName=#{bookName},\n            bookCounts=#{bookCounts},\n            detail=#{detail}\n        where bookID=#{bookId};\n    </update>\n\n    <select id=\"queryBook\" parameterType=\"Books\">\n        select * from ssmbuild.books\n        where bookID=#{bookId};\n    </select>\n\n    <select id=\"queryAllBooks\" parameterType=\"Books\">\n        select * from ssmbuild.books;\n    </select>\n</mapper>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "href": "posts/spring整合SSM/index.html#绑定mappermybatis-config.xml",
    "title": "spring整合SSM",
    "section": "11、绑定mapper【myBatis-config.xml】",
    "text": "11、绑定mapper【myBatis-config.xml】\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://www.mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"cn.usts.edu.pojo\" />\n    </typeAliases>\n\n<!--    绑定mapper-->\n    <mappers>\n        <mapper class=\"cn/usts/edu/dao/bookMapper.xml\"/>\n    </mappers>\n</configuration>\n\n【文件结构】"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#编写service层",
    "href": "posts/spring整合SSM/index.html#编写service层",
    "title": "spring整合SSM",
    "section": "12、编写service层",
    "text": "12、编写service层\n12.1 BookService接口\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\n\n\nimport java.util.List;\n\npublic interface BookService {\n    // 增加一本书\n    int addBook(Books books);\n    // 删除一本书\n    int deleteBook( int id);\n    // 根据id查询一本书\n    Books queryBook( int id);\n    // 更新一本书\n    int updateBook(Books books);\n    // 查询全部书\n    List<Books> queryAllBooks();\n}\n12.2 BookServiceImp.class\npackage cn.usts.edu.service;\n\nimport cn.usts.edu.pojo.Books;\nimport cn.usts.edu.dao.bookMapper;\nimport java.util.List;\n\npublic class BookServiceImp implements BookService {\n\n    // service层调用dao层\n    private bookMapper bookMapper;\n\n    public void setBookMapper(cn.usts.edu.dao.bookMapper bookMapper) {\n        this.bookMapper = bookMapper;\n    }\n\n    @Override\n    public int addBook(Books books) {\n        return bookMapper.addBook(books);\n    }\n\n    @Override\n    public int deleteBook(int id) {\n        return bookMapper.deleteBook(id);\n    }\n\n    @Override\n    public Books queryBook(int id) {\n        return bookMapper.queryBook(id);\n    }\n\n    @Override\n    public int updateBook(Books books) {\n        return bookMapper.updateBook(books);\n    }\n\n    @Override\n    public List<Books> queryAllBooks() {\n        return bookMapper.queryAllBooks();\n    }\n}"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "href": "posts/spring整合SSM/index.html#配置spring整合mybatis我们这里数据源使用c3p0连接池",
    "title": "spring整合SSM",
    "section": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；",
    "text": "13、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n<!--    1、关联数据库配置-->\n    <context:property-placeholder location=\"classpath:database.properties\"/>\n    <!--    2、连接池\n            dbcp,半自动化 不能自动连接\n            c3p0,自动化操作\n            druid,hikari\n    -->\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n        <property name=\"user\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n    </bean>\n<!--    3、sqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n<!--        绑定mybatis配置文件-->\n        <property name=\"configLocation\" value=\"classpath:myBatis-config.xml\"/>\n    </bean>\n\n<!--  配置dao接口扫描包，动态的实现了dao接口可以注入到spring容器中  -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"cn.usts.edu.dao\"/>\n    </bean>\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring整合service层",
    "href": "posts/spring整合SSM/index.html#spring整合service层",
    "title": "spring整合SSM",
    "section": "14、Spring整合service层",
    "text": "14、Spring整合service层\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n<!--    包扫描-->\n    <context:component-scan base-package=\"cn.usts.edu.service\"/>\n<!--    将所有业务类，注入到spring，可以通过配置，或者注解实现-->\n    <bean id=\"BookServiceImpl\" class=\"cn.usts.edu.service.BookServiceImp\">\n        <property name=\"bookMapper\" ref=\"bookMapper\"/>\n    </bean>\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!-- 注入数据库连接池 -->\n        <property name=\"dataSource\" ref=\"dataSource\" />\n    </bean>\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#web.xml",
    "href": "posts/spring整合SSM/index.html#web.xml",
    "title": "spring整合SSM",
    "section": "15、web.xml",
    "text": "15、web.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n<!--    前端控制器-->\n    <servlet>\n        <servlet-name>srpingmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>srpingmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n<!--    编码过滤器-->\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n<!--    session过期时间 15min-->\n    <session-config>\n        <session-timeout>15</session-timeout>\n    </session-config>\n</web-app>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "href": "posts/spring整合SSM/index.html#spring-mvc.xml",
    "title": "spring整合SSM",
    "section": "16、spring-mvc.xml",
    "text": "16、spring-mvc.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n<!--    包扫描-->\n    <context:component-scan base-package=\"cn.usts.edu.controller\"/>\n<!--    注解驱动-->\n    <mvc:annotation-driven/>\n<!--    默认静态资源过滤-->\n    <mvc:default-servlet-handler/>\n<!--    视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n</beans>\n17、Spring配置整合文件，applicationContext.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <import resource=\"classpath:spring-dao.xml\"/>\n    <import resource=\"classpath:spring-mvc.xml\"/>\n    <import resource=\"classpath:spring-service.xml\"/>\n\n\n</beans>"
  },
  {
    "objectID": "posts/spring整合SSM/index.html#index.jsp",
    "href": "posts/spring整合SSM/index.html#index.jsp",
    "title": "spring整合SSM",
    "section": "18、 index.jsp",
    "text": "18、 index.jsp\n在这里插入代码片"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "href": "posts/stm32F103-RT-Thread-- 互斥量(mutex)/index.html",
    "title": "stm32F103-RT-Thread– 互斥量(mutex)",
    "section": "",
    "text": "在编码前记得打开rtconfig.h中的IPC中的mutex设置 > 互斥量访问的是同一个资源,且只可以有一个线程进行访问, 保证数据的一致性.\n\n#include \"board.h\"\n#include \"rtthread.h\"\n\nstatic int count=0, num=0;\n\nstatic rt_mutex_t mutex = RT_NULL;\nstatic rt_thread_t mutex_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t mutex_2_thread = RT_NULL;                // semaphore thread_2 control block\nstatic rt_thread_t mutex_3_thread = RT_NULL;                // semaphore thread_2 control block\n\n\nstatic void mutex_thread_1_entry(void *parmaeter);\nstatic void mutex_thread_2_entry(void *parmaeter);\nstatic void mutex_thread_3_entry(void *parmaeter);\n\n\nint main(void)\n{\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_FIFO);\n    mutex_1_thread = rt_thread_create(\"mutex_1_thread\", mutex_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (mutex_1_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_2_thread = rt_thread_create(\"metux_2_thread\", mutex_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (mutex_2_thread!= RT_NULL){\n        \n        rt_thread_startup(mutex_2_thread);\n    }\n    else{\n        return -1;\n    }\n\n    mutex_3_thread = rt_thread_create(\"mutex3_thread\", mutex_thread_3_entry, RT_NULL,512, 3,20);\n    if(mutex_3_thread!=RT_NULL){\n        rt_thread_startup(mutex_3_thread);\n    }\n    else{\n        return -1;\n    }\n\n}\n\n\n\n\n/*this thread is release semaphore */\nstatic void mutex_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_1 count is [%d]\\n\",count);\n        rt_thread_delay(500);\n        num++;\n        rt_kprintf(\"thread_1 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);    \n    }\n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void mutex_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count--;\n        rt_kprintf(\"thread_2 count is [%d]\\n\",count);\n        rt_thread_delay(700);\n        num--;\n        rt_kprintf(\"thread_2 num is [%d]\\n\",num);   \n        rt_mutex_release(mutex);    \n    }\n}\n\nstatic void mutex_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        count++;\n        rt_kprintf(\"thread_3 count is [%d]\\n\",count);\n        num++;\n        rt_kprintf(\"thread_3 num is [%d]\\n\",num);\n        rt_mutex_release(mutex);\n    }   \n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "",
    "text": "创建一个固件库项目 参考:野火固件库创建  >下载RT-Thread\n>安装RT-Thread >https://www.keil.com/dd2/pack/ >"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.c",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.c",
    "text": "stm32f10x_it.c\n/* 存放终端函数 */\n#include \"stm32f10x_it.h\""
  },
  {
    "objectID": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "href": "posts/stm32F103-RT-Thread移植(固件库版本)-项目创建/index.html#stm32f10x_it.h",
    "title": "stm32F103-RT-Thread移植(固件库版本)-项目创建",
    "section": "stm32f10x_it.h",
    "text": "stm32f10x_it.h\n#ifndef __STM32F10x_IT_H\n#define __STM32F10x_IT_H\n\n\n#include \"stm32f10x.h\"\n\n\n\n#endif /* __STM32F10x_IT_H */"
  },
  {
    "objectID": "posts/webSocket-node -- 01简单跑通/index.html",
    "href": "posts/webSocket-node -- 01简单跑通/index.html",
    "title": "webSocket-node – 01简单跑通",
    "section": "",
    "text": "简单实现架构图\n\n\n\n在这里插入图片描述\n\n\n安装webSocket\nnpm install websocket\n启动程序前配置package.json\n{\n  \"scripts\": {\n    \"start\": \"node index.js 8080\"\n  },\n  \"dependencies\": {\n    \"websocket\": \"^1.0.34\"\n  }\n}\n服务端程序: serverClient.js\nvar WebSocket = require('websocket').server\nvar http = require('http')\n\n// 创建httpServer\nvar httpServer = http.createServer().listen(8080,function (){\n    console.log('http://127.0.0.1:8080')\n})\n\n// 创建webSocketServer\nvar wsServer = new WebSocket({\n    httpServer:httpServer,\n    autoAcceptConnections:false\n})\n\nwsServer.on('request',function (request){\n    var connection = request.accept()\n    connection.on('message',function (msg){\n        console.log(msg)\n\n        // 发送给客户端\n        connection.send(msg.utf8Data)\n    })\n})\n客户端程序: Client.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"msg\"></div>\n    <input type=\"text\" id=\"text\">\n    <input type=\"submit\" value=\"发送\" onclick=\"send()\">\n\n    <script>\n        var websocket = new WebSocket('ws://localhost:8080');\n        // ws ---> http\n        // wss ---> https\n\n        websocket.readyState\n        // 0 链接还没有建立\n        // 1 连接建立成功\n        // 2 连接正在关闭\n        // 3 连接已经关闭\n        websocket.onopen = function () {\n            console.log(websocket.readyState)\n        }\n        \n        function send() {\n            var text = document.getElementById('text').value\n            websocket.send(text)\n        }\n\n        websocket.onmessage = function (backMsg){\n            console.log(backMsg.data)\n        }\n    </script>\n\n</body>\n</html>\n客户端： 服务端："
  },
  {
    "objectID": "posts/TI_ccs修改环境变量/index.html",
    "href": "posts/TI_ccs修改环境变量/index.html",
    "title": "TI_ccs修改环境变量",
    "section": "",
    "text": "项目右键 \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/stm32H743使用/index.html",
    "href": "posts/stm32H743使用/index.html",
    "title": "stm32H743使用",
    "section": "",
    "text": "0. 所需材料\n\n\n\n材料\n数量\n\n\n\n\nST-Link V2\n1\n\n\n战舰扩展板\n1\n\n\nstm32H743核心板\n1\n\n\n\n\n\n1. 安装仿真器驱动程序\n # 1. 安装芯片包 \n\n\n\n在这里插入图片描述\n\n\n\n\n1. 使用MX-Cube配置工程\n时钟配置  串口设置:"
  },
  {
    "objectID": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "href": "posts/springMVC-设置日期时间对象【自定义日期时间格式】/index.html",
    "title": "springMVC-设置日期时间对象【自定义日期时间格式】",
    "section": "",
    "text": "// 返回格式化日期对象\n    @RequestMapping(\"/json4\")\n    public String json4() throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        // 不使用时间戳的方式\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf);\n        // 设置 日期格式\n        mapper.setDateFormat(sdf);\n        Date date = new Date();\n        // 设置字符串对象\n        String str = mapper.writeValueAsString(date);\n        return str;\n    }\n}"
  },
  {
    "objectID": "posts/qt--vs2022+qt5.15.2/index.html",
    "href": "posts/qt--vs2022+qt5.15.2/index.html",
    "title": "qt–vs2022+qt5.15.2",
    "section": "",
    "text": "最终效果\n项目结构 \n # demo的搭建 \n          \n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/web-packet --01/index.html",
    "href": "posts/web-packet --01/index.html",
    "title": "web-packet –01",
    "section": "",
    "text": "进入\nnpm -init -y\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div>\n<!--        ul>li{这是$}*9-->\n        <ul>\n            <li>这是第1个li</li>\n            <li>这是第2个li</li>\n            <li>这是第3个li</li>\n            <li>这是第4个li</li>\n            <li>这是第5个li</li>\n            <li>这是第6个li</li>\n            <li>这是第7个li</li>\n            <li>这是第8个li</li>\n            <li>这是第9个li</li>\n        </ul>\n    </div>\n</body>\n</html>\nindex.js\nimport $ from 'jquery'\n\n// 实现隔行变色\n$(function (){\n    // 奇数行\n    $('li:odd').css('backgroundColor','red')\n    // 偶数行\n    $('li:even').css('backgroundColor','red')\n})\n 安装 jQuery，webpack\nnpm install jquery -S\nnpm install webpack\n// 开发时存在\nnpm install webpack-cli -D\n创建名为 webpack.config.js 的 webpack 配置文件\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n  output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  }\n};\n在 package.json 的 scripts 节点下，新增 dev 脚本如下  ## 添加插件（修改自动同步） 安装\nnpm install webpack-dev-server -D\n配置 出现 使用webpack插件webpack-dev-server 出现Cannot GET/的解决办法\n \ndevServer: {\n        static:'./', // webpack can not GET /\n    }\nwebpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n    mode:'development', // 设置为开发，编译更快，设置production更小\n    entry: './src/index.js', // 输入程序\n\n    output: {\n    filename: 'main.js',//输出名\n    path: path.resolve(__dirname, 'dist') // 输出文件夹\n  },\n    devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:false,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    }\n};\n\n\n在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ * css-loader 可以打包处理 .css 相关的文件 * less-loader 可以打包处理 .less 相关的文件 * babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 ### 安准css-loader：\nnpm i style-loader@2.0.0 css-loader@5.0.1 -D\n# less-loader\nnpm i less less-loader -D\n\n\n\nmodule: {// 设置loader规则,从后往前生效\n    rules: [\n        { test: /\\.css$/, use: ['style-loader','css-loader'] },\n        { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] },\n    ],\n  },\n ### 打包处理样式表中与 url 路径相关的文件\nnpm i url-loader file-loader -D\n\nwebpack.config.js\n// 体积小于limit: 8192就会转成base64\n{ test: /\\.(png|jpg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 8192}}]},\n\n\n\n就要用到bable-loader webpack-loader配置 # 打包发布\n\"build\": \"webpack --mode production\"\n\n\n\n开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致：  ### 完成整 webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst path = require('path');\n\n// 1. 导入插件，得到构造函数\nconst HtmlPlugin = require('html-webpack-plugin')\n// 2. 创建插件的实例对象\nconst htmlPlugin = new HtmlPlugin({\n  template: './src/index.html',\n  filename: './index.html',\n})\n\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst cleanPlugin = new CleanWebpackPlugin()\n\nmodule.exports = {\n  mode: 'development', // development  production\n  // eval-source-map 仅限在开发模式下使用\n   devtool: 'eval-source-map',\n  // 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map\n  // devtool: 'nosources-source-map',\n  // devtool: 'source-map',\n  // 指定打包的入口\n  entry: path.join(__dirname, './src/index.js'),\n  // 指定打包的出口\n  output: {\n    // 表示输出文件的存放路径\n    path: path.join(__dirname, './dist'),\n    // 表示输出文件的名称\n    filename: 'js/bundle.js',\n  },\n  plugins: [htmlPlugin, cleanPlugin], // 3. 挂载插件的实例对象\n  devServer: {\n        static:'./src', // 直接http主頁就是src，記得修改index.html中的main.js位置 webpack can not GET /\n        open:true,// true直接打开\n        host:\"127.0.0.1\",\n        port:80,\n    },\n  module: {\n    rules: [\n      { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n      { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n      // { test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22228' }\n      {test: /\\.jpg|png|gif$/, use: {loader: 'url-loader', options: {limit: 22228,outputPath: 'image',},},},\n      {test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: ['@babel/plugin-proposal-class-properties'],\n          },\n        },\n      },//babel-loader\n    ],\n  },\n\n};"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "href": "posts/stm32F103-RT-Thread--信号量(semaphare)/index.html",
    "title": "stm32F103-RT-Thread–信号量(semaphare)",
    "section": "",
    "text": "信号量(semaphare)\n\n主要是量这个字, 表示这个信号有一定的量, 可以是0,也可是10,也可以是任意数字, 但是当他为0的时候就表示不可以使用了, 当为非零的时候可以使用,每使用一次即-1,释放的时候+1,为0就等待释放.\n\nstatic int count = 0;\n\nstatic rt_sem_t sem = RT_NULL;                          // semaphore control block\nstatic rt_thread_t sem_1_thread = RT_NULL;              // semaphore thread_1 control block\nstatic rt_thread_t sem_2_thread = RT_NULL;              // semaphore thread_2 control block\nstatic rt_thread_t sem_3_thread = RT_NULL;              // semaphore thread_2 control block\n\nstatic void sem_thread_1_entry(void *parmaeter);\nstatic void sem_thread_2_entry(void *parmaeter);\nstatic void sem_thread_3_entry(void *parmaeter);\n\nint main(void){\n\n    /* 这里的main简化了 */\n    sem = rt_sem_create(\"sem_count_per10_++\", 0,RT_IPC_FLAG_FIFO);\n    \n    sem_1_thread = rt_thread_create(\"sem_1_thread\", sem_thread_1_entry, RT_NULL, 512, 3, 20);\n    rt_thread_startup(sem_1_thread);\n    \n    \n    sem_2_thread = rt_thread_create(\"sem_2_thread\", sem_thread_2_entry, RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_2_thread);\n    \n    \n    sem_3_thread = rt_thread_create(\"sem_3_thread\", sem_thread_3_entry,RT_NULL, 512, 2, 20);\n    rt_thread_startup(sem_3_thread);\n    \n}\n\n\nstatic void sem_thread_1_entry(void *parameter){\n    while (1)   \n    {\n        if (count <= 100)\n        {\n            count++;\n        }\n        else\n            return;\n\n        if (0 == count % 10)\n        {\n            rt_kprintf(\"thread_1 is release the semaphore %d\\n\",count);\n            rt_sem_release(sem);    // release the semaphore\n        }\n        \n    }\n    \n}\n\n/*this thread is to get the semphore and do +1*/\nstatic void sem_thread_2_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[2] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[2]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}\n\n\nstatic void sem_thread_3_entry(void *parameter){\n\n    while (1)\n    {\n        rt_err_t result = RT_NULL;\n        result = rt_sem_take(sem,RT_WAITING_FOREVER);\n        \n        if(result==RT_EOK){\n            count++;\n            rt_kprintf(\"thread_[3] if take the semaphore and after ++ is: [%d]\\n\",count);\n        }\n        else{\n            rt_kprintf(\"[3]take the semaphore is failed!!!!!\\n\");\n            rt_sem_delete(sem);\n            return;\n        }\n    }   \n}"
  },
  {
    "objectID": "posts/qt无法输出/index.html",
    "href": "posts/qt无法输出/index.html",
    "title": "qt无法输出",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html",
    "href": "posts/webSocket -- 03 socket.io/index.html",
    "title": "webSocket – 03 socket.io",
    "section": "",
    "text": "为什么使用socket.io 1. 简单 2. 高效：连接池的管理比自己写的要高效（通常）"
  },
  {
    "objectID": "posts/webSocket -- 03 socket.io/index.html#测试",
    "href": "posts/webSocket -- 03 socket.io/index.html#测试",
    "title": "webSocket – 03 socket.io",
    "section": "测试：",
    "text": "测试：\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/smt32-f103寄存器点灯/index.html",
    "href": "posts/smt32-f103寄存器点灯/index.html",
    "title": "smt32-f103寄存器点灯",
    "section": "",
    "text": "STM32F103寄存器点灯\n通过寄存器中的状态来设置引脚状态 LED在GPIOB的第5引脚\n// RCC_ENR RCC must be first otherwise the LED can not be lighted\n    *(unsigned int*)0x40021018 |= (1<<3);\n    // port B   base address 0x4001 0c00\n\n    // output type is pull and push\n    *(unsigned int*)0x40010C00 |= ((1)<<(4*0));\n    //*(unsigned int*)0x40010C00 |= ((1)<<(8*0));\n    \n\n    // port B odr address is base address add 0x0c  \n    *(unsigned int*)0x40010C0C &= ~(1<<0);\n    //*(unsigned int*)0x40010C0C &= ~(1<<2);\n封装GPIO\n// REG mapping \n#define PERIPH_BASE                 ((unsigned int) 0x40000000)\n    \n#define APB1_PERIPH_BASE         PERIPH_BASE\n#define APB2_PERIPH_BASE        (PERIPH_BASE+0x10000)\n#define AHB_PERIPH_BASE         (PERIPH_BASE+0x20000)\n\n#define RCC_BASE                        (AHB_PERIPH_BASE+0x1000)\n#define GPIOB_BASE                      (APB2_PERIPH_BASE +0x0C00)\n\n#define RCC_APB2ENR                     *(unsigned int*)(RCC_BASE+0x18)\n    \n#define GPIOB_CRL                       *(unsigned int*)(GPIOB_BASE+0x00)\n#define GPIOB_CRH                       *(unsigned int*)(GPIOB_BASE+0x04)\n#define GPIOB_ODR                       *(unsigned int*)(GPIOB_BASE+0x0C)\n    \n#define GPIOB_BSRR                  *(unsigned int*)(GPIOB_BASE+0x10)\n#define GPIOB_BRR                       *(unsigned int*)(GPIOB_BASE+0x14)\n#define GPIOB_LOCK                      *(unsigned int*)(GPIOB_BASE+0x18)\n\ntypedef unsigned int        uint32_t;\ntypedef unsigned short  uint16_t; \n\ntypedef struct{\n    uint32_t CRL; \n    uint32_t CRH; \n    uint32_t IDL; \n    uint32_t ODR; \n    uint32_t BSRR; \n    uint32_t BRR; \n    uint32_t LCKR;  \n}GPIO_Struct; \n\n// change the GPIO type to GPIO_Struct then can use the REG like [GPIO_Struct->RCC] \n#define GPIOB ((GPIO_Struct*)GPIOB_BASE)\n\n    RCC_APB2ENR |= (1<<3);\n\n    GPIOB->CRL |= ((1)<<(4*0));\n    \n    // open LED set 0\n    //GPIOB->ODR &= ~(1<<0);\n    // off LED set 1\n    GPIOB->ODR |= (1<<0);\n简单封装\n    RCC_APB2ENR |= (1<<3);\n\n    GPIOB_CRL |= ((1)<<(4*0));\n    \n    // open LED set 0\n    GPIOB_ODR &= ~(1<<0);\n    // off LED set 1\n    //GPIOB_ODR |= (1<<0);"
  },
  {
    "objectID": "posts/stm32芯片开发包/index.html",
    "href": "posts/stm32芯片开发包/index.html",
    "title": "stm32芯片开发包",
    "section": "",
    "text": "stm32芯片开发包\nhttps://www.keil.com/dd2/pack/#!#eula-container\n\n\n固件库\nhttps://blog.csdn.net/cbkdgq/article/details/88076843   ## RCC - 218  ODR -269"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "href": "posts/stm32F103-RT-Thread线程同步(event)/index.html",
    "title": "stm32F103-RT-Thread线程同步(event)",
    "section": "",
    "text": "event是不同线程间满足条件时的控制块(比较适合多flag和多线程的情况) mutex访问单独的临界资源 semaphore访问多个临界资源 > 线程1接收event,查看其中的flag是否满足设置的条件 > 线程2发送flag1,flag2\n#include \"board.h\"\n#include \"rtthread.h\"\n\n#define FLAG3  1<<3\n#define FLAG5  1<<5\nstatic rt_event_t event1 = NULL;\nstatic rt_thread_t event_1_thread = RT_NULL;                // semaphore thread_1 control block\nstatic rt_thread_t event_2_thread = RT_NULL;                // semaphore thread_2 control block\n\n\n\nstatic void event_thread_1_entry(void *parmaeter);\nstatic void event_thread_2_entry(void *parmaeter);\n\n\n\n\nint main(void)\n{\n    event1 = rt_event_create(\"flag\", RT_IPC_FLAG_FIFO);\n\n    event_1_thread = rt_thread_create(\"event_1_thread\", event_thread_1_entry, RT_NULL, 512, 3, 20);\n    if (event_1_thread!= RT_NULL){\n        \n        rt_thread_startup(event_1_thread);\n    }\n    else{\n        return -1;\n    }\n\n    event_2_thread = rt_thread_create(\"metux_2_thread\", event_thread_2_entry, RT_NULL, 512, 3, 30);\n    if (event_2_thread!= RT_NULL){\n        \n        rt_thread_startup(event_2_thread);\n    }\n    else{\n        return -1;\n    }\n}\n\n\n\n\n/* receive envet thread */\nstatic void event_thread_1_entry(void *parameter)\n{\n    while (1)   \n    {\n        rt_uint32_t e;\n\n        // if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        // {\n        //  rt_kprintf(\"thread1: [AND] recv event 0x%x\\n\", &e);\n        // }\n        // rt_kprintf(\"thread1: delay 1s to prepare the second event\\n\");\n        // rt_thread_delay(1000);\n\n        if (rt_event_recv(event1, (FLAG3 | FLAG5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &e) == RT_EOK)\n        {\n            rt_kprintf(\"thread1: [OR] recv event 0x%x\\n\", &e);\n        }\n\n        rt_kprintf(\"thread1 leave.\\n\");\n    }\n}\n\n/* send event thread */\nstatic void event_thread_2_entry(void *parameter)\n{\n\n    while (1)\n    {\n        rt_kprintf(\"thread_2 is send event[3]\\n\");\n        rt_event_send(event1, FLAG3);\n        rt_thread_delay(500);\n\n        rt_kprintf(\"thread_2 is send event[5]\\n\");\n        rt_thread_delay(1800);\n        rt_event_send(event1, FLAG5);\n        rt_kprintf(\"thread2 leave.\\n\");\n        }\n}"
  },
  {
    "objectID": "posts/springmvc-hellomvc-02/index.html",
    "href": "posts/springmvc-hellomvc-02/index.html",
    "title": "springmvc-hellomvc-02",
    "section": "",
    "text": "1、web.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!--1.注册DispatcherServlet-->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc-servlet.xml</param-value>\n        </init-param>\n        <!--启动级别-1-->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <!--/ 匹配所有的请求；（不包括.jsp）-->\n    <!--/* 匹配所有的请求；（包括.jsp）-->\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n2、springmvc-servlet.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n\n\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n\n\n<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n\n\n        <!--视图解析器:DispatcherServlet给他的ModelAndView-->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n<!--前缀-->\n<property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n<!--后缀-->\n<property name=\"suffix\" value=\".jsp\"/>\n</bean>\n\n<!--    handler-->\n    <bean id=\"/hello\" class=\"cn.usts.edu.controller.HelloController\" />\n</beans>\n3、HelloController.java\npackage cn.usts.edu.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class HelloController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        ModelAndView mav = new ModelAndView();\n        // 封装对象\n        mav.addObject(\"msg\",\"helloMVC\");\n        // 跳转的视图名\n        mav.setViewName(\"hello\"); // 拼接前后缀\n        return  mav;\n    }\n}"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "href": "posts/stm32F103-RT-Thread邮箱(mailbox)/index.html",
    "title": "stm32F103-RT-Thread邮箱(mailbox)",
    "section": "",
    "text": "在编码前先打开rtconfig.h中的mailbox选项. > 这个程序会创建2个动态线程，一个静态的邮箱对象，其中一个线程往邮箱中发送邮件，一个线程往邮箱中收取邮件。 数据按照制定顺序进行发送,FIFO或者priority.\n#include \"board.h\"\n#include \"rtthread.h\"\n\n\nuint8_t count = 0;\n\n/* message */\nstatic char msg_1[] = \"hello\";\nstatic char msg_2[] = \"world.\";\nstatic char msg_3[] = \"@\";\n\n\n/* mail_box control block */\nstatic rt_mailbox_t mb_1 = RT_NULL;\n\n/* thread control blcok */\nstatic rt_thread_t mb_thread_1 = RT_NULL;\nstatic rt_thread_t mb_thread_2 = RT_NULL;\n\n/* thread_1 to send msg*/\nstatic void thread_1_entry(void *parameter)\n{\n    while (count < 10)\n    {\n        count++;\n        if (count & 0x1)\n        {\n            if(RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_1)){\n                // rt_kprintf(\"-----%x++++++++++%p\\n\",(rt_uint32_t)&msg_1,&msg_1); // -----20000029++++++++++20000029\n\n                rt_kprintf(\"msg_1_send successful!!!\\n\");\n            }\n            else{\n                rt_kprintf(\"msg_1_send failed!!!\\n\");\n            }\n        }\n        //\n        else\n        {\n            if (RT_EOK == rt_mb_send(mb_1, (rt_uint32_t)&msg_2))\n            {\n                rt_kprintf(\"msg_2_send successful!!!\\n\");\n            }\n            else\n            {\n                rt_kprintf(\"msg_2_send failed!!!\\n\");\n            }\n        }\n\n        // thread wait 200 ticks\n        rt_thread_delay(50);\n    }\n\n    // message send [finish]\n    rt_mb_send(mb_1, (rt_uint32_t)&msg_3);\n    rt_kprintf(\"END flag is send....\");\n}\n \n/* thread_2 to receive msg */\nstatic void thread_2_entry(void *parameter){\n    char *str;\n    while (1)\n    {\n        rt_kprintf(\"thread_[2]: try reveive msg.....\\n\");\n        \n        if (rt_mb_recv(mb_1, (rt_uint32_t *)&str, RT_WAITING_FOREVER) == RT_EOK)\n        {\n            rt_kprintf(\"[%d]msg:%s\\n\",count,str);\n            if(str==msg_3){\n                rt_kprintf(\"revc END ............\\n\");\n                break;\n            }\n            rt_thread_delay(100);\n        }\n        else{\n            rt_kprintf(\"2_recv msg faild.....\\n\");\n        }\n    }\n    rt_mb_detach(mb_1);\n    \n}\n\n\n\nint main(void){\n// 这里的1,是mb_size,控制mailbox可以同时发送几个邮件\n    mb_1 = rt_mb_create(\"mb_1\",1,RT_IPC_FLAG_FIFO);\n    \n    if(mb_1!=RT_NULL){\n        rt_kprintf(\"mail_box is create\\n\");\n    }\n    else{\n        rt_kprintf(\"mail_box is create failed.\\n\");\n        return -1;\n    }\n\n    // mb_thread_1 create\n    mb_thread_1 = rt_thread_create(\"mb_thread_1\",thread_1_entry,RT_NULL,512,3,20);\n    if(mb_thread_1!=RT_NULL){\n        rt_thread_startup(mb_thread_1);\n    }   \n    // mb_thread_2 create\n    mb_thread_2 = rt_thread_create(\"mb_thread_2\", thread_2_entry, RT_NULL, 512, 3, 20);\n    if (mb_thread_2 != RT_NULL)\n    {\n        rt_thread_startup(mb_thread_2);\n    }\n    return 0;\n}"
  },
  {
    "objectID": "posts/vmware镜像站/index.html",
    "href": "posts/vmware镜像站/index.html",
    "title": "vmware镜像站",
    "section": "",
    "text": "https://softwareupdate.vmware.com/cds/vmw-desktop/ws/"
  },
  {
    "objectID": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "href": "posts/stm32F103-RT-Thread动态内存分配/index.html",
    "title": "stm32F103-RT-Thread动态内存分配",
    "section": "",
    "text": "打开动态内存分配\n # 设置线程句柄\n/* 定义线程控制块 */\nstatic rt_thread_t led1_thread = RT_NULL;\n\n\n设置线程入口函数\n// 声明\nstatic void led1_thread_entry(void *parameter);\n// 实现\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\n\n设置动态内存分配并启动\n// 设置线程参数\nled1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n/* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\nmain.c\n#include \"board.h\"\n#include \"rtthread.h\"\n\n/*\n*************************************************************************\n*                               变量\n*************************************************************************\n*/\n/* 定义线程控制块 */\n//static struct rt_thread led1_thread;\nstatic rt_thread_t led1_thread = RT_NULL;\nstatic rt_thread_t led2_thread = RT_NULL;\n\n/******************************static memory*******************************/\n/* 定义线程控制块 */\n// static struct rt_thread led1_thread;\n/* 定义线程控栈时要求 RT_ALIGN_SIZE 个字节对齐 */\n// ALIGN(RT_ALIGN_SIZE)\n/* 定义线程栈 */\n// static rt_uint8_t rt_led1_thread_stack[1024];\n/****************************static memory end*****************************/\n/*\n*************************************************************************\n*                             函数声明\n*************************************************************************\n*/\nstatic void led1_thread_entry(void *parameter);\nstatic void led2_thread_entry(void *parameter);\n\n\n/*\n*************************************************************************\n*                             main 函数\n*************************************************************************\n\nint main(void)\n{\n    /* 暂时没有在main线程里面创建任务应用线程 */\n    // thread 1\n    led1_thread = rt_thread_create(\"led1\",led1_thread_entry,RT_NULL,512, 3,20);\n    \n    /* 线程启动,进行调度 */\n    if (led1_thread != RT_NULL)\n        rt_thread_startup(led1_thread);\n    else\n        return -1;\n\n\n\n    // thread 2\n    led2_thread = rt_thread_create(\"led2\", led2_thread_entry, RT_NULL, 512, 3, 20);\n\n    if (led2_thread != RT_NULL)\n        rt_thread_startup(led2_thread);\n    else\n        return -1;\n\n    /**********************************static memory demo ***************************************/\n    // rt_thread_init(&led1_thread,   /* 线程控制块 */\n    //             \"led1\",            /* 线程名字 */\n    //             led1_thread_entry, /* 线程入口函数 */\n    //             RT_NULL,           /* 线程入口函数参数 */\n\n    //             &rt_led1_thread_stack[0],     /* 线程栈起始地址 */\n    //             sizeof(rt_led1_thread_stack), /* 线程栈大小 */\n    //             3,                            /* 线程的优先级 */\n    //             20);                          /* 线程时间片 */\n    // rt_thread_startup(&led1_thread); /* 启动线程，开启调度 */\n    /******************************static memory demo end*************************************/\n}\n\n/*\n *************************************************************************\n *                                  线程定义\n *************************************************************************\n */\n\n\nstatic void led1_thread_entry(void *parameter){\n    while (1)\n    {\n        LED1_ON;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n        LED1_OFF;\n        rt_thread_delay(1500); /* 延时 500 个 tick */\n    }\n}\n\nstatic void led2_thread_entry(void *parameter)\n{\n    while (1)\n    {\n        LED2_ON;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n        LED2_OFF;\n        rt_thread_delay(500); /* 延时 500 个 tick */\n    }\n}\n\n\nboard.c\n/*\n * File      : board.c\n * This file is part of RT-Thread RTOS\n * COPYRIGHT (C) 2006, RT-Thread Development Team\n *\n * The license and distribution terms for this file may be\n * found in the file LICENSE in this distribution or at\n * http://www.rt-thread.org/license/LICENSE\n *\n * Change Logs:\n * Date           Author       Notes\n * 2017-07-24     Tanek        the first version\n */\n#include \"board.h\"\n#include <rthw.h>\n#include <rtthread.h>\n\n\n\n\n\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n#define RT_HEAP_SIZE 1024\nstatic uint32_t rt_heap[RT_HEAP_SIZE];  // heap default size: 4K(1024 * 4)\n\n\nRT_WEAK void *rt_heap_begin_get(void)\n{\n    return rt_heap;\n}\n\nRT_WEAK void *rt_heap_end_get(void)\n{\n    return rt_heap + RT_HEAP_SIZE;\n}\n#endif\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init()\n{   \n    \n    /* 初始化 SysTick */\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    /* 初始化开发板的 LED */\n    LED_GPIO_Config();\n   \n    /* 初始化测试部分, 测试完把代码删除*/\n    // LED2_ON;\n\n    // while (1)\n    // {\n    //     /* code */\n    // }\n    \n\n\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n    \n#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)\n    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);\n#endif\n    \n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n\nvoid SysTick_Handler(void)\n{\n    /* enter interrupt */\n    rt_interrupt_enter();\n\n    rt_tick_increase();\n\n    /* leave interrupt */\n    rt_interrupt_leave();\n}"
  },
  {
    "objectID": "posts/TI_icboost+IWR6843/index.html",
    "href": "posts/TI_icboost+IWR6843/index.html",
    "title": "TI_icboost+IWR6843",
    "section": "",
    "text": "概要\nti毫米波雷达开发过程，环境搭建\n参考:https://blog.csdn.net/Tronlong_/article/details/108147255\n\n\n硬件链接\n\n对应的拨码开关以及条线配置如图\n\n\n\n\n在这里插入图片描述\n\n\n\n\nccs配置\n >## 搜索对应的开发板的项目\n > ## 分别导入项目 > - mss 和 dss\n >## 编译dss项目\n >## 编译mss项目 同样的方法编译mss  > ### 如果遇到not find xxx, 请添加对应的sdk和依赖, 若果sdk安装位置不在默认的C:TI_PRODUCT的路径 \n\ndebug\n请参考:ccs脚本自动调试"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "",
    "text": "这里以test2.sh为例\nvim test2.sh"
  },
  {
    "objectID": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "href": "posts/shell批量创建20个指定文件名格式的文件（或文件夹）/index.html#主体程序",
    "title": "shell批量创建20个指定文件名格式的文件（或文件夹）",
    "section": "2、主体程序",
    "text": "2、主体程序\n#!/bin/bash\n#filename:test_2\n\n# 设置文件存储路径\npath=./space/\n\n# 判断路径是否存在\nif [ -d $path ]\nthen\n        echo $path\nelse\n        mkdir $path\nfi\n\n# 程序主体\ni=1\nwhile(($i<=9))\n\n# 程序主体循环\ndo\n        # 文件名格式\n        number=$[ \"183500110\"$i\"\" ]\n        filename=$number\n        #mkdir $path/$filename\n        let \"i++\"\ndone\n\n# 避免0不占位置导致的格式不对齐\nwhile(($i<=20))\ndo\n        number=$[ \"18350011\"$i\"\" ]\n        filename=$number\n        mkdir $path/$filename\n        let \"i++\"\ndone"
  },
  {
    "objectID": "posts/quarto/index.html",
    "href": "posts/quarto/index.html",
    "title": "quarto",
    "section": "",
    "text": "picgo（图床）\n    // picogo config\n    \"picgo.picBed.current\": \"github\",\n    \"picgo.picBed.github.token\": \"gxxxxxxxx\",\n    \"picgo.picBed.github.repo\": \"fly-t/blog\",\n    \"picgo.picBed.github.branch\": \"master\",\n    \"picgo.customUploadName\": \"${mdFileName}-${dateTime}${extName}\",\n    \"picgo.picBed.github.path\": \"images/\",\n    \"picgo.customOutputFormat\": \"![](${url})\",\n\n\ngithu连接问题\ngithub push不支持账号密码，使用token\n[core]\n    repositoryformatversion = 0\n    filemode = false\n    bare = false\n    logallrefupdates = true\n    ignorecase = true\n[remote \"origin\"]\n    url = https://ellisonpei:这里填access_token@github.com/项目名/项目名.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\n    remote = origin\n    merge = refs/heads/master\n[user]\n    name = aa5279aa\n    email = xxxx@qq.com\n[branch \"develop\"]\n    remote = origin\n    merge = refs/heads/develop\n[credential]\n    helper =\n\n\n这里没有反应， 关掉代理重新尝试\nquarto publish gh-pages\n\n\ngithub action 自动部署\n_quarto.yml\nexecute: \n  freeze: auto\n创建该目录并创建文件\n// 项目根目录\nmkdir .github/workflows\ncd \ntouch .github/workflows/publish.yml\n.github/workflows/publish.yml\non:\n  workflow_dispatch:\n  push:\n    branches: main\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v2\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n git config --global credential.helper store                              \n vim .gitconfig\n// close\ngit config --system --unset credential.helper\n\ngit config --global http.proxy 'http://127.0.0.1:7890'\ngit config --global https.proxy 'http://127.0.0.1:7890'\n修改上传快捷键 \n\n\n参考\n设置github push https://www.jianshu.com/p/3b4f7619999e 显示。git：https://blog.csdn.net/Mrs_chens/article/details/101191893\nQuarto 官方部署流程：https://quarto.org/docs/publishing/github-pages.html GitHub Pages: https://docs.github.com/cn/pages GitHub Actions: https://docs.github.com/cn/actions workflows 字段介绍：https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions"
  },
  {
    "objectID": "posts/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "href": "posts/TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析/index.html",
    "title": "TI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析",
    "section": "",
    "text": "EDMA的数据数据搬移，这部分比较重要，对于能否清楚数据排列很关键\n\n\n\n\nACount: Array(每个切分数据)的大小\nBCount: 一共有N个Array\nCCount: N个BCount\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nsrcBidx: 源数据块的读取偏移(上面的一个array的大小), 即读取每个array偏移的大小\ndstBidx: 目的地址偏移(如果为0 表示不偏移, 最大支持0xffffH的偏移)\n下图表示的是ab同步传输模式, 在vitalsign中使用的是a同步传输\n\n\n\n\n\n在这里插入图片描述\n\n\n/**\n * EDMA_Handle handle,\n    uint8_t *srcBuff,              ADCdataBuf\n    uint8_t *dstBuff,              adcDataIn\n    uint8_t chId,                   PONG\n    bool isEventTriggered,          false\n    uint16_t shadowParamId,\n    uint16_t aCount,                100*(16*2)\n    uint16_t bCount,                Rx*numChirp\n    int16_t srcBIdx,                \n    int16_t dstBIdx,                0\n    uint8_t eventQueueId,\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg\n * */\n\n\nEDMAutil_configType1(\n    context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n    (uint8_t *)(&obj->ADCdataBuf[obj->numAdcSamples * obj->numChirpsPerChirpEvent]),\n    (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->adcDataIn[obj->numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n    MMW_EDMA_CH_1D_IN_PONG,\n    false, // 如果要在配置后启用通道，则设置为 true，否则设置为 false。\n    shadowParam++,\n    obj->numAdcSamples * BYTES_PER_SAMP_1D,\n    MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,\n    (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent,\n    0,\n    eventQueue,\n    NULL,\n    (uintptr_t) obj);\n\n\n\n通道控制器(EDMA_TPCC0_REQ_FREE_0这里vitalsign使用的是通道控制器0)\ncc0 有 2个 TC(传输控制器)\ncc1 有 1个 TC(传输控制器)\n传输控制器\n\n\nvitalSign中的EDMA配置\n/*EDMA instance used*/\n#define MMW_DATA_PATH_EDMA_INSTANCE      EDMA_INSTANCE_0\n                                         \n/* channels */                           \n#define MMW_EDMA_CH_1D_IN_PING           EDMA_TPCC0_REQ_FREE_0\n#define MMW_EDMA_CH_1D_IN_PONG           EDMA_TPCC0_REQ_FREE_1\n#define MMW_EDMA_CH_1D_OUT_PING          EDMA_TPCC0_REQ_FREE_2\n#define MMW_EDMA_CH_1D_OUT_PONG          EDMA_TPCC0_REQ_FREE_3\n#define MMW_EDMA_CH_2D_IN_PING           EDMA_TPCC0_REQ_FREE_4\n#define MMW_EDMA_CH_2D_IN_PONG           EDMA_TPCC0_REQ_FREE_5\n#define MMW_EDMA_CH_DET_MATRIX           EDMA_TPCC0_REQ_FREE_6\n#define MMW_EDMA_CH_DET_MATRIX2          EDMA_TPCC0_REQ_FREE_7\n#define MMW_EDMA_CH_3D_IN_PING           EDMA_TPCC0_REQ_FREE_8\n#define MMW_EDMA_CH_3D_IN_PONG           EDMA_TPCC0_REQ_FREE_9\n#define MMW_EDMA_CH_SIGIMG_MON           EDMA_TPCC0_REQ_FREE_10\n#define MMW_EDMA_CH_RX_SATURATION_MON    EDMA_TPCC0_REQ_FREE_11\n\n/*shadow*/\n// #define EDMA_NUM_DMA_CHANNELS (64U)\n#define MMW_EDMA_CH_1D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 0U)    \n#define MMW_EDMA_CH_1D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 1U)\n#define MMW_EDMA_CH_1D_OUT_PING_SHADOW          (EDMA_NUM_DMA_CHANNELS + 2U)\n#define MMW_EDMA_CH_1D_OUT_PONG_SHADOW          (EDMA_NUM_DMA_CHANNELS + 3U)\n#define MMW_EDMA_CH_2D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 4U)\n#define MMW_EDMA_CH_2D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 5U)\n#define MMW_EDMA_CH_DET_MATRIX_SHADOW           (EDMA_NUM_DMA_CHANNELS + 6U)\n#define MMW_EDMA_CH_DET_MATRIX2_SHADOW          (EDMA_NUM_DMA_CHANNELS + 7U)\n#define MMW_EDMA_CH_3D_IN_PING_SHADOW           (EDMA_NUM_DMA_CHANNELS + 8U)\n#define MMW_EDMA_CH_3D_IN_PONG_SHADOW           (EDMA_NUM_DMA_CHANNELS + 9U)\n >## DMA触发方式 >- 手动触发(ESR) >- 链接触发(Link) [vitalsign使用的方式] > 用一个edma的传输结束来出发另外一个edma >- 事件触发(EER)\n这里vitalSign使用的是cc0, 所以查看cc0支持的事件表  下面的32个通道对应上面的32个事件(event), 如果我们想要通过UART0 Receice 来出发EDMA传输, 就需要配置到通道8, 这就是事件触发方式 \n\n\n每个EDMA事件对应一个paRAM, 每个paRAM存储一个EDMA配置, 每个paRAM包括8个字\n\n这里的参数对应EDMAutil_configType1里面的代码\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n    EDMA_transferCompletionCallbackFxn_t transferCompletionCallbackFxn,\n    uintptr_t transferCompletionCallbackFxnArg)\n{\n    EDMA_channelConfig_t config;\n    int32_t errorCode = EDMA_NO_ERROR;\n\n    config.channelId = chId;\n    config.channelType = (uint8_t)EDMA3_CHANNEL_TYPE_DMA;\n    config.paramId = chId;\n    config.eventQueueId = eventQueueId;\n\n    config.paramSetConfig.sourceAddress = (uint32_t) srcBuff;\n    config.paramSetConfig.destinationAddress = (uint32_t) dstBuff;\n\n    config.paramSetConfig.aCount = aCount;\n    config.paramSetConfig.bCount = bCount;\n    config.paramSetConfig.cCount = 1U;                      // 数据只有一行\n    config.paramSetConfig.bCountReload = 0U;\n\n    config.paramSetConfig.sourceBindex = srcBIdx;\n    config.paramSetConfig.destinationBindex = dstBIdx;\n\n    config.paramSetConfig.sourceCindex = 0U;            \n    config.paramSetConfig.destinationCindex = 0U;\n\n    config.paramSetConfig.linkAddress = EDMA_NULL_LINK_ADDRESS;\n    config.paramSetConfig.transferType = (uint8_t)EDMA3_SYNC_A;     // 传输模式A同步传输模式(Array*B)\n    config.paramSetConfig.transferCompletionCode = chId;\n    config.paramSetConfig.sourceAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n    config.paramSetConfig.destinationAddressingMode = (uint8_t) EDMA3_ADDRESSING_MODE_LINEAR;\n\n    /* don't care because of linear addressing modes above */\n    config.paramSetConfig.fifoWidth = (uint8_t) EDMA3_FIFO_WIDTH_8BIT;\n\n    config.paramSetConfig.isStaticSet = false;\n    config.paramSetConfig.isEarlyCompletion = false;\n    config.paramSetConfig.isFinalTransferInterruptEnabled = true;\n    config.paramSetConfig.isIntermediateTransferInterruptEnabled = true;\n    config.paramSetConfig.isFinalChainingEnabled = false;\n    config.paramSetConfig.isIntermediateChainingEnabled = false;\n    config.transferCompletionCallbackFxn = transferCompletionCallbackFxn;\n    config.transferCompletionCallbackFxnArg = transferCompletionCallbackFxnArg;\n\n    if ((errorCode = EDMA_configChannel(handle, &config, isEventTriggered)) != EDMA_NO_ERROR)\n    {\n        System_printf(\"Error: EDMA_configChannel() failed with error code = %d\\n\", errorCode);\n        goto exit;\n    }\n\n    errorCode = EDMA_setup_shadow_link(handle, chId, shadowParamId,\n        &config.paramSetConfig, config.transferCompletionCallbackFxn, transferCompletionCallbackFxnArg);\n\nexit:\n    return(errorCode);\n}\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n链接触发\n自动触发\n没有用到所有没写\n\n\n\n\n\n主要针对dma对数据的搬移\n\n\n >### EDMA配置 > - 上图处理过程主要用到4 个EDMA > - 1D_IN_Ping , 1D_IN_Pong, 1D_OUT_Ping, 1D_OUT_Pong\n\n\n\n这个edma主要的工作时将AdcDataBuf中的数据搬移到adcDataIn中\n这里的chrip1, chirp2 …表示的是一frame内的chirp序号, 不是所有的chirp, 每次++\nchirp1 和 chirp2 的到达时间肯定是不同的, chirp2在chirp1之后, 所以edma_1d_in_ping同一时间搬移到adcDataIn里面的数据是 chrip 1 Rx 1 chrip 1 Rx 2,\nbcount=4 表示一共传输4次\n将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong , 为后面的加窗 和fft操作组成流水线做准备\nshadow表示链接触发, shadow使用和1d_in_ping的一样的配置参数, 也发送4次,刚好将数据发送完\n这的ping(adcDataBuf)pong(adcDataBuf)表示的是一帧内的chirp, 每个buff中放两个chirp, 如果大于2chrip会组成pingpong\n\n\n > 将chrip 1 Rx 1 chrip 1 Rx 2组成ping pong > \n\n\n\n后续使用该api请参考这里\n\n\nint32_t EDMAutil_configType1(EDMA_Handle handle,\n    uint8_t *srcBuff,  // 源地址\n    uint8_t *dstBuff, // 目的地址\n    uint8_t chId,       // 通道\n    bool isEventTriggered,  // 是否立即触发\n    uint16_t shadowParamId, // 影子通道, 链接传输\n    uint16_t aCount,        // 源数据块(Array)大小\n    uint16_t bCount,        // 源数据块数量(N*Array)\n    int16_t srcBIdx,        // 源数据读取偏移\n    int16_t dstBIdx,        // 目的地址写入偏移\n    uint8_t eventQueueId,   // 事件队列id\n)\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj->ADCdataBuf[0]), \n        (uint8_t *)(SOC_translateAddress((uint32_t)&obj->adcDataIn[0],SOC_TranslateAddr_Dir_TO_EDMA,NULL)), \n        MMW_EDMA_CH_1D_IN_PING,\n        false,\n        shadowParam++,\n        obj->numAdcSamples * BYTES_PER_SAMP_1D,// acount\n        MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,// bcount\n        (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent, // srcbidx\n        0,                                                                         // dstbidx\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这个edma和1d_in_ping类似\n参考上面描述\n\n\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\nEDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(&obj->ADCdataBuf[obj->numAdcSamples * obj->numChirpsPerChirpEvent]),\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->adcDataIn[obj->numRangeBins]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        MMW_EDMA_CH_1D_IN_PONG,\n        false,\n        shadowParam++,\n        obj->numAdcSamples * BYTES_PER_SAMP_1D,\n        MAX(obj->numRxAntennas / 2, 1) * obj->numChirpsPerChirpEvent,\n        (obj->numAdcSamples * BYTES_PER_SAMP_1D * 2) * obj->numChirpsPerChirpEvent,\n        0,\n        eventQueue,\n#ifdef EDMA_1D_INPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n这里的ping pong 表示按照发射天线进行区分, 将前面的Ping(adcDataBuf) 或者Pong(adcDataBuf) 单个Buffer中的接收数据进行全部分组, 按照发射天线进行分组\n后将数据搬移到RadarCube中\nCube中只有一帧的数据,并按照天线的奇偶进行拆分排列\n该EDMA中的配置的搬移到Cube中的数据按照配置生成, dataPathObj->numRangeBins        = MmwDemo_pow2roundup(dataPathObj->numAdcSamples); 按照满足的二次幂来设置, numAdcSamples = 100, 那么此时的numRangeBins=128, 如果numAdcSamples=64则numRangeBins=64, 所以这里的EDMA配置根据该参数自动调整\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->fftOut1D[0]),SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        (uint8_t *)(&obj->radarCube[0]),\n        MMW_EDMA_CH_1D_OUT_PING,\n        false,\n        shadowParam++,\n        aCount,   // 128*Rx*complex\n        obj->numChirpsPerFrame / 2, //bCount  4/2\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);\n\n\n\n对应参照 1D_OUT_Ping\n\n\n\n\n在这里插入图片描述\n\n\n\n\n\n\n    EDMAutil_configType1(context->edmaHandle[MMW_DATA_PATH_EDMA_INSTANCE],\n        (uint8_t *)(SOC_translateAddress((uint32_t)(&obj->fftOut1D[numPingOrPongSamples]),// numPingOrPongSamples:  128*Rx\n                                         SOC_TranslateAddr_Dir_TO_EDMA,NULL)),\n        oneD_destinationPongAddress, // 128*4*1\n        MMW_EDMA_CH_1D_OUT_PONG,\n        false,\n        shadowParam++,\n        aCount,\n        obj->numChirpsPerFrame / 2, //bCount\n        0, //srcBidx\n        oneD_destinationBindex, //dstBidx\n        eventQueue,\n#ifdef EDMA_1D_OUTPUT_BLOCKING\n        MmwDemo_EDMA_transferCompletionCallbackFxn,\n#else\n        NULL,\n#endif\n        (uintptr_t) obj);"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html",
    "href": "posts/shell编程的简单实现/index.html",
    "title": "shell编程的简单实现",
    "section": "",
    "text": "这里以 bashscript.sh 为例\nvim bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "href": "posts/shell编程的简单实现/index.html#在文件中编写简单的输出指令",
    "title": "shell编程的简单实现",
    "section": "2、在文件中编写简单的输出指令",
    "text": "2、在文件中编写简单的输出指令\n#！ /bin/bash                           // 脚本解释器程序路径\n#filename:bashscript                       // 注释\necho  “这是一个bash脚本程序。”                   // 输出指令\necho “---------------------------------------“"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#给文件赋权",
    "href": "posts/shell编程的简单实现/index.html#给文件赋权",
    "title": "shell编程的简单实现",
    "section": "3、给文件赋权",
    "text": "3、给文件赋权\nchmod u+x bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "href": "posts/shell编程的简单实现/index.html#运行.sh文件",
    "title": "shell编程的简单实现",
    "section": "4、运行.sh文件",
    "text": "4、运行.sh文件\n执行程序bashscript.sh\n./bashscript.sh"
  },
  {
    "objectID": "posts/shell编程的简单实现/index.html#运行结果",
    "href": "posts/shell编程的简单实现/index.html#运行结果",
    "title": "shell编程的简单实现",
    "section": "99、运行结果",
    "text": "99、运行结果\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html",
    "href": "posts/Ubuntu18版本换源/index.html",
    "title": "Ubuntu18版本换源",
    "section": "",
    "text": "【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 【此源只适合bionic版本！！！！！！！，重要的事情说三遍】 ## 0. Ubuntu版本必须匹配 查看Ubuntu版本命令"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "href": "posts/Ubuntu18版本换源/index.html#备份sources.list",
    "title": "Ubuntu18版本换源",
    "section": "1.备份sources.list",
    "text": "1.备份sources.list\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "href": "posts/Ubuntu18版本换源/index.html#编辑sources.list换源",
    "title": "Ubuntu18版本换源",
    "section": "2.编辑sources.list（换源）",
    "text": "2.编辑sources.list（换源）\nsudo gedit /etc/apt/sources.list"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "href": "posts/Ubuntu18版本换源/index.html#把打开的sources.list里面的东西都删除把下面代码复制进去保存保存保存",
    "title": "Ubuntu18版本换源",
    "section": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。",
    "text": "3.把打开的sources.list里面的东西都删除，把下面代码复制进去，【保存】，【保存】，【保存】。\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\n \n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#更新源",
    "href": "posts/Ubuntu18版本换源/index.html#更新源",
    "title": "Ubuntu18版本换源",
    "section": "4.更新源",
    "text": "4.更新源\nsudo apt-get update"
  },
  {
    "objectID": "posts/Ubuntu18版本换源/index.html#完成换源",
    "href": "posts/Ubuntu18版本换源/index.html#完成换源",
    "title": "Ubuntu18版本换源",
    "section": "5.完成换源",
    "text": "5.完成换源"
  },
  {
    "objectID": "posts/webSocket-node -- 02 聊天室/index.html",
    "href": "posts/webSocket-node -- 02 聊天室/index.html",
    "title": "webSocket-node – 02 聊天室",
    "section": "",
    "text": "在这里插入图片描述"
  },
  {
    "objectID": "posts/qt大小端转换/index.html",
    "href": "posts/qt大小端转换/index.html",
    "title": "qt大小端转换",
    "section": "",
    "text": "在这里插入图片描述\n\n\n以1580 0001为例\n    QByteArray b(\"15800001\");\n    qint32 a = parseValueInt32(b, 0, 8);\n    qDebug() << \"\\tseqNum:\" << a;\n32位大端解析:\nqint32 single_test::parseValueInt32(QByteArray data, int valuePos, int valueSize)\n{\n    bool ok;\n    QByteArray parseData;\n    parseData = data.mid(valuePos, valueSize);\n    QString strParseData = parseData;\n    qint32 tempInt32 = strParseData.toInt(&ok, 16);\n                            //                     0x15 80 00 01(原始数据反过来)\n    qDebug() << tempInt32; // 16810005 (十进制) --> 0x01 00 80 15(十六进制)\n    qint32 parseValueOut = qToBigEndian(tempInt32);     // Convert to Big-Endian\n    return parseValueOut;    \n}\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "",
    "text": "darknet框架相pyrtorch轻量化很多，将darknet和qt进行整合，大多项目都是基于单独的框架的，对于整合的工作相对来说低很多"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#创建完成记得保存",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "创建完成记得保存",
    "text": "创建完成记得保存\n对修改完的ui文件进行编译"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#环境配置需要的文件",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "环境配置需要的文件",
    "text": "环境配置需要的文件\n\nincldue 文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nconfig文件夹\n\n\n\n在这里插入图片描述\n\n\n\n\nlib文件夹"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#链接器中附加目录中的附加依赖项",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "链接器中附加目录中的附加依赖项",
    "text": "链接器中附加目录中的附加依赖项\nopencv版本根据自身开发环境进行配置"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#生成",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "生成",
    "text": "生成\n\n\n\n在这里插入图片描述"
  },
  {
    "objectID": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "href": "posts/qt+darknet+yolo+vs2022(附加库目录lib库)/index.html#双击即可运行",
    "title": "qt+darknet+yolo+vs2022(附加库目录lib库)",
    "section": "双击即可运行",
    "text": "双击即可运行\n点击右上角的 x 关闭只关闭了界面, 系统检测进程还是在后台运行, 需要重写closeEvent 进行关闭系统."
  },
  {
    "objectID": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "href": "posts/qt移动界面无响应[ 多线程 ]/index.html",
    "title": "qt移动界面无响应[ 多线程 ]",
    "section": "",
    "text": "创建子进程类\n\n普通的长时间操作界面容易卡死, 体验非常不好,为了提升体验, 所以将需要较长时间响应的事件都放到了子线程中执行, 这样主线程就不会出现假死的状态\n\n\n方法1(继承QThread):\n.h [头文件]\n#ifndef MYTHREAD_H\n#define MYTHREAD_H\n\n#include <QThread>\n\nclass Generate : public QThread\n{\n    Q_OBJECT\npublic:\n    explicit Generate(QObject* parent = nullptr);// 直接使用qt的类生成,这里没有默认的空指针,new的时候会报错,需要设置成nullptr\n\nprotected:\n    void run(); // 重写run函数\n\nsignals:\n    void curNumber(int num);// 自定义信号, 传递数据\n    void curimg(QImage* img); // 传递图片, 如果是自定义的结构, 需要注册类型:qRegisterMetaType<int>(\"int\")  [int根据自己的类型设置];\n\npublic slots:\n};\n\n#endif // MYTHREAD_H\n.c[源文件]\n#include \"mythread.h\"\n#include \"qdebug.h\"\n\nGenerate::Generate(QObject* parent) : QThread(parent)\n{\n\n}\n\nvoid Generate::run()\n{\n    qDebug() << \"current Thread id is: \" << QThread::currentThread();\n\n    int num = 0;\n    while (1)\n    {\n        emit curNumber(num++);\n        if (num == 999)\n        {\n            qDebug() << \" sub Thread is finished...\";\n            break;\n        }\n        QThread::usleep(1);\n    }\n}\nmainwindow.c主线程\n#include \"qtwidgetsapplication_thread.h\"\n#include \"MyCreate.h\"\n\n\n\n#include <qdebug.h>\n\nQtWidgetsApplication_Thread::QtWidgetsApplication_Thread(QWidget *parent)\n    : QMainWindow(parent)\n{\n    ui.setupUi(this);\n    qDebug() << \"main thread is : \" << QThread::currentThread();\n    \n    // 将刚才的创建的类实例化\n    Generate * subThread_A = new Generate ;\n   \n\n\n    // 绑定信号和槽\n    connect(subThread_A, &Generate ::curNumber, this, [=](int num) {\n        ui.label->setNum(num);\n        });\n   \n\n\n    // 启动线程\n    connect(ui.pushButton, &QPushButton::clicked, this, [=]() {\n        subThread_A->start();\n        });\n    \n   \n\n}\n\n\n\n方法二(moveToThread):\n这种方法相对来说更加灵活     打开创建类的头文件MyThread.h\n\n修改MyThread(QObject *parent);—–>MyThread(QObject *parent=nullptr);, 不修改在new的时候会报错 [类 不存在默认构造函数]\n\n 修改完成后如下\n#include <QObject>\n\nclass MyThread  : public QObject\n{\n    Q_OBJECT\n    \npublic:\n    MyThread(QObject *parent=nullptr);\n    ~MyThread();\n\n    // create working function to do sth what you want\n    void working(); //线程中执行的代码写到working中,这个函数名随意\n\nsignals:\n    // create a signal to kick the thread\n    void signal_hello(int count); // 设置一个触发信号, count为传递的变量, 将这个变量用来讲子线程和主线程之间进行传递数据.\n};\n打开创建类的源文件MyThread.cpp\n\n将刚才创建的头文件进行实现 这个程序的作用主要是将子线程中的变量发送到主线程进行显示\n\n#include \"MyThread.h\"\n\n#include \"qdebug.h\"\n#include \"qthread.h\"\n\nMyThread::MyThread(QObject *parent)\n    : QObject(parent)\n{}\n\nMyThread::~MyThread()\n{}\n\nvoid MyThread::working()\n{\n    int count = 0;\n    while (1) {\n        // kick the signal, and post the data [count] by this signal\n        emit signal_hello(++count);  // 将信号发送, 并将数据发送到主线程\n        if (count == 999) {\n            qDebug() << \"sub thread is stoped:\";\n            break;\n        }\n        qDebug() << \"current thread is:\" << QThread::currentThread;\n    }\n}\n进入到主线程进行实现mainwindow.cpp\nMyThread* work = new MyThread;\nQThread* thread_c = new QThread;\n\nwork->moveToThread(thread_c);                    // 放到新线程中\nthread_c->start();                               // 启动线程\n\nconnect(ui.pushButton, &QPushButton::clicked, work, &MyThread::working);// 按钮点击信号\nconnect(work, &MyThread::signal_hello, this, [=](int count) {\n       ui.label->setNum(count);\n       });  // 界面刷新信号"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TengFei Zhang",
    "section": "",
    "text": "Fresh graduates majoring in computer science, love life and love coding."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "TengFei Zhang",
    "section": "Education",
    "text": "Education\nSuzhou University of Science and Technology | Jun 2022"
  },
  {
    "objectID": "index.html#experience-at-school",
    "href": "index.html#experience-at-school",
    "title": "TengFei Zhang",
    "section": "Experience at school",
    "text": "Experience at school\nRanking: 5/45 | GPA: 3.24 | Teaching assistant | Scholarship x 3\nQualification Certificate of Computer and Software Technology Proficiency Of Junior"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "TengFei Zhang",
    "section": "Experience",
    "text": "Experience\nElectric Vehicle Helmet Illegal Detection System(Yolo, Ocr, Spider.. ) | Graduation Project | Feb 2022\nVideo Capture Tools (Pyqt, OpenCv, Ftplib..) | Su Zhou HighWise | Oct 2021\nLicense Management Platform (Django, Vue, Mysql..) | Su Zhou HighWise | Jan 2021\nHuman Detection (Yolo, Qt..) | Su Zhou Ravsense | Apr 2022\nRadar Raw ADC Data Capture(AWR6843, not DCA1000..) | Su Zhou Ravsense | Jul 2022\nVitalSign Algorithm Porting(RTOS, Matlab Coder, STM32H7..) | Su Zhou Ravsense | Oct 2022\nE-mail:izhangtengfei@163.com"
  },
  {
    "objectID": "article.html",
    "href": "article.html",
    "title": "Article",
    "section": "",
    "text": "qt线程问题(耗时操作)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32–io口拉高还是拉低\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell脚本批量创建多个用户\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqtQByteArry以二进制写入多n个字节\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程管理\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_js脚本自动调试\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs studio添加include和依赖库\n\n\n\n\n\n\n\nide\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt –问题总结(头文件问题,QString转换,查找组件)\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread 重映射串口到 rt_kprintf 函数\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_dsp入门-ti c660\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread定时器\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nSpring简单使用（依赖注入）\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt上位机 – 自己开发出口助手\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743+CubeMX+RtThread工程创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvue – 01安装、创建、跑通\n\n\n\n\n\n\n\nvue\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt多线程QThread()\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwin11-删除账户导致输入正确密码也无法卡机（windows无法进入系统）\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvs打包qt程序\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-json-乱码解决\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu21 美化\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspring整合SSM\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread– 互斥量(mutex)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread移植(固件库版本)-项目创建\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 01简单跑通\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_ccs修改环境变量\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32H743使用\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringMVC-设置日期时间对象【自定义日期时间格式】\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt–vs2022+qt5.15.2\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nweb-packet –01\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread–信号量(semaphare)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt无法输出\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket – 03 socket.io\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nsmt32-f103寄存器点灯\n\n\n\n\n\n\n\nstm32\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32芯片开发包\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread线程同步(event)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nspringmvc-hellomvc-02\n\n\n\n\n\n\n\nspring\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread邮箱(mailbox)\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nvmware镜像站\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nstm32F103-RT-Thread动态内存分配\n\n\n\n\n\n\n\nrtthread\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_icboost+IWR6843\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell批量创建20个指定文件名格式的文件（或文件夹）\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nquarto\n\n\n\n\n\n\n\nclutter\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nTI_MMWave_EDMA_以及ti_OutOfBoxDemo数据处理(data_path)_解析\n\n\n\n\n\n\n\nmmwave\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nshell编程的简单实现\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nUbuntu18版本换源\n\n\n\n\n\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nwebSocket-node – 02 聊天室\n\n\n\n\n\n\n\nnodejs\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt大小端转换\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt+darknet+yolo+vs2022(附加库目录lib库)\n\n\n\n\n\n\n\nprojects\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nqt移动界面无响应[ 多线程 ]\n\n\n\n\n\n\n\nqt\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\ndd21\n\n\n\n\n\n\n  \n\n\n\n\nMatlab Coder\n\n\n\n\n\n\n\nmatlab\n\n\n\n\n\n\n\n\n\n\n\nNov 22, 2022\n\n\ndd21\n\n\n\n\n\n\nNo matching items"
  }
]